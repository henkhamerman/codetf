Refactoring Types: ['Extract Method']
/main/java/org/neo4j/ndp/messaging/NDPIOException.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging;

import java.io.IOException;

import org.neo4j.kernel.api.exceptions.Status;

public class NDPIOException extends IOException implements Status.HasStatus
{
    private final Status status;

    public NDPIOException( Status status, String message )
    {
        super(message);
        this.status = status;
    }

    @Override
    public Status status()
    {
        return status;
    }
}


File: community/ndp/messaging-v1/src/main/java/org/neo4j/ndp/messaging/v1/PackStreamMessageFormatV1.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.neo4j.graphdb.DynamicLabel;
import org.neo4j.graphdb.DynamicRelationshipType;
import org.neo4j.graphdb.Label;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Path;
import org.neo4j.graphdb.PropertyContainer;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.RelationshipType;
import org.neo4j.helpers.collection.Iterables;
import org.neo4j.kernel.api.exceptions.Status;
import org.neo4j.ndp.messaging.NDPIOException;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueNode;
import org.neo4j.ndp.messaging.v1.infrastructure.ValuePath;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueRelationship;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.packstream.PackStream;
import org.neo4j.packstream.PackType;
import org.neo4j.ndp.runtime.spi.Record;

import static org.neo4j.ndp.messaging.v1.infrastructure.ValueParser.parseId;
import static org.neo4j.ndp.runtime.internal.Neo4jError.codeFromString;
import static org.neo4j.ndp.runtime.spi.Records.record;

public class PackStreamMessageFormatV1 implements MessageFormat
{
    public static final int VERSION = 1;

    public static final byte NODE = 'N';
    public static final byte RELATIONSHIP = 'R';
    public static final byte PATH = 'P';

    @Override
    public int version()
    {
        return VERSION;
    }

    public interface MessageTypes
    {
        byte MSG_INITIALIZE = 0x01;
        byte MSG_ACK_FAILURE = 0x0F;
        byte MSG_RUN = 0x10;
        byte MSG_DISCARD_ALL = 0x2F;
        byte MSG_PULL_ALL = 0x3F;

        byte MSG_RECORD = 0x71;
        byte MSG_SUCCESS = 0x70;
        byte MSG_IGNORED = 0x7E;
        byte MSG_FAILURE = 0x7F;
    }

    static String messageTypeName( int type )
    {
        switch( type )
        {
        case MessageTypes.MSG_ACK_FAILURE: return "MSG_ACK_FAILURE";
        case MessageTypes.MSG_RUN:         return "MSG_RUN";
        case MessageTypes.MSG_DISCARD_ALL: return "MSG_DISCARD_ALL";
        case MessageTypes.MSG_PULL_ALL:    return "MSG_PULL_ALL";
        case MessageTypes.MSG_RECORD:      return "MSG_RECORD";
        case MessageTypes.MSG_SUCCESS:     return "MSG_SUCCESS";
        case MessageTypes.MSG_IGNORED:     return "MSG_IGNORED";
        case MessageTypes.MSG_FAILURE:     return "MSG_FAILURE";
        default: return "0x" + Integer.toHexString(type);
        }
    }

    public static class Writer implements MessageFormat.Writer
    {
        public static final MessageBoundaryHook NO_OP = new MessageBoundaryHook()
        {
            @Override
            public void onMessageComplete() throws IOException
            {

            }
        };

        private final PackStream.Packer packer;
        private final MessageBoundaryHook onMessageComplete;

        /**
         * @param packer serializer to output channel
         * @param onMessageComplete invoked for each message, after it's done writing to the output
         */
        public Writer( PackStream.Packer packer, MessageBoundaryHook onMessageComplete )
        {
            this.packer = packer;
            this.onMessageComplete = onMessageComplete;
        }

        @Override
        public Writer write( Message message ) throws IOException
        {
            message.dispatch( this );
            return this;
        }

        @Override
        public void handleRunMessage( String statement, Map<String,Object> params )
                throws IOException
        {
            packer.packStructHeader( 2, MessageTypes.MSG_RUN );
            packer.pack( statement );
            packRawMap( params );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handlePullAllMessage()
                throws IOException
        {
            packer.packStructHeader( 0, MessageTypes.MSG_PULL_ALL );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleDiscardAllMessage()
                throws IOException
        {
            packer.packStructHeader( 0, MessageTypes.MSG_DISCARD_ALL );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleAckFailureMessage() throws IOException
        {
            packer.packStructHeader( 0, MessageTypes.MSG_ACK_FAILURE );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleRecordMessage( Record item )
                throws IOException
        {
            Object[] fields = item.fields();
            packer.packStructHeader( 1, MessageTypes.MSG_RECORD );
            packer.packListHeader( fields.length );
            for ( Object field : fields )
            {
                packValue( field );
            }
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleSuccessMessage( Map<String,Object> metadata )
                throws IOException
        {
            packer.packStructHeader( 1, MessageTypes.MSG_SUCCESS );
            packRawMap( metadata );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleFailureMessage( Status status, String message )
                throws IOException
        {
            packer.packStructHeader( 1, MessageTypes.MSG_FAILURE );
            packer.packMapHeader( 2 );

            packer.pack( "code" );
            packer.pack( status.code().serialize() );

            packer.pack( "message" );
            packer.pack( message );
            
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleIgnoredMessage() throws IOException
        {
            packer.packStructHeader( 0, MessageTypes.MSG_IGNORED );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void handleInitializeMessage( String clientName ) throws IOException
        {
            packer.packStructHeader( 1, MessageTypes.MSG_INITIALIZE );
            packer.pack( clientName );
            onMessageComplete.onMessageComplete();
        }

        @Override
        public void flush() throws IOException
        {
            packer.flush();
        }

        private void packRawMap( Map<String,Object> map ) throws IOException
        {
            packer.packMapHeader( map.size() );
            if ( map.size() > 0 )
            {
                for ( Map.Entry<String,Object> entry : map.entrySet() )
                {
                    packer.pack( entry.getKey() );
                    packValue( entry.getValue() );
                }
            }
        }

        private void packValue( Object obj ) throws IOException
        {
            // Note: below uses instanceof for quick implementation, this should be swapped over to a dedicated
            // visitable type that the serializer can simply visit. This would create explicit contract for what can
            // be serialized and allow performant method dispatch rather than if branching.
            if ( obj == null )
            {
                packer.packNull();
            }
            else if ( obj instanceof Boolean )
            {
                packer.pack( (boolean) obj );
            }
            else if ( obj instanceof Byte || obj instanceof Short || obj instanceof Integer || obj instanceof Long )
            {
                packer.pack( ((Number) obj).longValue() );
            }
            else if ( obj instanceof Float || obj instanceof Double )
            {
                packer.pack( ((Number) obj).doubleValue() );
            }
            else if ( obj instanceof String )
            {
                packer.pack( (String) obj );
            }
            else if ( obj instanceof Map )
            {
                Map<Object,Object> map = (Map<Object,Object>) obj;

                packer.packMapHeader( map.size() );
                for ( Map.Entry<?,?> entry : map.entrySet() )
                {
                    packer.pack( entry.getKey().toString() );
                    packValue( entry.getValue() );
                }
            }
            else if ( obj instanceof Collection )
            {
                List list = (List) obj;
                packer.packListHeader( list.size() );
                for ( Object item : list )
                {
                    packValue( item );
                }
            }
            else if ( obj instanceof byte[] )
            {
                // Pending decision
                throw new UnsupportedOperationException( "Binary values cannot be packed." );
            }
            else if ( obj instanceof short[] )
            {
                short[] arr = (short[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj instanceof int[] )
            {
                int[] arr = (int[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj instanceof long[] )
            {
                long[] arr = (long[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj instanceof float[] )
            {
                float[] arr = (float[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj instanceof double[] )
            {
                double[] arr = (double[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj instanceof boolean[] )
            {
                boolean[] arr = (boolean[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packer.pack( arr[i] );
                }
            }
            else if ( obj.getClass().isArray() )
            {
                Object[] arr = (Object[]) obj;
                packer.packListHeader( arr.length );
                for ( int i = 0; i < arr.length; i++ )
                {
                    packValue( arr[i] );
                }
            }
            else if ( obj instanceof Node )
            {
                Node node = (Node) obj;
                packer.packStructHeader( 3, NODE );
                packer.pack( "node/" + node.getId() );

                Collection<Label> labels = Iterables.toList( node.getLabels() );
                packer.packListHeader( labels.size() );
                for ( Label label : labels )
                {
                    packer.pack( label.name() );
                }

                Collection<String> propertyKeys = Iterables.toList( node.getPropertyKeys() );
                packer.packMapHeader( propertyKeys.size() );
                for ( String propertyKey : propertyKeys )
                {
                    packer.pack( propertyKey );
                    packValue( node.getProperty( propertyKey ) );
                }
            }
            else if ( obj instanceof Relationship )
            {
                Relationship rel = (Relationship) obj;
                packer.packStructHeader( 5, RELATIONSHIP );
                packer.pack( "rel/" + rel.getId() );
                packer.pack( "node/" + rel.getStartNode().getId() );
                packer.pack( "node/" + rel.getEndNode().getId() );

                packer.pack( rel.getType().name() );

                Collection<String> propertyKeys = Iterables.toList( rel.getPropertyKeys() );
                packer.packMapHeader( propertyKeys.size() );
                for ( String propertyKey : propertyKeys )
                {
                    packer.pack( propertyKey );
                    packValue( rel.getProperty( propertyKey ) );
                }
            }
            else if ( obj instanceof Path )
            {
                Path path = (Path) obj;
                packer.packStructHeader( 1, PATH );
                packer.packListHeader( path.length() * 2 + 1 );
                for ( PropertyContainer pc : path )
                {
                    packValue( pc );
                }
            }
            else
            {
                throw new NDPIOException( Status.General.UnknownFailure, "Unpackable value " + obj + " of type " + obj.getClass().getName() );
            }
        }
    }

    public static class Reader implements MessageFormat.Reader
    {
        private final PackStream.Unpacker unpacker;

        public Reader( PackStream.Unpacker input )
        {
            unpacker = input;
        }

        @Override
        public boolean hasNext() throws IOException
        {
            return unpacker.hasNext();
        }

        /**
         * Parse a single message into the given consumer.
         */
        @Override
        public <E extends Exception> void read( MessageHandler<E> output ) throws IOException, E
        {
            try
            {
                unpacker.unpackStructHeader();
                int type = (int) unpacker.unpackLong();

                try
                {
                    switch ( type )
                    {
                    case MessageTypes.MSG_RUN:
                        unpackRunMessage( output );
                        break;
                    case MessageTypes.MSG_DISCARD_ALL:
                        unpackDiscardAllMessage( output );
                        break;
                    case MessageTypes.MSG_PULL_ALL:
                        unpackPullAllMessage( output );
                        break;
                    case MessageTypes.MSG_RECORD:
                        unpackRecordMessage( output );
                        break;
                    case MessageTypes.MSG_SUCCESS:
                        unpackSuccessMessage( output );
                        break;
                    case MessageTypes.MSG_FAILURE:
                        unpackFailureMessage( output );
                        break;
                    case MessageTypes.MSG_ACK_FAILURE:
                        unpackAckFailureMessage( output );
                        break;
                    case MessageTypes.MSG_IGNORED:
                        unpackIgnoredMessage( output );
                        break;
                    case MessageTypes.MSG_INITIALIZE:
                        unpackInitializeMessage( output );
                        break;
                    default:
                        throw new NDPIOException( Status.Request.Invalid,
                                "0x" + Integer.toHexString(type) + " is not a valid message type." );
                    }
                }
                catch( PackStream.PackstreamException e )
                {
                    throw new NDPIOException( Status.Request.InvalidFormat,
                            "Unable to read " + messageTypeName (type) + " message. " +
                            "Error was: " + e.getMessage() );
                }
            }
            catch( PackStream.PackstreamException e )
            {
                throw new NDPIOException( Status.Request.InvalidFormat, "Unable to read message type. " +
                        "Error was: " + e.getMessage() );
            }
        }

        private <E extends Exception> void unpackAckFailureMessage( MessageHandler<E> output )
                throws E
        {
            output.handleAckFailureMessage();
        }

        private <E extends Exception> void unpackSuccessMessage( MessageHandler<E> output )
                throws E, IOException
        {
            Map<String,Object> map = unpackRawMap();
            output.handleSuccessMessage( map );
        }

        private <E extends Exception> void unpackFailureMessage( MessageHandler<E> output )
                throws E, IOException
        {
            Map<String,Object> map = unpackRawMap();

            String codeStr = map.containsKey( "code" ) ?
                             (String) map.get( "code" ) :
                             Status.General.UnknownFailure.name();

            String msg = map.containsKey( "message" ) ?
                         (String) map.get( "message" ) :
                         "<No message supplied>";

            output.handleFailureMessage( codeFromString( codeStr ), msg );
        }

        private <E extends Exception> void unpackIgnoredMessage( MessageHandler<E> output )
                throws E
        {
            output.handleIgnoredMessage();
        }

        private <E extends Exception> void unpackRecordMessage( MessageHandler<E> output )
                throws E, IOException
        {
            long length = unpacker.unpackListHeader();
            final Object[] fields = new Object[(int) length];
            for ( int i = 0; i < length; i++ )
            {
                fields[i] = unpackValue();
            }
            output.handleRecordMessage( record( fields ) );
        }

        private <E extends Exception> void unpackRunMessage( MessageHandler<E> output )
                throws E, IOException
        {
            String statement = unpacker.unpackString();
            Map<String,Object> params = unpackRawMap();
            output.handleRunMessage( statement, params );
        }

        private <E extends Exception> void unpackDiscardAllMessage( MessageHandler<E> output )
                throws E, IOException
        {
            output.handleDiscardAllMessage();
        }

        private <E extends Exception> void unpackPullAllMessage( MessageHandler<E> output )
                throws E, IOException
        {
            output.handlePullAllMessage();
        }

        private <E extends Exception> void unpackInitializeMessage( MessageHandler<E> output ) throws IOException, E
        {
            String clientName = unpacker.unpackString();
            output.handleInitializeMessage( clientName );
        }

        private Map<String,Object> unpackRawMap() throws IOException
        {
            int size = (int) unpacker.unpackMapHeader();
            if ( size == 0 )
            {
                return Collections.emptyMap();
            }
            Map<String,Object> map = new HashMap<>( size, 1 );
            for ( int i = 0; i < size; i++ )
            {
                String key = unpacker.unpackString();
                map.put( key, unpackValue() );
            }
            return map;
        }

        private Object unpackValue() throws IOException
        {
            PackType valType = unpacker.peekNextType();
            switch ( valType )
            {
            case TEXT:
                return unpacker.unpackString();
            case INTEGER:
                return unpacker.unpackLong();
            case FLOAT:
                return unpacker.unpackDouble();
            case BOOLEAN:
                return unpacker.unpackBoolean();
            case NULL:
                // still need to move past the null value
                unpacker.unpackNull();
                return null;
            case LIST:
            {
                int size = (int) unpacker.unpackListHeader();
                if ( size == 0 )
                {
                    return Collections.EMPTY_LIST;
                }
                ArrayList<Object> vals = new ArrayList<>( size );
                for ( int j = 0; j < size; j++ )
                {
                    vals.add( unpackValue() );
                }
                return vals;
            }
            case MAP:
            {
                int size = (int) unpacker.unpackMapHeader();
                if ( size == 0 )
                {
                    return Collections.EMPTY_MAP;
                }
                Map<String,Object> map = new HashMap<>( size, 1 );
                for ( int j = 0; j < size; j++ )
                {
                    String key = unpacker.unpackString();
                    Object val = unpackValue();
                    map.put( key, val );
                }
                return map;
            }
            case STRUCT:
            {
                unpacker.unpackStructHeader();
                char signature = unpacker.unpackStructSignature();
                switch ( signature )
                {
                case NODE:
                {
                    String urn = unpacker.unpackString();

                    int numLabels = (int) unpacker.unpackListHeader();
                    List<Label> labels;
                    if ( numLabels > 0 )
                    {
                        labels = new ArrayList<>( numLabels );
                        for ( int i = 0; i < numLabels; i++ )
                        {
                            labels.add( DynamicLabel.label( unpacker.unpackString() ) );
                        }
                    }
                    else
                    {
                        labels = Collections.emptyList();
                    }

                    Map<String,Object> props = unpackProperties();

                    return new ValueNode( parseId( urn ), labels, props );
                }
                case RELATIONSHIP:
                {
                    String urn = unpacker.unpackString();
                    String startUrn = unpacker.unpackString();
                    String endUrn = unpacker.unpackString();
                    String relTypeName = unpacker.unpackString();

                    Map<String,Object> props = unpackProperties();

                    long relId = parseId( urn );
                    long startNodeId = parseId( startUrn );
                    long endNodeId = parseId( endUrn );
                    RelationshipType relType = DynamicRelationshipType.withName( relTypeName );

                    return new ValueRelationship( relId, startNodeId, endNodeId, relType, props );
                }
                case PATH:
                {
                    int length = (int) unpacker.unpackListHeader();
                    // Note, this obviously assumes blindly that the client will send us paths of manageble sizes,
                    // opening
                    // the door for a bad client to make us allocate a ton of extra RAM. The assumption here is that
                    // the client has gone through a handshake and we trust her. That said, this is still wasteful, so
                    // look into more efficient ways to handle this if we ever take paths as input arguments.
                    PropertyContainer[] entities = new PropertyContainer[length];
                    for ( int i = 0; i < length; i++ )
                    {
                        entities[i] = (PropertyContainer) unpackValue();
                    }
                    return new ValuePath( entities );
                }
                default:
                    throw new NDPIOException( Status.Request.InvalidFormat, "Unknown struct type: " + signature );
                }
            }
            default:
                throw new NDPIOException( Status.Request.InvalidFormat, "Unknown value type: " + valType );
            }
        }

        private Map<String,Object> unpackProperties() throws IOException
        {
            int numProps = (int) unpacker.unpackMapHeader();
            Map<String,Object> map;
            if ( numProps > 0 )
            {
                map = new HashMap<>( numProps, 1 );
                for ( int j = 0; j < numProps; j++ )
                {
                    String key = unpacker.unpackString();
                    Object val = unpackValue();
                    map.put( key, val );
                }
            }
            else
            {
                map = Collections.EMPTY_MAP;
            }
            return map;
        }
    }
}


File: community/ndp/messaging-v1/src/main/java/org/neo4j/ndp/messaging/v1/infrastructure/ValueNode.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1.infrastructure;

import java.util.List;
import java.util.Map;

import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Label;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.RelationshipType;
import org.neo4j.graphdb.ReturnableEvaluator;
import org.neo4j.graphdb.StopEvaluator;
import org.neo4j.graphdb.Traverser;

public class ValueNode implements Node
{
    private final long id;
    private final List<Label> labels;
    private final Map<String,Object> props;

    public ValueNode( long id, List<Label> labels, Map<String,Object> props )
    {
        this.id = id;
        this.labels = labels;
        this.props = props;
    }

    @Override
    public long getId()
    {
        return id;
    }

    @Override
    public Iterable<Label> getLabels()
    {
        return labels;
    }

    @Override
    public Object getProperty( String s )
    {
        return props.get( s );
    }

    @Override
    public Iterable<String> getPropertyKeys()
    {
        return props.keySet();
    }

    @Override
    public void delete()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> getRelationships()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasRelationship()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> getRelationships( RelationshipType... relationshipTypes )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> getRelationships( Direction direction, RelationshipType... relationshipTypes )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasRelationship( RelationshipType... relationshipTypes )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasRelationship( Direction direction, RelationshipType... relationshipTypes )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> getRelationships( Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasRelationship( Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> getRelationships( RelationshipType relationshipType, Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasRelationship( RelationshipType relationshipType, Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Relationship getSingleRelationship( RelationshipType relationshipType, Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Relationship createRelationshipTo( Node node, RelationshipType relationshipType )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<RelationshipType> getRelationshipTypes()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getDegree()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getDegree( RelationshipType relationshipType )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getDegree( Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public int getDegree( RelationshipType relationshipType, Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Traverser traverse( Traverser.Order order, StopEvaluator stopEvaluator,
            ReturnableEvaluator returnableEvaluator, RelationshipType relationshipType, Direction direction )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Traverser traverse( Traverser.Order order, StopEvaluator stopEvaluator,
            ReturnableEvaluator returnableEvaluator, RelationshipType relationshipType, Direction direction,
            RelationshipType relationshipType2, Direction direction2 )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Traverser traverse( Traverser.Order order, StopEvaluator stopEvaluator,
            ReturnableEvaluator returnableEvaluator, Object... objects )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public void addLabel( Label label )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public void removeLabel( Label label )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasLabel( Label label )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public GraphDatabaseService getGraphDatabase()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasProperty( String s )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Object getProperty( String s, Object o )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setProperty( String s, Object o )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Object removeProperty( String s )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        ValueNode valueNode = (ValueNode) o;

        return id == valueNode.id && labels.equals( valueNode.labels );

    }

    @Override
    public int hashCode()
    {
        int result = (int) (id ^ (id >>> 32));
        result = 31 * result + labels.hashCode();
        result = 31 * result + props.hashCode();
        return result;
    }

    @Override
    public String toString()
    {
        return "ValueNode{" +
               "id=" + id +
               ", labels=" + labels +
               ", props=" + props +
               '}';
    }
}


File: community/ndp/messaging-v1/src/main/java/org/neo4j/ndp/messaging/v1/infrastructure/ValuePath.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1.infrastructure;

import java.util.Arrays;
import java.util.Iterator;

import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Path;
import org.neo4j.graphdb.PropertyContainer;
import org.neo4j.graphdb.Relationship;

public class ValuePath implements Path
{
    private final PropertyContainer[] entities;

    public ValuePath( PropertyContainer... entities )
    {
        this.entities = entities;
    }

    @Override
    public Node startNode()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Node endNode()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Relationship lastRelationship()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> relationships()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Relationship> reverseRelationships()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Node> nodes()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Iterable<Node> reverseNodes()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public int length()
    {
        return (entities.length - 1) / 2;
    }

    @Override
    public Iterator<PropertyContainer> iterator()
    {
        return new Iterator<PropertyContainer>()
        {
            private int idx = 0;

            @Override
            public boolean hasNext()
            {
                return idx < entities.length;
            }

            @Override
            public PropertyContainer next()
            {
                return entities[idx++];
            }

            @Override
            public void remove()
            {

            }
        };
    }

    @Override
    public String toString()
    {
        return "ValuePath{" +
               "entities=" + Arrays.toString( entities ) +
               '}';
    }

    @Override
    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        ValuePath that = (ValuePath) o;

        return Arrays.equals( entities, that.entities );

    }

    @Override
    public int hashCode()
    {
        return Arrays.hashCode( entities );
    }
}


File: community/ndp/messaging-v1/src/main/java/org/neo4j/ndp/messaging/v1/infrastructure/ValueRelationship.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1.infrastructure;

import java.util.Map;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.graphdb.RelationshipType;

public class ValueRelationship implements Relationship
{
    private final long id;
    private final long startNode;
    private final long endNode;
    private final RelationshipType type;
    private final Map<String,Object> props;

    public ValueRelationship( long id, long from, long to, RelationshipType type, Map<String,Object> props )
    {
        this.id = id;
        this.startNode = from;
        this.endNode = to;
        this.type = type;
        this.props = props;
    }

    @Override
    public long getId()
    {
        return id;
    }

    @Override
    public Node getStartNode()
    {
        return new ValueNode( startNode, null, null );
    }

    @Override
    public Node getEndNode()
    {
        return new ValueNode( endNode, null, null );
    }

    @Override
    public Iterable<String> getPropertyKeys()
    {
        return props.keySet();
    }

    @Override
    public Object getProperty( String s )
    {
        return props.get( s );
    }

    @Override
    public RelationshipType getType()
    {
        return type;
    }

    @Override
    public Node getOtherNode( Node node )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Node[] getNodes()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean isType( RelationshipType relationshipType )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public GraphDatabaseService getGraphDatabase()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean hasProperty( String s )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Object getProperty( String s, Object o )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public void setProperty( String s, Object o )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public Object removeProperty( String s )
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public void delete()
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public String toString()
    {
        return "ValueRelationship{" +
               "id=" + id +
               ", startNode=" + startNode +
               ", endNode=" + endNode +
               ", type=" + type +
               ", props=" + props +
               '}';
    }

    @Override
    public boolean equals( Object o )
    {
        if ( this == o )
        {
            return true;
        }
        if ( o == null || getClass() != o.getClass() )
        {
            return false;
        }

        ValueRelationship that = (ValueRelationship) o;

        if ( endNode != that.endNode )
        {
            return false;
        }
        if ( id != that.id )
        {
            return false;
        }
        return startNode == that.startNode &&
               !(type != null ? !type.name().equals( that.type.name() ) : that.type != null);

    }

    @Override
    public int hashCode()
    {
        int result = (int) (id ^ (id >>> 32));
        result = 31 * result + (int) (startNode ^ (startNode >>> 32));
        result = 31 * result + (int) (endNode ^ (endNode >>> 32));
        result = 31 * result + (type != null ? type.hashCode() : 0);
        return result;
    }
}


File: community/ndp/messaging-v1/src/test/java/org/neo4j/ndp/messaging/v1/MessageFormatTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1;

import org.junit.Test;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

import org.neo4j.graphdb.DynamicRelationshipType;
import org.neo4j.kernel.api.exceptions.Status;
import org.neo4j.kernel.impl.util.HexPrinter;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueNode;
import org.neo4j.ndp.messaging.v1.infrastructure.ValuePath;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueRelationship;
import org.neo4j.ndp.messaging.v1.message.AcknowledgeFailureMessage;
import org.neo4j.ndp.messaging.v1.message.DiscardAllMessage;
import org.neo4j.ndp.messaging.v1.message.FailureMessage;
import org.neo4j.ndp.messaging.v1.message.IgnoredMessage;
import org.neo4j.ndp.messaging.v1.message.InitializeMessage;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.ndp.messaging.v1.message.PullAllMessage;
import org.neo4j.ndp.messaging.v1.message.RecordMessage;
import org.neo4j.ndp.messaging.v1.message.RunMessage;
import org.neo4j.ndp.messaging.v1.message.SuccessMessage;
import org.neo4j.packstream.BufferedChannelInput;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;

import static java.util.Arrays.asList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.neo4j.graphdb.DynamicLabel.label;
import static org.neo4j.helpers.collection.MapUtil.map;
import static org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1.Writer.NO_OP;
import static org.neo4j.ndp.runtime.spi.Records.record;

public class MessageFormatTest
{
    @Test
    public void shouldHandleCommonMessages() throws Throwable
    {
        assertSerializes( new RunMessage( "CREATE (n) RETURN åäö" ) );
        assertSerializes( new DiscardAllMessage() );
        assertSerializes( new PullAllMessage() );
        assertSerializes( new RecordMessage( record( 1l, "b", 2l ) ) );
        assertSerializes( new SuccessMessage( new HashMap<String,Object>() ) );
        assertSerializes( new FailureMessage( Status.General.UnknownFailure, "Err" ) );
        assertSerializes( new IgnoredMessage() );
        assertSerializes( new AcknowledgeFailureMessage() );
        assertSerializes( new InitializeMessage("MyClient/1.0") );
    }

    @Test
    public void shouldHandleParameterizedStatements() throws Throwable
    {
        // Given
        Map<String,Object> expected = map( "n", 12l );

        // When
        RunMessage msg = serializeAndDeserialize( new RunMessage( "asd", expected ) );

        // Then
        assertThat( msg.params().entrySet(), equalTo( expected.entrySet() ) );
    }

    @Test
    public void shouldSerializeBasicTypes() throws Throwable
    {
        assertSerializesNeoValue( null );
        assertSerializesNeoValue( true );
        assertSerializesNeoValue( false );

        assertSerializesNeoValue( Long.MAX_VALUE );
        assertSerializesNeoValue( 1337l );
        assertSerializesNeoValue( Long.MIN_VALUE );

        assertSerializesNeoValue( Double.MIN_VALUE );
        assertSerializesNeoValue( 13.37d );
        assertSerializesNeoValue( Double.MAX_VALUE );

        assertSerializesNeoValue( "" );
        assertSerializesNeoValue( "A basic piece of text" );
        assertSerializesNeoValue( new String( new byte[16000], StandardCharsets.UTF_8 ) );

        assertSerializesNeoValue( asList() );
        assertSerializesNeoValue( asList( null, null ) );
        assertSerializesNeoValue( asList( true, false ) );
        assertSerializesNeoValue( asList( "one", "", "three" ) );
        assertSerializesNeoValue( asList( 12.4d, 0.0d ) );

        assertSerializesNeoValue( map( "k", null ) );
        assertSerializesNeoValue( map( "k", true ) );
        assertSerializesNeoValue( map( "k", false ) );
        assertSerializesNeoValue( map( "k", 1337l ) );
        assertSerializesNeoValue( map( "k", 133.7d ) );
        assertSerializesNeoValue( map( "k", "Hello" ) );
        assertSerializesNeoValue( map( "k", asList( "one", "", "three" ) ) );
    }

    @Test
    public void shouldSerializeNode() throws Throwable
    {
        assertSerializesNeoValue( new ValueNode( 12l, asList( label( "User" ), label( "Banana" ) ),
                map( "name", "Bob", "age", 14 ) ) );
    }

    @Test
    public void shouldSerializeRelationship() throws Throwable
    {
        assertSerializesNeoValue( new ValueRelationship( 12l, 1l, 2l, DynamicRelationshipType.withName( "KNOWS" ),
                map( "name", "Bob", "age", 14 ) ) );
    }

    @Test
    public void shouldSerializePath() throws Throwable
    {
        assertSerializesNeoValue( new ValuePath(
                new ValueNode( 12l, asList( label( "User" ), label( "Banana" ) ),
                        map( "name", "Bob", "age", 14 ) ),
                new ValueRelationship( 1l, 12l, 13l, DynamicRelationshipType.withName( "KNOWS" ),
                        map( "name", "Bob", "age", 14 ) ),
                new ValueNode( 13l, asList( label( "User" ), label( "Banana" ) ),
                        map( "name", "Bob", "age", new int[]{1, 2, 3} ) )
        ) );
    }

    private void assertSerializes( Message msg ) throws IOException
    {
        assertThat( serializeAndDeserialize( msg ), equalTo( msg ) );
    }

    private <T extends Message> T serializeAndDeserialize( T msg ) throws IOException
    {
        RecordingByteChannel channel = new RecordingByteChannel();
        MessageFormat.Reader reader = new PackStreamMessageFormatV1.Reader(
                new PackStream.Unpacker( new BufferedChannelInput( 16 ).reset( channel ) ) );
        MessageFormat.Writer writer = new PackStreamMessageFormatV1.Writer(
                new PackStream.Packer( new BufferedChannelOutput( channel ) ), NO_OP );

        writer.write( msg ).flush();

        channel.eof();
        return unpack( reader, channel );
    }

    private <T extends Message> T unpack( MessageFormat.Reader reader, RecordingByteChannel channel )
    {
        // Unpack
        String serialized = HexPrinter.hex( channel.getBytes() );
        RecordingMessageHandler messages = new RecordingMessageHandler();
        try
        {
            reader.read( messages );
        }
        catch ( Throwable e )
        {
            throw new AssertionError( "Failed to unpack message, wire data was:\n" + serialized + "[" + channel
                    .getBytes().length + "b]", e );
        }

        return (T) messages.asList().get( 0 );
    }

    private void assertSerializesNeoValue( Object val ) throws IOException
    {
        assertSerializes( new RecordMessage( record( val ) ) );
    }

}


File: community/ndp/messaging-v1/src/test/java/org/neo4j/ndp/messaging/v1/util/MessageMatchers.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.messaging.v1.util;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.neo4j.kernel.api.exceptions.Status;
import org.neo4j.kernel.impl.util.HexPrinter;
import org.neo4j.ndp.messaging.v1.MessageFormat;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.RecordingMessageHandler;
import org.neo4j.ndp.messaging.v1.message.FailureMessage;
import org.neo4j.ndp.messaging.v1.message.IgnoredMessage;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.ndp.messaging.v1.message.RecordMessage;
import org.neo4j.ndp.messaging.v1.message.SuccessMessage;
import org.neo4j.packstream.BufferedChannelInput;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;
import org.neo4j.ndp.runtime.spi.Record;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertThat;
import static org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1.Writer.NO_OP;

public class MessageMatchers
{

    public static Matcher<List<Message>> equalsMessages( final Matcher<Message>... messageMatchers )
    {
        return new TypeSafeMatcher<List<Message>>()
        {
            @Override
            protected boolean matchesSafely( List<Message> messages )
            {
                if ( messageMatchers.length != messages.size() )
                {
                    return false;
                }
                for ( int i = 0; i < messageMatchers.length; i++ )
                {
                    if ( !messageMatchers[i].matches( messages.get( i ) ) ) { return false; }
                }
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendList( "MessageList[", ", ", "]", Arrays.asList( messageMatchers
                ) );
            }
        };
    }

    public static Matcher<Message> msgSuccess( final Map<String,Object> metadata )
    {
        return new TypeSafeMatcher<Message>()
        {
            @Override
            protected boolean matchesSafely( Message t )
            {
                assertThat( t, instanceOf( SuccessMessage.class ) );
                assertThat( ((SuccessMessage) t).meta(), equalTo( metadata ) );
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "SUCCESS" );
            }
        };
    }

    public static Matcher<Message> msgSuccess()
    {
        return new TypeSafeMatcher<Message>()
        {
            @Override
            protected boolean matchesSafely( Message t )
            {
                assertThat( t, instanceOf( SuccessMessage.class ) );
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "SUCCESS" );
            }
        };
    }

    public static Matcher<Message> msgIgnored()
    {
        return new TypeSafeMatcher<Message>()
        {
            @Override
            protected boolean matchesSafely( Message t )
            {
                assertThat( t, instanceOf( IgnoredMessage.class ) );
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "SUCCESS" );
            }
        };
    }

    public static Matcher<Message> msgFailure( final Status status, final String message )
    {
        return new TypeSafeMatcher<Message>()
        {
            @Override
            protected boolean matchesSafely( Message t )
            {
                assertThat( t, instanceOf( FailureMessage.class ) );
                FailureMessage msg = (FailureMessage) t;
                assertThat( msg.status(), equalTo( status ) );
                assertThat( msg.message(), equalTo( message ) );
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "SUCCESS" );
            }
        };
    }

    public static Matcher<Message> msgRecord( final Matcher<Record> matcher )
    {
        return new TypeSafeMatcher<Message>()
        {
            @Override
            protected boolean matchesSafely( Message t )
            {
                assertThat( t, instanceOf( RecordMessage.class ) );

                RecordMessage msg = (RecordMessage) t;
                assertThat( msg.record(), matcher );
                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "RECORD " );
                description.appendDescriptionOf( matcher );
            }
        };
    }

    public static byte[] serialize( Message... messages ) throws IOException
    {
        final RecordingByteChannel rawData = new RecordingByteChannel();
        final MessageFormat.Writer packer = new PackStreamMessageFormatV1.Writer( new PackStream.Packer( new
                BufferedChannelOutput( rawData )), NO_OP );

        for ( Message message : messages )
        {
            packer.write( message );
        }
        packer.flush();

        return rawData.getBytes();
    }

    public static List<Message> messages( byte[] bytes ) throws IOException
    {
        PackStreamMessageFormatV1.Reader unpacker = reader( bytes );
        RecordingMessageHandler consumer = new RecordingMessageHandler();

        try
        {
            while ( unpacker.hasNext() )
            {
                unpacker.read( consumer );
            }

            return consumer.asList();
        }
        catch ( Throwable e )
        {
            throw new IOException( "Failed to deserialize response, '" + e.getMessage() + "'. Messages read so " +
                                   "far: \n" + consumer.asList() + "\n" +
                                   "Raw data: \n" +
                                   HexPrinter.hex( bytes ) );
        }
    }

    public static Message message( byte[] bytes ) throws IOException
    {
        PackStreamMessageFormatV1.Reader unpacker = reader( bytes );
        RecordingMessageHandler consumer = new RecordingMessageHandler();

        try
        {
            if ( unpacker.hasNext() )
            {
                unpacker.read( consumer );
                return consumer.asList().get( 0 );
            }

            throw new IllegalArgumentException( "Expected a message in " + HexPrinter.hex( bytes ) );
        }
        catch ( Throwable e )
        {
            throw new IOException( "Failed to deserialize response, '" + e.getMessage() + "'. Messages read so " +
                                   "far: \n" + consumer.asList() + "\n" +
                                   "Raw data: \n" +
                                   HexPrinter.hex( bytes ), e );
        }
    }

    private static PackStreamMessageFormatV1.Reader reader( byte[] bytes )
    {
        return new PackStreamMessageFormatV1.Reader(
                    new PackStream.Unpacker( new BufferedChannelInput( 128 ).reset( new ArrayByteChannel( bytes ) ) ) );
    }

}


File: community/ndp/packstream-v1/src/main/java/org/neo4j/packstream/PackStream.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.packstream;

import java.io.IOException;
import java.nio.charset.Charset;

/**
 * PackStream is a messaging serialisation format heavily inspired by MessagePack.
 * The key differences are in the type system itself which (among other things) replaces extensions with structures.
 * The Packer and Unpacker implementations are also faster than their MessagePack counterparts.
 * <p/>
 * Note that several marker byte values are RESERVED for future use.
 * Extra markers should <em>not</em> be added casually and such additions must be follow a strict process involving both
 * client and server software.
 * <p/>
 * The table below shows all allocated marker byte values.
 * <p/>
 * <table>
 * <tr><th>Marker</th><th>Binary</th><th>Type</th><th>Description</th></tr>
 * <tr><td><code>00..7F</code></td><td><code>0xxxxxxx</code></td><td>+TINY_INT</td><td>Integer 0 to 127</td></tr>
 * <tr><td><code>80..8F</code></td><td><code>1000xxxx</code></td><td>TINY_TEXT</td><td></td></tr>
 * <tr><td><code>90..9F</code></td><td><code>1001xxxx</code></td><td>TINY_LIST</td><td></td></tr>
 * <tr><td><code>A0..AF</code></td><td><code>1010xxxx</code></td><td>TINY_MAP</td><td></td></tr>
 * <tr><td><code>B0..BF</code></td><td><code>1011xxxx</code></td><td>TINY_STRUCT</td><td></td></tr>
 * <tr><td><code>C0</code></td><td><code>11000000</code></td><td>NULL</td><td></td></tr>
 * <tr><td><code>C1</code></td><td><code>11000001</code></td><td>FLOAT_64</td><td>64-bit floating point number
 * (double)</td></tr>
 * <tr><td><code>C2</code></td><td><code>11000010</code></td><td>FALSE</td><td>Boolean false</td></tr>
 * <tr><td><code>C3</code></td><td><code>11000011</code></td><td>TRUE</td><td>Boolean true</td></tr>
 * <tr><td><code>C4..C7</code></td><td><code>110001xx</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>C8</code></td><td><code>11001000</code></td><td>INT_8</td><td>8-bit signed integer</td></tr>
 * <tr><td><code>C9</code></td><td><code>11001001</code></td><td>INT_8</td><td>16-bit signed integer</td></tr>
 * <tr><td><code>CA</code></td><td><code>11001010</code></td><td>INT_8</td><td>32-bit signed integer</td></tr>
 * <tr><td><code>CB</code></td><td><code>11001011</code></td><td>INT_8</td><td>64-bit signed integer</td></tr>
 * <tr><td><code>CC</code></td><td><code>11001100</code></td><td>BYTES_8</td><td>Byte string (fewer than 2<sup>8</sup>
 * bytes)</td></tr>
 * <tr><td><code>CD</code></td><td><code>11001101</code></td><td>BYTES_16</td><td>Byte string (fewer than 2<sup>16</sup>
 * bytes)</td></tr>
 * <tr><td><code>CE</code></td><td><code>11001110</code></td><td>BYTES_32</td><td>Byte string (fewer than 2<sup>32</sup>
 * bytes)</td></tr>
 * <tr><td><code>CF</code></td><td><code>11001111</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>D0</code></td><td><code>11010000</code></td><td>TEXT_8</td><td>UTF-8 encoded text string (fewer than
 * 2<sup>8</sup> bytes)</td></tr>
 * <tr><td><code>D1</code></td><td><code>11010001</code></td><td>TEXT_16</td><td>UTF-8 encoded text string (fewer than
 * 2<sup>16</sup> bytes)</td></tr>
 * <tr><td><code>D2</code></td><td><code>11010010</code></td><td>TEXT_32</td><td>UTF-8 encoded text string (fewer than
 * 2<sup>32</sup> bytes)</td></tr>
 * <tr><td><code>D3</code></td><td><code>11010011</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>D4</code></td><td><code>11010100</code></td><td>LIST_8</td><td>List (fewer than 2<sup>8</sup>
 * items)</td></tr>
 * <tr><td><code>D5</code></td><td><code>11010101</code></td><td>LIST_16</td><td>List (fewer than 2<sup>16</sup>
 * items)</td></tr>
 * <tr><td><code>D6</code></td><td><code>11010110</code></td><td>LIST_32</td><td>List (fewer than 2<sup>32</sup>
 * items)</td></tr>
 * <tr><td><code>D7</code></td><td><code>11010111</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>D8</code></td><td><code>11011000</code></td><td>MAP_8</td><td>Map (fewer than 2<sup>8</sup> key:value
 * pairs)</td></tr>
 * <tr><td><code>D9</code></td><td><code>11011001</code></td><td>MAP_16</td><td>Map (fewer than 2<sup>16</sup> key:value
 * pairs)</td></tr>
 * <tr><td><code>DA</code></td><td><code>11011010</code></td><td>MAP_32</td><td>Map (fewer than 2<sup>32</sup> key:value
 * pairs)</td></tr>
 * <tr><td><code>DB</code></td><td><code>11011011</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>DC</code></td><td><code>11011100</code></td><td>STRUCT_8</td><td>Structure (fewer than 2<sup>8</sup>
 * fields)</td></tr>
 * <tr><td><code>DD</code></td><td><code>11011101</code></td><td>STRUCT_16</td><td>Structure (fewer than 2<sup>16</sup>
 * fields)</td></tr>
 * <tr><td><code>DE</code></td><td><code>11011110</code></td><td>STRUCT_32</td><td>Structure (fewer than 2<sup>32</sup>
 * fields)</td></tr>
 * <tr><td><code>DF</code></td><td><code>11011111</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>E0..EF</code></td><td><code>1110xxxx</code></td><td><em>RESERVED</em></td><td></td></tr>
 * <tr><td><code>F0..FF</code></td><td><code>1111xxxx</code></td><td>-TINY_INT</td><td>Integer -1 to -16</td></tr>
 * </table>
 */
public class PackStream
{

    public static final byte TINY_TEXT = (byte) 0x80;
    public static final byte TINY_LIST = (byte) 0x90;
    public static final byte TINY_MAP = (byte) 0xA0;
    public static final byte TINY_STRUCT = (byte) 0xB0;
    public static final byte NULL = (byte) 0xC0;
    public static final byte FLOAT_64 = (byte) 0xC1;
    public static final byte FALSE = (byte) 0xC2;
    public static final byte TRUE = (byte) 0xC3;
    public static final byte RESERVED_C4 = (byte) 0xC4;
    public static final byte RESERVED_C5 = (byte) 0xC5;
    public static final byte RESERVED_C6 = (byte) 0xC6;
    public static final byte RESERVED_C7 = (byte) 0xC7;
    public static final byte INT_8 = (byte) 0xC8;
    public static final byte INT_16 = (byte) 0xC9;
    public static final byte INT_32 = (byte) 0xCA;
    public static final byte INT_64 = (byte) 0xCB;
    public static final byte BYTES_8 = (byte) 0xCC;
    public static final byte BYTES_16 = (byte) 0xCD;
    public static final byte BYTES_32 = (byte) 0xCE;
    public static final byte RESERVED_CF = (byte) 0xCF;
    public static final byte TEXT_8 = (byte) 0xD0;
    public static final byte TEXT_16 = (byte) 0xD1;
    public static final byte TEXT_32 = (byte) 0xD2;
    public static final byte RESERVED_D3 = (byte) 0xD3;
    public static final byte LIST_8 = (byte) 0xD4;
    public static final byte LIST_16 = (byte) 0xD5;
    public static final byte LIST_32 = (byte) 0xD6;
    public static final byte RESERVED_D7 = (byte) 0xD7;
    public static final byte MAP_8 = (byte) 0xD8;
    public static final byte MAP_16 = (byte) 0xD9;
    public static final byte MAP_32 = (byte) 0xDA;
    public static final byte RESERVED_DB = (byte) 0xDB;
    public static final byte STRUCT_8 = (byte) 0xDC;
    public static final byte STRUCT_16 = (byte) 0xDD;
    public static final byte RESERVED_DE = (byte) 0xDE;
    public static final byte RESERVED_DF = (byte) 0xDF;
    public static final byte RESERVED_E0 = (byte) 0xE0;
    public static final byte RESERVED_E1 = (byte) 0xE1;
    public static final byte RESERVED_E2 = (byte) 0xE2;
    public static final byte RESERVED_E3 = (byte) 0xE3;
    public static final byte RESERVED_E4 = (byte) 0xE4;
    public static final byte RESERVED_E5 = (byte) 0xE5;
    public static final byte RESERVED_E6 = (byte) 0xE6;
    public static final byte RESERVED_E7 = (byte) 0xE7;
    public static final byte RESERVED_E8 = (byte) 0xE8;
    public static final byte RESERVED_E9 = (byte) 0xE9;
    public static final byte RESERVED_EA = (byte) 0xEA;
    public static final byte RESERVED_EB = (byte) 0xEB;
    public static final byte RESERVED_EC = (byte) 0xEC;
    public static final byte RESERVED_ED = (byte) 0xED;
    public static final byte RESERVED_EE = (byte) 0xEE;
    public static final byte RESERVED_EF = (byte) 0xEF;

    private static final long PLUS_2_TO_THE_31 = 2147483648L;
    private static final long PLUS_2_TO_THE_15 = 32768L;
    private static final long PLUS_2_TO_THE_7 = 128L;
    private static final long MINUS_2_TO_THE_4 = -16L;
    private static final long MINUS_2_TO_THE_7 = -128L;
    private static final long MINUS_2_TO_THE_15 = -32768L;
    private static final long MINUS_2_TO_THE_31 = -2147483648L;

    private static final Charset UTF_8 = Charset.forName( "UTF-8" );

    private static final int DEFAULT_BUFFER_CAPACITY = 8192;

    private PackStream()
    {
    }

    public static class Packer
    {
        private PackOutput out;

        public Packer( PackOutput out )
        {
            this.out = out;
        }

        public void flush() throws IOException
        {
            out.flush();
        }

        private void packRaw( byte[] data ) throws IOException
        {
            out.writeBytes( data, 0, data.length );
        }

        public void packNull() throws IOException
        {
            out.writeByte( NULL );
        }

        public void pack( boolean value ) throws IOException
        {
            out.writeByte( value ? TRUE : FALSE );
        }

        public void pack( long value ) throws IOException
        {
            if ( value >= MINUS_2_TO_THE_4 && value < PLUS_2_TO_THE_7 )
            {
                out.writeByte( (byte) value );
            }
            else if ( value >= MINUS_2_TO_THE_7 && value < MINUS_2_TO_THE_4 )
            {
                out.writeByte( INT_8 ).writeByte( (byte)value );
            }
            else if ( value >= MINUS_2_TO_THE_15 && value < PLUS_2_TO_THE_15 )
            {
                out.writeByte( INT_16 ).writeShort( (short) value );
            }
            else if ( value >= MINUS_2_TO_THE_31 && value < PLUS_2_TO_THE_31 )
            {
                out.writeByte( INT_32 ).writeInt( (int) value );
            }
            else
            {
                out.writeByte( INT_64 ).writeLong( value );
            }
        }

        public void pack( double value ) throws IOException
        {
            out.writeByte( FLOAT_64 ).writeDouble( value );
        }

        public void pack( byte[] values ) throws IOException
        {
            if ( values == null ) { packNull(); }
            else
            {
                packBytesHeader( values.length );
                packRaw( values );
            }
        }

        public void pack( String value ) throws IOException
        {
            if ( value == null ) { packNull(); }
            else
            {
                byte[] utf8 = value.getBytes( UTF_8 );
                packTextHeader( utf8.length );
                packRaw( utf8 );
            }
        }

        public void packText( byte[] utf8 ) throws IOException
        {
            if ( utf8 == null ) { packNull(); }
            else
            {
                packTextHeader( utf8.length );
                packRaw( utf8 );
            }
        }

        private void packBytesHeader( int size ) throws IOException
        {
            if ( size <= Byte.MAX_VALUE )
            {
                out.writeShort( (short) (BYTES_8 << 8 | (byte) size) );
            }
            else if ( size <= Short.MAX_VALUE )
            {
                out.writeByte( BYTES_16 ).writeShort( (short) size );
            }
            else
            {
                out.writeByte( BYTES_32 ).writeInt( size );
            }
        }

        private void packTextHeader( int size ) throws IOException
        {
            if ( size < 0x10 )
            {
                out.writeByte( (byte) (TINY_TEXT | size) );
            }
            else if ( size <= Byte.MAX_VALUE )
            {
                out.writeShort( (short) (TEXT_8 << 8 | (byte) size) );
            }
            else if ( size <= Short.MAX_VALUE )
            {
                out.writeByte( TEXT_16 ).writeShort( (short) size );
            }
            else
            {
                out.writeByte( TEXT_32 ).writeInt( size );
            }
        }

        public void packListHeader( int size ) throws IOException
        {
            if ( size < 0x10 )
            {
                out.writeByte( (byte) (TINY_LIST | size) );
            }
            else if ( size <= Byte.MAX_VALUE )
            {
                out.writeShort( (short) (LIST_8 << 8 | (byte) size) );
            }
            else if ( size <= Short.MAX_VALUE )
            {
                out.writeByte( LIST_16 ).writeShort( (short) size );
            }
            else
            {
                out.writeByte( LIST_32 ).writeInt( size );
            }
        }

        public void packMapHeader( int size ) throws IOException
        {
            if ( size < 0x10 )
            {
                out.writeByte( (byte) (TINY_MAP | size) );
            }
            else if ( size <= Byte.MAX_VALUE )
            {
                out.writeShort( (short) (MAP_8 << 8 | (byte) size) );
            }
            else if ( size <= Short.MAX_VALUE )
            {
                out.writeByte( MAP_16 ).writeShort( (short) size );
            }
            else
            {
                out.writeByte( MAP_32 ).writeInt( size );
            }
        }

        public void packStructHeader( int size, byte signature ) throws IOException
        {
            if ( size < 0x10 )
            {
                out.writeShort( (short) ((byte) (TINY_STRUCT | size) << 8 | signature) );
            }
            else if ( size <= Byte.MAX_VALUE )
            {
                out.writeByte( STRUCT_8 ).writeByte( (byte) size ).writeByte( signature );
            }
            else if ( size <= Short.MAX_VALUE )
            {
                out.writeByte( STRUCT_16 ).writeShort( (short) size ).writeByte( signature );
            }
            else
            {
                throw new Overflow( "Structures cannot have more than " + Short.MAX_VALUE + " fields" );
            }
        }

    }

    public static class Unpacker
    {
        private static final byte[] EMPTY_BYTE_ARRAY = {};

        private PackInput in;

        public Unpacker( PackInput in )
        {
            this.in = in;
        }

        public boolean hasNext() throws IOException
        {
            return in.hasMoreData();
        }

        // TODO: This currently returns the number of fields in the struct. In 99% of cases we will look at the struct
        // signature to determine how to read it, suggest we make that what we return here,
        // and have the number of fields available through some alternate optional mechanism.
        public long unpackStructHeader() throws IOException
        {
            final byte markerByte = in.readByte();
            final byte markerHighNibble = (byte) (markerByte & 0xF0);
            final byte markerLowNibble = (byte) (markerByte & 0x0F);

            if ( markerHighNibble == TINY_STRUCT ) { return markerLowNibble; }
            switch ( markerByte )
            {
            case STRUCT_8:
                return unpackUINT8();
            case STRUCT_16:
                return unpackUINT16();
            default:
                throw new Unexpected( PackType.STRUCT, markerByte );
            }
        }

        public char unpackStructSignature() throws IOException
        {
            return (char) in.readByte();
        }

        public long unpackListHeader() throws IOException
        {
            final byte markerByte = in.readByte();
            final byte markerHighNibble = (byte) (markerByte & 0xF0);
            final byte markerLowNibble = (byte) (markerByte & 0x0F);

            if ( markerHighNibble == TINY_LIST ) { return markerLowNibble; }
            switch ( markerByte )
            {
            case LIST_8:
                return unpackUINT8();
            case LIST_16:
                return unpackUINT16();
            case LIST_32:
                return unpackUINT32();
            default:
                throw new Unexpected( PackType.LIST, markerByte);
            }
        }

        public long unpackMapHeader() throws IOException
        {
            final byte markerByte = in.readByte();
            final byte markerHighNibble = (byte) (markerByte & 0xF0);
            final byte markerLowNibble = (byte) (markerByte & 0x0F);

            if ( markerHighNibble == TINY_MAP ) { return markerLowNibble; }
            switch ( markerByte )
            {
            case MAP_8:
                return unpackUINT8();
            case MAP_16:
                return unpackUINT16();
            case MAP_32:
                return unpackUINT32();
            default:
                throw new Unexpected( PackType.MAP, markerByte);
            }
        }

        public long unpackLong() throws IOException
        {
            final byte markerByte = in.readByte();
            if ( markerByte >= MINUS_2_TO_THE_4 ) { return markerByte; }
            switch ( markerByte )
            {
            case INT_8:
                return in.readByte();
            case INT_16:
                return in.readShort();
            case INT_32:
                return in.readInt();
            case INT_64:
                return in.readLong();
            default:
                throw new Unexpected( PackType.INTEGER, markerByte);
            }
        }

        public double unpackDouble() throws IOException
        {
            final byte markerByte = in.readByte();
            if ( markerByte == FLOAT_64 )
            {
                return in.readDouble();
            }
            throw new Unexpected( PackType.FLOAT, markerByte);
        }

        public String unpackString() throws IOException
        {
            return new String( unpackUtf8(), UTF_8 );
        }

        public byte[] unpackBytes() throws IOException
        {
            final byte markerByte = in.readByte();

            switch ( markerByte )
            {
            case BYTES_8:
                return unpackBytes( unpackUINT8() );
            case BYTES_16:
                return unpackBytes( unpackUINT16() );
            case BYTES_32:
            {
                long size = unpackUINT32();
                if ( size <= Integer.MAX_VALUE )
                {
                    return unpackBytes( (int) size );
                }
                else
                {
                    throw new Overflow( "BYTES_32 too long for Java" );
                }
            }
            default:
                throw new Unexpected( PackType.BYTES, markerByte);
            }
        }

        public byte[] unpackUtf8() throws IOException
        {
            final byte markerByte = in.readByte();
            final byte markerHighNibble = (byte) (markerByte & 0xF0);
            final byte markerLowNibble = (byte) (markerByte & 0x0F);

            if ( markerHighNibble == TINY_TEXT ) { return unpackBytes( markerLowNibble ); }
            switch ( markerByte )
            {
            case TEXT_8:
                return unpackBytes( unpackUINT8() );
            case TEXT_16:
                return unpackBytes( unpackUINT16() );
            case TEXT_32:
            {
                long size = unpackUINT32();
                if ( size <= Integer.MAX_VALUE )
                {
                    return unpackBytes( (int) size );
                }
                else
                {
                    throw new Overflow( "TEXT_32 too long for Java" );
                }
            }
            default:
                throw new Unexpected( PackType.TEXT, markerByte);
            }
        }

        public boolean unpackBoolean() throws IOException
        {
            final byte markerByte = in.readByte();
            switch ( markerByte )
            {
            case TRUE:
                return true;
            case FALSE:
                return false;
            default:
                throw new Unexpected( PackType.BOOLEAN, markerByte);
            }
        }

        public void unpackNull() throws IOException
        {
            final byte markerByte = in.readByte();
            assert  markerByte == NULL;
        }

        private int unpackUINT8() throws IOException
        {
            return in.readByte() & 0xFF;
        }

        private int unpackUINT16() throws IOException
        {
            return in.readShort() & 0xFFFF;
        }

        private long unpackUINT32() throws IOException
        {
            return in.readInt() & 0xFFFFFFFFL;
        }

        private byte[] unpackBytes( int size ) throws IOException
        {
            if ( size == 0 )
            {
                return EMPTY_BYTE_ARRAY;
            }

            byte[] heapBuffer = new byte[size];
            in.readBytes( heapBuffer, 0, heapBuffer.length );
            return heapBuffer;
        }

        public PackType peekNextType() throws IOException
        {
            final byte markerByte = in.peekByte();
            return type( markerByte );
        }
    }

    private static PackType type( byte markerByte )
    {
        final byte markerHighNibble = (byte) (markerByte & 0xF0);

        switch ( markerHighNibble )
        {
        case TINY_TEXT:
            return PackType.TEXT;
        case TINY_LIST:
            return PackType.LIST;
        case TINY_MAP:
            return PackType.MAP;
        case TINY_STRUCT:
            return PackType.STRUCT;
        }

        if ( markerByte >= MINUS_2_TO_THE_4 )
        {
            return PackType.INTEGER;
        }

        switch ( markerByte )
        {
        case NULL:
            return PackType.NULL;
        case TRUE:
        case FALSE:
            return PackType.BOOLEAN;
        case FLOAT_64:
            return PackType.FLOAT;
        case BYTES_8:
        case BYTES_16:
        case BYTES_32:
            return PackType.BYTES;
        case TEXT_8:
        case TEXT_16:
        case TEXT_32:
            return PackType.TEXT;
        case LIST_8:
        case LIST_16:
        case LIST_32:
            return PackType.LIST;
        case MAP_8:
        case MAP_16:
        case MAP_32:
            return PackType.MAP;
        case STRUCT_8:
        case STRUCT_16:
            return PackType.STRUCT;
        case INT_8:
        case INT_16:
        case INT_32:
        case INT_64:
            return PackType.INTEGER;
        default:
            return PackType.RESERVED;
        }
    }

    public static class PackstreamException extends IOException
    {
        public PackstreamException( String message )
        {
            super( message );
        }
    }

    public static class EndOfStream extends PackstreamException
    {
        public EndOfStream( String message )
        {
            super( message );
        }
    }

    public static class Overflow extends PackstreamException
    {
        public Overflow( String message )
        {
            super( message );
        }
    }

    public static class Unexpected extends PackstreamException
    {
        public Unexpected( PackType expectedType, byte unexpectedMarkerByte )
        {
            super( "Wrong type received. Expected " + expectedType + ", received: " + type(unexpectedMarkerByte) + " " +
                   "(" + toHexString( unexpectedMarkerByte ) + ").");
        }

        private static String toHexString( byte unexpectedMarkerByte )
        {
            String s = Integer.toHexString( unexpectedMarkerByte );
            if(s.length() > 2)
            {
                s = s.substring( 0, 2 );
            }
            else if(s.length() < 2)
            {
                return "0" + s;
            }
            return "0x" + s;
        }
    }
}


File: community/ndp/packstream-v1/src/test/java/org/neo4j/packstream/PackStreamTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.packstream;

import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static java.util.Arrays.asList;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.junit.Assert.assertEquals;

public class PackStreamTest
{

    public static Map<String,Object> asMap( Object... keysAndValues )
    {
        Map<String,Object> map = new LinkedHashMap<>( keysAndValues.length / 2 );
        String key = null;
        for ( Object keyOrValue : keysAndValues )
        {
            if ( key == null )
            {
                key = keyOrValue.toString();
            }
            else
            {
                map.put( key, keyOrValue );
                key = null;
            }
        }
        return map;
    }

    private static class Machine
    {

        private final ByteArrayOutputStream output;
        private final WritableByteChannel writable;
        private final PackStream.Packer packer;

        public Machine()
        {
            this.output = new ByteArrayOutputStream();
            this.writable = Channels.newChannel( this.output );
            this.packer = new PackStream.Packer( new BufferedChannelOutput( this.writable ) );
        }

        public Machine( int bufferSize )
        {
            this.output = new ByteArrayOutputStream();
            this.writable = Channels.newChannel( this.output );
            this.packer = new PackStream.Packer( new BufferedChannelOutput( this.writable, bufferSize ) );
        }

        public void reset()
        {
            output.reset();
        }

        public byte[] output()
        {
            return output.toByteArray();
        }

        public PackStream.Packer packer()
        {
            return packer;
        }

    }

    private PackStream.Unpacker newUnpacker( byte[] bytes )
    {
        ByteArrayInputStream input = new ByteArrayInputStream( bytes );
        return new PackStream.Unpacker( new BufferedChannelInput( 16 ).reset( Channels.newChannel( input ) ) );
    }

    @Test
    public void testCanPackAndUnpackNull() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        machine.packer().packNull();
        machine.packer().flush();

        // Then
        byte[] bytes = machine.output();
        assertThat( bytes, equalTo( new byte[]{(byte) 0xC0} ) );

        // When
        PackStream.Unpacker unpacker = newUnpacker( bytes );
        unpacker.unpackNull();

        // Then
        // it does not blow up
    }

    @Test
    public void testCanPackAndUnpackTrue() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        machine.packer().pack( true );
        machine.packer().flush();

        // Then
        byte[] bytes = machine.output();
        assertThat( bytes, equalTo( new byte[]{(byte) 0xC3} ) );

        // When
        PackStream.Unpacker unpacker = newUnpacker( bytes );

        // Then
        assertThat( unpacker.unpackBoolean(), equalTo( true ) );

    }

    @Test
    public void testCanPackAndUnpackFalse() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        machine.packer().pack( false );
        machine.packer().flush();

        // Then
        byte[] bytes = machine.output();
        assertThat( bytes, equalTo( new byte[]{(byte) 0xC2} ) );

        // When
        PackStream.Unpacker unpacker = newUnpacker( bytes );

        // Then
        assertThat( unpacker.unpackBoolean(), equalTo( false ) );

    }

    @Test
    public void testCanPackAndUnpackTinyIntegers() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        for ( long i = -16; i < 128; i++ )
        {
            // When
            machine.reset();
            machine.packer().pack( i );
            machine.packer().flush();

            // Then
            byte[] bytes = machine.output();
            assertThat( bytes.length, equalTo( 1 ) );

            // When
            PackStream.Unpacker unpacker = newUnpacker( bytes );

            // Then
            assertThat( unpacker.unpackLong(), equalTo( i ) );
        }
    }

    @Test
    public void testCanPackAndUnpackShortIntegers() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        for ( long i = -32768; i < 32768; i++ )
        {
            // When
            machine.reset();
            machine.packer().pack( i );
            machine.packer().flush();

            // Then
            byte[] bytes = machine.output();
            assertThat( bytes.length, lessThanOrEqualTo( 3 ) );

            // When
            PackStream.Unpacker unpacker = newUnpacker( bytes );

            // Then
            assertThat( unpacker.unpackLong(), equalTo( i ) );
        }
    }

    @Test
    public void testCanPackAndUnpackPowersOfTwoAsIntegers() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        for ( int i = 0; i < 32; i++ )
        {
            long n = (long) Math.pow( 2, i );

            // When
            machine.reset();
            machine.packer().pack( n );
            machine.packer().flush();

            // Then
            long value = newUnpacker( machine.output() ).unpackLong();
            assertThat( value, equalTo( n ) );
        }
    }

    @Test
    public void testCanPackAndUnpackPowersOfTwoPlusABitAsDoubles() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        for ( int i = 0; i < 32; i++ )
        {
            double n = Math.pow( 2, i ) + 0.5;

            // When
            machine.reset();
            machine.packer().pack( n );
            machine.packer().flush();

            double value = newUnpacker( machine.output() ).unpackDouble();

            // Then
            assertThat( value, equalTo( n ) );
        }
    }

    @Test
    public void testCanPackAndUnpackPowersOfTwoMinusABitAsDoubles() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        for ( int i = 0; i < 32; i++ )
        {
            double n = Math.pow( 2, i ) - 0.5;

            // When
            machine.reset();
            machine.packer().pack( n );
            machine.packer().flush();

            // Then
            double value = newUnpacker( machine.output() ).unpackDouble();
            assertThat( value, equalTo( n ) );
        }
    }

    @Test
    public void testCanPackAndUnpackByteArrays() throws Throwable
    {
        // Given
        Machine machine = new Machine( 17000000 );

        for ( int i = 0; i < 24; i++ )
        {
            byte[] array = new byte[(int) Math.pow( 2, i )];

            // When
            machine.reset();
            machine.packer().pack( array );
            machine.packer().flush();

            // Then
            byte[] value = newUnpacker( machine.output() ).unpackBytes();
            assertThat( value, equalTo( array ) );
        }
    }

    @Test
    public void testCanPackAndUnpackStrings() throws Throwable
    {
        // Given
        Machine machine = new Machine( 17000000 );

        for ( int i = 0; i < 24; i++ )
        {
            String string = new String( new byte[(int) Math.pow( 2, i )] );

            // When
            machine.reset();
            machine.packer().pack( string );
            machine.packer().flush();

            // Then
            String value = newUnpacker( machine.output() ).unpackString();
            assertThat( value, equalTo( string ) );
        }
    }

    @Test
    public void testCanPackAndUnpackBytes() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        byte[] bytes = "ABCDEFGHIJ".getBytes();

        // When
        PackStream.Packer packer = machine.packer();
        packer.pack( bytes );
        packer.flush();

        // Then
        byte[] value = newUnpacker( machine.output() ).unpackBytes();
        assertThat( value, equalTo( bytes ) );

    }

    @Test
    public void testCanPackAndUnpackText() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        String abcdefghij = "ABCDEFGHIJ";

        // When
        PackStream.Packer packer = machine.packer();
        packer.pack( abcdefghij );
        packer.flush();

        // Then
        String value = newUnpacker( machine.output() ).unpackString();
        assertThat( value, equalTo( abcdefghij ) );
    }

    @Test
    public void testCanPackAndUnpackTextFromBytes() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        String abcdefghij = "ABCDEFGHIJ";

        // When
        PackStream.Packer packer = machine.packer();
        packer.packText( abcdefghij.getBytes() );
        packer.flush();

        // Then
        String value = newUnpacker( machine.output() ).unpackString();
        assertThat( value, equalTo( abcdefghij ) );
    }

    @Test
    public void testCanPackAndUnpackListInOneCall() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packListHeader( 3 );
        packer.pack( 12 );
        packer.pack( 13 );
        packer.pack( 14 );
        packer.flush();
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then
        assertThat( unpacker.unpackListHeader(), equalTo( 3L ) );

        assertThat( unpacker.unpackLong(), equalTo( 12L ) );
        assertThat( unpacker.unpackLong(), equalTo( 13L ) );
        assertThat( unpacker.unpackLong(), equalTo( 14L ) );
    }

    @Test
    public void testCanPackAndUnpackListOneItemAtATime() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packListHeader( 3 );
        packer.pack( 12 );
        packer.pack( 13 );
        packer.pack( 14 );
        packer.flush();
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then
        assertThat( unpacker.unpackListHeader(), equalTo( 3L ) );

        assertThat( unpacker.unpackLong(), equalTo( 12L ) );
        assertThat( unpacker.unpackLong(), equalTo( 13L ) );
        assertThat( unpacker.unpackLong(), equalTo( 14L ) );
    }

    @Test
    public void testCanPackAndUnpackListOfText() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packListHeader( 3 );
        packer.flush();
        packer.pack( "eins" );
        packer.flush();
        packer.pack( "zwei" );
        packer.flush();
        packer.pack( "drei" );
        packer.flush();
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then
        assertThat( unpacker.unpackListHeader(), equalTo( 3L ) );

        assertThat( unpacker.unpackString(), equalTo( "eins" ) );
        assertThat( unpacker.unpackString(), equalTo( "zwei" ) );
        assertThat( unpacker.unpackString(), equalTo( "drei" ) );
    }

    @Test
    public void testCanPackAndUnpackMap() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packMapHeader( 2 );
        packer.pack( "one" );
        packer.pack( 1 );
        packer.pack( "two" );
        packer.pack( 2 );
        packer.flush();
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then

        assertThat( unpacker.unpackMapHeader(), equalTo( 2L ) );

        assertThat( unpacker.unpackString(), equalTo( "one" ) );
        assertThat( unpacker.unpackLong(), equalTo( 1L ) );
        assertThat( unpacker.unpackString(), equalTo( "two" ) );
        assertThat( unpacker.unpackLong(), equalTo( 2L ) );
    }

    @Test
    public void testCanPackAndUnpackStruct() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packStructHeader( 3, (byte)'N' );
        packer.pack( 12 );
        packer.packListHeader( 2 );
        packer.pack( "Person" );
        packer.pack( "Employee" );
        packer.packMapHeader( 2 );
        packer.pack( "name" );
        packer.pack( "Alice" );
        packer.pack( "age" );
        packer.pack( 33 );
        packer.flush();
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then
        assertThat( unpacker.unpackStructHeader(), equalTo( 3L ) );
        assertThat( unpacker.unpackStructSignature(), equalTo( 'N' ) );

        assertThat( unpacker.unpackLong(), equalTo( 12L ) );

        assertThat( unpacker.unpackListHeader(), equalTo( 2L ) );
        assertThat( unpacker.unpackString(), equalTo( "Person" ) );
        assertThat( unpacker.unpackString(), equalTo( "Employee" ) );

        assertThat( unpacker.unpackMapHeader(), equalTo( 2L ) );
        assertThat( unpacker.unpackString(), equalTo( "name" ) );
        assertThat( unpacker.unpackString(), equalTo( "Alice" ) );
        assertThat( unpacker.unpackString(), equalTo( "age" ) );
        assertThat( unpacker.unpackLong(), equalTo( 33L ) );
    }

    @Test
    public void testCanPackStructIncludingSignature() throws Throwable
    {
        // Given
        Machine machine = new Machine();

        // When
        PackStream.Packer packer = machine.packer();
        packer.packStructHeader( 3,  (byte)'N' );
        packer.pack( 12 );
        packer.packListHeader( 2 );
        packer.pack( "Person" );
        packer.pack( "Employee" );
        packer.packMapHeader( 2 );
        packer.pack( "name" );
        packer.pack( "Alice" );
        packer.pack( "age" );
        packer.pack( 33 );
        packer.flush();

        // Then
        byte[] bytes = machine.output();
        byte[] expected = new byte[]{
                PackStream.TINY_STRUCT | 3,
                'N',
                12,
                PackStream.TINY_LIST | 2,
                PackStream.TINY_TEXT | 6, 'P', 'e', 'r', 's', 'o', 'n',
                PackStream.TINY_TEXT | 8, 'E', 'm', 'p', 'l', 'o', 'y', 'e', 'e',
                PackStream.TINY_MAP | 2,
                PackStream.TINY_TEXT | 4, 'n', 'a', 'm', 'e',
                PackStream.TINY_TEXT | 5, 'A', 'l', 'i', 'c', 'e',
                PackStream.TINY_TEXT | 3, 'a', 'g', 'e',
                33};
        assertThat( bytes, equalTo( expected ) );
    }

    @Test
    public void testCanDoStreamingListUnpacking() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        PackStream.Packer packer = machine.packer();
        packer.packListHeader( 4 );
        packer.pack( 1 );
        packer.pack( 2 );
        packer.pack( 3 );
        packer.packListHeader( 2 );
        packer.pack( 4 );
        packer.pack( 5 );
        packer.flush();

        // When I unpack this value
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then I can do streaming unpacking
        long size = unpacker.unpackListHeader();
        long a = unpacker.unpackLong();
        long b = unpacker.unpackLong();
        long c = unpacker.unpackLong();

        long innerSize = unpacker.unpackListHeader();
        long d = unpacker.unpackLong();
        long e = unpacker.unpackLong();

        // And all the values should be sane
        assertEquals( 4, size );
        assertEquals( 2, innerSize );
        assertEquals( 1, a );
        assertEquals( 2, b );
        assertEquals( 3, c );
        assertEquals( 4, d );
        assertEquals( 5, e );
    }

    @Test
    public void testCanDoStreamingStructUnpacking() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        PackStream.Packer packer = machine.packer();
        packer.packStructHeader( 4,  (byte)'~' );
        packer.pack( 1 );
        packer.pack( 2 );
        packer.pack( 3 );
        packer.packListHeader( 2 );
        packer.pack( 4 );
        packer.pack( 5 );
        packer.flush();

        // When I unpack this value
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then I can do streaming unpacking
        long size = unpacker.unpackStructHeader();
        char signature = unpacker.unpackStructSignature();
        long a = unpacker.unpackLong();
        long b = unpacker.unpackLong();
        long c = unpacker.unpackLong();

        long innerSize = unpacker.unpackListHeader();
        long d = unpacker.unpackLong();
        long e = unpacker.unpackLong();

        // And all the values should be sane
        assertEquals( 4, size );
        assertEquals( '~', signature );
        assertEquals( 2, innerSize );
        assertEquals( 1, a );
        assertEquals( 2, b );
        assertEquals( 3, c );
        assertEquals( 4, d );
        assertEquals( 5, e );
    }

    @Test
    public void testCanDoStreamingMapUnpacking() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        PackStream.Packer packer = machine.packer();
        packer.packMapHeader( 2 );
        packer.pack( "name" );
        packer.pack( "Bob" );
        packer.pack( "cat_ages" );
        packer.packListHeader( 2 );
        packer.pack( 4.3 );
        packer.pack( true );
        packer.flush();

        // When I unpack this value
        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // Then I can do streaming unpacking
        long size = unpacker.unpackMapHeader();
        String k1 = unpacker.unpackString();
        String v1 = unpacker.unpackString();
        String k2 = unpacker.unpackString();

        long innerSize = unpacker.unpackListHeader();
        double d = unpacker.unpackDouble();
        boolean e = unpacker.unpackBoolean();

        // And all the values should be sane
        assertEquals( 2, size );
        assertEquals( 2, innerSize );
        assertEquals( "name", k1 );
        assertEquals( "Bob", v1 );
        assertEquals( "cat_ages", k2 );
        assertEquals( 4.3, d, 0.0001 );
        assertEquals( true, e );
    }

    @Test
    public void handlesDataCrossingBufferBoundaries() throws Throwable
    {
        // Given
        Machine machine = new Machine();
        PackStream.Packer packer = machine.packer();
        packer.pack( Long.MAX_VALUE );
        packer.pack( Long.MAX_VALUE );
        packer.flush();

        ReadableByteChannel ch = Channels.newChannel( new ByteArrayInputStream( machine.output() ) );
        PackStream.Unpacker unpacker = new PackStream.Unpacker( new BufferedChannelInput( 11 ).reset( ch ) );

        // Serialized ch will look like, and misalign with the 11-byte unpack buffer:

        // [XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX][XX]
        //  mkr \___________data______________/ mkr \___________data______________/
        // \____________unpack buffer_________________/

        // When
        long first = unpacker.unpackLong();
        long second = unpacker.unpackLong();

        // Then
        assertEquals( Long.MAX_VALUE, first );
        assertEquals( Long.MAX_VALUE, second );
    }

    @Test
    public void testCanPeekOnNextType() throws Throwable
    {
        // When & Then
        assertPeekType( PackType.TEXT, "a string" );
        assertPeekType( PackType.INTEGER, 123L );
        assertPeekType( PackType.FLOAT, 123.123d );
        assertPeekType( PackType.BOOLEAN, true );
        assertPeekType( PackType.LIST, asList( 1, 2, 3 ) );
        assertPeekType( PackType.MAP, asMap( "l", 3 ) );
    }

    private void assertPeekType( PackType type, Object value ) throws IOException
    {
        // Given
        Machine machine = new Machine();
        PackStream.Packer packer = machine.packer();
        doTheThing( packer, value );
        packer.flush();

        PackStream.Unpacker unpacker = newUnpacker( machine.output() );

        // When & Then
        assertEquals( type, unpacker.peekNextType() );
    }

    private void doTheThing( PackStream.Packer packer, Object value ) throws IOException
    {
        if ( value instanceof String )
        {
            packer.pack( (String) value );
        }
        else if ( value instanceof Long || value instanceof Integer)
        {
            packer.pack( ((Number) value).longValue() );
        }
        else if ( value instanceof Double || value instanceof Float )
        {
            packer.pack( ((Number) value).doubleValue() );
        }
        else if ( value instanceof Boolean )
        {
            packer.pack( (Boolean) value );
        }
        else if ( value instanceof List )
        {
            List list = (List) value;
            packer.packListHeader( list.size() );
            for ( Object o : list )
            {
                doTheThing( packer, o );
            }
        }
        else if ( value instanceof Map )
        {
            Map<?,?> map = (Map<?,?>) value;
            packer.packMapHeader( map.size() );
            for ( Map.Entry<?,?> o : map.entrySet() )
            {
                doTheThing( packer, o.getKey() );
                doTheThing( packer, o.getValue() );
            }
        }
    }
}


File: community/ndp/transport-socket/src/main/java/org/neo4j/ndp/transport/socket/SocketProtocolV1.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicInteger;

import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.logging.Log;
import org.neo4j.ndp.messaging.v1.MessageFormat;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.msgprocess.TransportBridge;
import org.neo4j.ndp.runtime.Session;
import org.neo4j.ndp.runtime.internal.ErrorReporter;
import org.neo4j.ndp.runtime.internal.Neo4jError;
import org.neo4j.packstream.PackStream;
import org.neo4j.udc.UsageData;

import static org.neo4j.ndp.messaging.v1.msgprocess.MessageProcessingCallback.publishError;

/**
 * Implements version one of the Neo4j protocol when transported over a socket. This means this class will handle a
 * simple message framing protocol and forward messages to the messaging protocol implementation, version 1.
 * <p/>
 * Versions of the framing protocol are lock-step with the messaging protocol versioning.
 */
public class SocketProtocolV1 implements SocketProtocol
{
    public static final int VERSION = 1;
    public static final int DEFAULT_BUFFER_SIZE = 8192;

    private final ChunkedInput input;
    private final ChunkedOutput output;

    private final MessageFormat.Reader unpacker;
    private final MessageFormat.Writer packer;

    private final TransportBridge bridge;
    private final Session session;

    private final Log log;
    private final AtomicInteger inFlight = new AtomicInteger( 0 );
    private final ErrorReporter errorReporter;

    // Remembering that the actual work processing is done in threads separate from the IO threads, this callback gets invoked for each
    // completed request on the worker thread. We use it to ensure that we flush outbound buffers when all in-flight messages for a session have been handled.
    private final Runnable onEachCompletedMessage = new Runnable()
    {
        @Override
        public void run()
        {
            onMessageDone();
        }
    };

    public enum State
    {
        AWAITING_CHUNK,
        IN_CHUNK,
        IN_HEADER,
        CLOSED
    }

    private State state = State.AWAITING_CHUNK;
    private int chunkSize = 0;

    public SocketProtocolV1( final LogService logging, Session session, Channel channel, UsageData usageData )
    {
        this.log = logging.getInternalLog( getClass() );
        this.session = session;
        this.errorReporter = new ErrorReporter( logging, usageData );
        this.output = new ChunkedOutput( channel, DEFAULT_BUFFER_SIZE );
        this.input = new ChunkedInput();
        this.packer = new PackStreamMessageFormatV1.Writer( new PackStream.Packer( output ), output );
        this.unpacker = new PackStreamMessageFormatV1.Reader( new PackStream.Unpacker( input ) );
        this.bridge = new TransportBridge( log ).reset( session, packer, onEachCompletedMessage );
    }

    /**
     * Handle an incoming network packet. We currently deal with the chunked input by building up full messages in
     * RAM before we deserialize them. This is fine with most messages, but will become a problem with very large
     * parameters and so on. The next step will be to write a new protocol V1 deserializer that can do incremental
     * deserialization, see the Netty HTTP parser for an example.
     */
    @Override
    public void handle( ChannelHandlerContext channelContext, ByteBuf data )
    {
        try
        {
            while ( data.readableBytes() > 0 )
            {
                switch ( state )
                {
                case AWAITING_CHUNK:
                {
                    if ( data.readableBytes() >= 2 )
                    {
                        // Whole header available, read that
                        chunkSize = data.readUnsignedShort();
                        handleHeader( channelContext );
                    }
                    else
                    {
                        // Only one byte available, read that and wait for the second byte
                        chunkSize = data.readByte() << 8;
                        state = State.IN_HEADER;
                    }
                    break;
                }
                case IN_HEADER:
                {
                    // First header byte read, now we read the next one
                    chunkSize = (chunkSize | data.readByte()) & 0xFFFF;
                    handleHeader( channelContext );
                    break;
                }
                case IN_CHUNK:
                {
                    if ( chunkSize < data.readableBytes() )
                    {
                        // Current packet is larger than current chunk, slice of the chunk
                        input.append( data.readSlice( chunkSize ) );
                        state = State.AWAITING_CHUNK;
                    }
                    else if ( chunkSize == data.readableBytes() )
                    {
                        // Current packet perfectly maps to current chunk
                        input.append( data );
                        state = State.AWAITING_CHUNK;
                        return;
                    }
                    else
                    {
                        // Current packet is smaller than the chunk we're reading, split the current chunk itself up
                        chunkSize -= data.readableBytes();
                        input.append( data );
                        return;
                    }
                    break;
                }
                case CLOSED:
                {
                    // No-op
                    return;
                }
                }
            }
        }
        finally
        {
            data.release();
        }
    }

    @Override
    public int version()
    {
        return VERSION;
    }

    @Override
    public synchronized void close()
    {
        if( state != State.CLOSED )
        {
            state = State.CLOSED;
            input.close();
            session.close();
            output.close();
        }
    }

    public State state()
    {
        return state;
    }

    private void handleHeader( ChannelHandlerContext channelContext )
    {
        if(chunkSize == 0)
        {
            // Message boundary
            processCollectedMessage( channelContext );
            state = State.AWAITING_CHUNK;
        }
        else
        {
            state = State.IN_CHUNK;
        }
    }

    private void processCollectedMessage( final ChannelHandlerContext channelContext )
    {
        try
        {
            onMessageStarted();
            unpacker.read( bridge );
            // onMessageDone() called via onEachCompletedMessage
        }
        catch ( Throwable e )
        {
            handleUnexpectedError( channelContext, e );
        }
        finally
        {
            input.clear();
        }
    }

    private void handleUnexpectedError( ChannelHandlerContext channelContext, Throwable e )
    {
        try
        {
            try
            {
                // TODO: This is dangerousish, since the worker thread may be writing to the packer at the same time. Better have an approach where we can
                // signal to the worker that we are shutting it down because of this error, and it can signal to the client.
                publishError( packer, Neo4jError.from( e ) );
                packer.flush();
            }
            catch ( Throwable e1 )
            {
                log.error( String.format( "Session %s: Secondary error while notifying client of problem: %s",
                        session.key(), e.getMessage() ), e );
            }
            finally
            {
                channelContext.close();
            }
        }
        finally
        {
            close();
        }
    }

    /*
     * Ths methods below are used to track in-flight messages (messages the client has sent us that are waiting to be processed). We use this information
     * to determine when to explicitly flush our output buffers - if there are no more pending messages when a message is done processing, we should flush
     * the buffers for the session.
     */
    private void onMessageStarted()
    {
        inFlight.incrementAndGet();
    }

    private void onMessageDone()
    {
        // If this is the last in-flight message, and we're not in the middle of reading another message over the wire
        if ( inFlight.decrementAndGet() == 0 && state == State.AWAITING_CHUNK )
        {
            try
            {
                // Then flush outbound buffers
                packer.flush();
            }
            catch ( IOException e )
            {
                throw new RuntimeException( e );
            }
        }
    }
}


File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/FragmentedMessageDeliveryTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.Map;

import org.neo4j.kernel.impl.logging.NullLogService;
import org.neo4j.kernel.impl.util.HexPrinter;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.ndp.runtime.Session;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;
import org.neo4j.udc.UsageData;

import static io.netty.buffer.Unpooled.wrappedBuffer;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1.Writer.NO_OP;
import static org.neo4j.ndp.messaging.v1.message.Messages.run;
import static org.neo4j.ndp.transport.socket.SocketProtocolV1.State.AWAITING_CHUNK;

/**
 * This tests network fragmentation of messages. Given a set of messages, it will serialize and chunk the message up
 * to a specified chunk size. Then it will split that data into a specified number of fragments, trying every possible
 * permutation of fragment sizes for the specified number. For instance, assuming an unfragmented message size of 15,
 * and a fragment count of 3, it will create fragment size permutations like:
 * <p/>
 * [1,1,13]
 * [1,2,12]
 * [1,3,11]
 * ..
 * [12,1,1]
 * <p/>
 * For each permutation, it delivers the fragments to the protocol implementation, and asserts the protocol handled
 * them properly.
 */
public class FragmentedMessageDeliveryTest
{
    // Only test one chunk size for now, this can be parameterized to test lots of different ones
    private int chunkSize = 16;

    // Only test messages broken into three fragments for now, this can be parameterized later
    private int numFragments = 3;

    // Only test one message for now. This can be parameterized later to test lots of different ones
    private Message[] messages = new Message[]{run( "Mjölnir" )};

    @Test
    public void testFragmentedMessageDelivery() throws Throwable
    {
        // Given
        byte[] unfragmented = serialize( chunkSize, messages );

        // When & Then
        int n = unfragmented.length;
        for ( int i = 1; i < n - 1; i++ )
        {
            for ( int j = 1; j < n - i; j++ )
            {
                testPermutation( unfragmented, i, j, n - i - j );
            }
        }
    }

    private void testPermutation( byte[] unfragmented, int... sizes )
    {
        int pos = 0;
        ByteBuf[] fragments = new ByteBuf[sizes.length];
        for ( int i = 0; i < sizes.length; i++ )
        {
            fragments[i] = wrappedBuffer( unfragmented, pos, sizes[i] );
            pos += sizes[i];
        }
        testPermutation( unfragmented, fragments );
    }

    private void testPermutation( byte[] unfragmented, ByteBuf[] fragments )
    {
        // Given
        // System.out.println( "Testing fragmentation:" + describeFragments( fragments ) );
        Session sess = mock( Session.class );

        Channel ch = mock( Channel.class );
        when(ch.alloc()).thenReturn( UnpooledByteBufAllocator.DEFAULT );

        ChannelHandlerContext ctx = mock( ChannelHandlerContext.class );
        when(ctx.channel()).thenReturn( ch );

        SocketProtocolV1 protocol = new SocketProtocolV1( NullLogService.getInstance(), sess, ch, new UsageData() );

        // When data arrives split up according to the current permutation
        for ( ByteBuf fragment : fragments )
        {
            fragment.readerIndex( 0 ).retain();
            protocol.handle( ctx, fragment );
        }

        // Then the session should've received the specified messages, and the protocol should be in a nice clean state
        try
        {
            assertEquals( AWAITING_CHUNK, protocol.state() );
            verify( sess ).run( eq( "Mjölnir" ), any( Map.class ), any(), any( Session.Callback.class ) );
        }
        catch ( AssertionError e )
        {
            throw new AssertionError( "Failed to handle fragmented delivery.\n" +
                                      "Messages: " + Arrays.toString( messages ) + "\n" +
                                      "Chunk size: " + chunkSize + "\n" +
                                      "Serialized data delivered in fragments: " + describeFragments( fragments ) +
                                      "\n" +
                                      "Unfragmented data: " + HexPrinter.hex( unfragmented ) + "\n", e );
        }
        finally
        {
            protocol.close(); // To avoid buffer leak errors
        }
    }

    private String describeFragments( ByteBuf[] fragments )
    {
        StringBuilder sb = new StringBuilder();
        for ( int i = 0; i < fragments.length; i++ )
        {
            if ( i > 0 ) { sb.append( "," ); }
            sb.append( fragments[i].capacity() );
        }
        return sb.toString();
    }

    private byte[] serialize( int chunkSize, Message... msgs ) throws IOException
    {
        byte[][] serialized = new byte[msgs.length][];
        for ( int i = 0; i < msgs.length; i++ )
        {
            RecordingByteChannel channel = new RecordingByteChannel();

            PackStreamMessageFormatV1.Writer format = new PackStreamMessageFormatV1.Writer(
                    new PackStream.Packer( new BufferedChannelOutput( channel ) ), NO_OP );
            format.write( msgs[i] ).flush();
            serialized[i] = channel.getBytes();
        }
        return Chunker.chunk( chunkSize, serialized );
    }
}

File: community/ndp/v1-docs/src/test/java/org/neo4j/ndp/docs/v1/DocSerialization.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.docs.v1;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import org.neo4j.kernel.api.exceptions.Status;
import org.neo4j.kernel.impl.util.HexPrinter;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.RecordingMessageHandler;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.ndp.runtime.internal.Neo4jError;
import org.neo4j.ndp.transport.socket.ChunkedInput;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;
import org.neo4j.ndp.runtime.spi.ImmutableRecord;

import static java.util.Arrays.asList;
import static org.neo4j.helpers.collection.MapUtil.map;
import static org.neo4j.ndp.transport.socket.Chunker.chunk;

/**
 * Takes human-readable value descriptions and packs them to binary data, and vice versa.
 * <p/>
 * Examples:
 * <p/>
 * - 1
 * - "hello, world"
 * - RUN "RETURN a", {a:12}
 * - SUCCESS {}
 */
public class DocSerialization
{
    public static byte[] packAndChunk( String value, int chunkSize ) throws IOException
    {
        return chunk( chunkSize, new byte[][]{pack( value )} );
    }

    public static byte[] pack( String value ) throws IOException
    {
        RecordingByteChannel ch = new RecordingByteChannel();
        PackStream.Packer packer = new PackStream.Packer( new BufferedChannelOutput( ch, 128 ) );
        PackStreamMessageFormatV1.Writer writer = new PackStreamMessageFormatV1.Writer( packer, PackStreamMessageFormatV1.Writer.NO_OP );

        pack( value, packer, writer );

        packer.flush();
        return ch.getBytes();
    }

    /**
     * @param value
     * @param packer
     * @param writer a message writer that delegates to the packer, for packing protocol messages
     * @throws IOException
     */
    public static void pack( String value, PackStream.Packer packer, PackStreamMessageFormatV1.Writer writer )
            throws IOException
    {
        // NOTE: This currently has hard-coded handling of specific messages, it did not seem worth the time
        // to write a custom parser for this yet. We may want to come back and do that as the docs evolve.
        if ( value.equalsIgnoreCase( "null" ) )
        {
            packer.packNull();
        }
        else if ( value.equalsIgnoreCase( "true" ) )
        {
            packer.pack( true );
        }
        else if ( value.equalsIgnoreCase( "false" ) )
        {
            packer.pack( false );
        }
        else if ( value.startsWith( "\"" ) )
        {
            packer.pack( value.substring( 1, value.length() - 1 ) );
        }
        else if ( value.startsWith( "[" ) )
        {
            if ( value.equals( "[]" ) )
            {
                packer.packListHeader( 0 );
            }
            else
            {
                String[] values = value.substring( 1, value.length() - 1 ).split( "," );
                packer.packListHeader( values.length );
                for ( String s : values )
                {
                    pack( s, packer, writer );
                }
            }
        }
        else if ( value.startsWith( "{" ) )
        {
            if ( value.equals( "{}" ) )
            {
                packer.packMapHeader( 0 );
            }
            else
            {
                String[] pairs = value.substring( 1, value.length() - 1 ).split( "," );
                packer.packMapHeader( pairs.length );
                for ( String pair : pairs )
                {
                    String[] split = pair.split( ":" );
                    packer.pack(
                            split[0] );  // Key, different from packing value because it doesn't use quotation marks
                    pack( split[1], packer, writer ); // Value
                }
            }
        }
        else if ( value.startsWith( "Struct" ) )
        {
            DocStructExample struct = new DocStructExample( value );
            packer.packStructHeader( struct.size(), (byte)struct.signature() );

            for ( String s : struct )
            {
                pack( s, packer, writer );
            }
        }
        else if ( value.matches( "-?[0-9]+\\.[0-9]+" ) )
        {
            packer.pack( Double.parseDouble( value ) );
        }
        else if ( value.matches( "-?[0-9]+" ) )
        {
            packer.pack( Long.parseLong( value ) );
        }
        else if ( value.equals( "DISCARD_ALL" ) )
        {
            writer.handleIgnoredMessage();
        }
        else if ( value.equals( "PULL_ALL" ) )
        {
            writer.handlePullAllMessage();
        }
        else if ( value.equals( "ACK_FAILURE" ) )
        {
            writer.handleAckFailureMessage();
        }
        else if ( value.equals( "IGNORED" ) ) // kiss..
        {
            writer.handleIgnoredMessage();
        }
        else if ( value.equals( "RUN \"RETURN 1 AS num\" {}" ) ) // kiss..
        {
            writer.handleRunMessage( "RETURN 1 AS num", Collections.<String,Object>emptyMap() );
        }
        else if ( value.equals( "RUN \"This will cause a syntax error\" {}" ) ) // kiss..
        {
            writer.handleRunMessage( "This will cause a syntax error", Collections.<String,Object>emptyMap() );
        }
        else if ( value.equals( "RECORD [1,2,3]" ) ) // kiss..
        {
            writer.handleRecordMessage( new ImmutableRecord( new Object[]{1, 2, 3} ) );
        }
        else if ( value.equals( "RECORD [1]" ) ) // kiss..
        {
            writer.handleRecordMessage( new ImmutableRecord( new Object[]{1} ) );
        }
        else if ( value.equals( "SUCCESS {fields:[\"name\", \"age\"]}" ) ) // kiss..
        {
            writer.handleSuccessMessage( map( "fields", asList( "name", "age" ) ) );
        }
        else if ( value.equals( "SUCCESS { fields: ['num'] }" ) ) // kiss..
        {
            writer.handleSuccessMessage( map( "fields", asList( "num" ) ) );
        }
        else if ( value.equals( "SUCCESS {}" ) ) // kiss..
        {
            writer.handleSuccessMessage( map() );
        }
        else if ( value.equals( "FAILURE {code:\"Neo.ClientError.Statement.InvalidSyntax\", " +
                                "message:\"Invalid syntax.\"}" ) ) // kiss..
        {
            writer.handleFailureMessage(  Status.Statement.InvalidSyntax, "Invalid syntax." );
        }
        else if ( value.equals( "FAILURE {code:\"Neo.ClientError.Statement.InvalidSyntax\"," ) ) // kiss..
        {
            writer.handleFailureMessage(  Status.Statement.InvalidSyntax,
                    "Invalid input 'T': expected <init> (line 1, column 1 (offset: 0))\n" +
                    "\"This will cause a syntax error\"\n" +
                    " ^" );
        }
        else if( value.equals( "INITIALIZE \"MyClient/1.0\"" ))
        {
            writer.handleInitializeMessage( "MyClient/1.0" );
        }
        else
        {
            throw new RuntimeException( "Unknown value: " + value );
        }
    }

    public static List<Message> unpackChunked( byte[] data ) throws Exception
    {
        ChunkedInput input = new ChunkedInput();
        PackStreamMessageFormatV1.Reader reader =
                new PackStreamMessageFormatV1.Reader( new PackStream.Unpacker(  input ) );
        RecordingMessageHandler messages = new RecordingMessageHandler();

        ByteBuf buf = Unpooled.wrappedBuffer( data );
        while ( buf.readableBytes() > 0 )
        {
            int chunkSize = buf.readUnsignedShort();
            if ( chunkSize > 0 )
            {
                input.append( buf.readSlice( chunkSize ) );
            }
            else
            {
                reader.read( messages );
                input.clear();
            }
        }
        return messages.asList();
    }

    public static String normalizedHex( byte[] data )
    {
        return normalizedHex( HexPrinter.hex( data ) );
    }

    /** Convert a hex string into a normalized format for string comparison */
    public static String normalizedHex( String dirtyHex )
    {
        StringBuilder str = new StringBuilder( dirtyHex.replace( "\r", "" ).replace( "\n", "" ).replace( " ", "" ) );
        int idx = str.length() - 2;

        while ( idx > 0 )
        {
            str.insert( idx, " " );
            idx = idx - 2;
        }

        return str.toString().toUpperCase();
    }
}


File: community/ndp/v1-docs/src/test/java/org/neo4j/ndp/docs/v1/DocStruct.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.docs.v1;

import org.jsoup.nodes.Element;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.neo4j.function.Function;

import static java.util.regex.Pattern.CASE_INSENSITIVE;
import static java.util.regex.Pattern.COMMENTS;
import static java.util.regex.Pattern.DOTALL;

/**
 * Node (signature=0x4E) {
 * Identity          identity
 * List<Text>        labels
 * Map<Text, Value>  properties
 * }
 */
public class DocStruct implements Iterable<DocStruct.Field>
{
    public static Function<Element,DocStruct> struct_definition = new Function<Element,DocStruct>()
    {
        @Override
        public DocStruct apply( Element s ) throws RuntimeException
        {
            return new DocStruct( s.text() );
        }
    };

    private final String name;
    private final Map<String,String> attributes;
    private final List<Field> fields;
    private final String raw;

    public static class Field
    {
        private final String typeSignature;
        private final String name;

        public Field( String typeSignature, String name )
        {
            this.typeSignature = typeSignature;
            this.name = name;
        }

        @Override
        public String toString()
        {
            return typeSignature + "  " + name;
        }

        public String type()
        {
            return typeSignature;
        }
    }

    public static final Pattern STRUCT_PATTERN = Pattern.compile(
            "^(?<name>[a-z]+)\\s+                 # StructName \n" +
            "     \\( (?<attrs>[^)]+) \\) \\s*    # (identifier=0x01,..) \n" +
            "\\{                                  # \\{\n" +
            "\\s*    (?<fields>[^\\}]+)           #     Type fieldName..\n" +
            "\\}\\s*                              # \\}\n" +
            "(.*)$" +
            "", CASE_INSENSITIVE | COMMENTS | DOTALL );

    public DocStruct( String structDefinition )
    {
        Matcher matcher = STRUCT_PATTERN.matcher( structDefinition );
        if ( !matcher.matches() )
        {
            throw new RuntimeException( "Unable to parse struct definition: \n" + structDefinition );
        }
        this.raw = structDefinition;
        this.name = matcher.group( "name" );
        this.attributes = parseAttributes( matcher.group( "attrs" ) );
        this.fields = parseFields( matcher.group( "fields" ) );
    }

    public String name()
    {
        return name;
    }

    public String attribute( String key )
    {
        return attributes.get( key );
    }

    @Override
    public Iterator<Field> iterator()
    {
        return fields.iterator();
    }

    private List<Field> parseFields( String raw )
    {
        List<Field> out = new LinkedList<>();
        for ( String s : raw.split( "\n" ) )
        {
            String[] parts = s.trim().split( "\\s+" );
            out.add( new Field( parts[0], parts[1] ) );
        }
        return out;
    }

    public static Map<String,String> parseAttributes( String raw )
    {
        Map<String,String> out = new HashMap<>();
        for ( String attr : raw.split( "," ) )
        {
            String[] split = attr.split( "=" );
            out.put( split[0].trim(), split[1].trim() );
        }
        return out;
    }

    @Override
    public String toString()
    {
        return raw;
    }

    public byte signature()
    {
        return (byte) Integer.parseInt( attribute( "signature" ).substring( 2 ), 16 );
    }

    public int size()
    {
        return fields.size();
    }
}


File: community/ndp/v1-docs/src/test/java/org/neo4j/ndp/docs/v1/NDPMessageStructsDocTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.docs.v1;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;

import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.RecordingMessageHandler;
import org.neo4j.ndp.messaging.v1.util.ArrayByteChannel;
import org.neo4j.packstream.BufferedChannelInput;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;

import static org.junit.Assert.assertEquals;
import static org.neo4j.ndp.docs.v1.DocStruct.struct_definition;
import static org.neo4j.ndp.docs.v1.DocsRepository.docs;

/** This tests that message data structures look the way we say they do */
@RunWith( Parameterized.class )
public class NDPMessageStructsDocTest
{
    @Parameterized.Parameter( 0 )
    public DocStruct struct;

    @Parameterized.Parameters( name = "{0}" )
    public static Collection<Object[]> documentedTypeMapping()
    {
        Collection<Object[]> mappings = new ArrayList<>();

        // Load the documented mappings
        for ( DocStruct struct : docs().read(
                "dev/messaging.asciidoc",
                "code[data-lang=\"ndp_message_struct\"]",
                struct_definition ) )
        {
            mappings.add( new Object[]{struct} );
        }

        return mappings;
    }

    @Test
    public void ensureSerializingMessagesAsDocumentedWorks() throws Throwable
    {
        // Given
        RecordingByteChannel ch = new RecordingByteChannel();
        PackStream.Packer packer = new PackStream.Packer( new BufferedChannelOutput( ch, 128 ) );

        // When I pack a message according to the documentation
        packer.packStructHeader( struct.size(), struct.signature() );
        for ( DocStruct.Field field : struct )
        {
            packValueOf( field.type(), packer );
        }
        packer.flush();

        // Then it should get interpreted as the documented message
        RecordingMessageHandler messages = new RecordingMessageHandler();
        PackStreamMessageFormatV1.Reader reader = new PackStreamMessageFormatV1.Reader(
                new PackStream.Unpacker(
                        new BufferedChannelInput( 128 ).reset( new ArrayByteChannel( ch.getBytes() ) ) ) );
        reader.read( messages );

        // Hello, future traveler. The assertion below is not strictly necessary. What we're trying to do here
        // is simply to ensure that the documented message type is what we get back out when we deserialize, the
        // name of the class does not strictly have to map to the name in the docs, if that is causing you trouble.
        assertEquals( struct.name(), messages.asList().get( 0 ).getClass().getSimpleName() );
    }

    private void packValueOf( String type, PackStream.Packer packer ) throws IOException
    {
        if ( type.equalsIgnoreCase( "Text" ) )
        {
            packer.pack( "Hello, world!" );
        }
        else if ( type.startsWith( "Map" ) )
        {
            packer.packMapHeader( 1 );
            packer.pack( "k" );
            packer.pack( 12345 );
        }
        else if ( type.startsWith( "List" ) )
        {
            packer.packListHeader( 2 );
            packer.pack( 1 );
            packer.pack( 2 );
        }
        else
        {
            throw new RuntimeException( "Unknown type: " + type );
        }
    }
}


File: community/ndp/v1-docs/src/test/java/org/neo4j/ndp/docs/v1/NDPValueDocTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.docs.v1;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;

import org.neo4j.graphdb.DynamicRelationshipType;
import org.neo4j.ndp.messaging.v1.MessageFormat;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueNode;
import org.neo4j.ndp.messaging.v1.infrastructure.ValuePath;
import org.neo4j.ndp.messaging.v1.infrastructure.ValueRelationship;
import org.neo4j.ndp.messaging.v1.message.RecordMessage;
import org.neo4j.ndp.messaging.v1.util.ArrayByteChannel;
import org.neo4j.packstream.BufferedChannelInput;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;
import org.neo4j.packstream.PackType;

import static java.util.Arrays.asList;
import static junit.framework.TestCase.fail;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.neo4j.graphdb.DynamicLabel.label;
import static org.neo4j.helpers.collection.MapUtil.map;
import static org.neo4j.ndp.docs.v1.DocTable.table;
import static org.neo4j.ndp.docs.v1.DocsRepository.docs;
import static org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1.Writer.NO_OP;
import static org.neo4j.ndp.runtime.spi.Records.record;

/** This tests that Neo4j value mappings described in the documentation work the way we say they do. */
@RunWith( Parameterized.class )
public class NDPValueDocTest
{
    @Parameterized.Parameter( 0 )
    public String type;

    @Parameterized.Parameters( name = "{0}" )
    public static Collection<Object[]> documentedTypeMapping()
    {
        Collection<Object[]> mappings = new ArrayList<>();

        // Load the documented mappings
        for ( DocTable.Row row : docs().read( "dev/serialization.asciidoc", "#ndp-type-system-mapping", table )
                .get( 0 ) )
        {
            mappings.add( new Object[]{row.get( 0 )} );
        }

        return mappings;
    }

    @Test
    public void mappingShouldBeCorrect() throws Throwable
    {
        assertThat( serialize( neoValue( type ) ), isPackstreamType( type ) );
    }

    private Matcher<? super byte[]> isPackstreamType( final String packStreamType )
    {
        return new TypeSafeMatcher<byte[]>()
        {
            @Override
            protected boolean matchesSafely( byte[] recordWithValue )
            {
                PackStream.Unpacker unpacker = new PackStream.Unpacker(
                        new BufferedChannelInput( 11 ).reset( new ArrayByteChannel( recordWithValue ) ) );

                try
                {
                    // Wrapped in a "Record" struct
                    unpacker.unpackStructHeader();
                    unpacker.unpackStructSignature();
                    unpacker.unpackListHeader();

                    PackType type = unpacker.peekNextType();
                    if ( type.name().equalsIgnoreCase( "struct" ) )
                    {
                        String structName = null;
                        unpacker.unpackStructHeader();
                        char sig = unpacker.unpackStructSignature();
                        switch ( sig )
                        {
                        case PackStreamMessageFormatV1.NODE:
                            structName = "node";
                            break;
                        case PackStreamMessageFormatV1.RELATIONSHIP:
                            structName = "relationship";
                            break;
                        case PackStreamMessageFormatV1.PATH:
                            structName = "path";
                            break;
                        default:
                            fail( "Unknown struct type: " + sig );
                        }
                        assertThat( structName, equalTo( packStreamType.toLowerCase() ) );
                    }
                    else
                    {
                        assertThat( type.name().toLowerCase(), equalTo( packStreamType.toLowerCase() ) );
                    }
                }
                catch ( IOException e )
                {
                    throw new RuntimeException( e );
                }

                return true;
            }

            @Override
            public void describeTo( Description description )
            {
                description.appendText( "PackStream type " + packStreamType );
            }
        };
    }

    private Object neoValue( String type )
    {
        if ( type.equalsIgnoreCase( "float" ) )
        {
            return 12345.12345d;
        }
        else if ( type.equalsIgnoreCase( "integer" ) )
        {
            return 1337l;
        }
        else if ( type.equalsIgnoreCase( "boolean" ) )
        {
            return true;
        }
        else if ( type.equalsIgnoreCase( "text" ) )
        {
            return "Steven Brookreson";
        }
        else if ( type.equalsIgnoreCase( "list" ) )
        {
            return asList( 1, 2, 3 );
        }
        else if ( type.equalsIgnoreCase( "map" ) )
        {
            return map( "k", 1 );
        }
        else if ( type.equalsIgnoreCase( "node" ) )
        {
            return new ValueNode( 12, asList( label( "User" ) ), map() );
        }
        else if ( type.equalsIgnoreCase( "relationship" ) )
        {
            return new ValueRelationship( 12, 1, 2, DynamicRelationshipType.withName( "KNOWS" ), map() );
        }
        else if ( type.equalsIgnoreCase( "path" ) )
        {
            return new ValuePath();
        }
        else if ( type.equalsIgnoreCase( "null" ) )
        {
            return null;
        }
        else if ( type.equalsIgnoreCase( "identity" ) )
        {
            return null; // TODO: No representation for identity yet
        }
        else
        {
            throw new RuntimeException( "Unknown neo type: " + type );
        }
    }

    private byte[] serialize( Object neoValue ) throws IOException
    {
        RecordingByteChannel channel = new RecordingByteChannel();
        RecordMessage msg = new RecordMessage( record( neoValue ) );
        MessageFormat.Writer writer = new PackStreamMessageFormatV1.Writer(
                new PackStream.Packer( new BufferedChannelOutput( channel ) ), NO_OP );

        writer.write( msg ).flush();

        channel.eof();
        return channel.getBytes();
    }
}
