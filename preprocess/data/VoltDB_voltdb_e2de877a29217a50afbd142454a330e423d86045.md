Refactoring Types: ['Pull Up Method']
patches/Expression.java
/* Copyright (c) 1995-2000, The Hypersonic SQL Group.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the Hypersonic SQL Group nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE HYPERSONIC SQL GROUP,
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * on behalf of the Hypersonic SQL Group.
 *
 *
 * For work added by the HSQL Development Group:
 *
 * Copyright (c) 2001-2009, The HSQL Development Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the HSQL Development Group nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package org.hsqldb_voltpatches;

// A VoltDB extension to transfer Expression structures to the VoltDB planner
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;

/// We DO NOT reorganize imports in hsql code. And we try to keep these structured comment in place.
import java.math.BigDecimal;
import org.hsqldb_voltpatches.types.BinaryData;
import org.hsqldb_voltpatches.types.TimestampData;
import org.hsqldb_voltpatches.types.NumberType;
import org.hsqldb_voltpatches.HSQLInterface.HSQLParseException;
// End of VoltDB extension

import org.hsqldb_voltpatches.HsqlNameManager.SimpleName;
import org.hsqldb_voltpatches.ParserDQL.CompileContext;
import org.hsqldb_voltpatches.lib.ArrayListIdentity;
import org.hsqldb_voltpatches.lib.HsqlArrayList;
import org.hsqldb_voltpatches.lib.HsqlList;
import org.hsqldb_voltpatches.lib.OrderedHashSet;
import org.hsqldb_voltpatches.lib.OrderedIntHashSet;
import org.hsqldb_voltpatches.lib.Set;
import org.hsqldb_voltpatches.persist.PersistentStore;
import org.hsqldb_voltpatches.types.CharacterType;
import org.hsqldb_voltpatches.types.NullType;
import org.hsqldb_voltpatches.types.Type;

/**
 * Expression class.
 *
 * @author Campbell Boucher-Burnett (boucherb@users dot sourceforge.net)
 * @author Fred Toussi (fredt@users dot sourceforge.net)
 * @version 1.9.0
 * @since 1.9.0
 */
public class Expression {

    public static final int LEFT   = 0;
    public static final int RIGHT  = 1;
    public static final int UNARY  = 1;
    public static final int BINARY = 2;

    //
    //
    static final Expression[] emptyExpressionArray = new Expression[]{};

    //
    static final Expression EXPR_TRUE  = new ExpressionLogical(true);
    static final Expression EXPR_FALSE = new ExpressionLogical(false);

    //
    static final OrderedIntHashSet aggregateFunctionSet =
        new OrderedIntHashSet();

    static {
        aggregateFunctionSet.add(OpTypes.COUNT);
        // A VoltDB extension APPROX_COUNT_DISTINCT
        aggregateFunctionSet.add(OpTypes.APPROX_COUNT_DISTINCT);
        // End of VoltDB extension
        aggregateFunctionSet.add(OpTypes.SUM);
        aggregateFunctionSet.add(OpTypes.MIN);
        aggregateFunctionSet.add(OpTypes.MAX);
        aggregateFunctionSet.add(OpTypes.AVG);
        aggregateFunctionSet.add(OpTypes.EVERY);
        aggregateFunctionSet.add(OpTypes.SOME);
        aggregateFunctionSet.add(OpTypes.STDDEV_POP);
        aggregateFunctionSet.add(OpTypes.STDDEV_SAMP);
        aggregateFunctionSet.add(OpTypes.VAR_POP);
        aggregateFunctionSet.add(OpTypes.VAR_SAMP);
    }

    static final OrderedIntHashSet columnExpressionSet =
        new OrderedIntHashSet();

    static {
        columnExpressionSet.add(OpTypes.COLUMN);
    }

    static final OrderedIntHashSet subqueryExpressionSet =
        new OrderedIntHashSet();

    static {
        subqueryExpressionSet.add(OpTypes.ROW_SUBQUERY);
        subqueryExpressionSet.add(OpTypes.TABLE_SUBQUERY);
    }

    static final OrderedIntHashSet subqueryAggregateExpressionSet =
        new OrderedIntHashSet();

    static {
        subqueryAggregateExpressionSet.add(OpTypes.COUNT);
        // A VoltDB extension APPROX_COUNT_DISTINCT
        subqueryAggregateExpressionSet.add(OpTypes.APPROX_COUNT_DISTINCT);
        // End of VoltDB extension
        subqueryAggregateExpressionSet.add(OpTypes.SUM);
        subqueryAggregateExpressionSet.add(OpTypes.MIN);
        subqueryAggregateExpressionSet.add(OpTypes.MAX);
        subqueryAggregateExpressionSet.add(OpTypes.AVG);
        subqueryAggregateExpressionSet.add(OpTypes.EVERY);
        subqueryAggregateExpressionSet.add(OpTypes.SOME);
        subqueryAggregateExpressionSet.add(OpTypes.STDDEV_POP);
        subqueryAggregateExpressionSet.add(OpTypes.STDDEV_SAMP);
        subqueryAggregateExpressionSet.add(OpTypes.VAR_POP);
        subqueryAggregateExpressionSet.add(OpTypes.VAR_SAMP);

        //
        subqueryAggregateExpressionSet.add(OpTypes.TABLE_SUBQUERY);
        subqueryAggregateExpressionSet.add(OpTypes.ROW_SUBQUERY);
    }

    static final OrderedIntHashSet emptyExpressionSet =
        new OrderedIntHashSet();

    // type
    protected int opType;

    // type qualifier
    protected int exprSubType;

    //
    SimpleName alias;

    // aggregate
    protected boolean isAggregate;

    // VALUE
    protected Object       valueData;
    protected Expression[] nodes;
    Type[]                 nodeDataTypes;

    // QUERY - in single value selects, IN, EXISTS etc.
    SubQuery subQuery;

    // for query and value lists, etc
    boolean isCorrelated;

    // for COLUMN
    int columnIndex = -1;

    // data type
    protected Type dataType;

    //
    int     queryTableColumnIndex = -1;    // >= 0 when it is used for order by
    boolean isParam;

    // index of a session-dependent field
    int parameterIndex = -1;

    //
    int rangePosition = -1;

    //
    boolean isColumnEqual;

    Expression(int type) {
        opType = type;
        nodes  = emptyExpressionArray;
    }

    // IN condition optimisation

    /**
     * Creates a SCALAR SUBQUERY expression. Is called as ROW_SUBQUERY
     */
    Expression(int exprType, SubQuery sq) {

        this(OpTypes.TABLE_SUBQUERY);

        subQuery = sq;
    }

    /**
     * ROW or VALUELIST
     */
    Expression(int type, Expression[] list) {

        this(type);

        this.nodes = list;
    }

    public String describe(Session session) {
        return describe(session, 0);
    }

    static String getContextSQL(Expression expression) {

        if (expression == null) {
            return null;
        }

        String ddl = expression.getSQL();

        switch (expression.opType) {

            case OpTypes.VALUE :
            case OpTypes.COLUMN :
            case OpTypes.ROW :
            case OpTypes.FUNCTION :
            case OpTypes.SQL_FUNCTION :
            case OpTypes.ALTERNATIVE :
            case OpTypes.CASEWHEN :
            case OpTypes.CAST :
                return ddl;
        }

        StringBuffer sb = new StringBuffer();

        ddl = sb.append('(').append(ddl).append(')').toString();

        return ddl;
    }

    /**
     * For use with CHECK constraints. Under development.
     *
     * Currently supports a subset of expressions and is suitable for CHECK
     * search conditions that refer only to the inserted/updated row.
     *
     * For full DDL reporting of VIEW select queries and CHECK search
     * conditions, future improvements here are dependent upon improvements to
     * SELECT query parsing, so that it is performed in a number of passes.
     * An early pass should result in the query turned into an Expression tree
     * that contains the information in the original SQL without any
     * alterations, and with tables and columns all resolved. This Expression
     * can then be preserved for future use. Table and column names that
     * are not user-defined aliases should be kept as the HsqlName structures
     * so that table or column renaming is reflected in the precompiled
     * query.
     */
    public String getSQL() {

        StringBuffer sb = new StringBuffer(64);

        switch (opType) {

            case OpTypes.VALUE :
                if (valueData == null) {
                    return Tokens.T_NULL;
                }

                return dataType.convertToSQLString(valueData);

            case OpTypes.ROW :
                sb.append('(');

                for (int i = 0; i < nodes.length; i++) {
                    sb.append(nodes[i].getSQL());

                    if (i < nodes.length - 1) {
                        sb.append(',');
                    }
                }

                sb.append(')');

                return sb.toString();

            //
            case OpTypes.TABLE :
                for (int i = 0; i < nodes.length; i++) {
                    sb.append(nodes[i].getSQL());

                    if (i < nodes.length - 1) {
                        sb.append(',');
                    }
                }

                return sb.toString();
        }

        switch (opType) {

            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY :
/*
                buf.append('(');
                buf.append(subSelect.getSQL());
                buf.append(')');
*/
                break;

            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "Expression");
        }

        return sb.toString();
    }

    protected String describe(Session session, int blanks) {

        StringBuffer sb = new StringBuffer(64);

        sb.append('\n');

        for (int i = 0; i < blanks; i++) {
            sb.append(' ');
        }

        switch (opType) {

            case OpTypes.VALUE :
                sb.append("VALUE = ").append(valueData);
                sb.append(", TYPE = ").append(dataType.getNameString());

                return sb.toString();

            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY :
                sb.append("QUERY ");
                sb.append(subQuery.queryExpression.describe(session));

                return sb.toString();

            case OpTypes.ROW :
                sb.append("ROW = ");

                for (int i = 0; i < nodes.length; i++) {
                    sb.append(nodes[i].describe(session, blanks + 1));
                }

                sb.append("), TYPE = ").append(dataType.getNameString());
                break;

            case OpTypes.TABLE :
                sb.append("VALUELIST ");

                for (int i = 0; i < nodes.length; i++) {
                    sb.append(nodes[i].describe(session, blanks + 1));
                    sb.append(' ');
                }
                break;
        }

        if (nodes[LEFT] != null) {
            sb.append(" arg1=[");
            sb.append(nodes[LEFT].describe(session, blanks + 1));
            sb.append(']');
        }

        if (nodes[RIGHT] != null) {
            sb.append(" arg2=[");
            sb.append(nodes[RIGHT].describe(session, blanks + 1));
            sb.append(']');
        }

        return sb.toString();
    }

    /**
     * Set the data type
     */
    void setDataType(Session session, Type type) {

        if (opType == OpTypes.VALUE) {
            valueData = type.convertToType(session, valueData, dataType);
        }

        dataType = type;
    }

    public boolean equals(Expression other) {

        if (other == this) {
            return true;
        }

        if (other == null) {
            return false;
        }

        if (opType != other.opType || exprSubType != other.exprSubType
                || !equals(dataType, other.dataType)) {
            return false;
        }

        switch (opType) {

            case OpTypes.SIMPLE_COLUMN :
                return this.columnIndex == other.columnIndex;

            case OpTypes.VALUE :
                return equals(valueData, other.valueData);

            default :
                return equals(nodes, other.nodes)
                       && equals(subQuery, other.subQuery);
        }
    }

    public boolean equals(Object other) {

        if (other == this) {
            return true;
        }

        if (other instanceof Expression) {
            return equals((Expression) other);
        }

        return false;
    }

    public int hashCode() {

        int val = opType + exprSubType;

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] != null) {
                val += nodes[i].hashCode();
            }
        }

        return val;
    }

    static boolean equals(Object o1, Object o2) {

        if (o1 == o2) {
            return true;
        }

        return (o1 == null) ? o2 == null
                            : o1.equals(o2);
    }

    static boolean equals(Expression[] row1, Expression[] row2) {

        if (row1 == row2) {
            return true;
        }

        if (row1.length != row2.length) {
            return false;
        }

        int len = row1.length;

        for (int i = 0; i < len; i++) {
            Expression e1     = row1[i];
            Expression e2     = row2[i];
            boolean    equals = (e1 == null) ? e2 == null
                                             : e1.equals(e2);

            if (!equals) {
                return false;
            }
        }

        return true;
    }

    boolean isComposedOf(Expression exprList[], int start, int end,
                         OrderedIntHashSet excludeSet) {

        if (opType == OpTypes.VALUE) {
            return true;
        }

        if (excludeSet.contains(opType)) {
            return true;
        }

        for (int i = start; i < end; i++) {
            if (equals(exprList[i])) {
                return true;
            }
        }

        switch (opType) {

            case OpTypes.LIKE :
            case OpTypes.MATCH_SIMPLE :
            case OpTypes.MATCH_PARTIAL :
            case OpTypes.MATCH_FULL :
            case OpTypes.MATCH_UNIQUE_SIMPLE :
            case OpTypes.MATCH_UNIQUE_PARTIAL :
            case OpTypes.MATCH_UNIQUE_FULL :
            case OpTypes.UNIQUE :
            case OpTypes.EXISTS :
            case OpTypes.TABLE_SUBQUERY :
            case OpTypes.ROW_SUBQUERY :

            //
            case OpTypes.COUNT :
            // A VoltDB extension APPROX_COUNT_DISTINCT
            case OpTypes.APPROX_COUNT_DISTINCT:
            // End of VoltDB extension
            case OpTypes.SUM :
            case OpTypes.MIN :
            case OpTypes.MAX :
            case OpTypes.AVG :
            case OpTypes.EVERY :
            case OpTypes.SOME :
            case OpTypes.STDDEV_POP :
            case OpTypes.STDDEV_SAMP :
            case OpTypes.VAR_POP :
            case OpTypes.VAR_SAMP :
                return false;
        }

        if (nodes.length == 0) {
            return false;
        }

        boolean result = true;

        for (int i = 0; i < nodes.length; i++) {
            result &= (nodes[i] == null
                       || nodes[i].isComposedOf(exprList, start, end,
                                                excludeSet));
        }

        return result;
    }

    boolean isComposedOf(OrderedHashSet expressions,
                         OrderedIntHashSet excludeSet) {

        // BEGIN Cherry-picked code change from hsqldb-2.3.2
        if (opType == OpTypes.VALUE || opType == OpTypes.DYNAMIC_PARAM
                || opType == OpTypes.PARAMETER || opType == OpTypes.VARIABLE) {
            return true;
        }
        // END Cherry-picked code change from hsqldb-2.3.2

        if (excludeSet.contains(opType)) {
            return true;
        }

        for (int i = 0; i < expressions.size(); i++) {
            if (equals(expressions.get(i))) {
                return true;
            }
        }

        switch (opType) {

            case OpTypes.COUNT :
            // A VoltDB extension APPROX_COUNT_DISTINCT
            case OpTypes.APPROX_COUNT_DISTINCT:
            // End of VoltDB extension
            case OpTypes.SUM :
            case OpTypes.MIN :
            case OpTypes.MAX :
            case OpTypes.AVG :
            case OpTypes.EVERY :
            case OpTypes.SOME :
            case OpTypes.STDDEV_POP :
            case OpTypes.STDDEV_SAMP :
            case OpTypes.VAR_POP :
            case OpTypes.VAR_SAMP :
                return false;
        }

/*
        case OpCodes.LIKE :
        case OpCodes.ALL :
        case OpCodes.ANY :
        case OpCodes.IN :
        case OpCodes.MATCH_SIMPLE :
        case OpCodes.MATCH_PARTIAL :
        case OpCodes.MATCH_FULL :
        case OpCodes.MATCH_UNIQUE_SIMPLE :
        case OpCodes.MATCH_UNIQUE_PARTIAL :
        case OpCodes.MATCH_UNIQUE_FULL :
        case OpCodes.UNIQUE :
        case OpCodes.EXISTS :
        case OpCodes.TABLE_SUBQUERY :
        case OpCodes.ROW_SUBQUERY :
*/
        if (nodes.length == 0) {
            return false;
        }

        boolean result = true;

        for (int i = 0; i < nodes.length; i++) {
            result &= (nodes[i] == null
                       || nodes[i].isComposedOf(expressions, excludeSet));
        }

        return result;
    }

    Expression replace(OrderedHashSet expressions,
                       OrderedHashSet replacements) {

        if (opType == OpTypes.VALUE) {
            return this;
        }

        int index = expressions.getIndex(this);

        if (index != -1) {
            return (Expression) replacements.get(index);
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            nodes[i] = nodes[i].replace(expressions, replacements);
        }

        return this;
    }

    Expression replaceColumnReferences(RangeVariable range,
                                       Expression[] list) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            nodes[i] = nodes[i].replaceColumnReferences(range, list);
        }

        return this;
    }

    void convertToSimpleColumn(OrderedHashSet expressions,
                               OrderedHashSet replacements) {

        if (opType == OpTypes.VALUE) {
            return;
        }

        int index = expressions.getIndex(this);

        if (index != -1) {
            Expression e = (Expression) replacements.get(index);

            nodes         = emptyExpressionArray;
            opType        = OpTypes.SIMPLE_COLUMN;
            columnIndex   = e.columnIndex;
            rangePosition = e.rangePosition;

            return;
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            nodes[i].convertToSimpleColumn(expressions, replacements);
        }
    }

    boolean isSelfAggregate() {
        return false;
    }

    /**
     * Set the column alias
     */
    void setAlias(SimpleName name) {
        alias = name;
    }

    /**
     * Get the column alias
     */
    String getAlias() {

        if (alias != null) {
            return alias.name;
        }

        return "";
    }

    SimpleName getSimpleName() {

        if (alias != null) {
            return alias;
        }

        return null;
    }

    /**
     * Returns the type of expression
     */
    public int getType() {
        return opType;
    }

    /**
     * Returns the left node
     */
    Expression getLeftNode() {
        return nodes.length > 0 ? nodes[LEFT]
                                : null;
    }

    /**
     * Returns the right node
     */
    Expression getRightNode() {
        return nodes.length > 1 ? nodes[RIGHT]
                                : null;
    }

    void setLeftNode(Expression e) {
        nodes[LEFT] = e;
    }

    void setRightNode(Expression e) {
        nodes[RIGHT] = e;
    }

    /**
     * Returns the range variable for a COLUMN expression
     */
    RangeVariable getRangeVariable() {
        return null;
    }

    /**
     * return the expression for an alias used in an ORDER BY clause
     */
    Expression replaceAliasInOrderBy(Expression[] columns, int length) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            nodes[i] = nodes[i].replaceAliasInOrderBy(columns, length);
        }

        return this;
    }

    /**
     * Find a range variable with the given table alias
     */
    int findMatchingRangeVariableIndex(RangeVariable[] rangeVarArray) {
        return -1;
    }

    /**
     * collects all range variables in expression tree
     */
    void collectRangeVariables(RangeVariable[] rangeVariables, Set set) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] != null) {
                nodes[i].collectRangeVariables(rangeVariables, set);
            }
        }

        if (subQuery != null && subQuery.queryExpression != null) {
            HsqlList unresolvedExpressions =
                subQuery.queryExpression.getUnresolvedExpressions();

            if (unresolvedExpressions != null) {
                for (int i = 0; i < unresolvedExpressions.size(); i++) {
                    Expression e = (Expression) unresolvedExpressions.get(i);

                    e.collectRangeVariables(rangeVariables, set);
                }
            }
        }
    }

    /**
     * collects all range variables in expression tree
     */
    void collectObjectNames(Set set) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] != null) {
                nodes[i].collectObjectNames(set);
            }
        }

        if (subQuery != null) {
            if (subQuery.queryExpression != null) {
                subQuery.queryExpression.collectObjectNames(set);
            }
        }
    }

    /**
     * return true if given RangeVariable is used in expression tree
     */
    boolean hasReference(RangeVariable range) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] != null) {
                if (nodes[i].hasReference(range)) {
                    return true;
                }
            }
        }

        if (subQuery != null && subQuery.queryExpression != null) {
            if (subQuery.queryExpression.hasReference(range)) {
                return true;
            }
        }

        return false;
    }

    /**
     * resolve tables and collect unresolved column expressions
     */
    public HsqlList resolveColumnReferences(RangeVariable[] rangeVarArray,
            HsqlList unresolvedSet) {
        return resolveColumnReferences(rangeVarArray, rangeVarArray.length,
                                       unresolvedSet, true);
    }

    public HsqlList resolveColumnReferences(RangeVariable[] rangeVarArray,
            int rangeCount, HsqlList unresolvedSet, boolean acceptsSequences) {

        if (opType == OpTypes.VALUE) {
            return unresolvedSet;
        }

        switch (opType) {

            case OpTypes.CASEWHEN :
                acceptsSequences = false;
                break;

            case OpTypes.TABLE : {
                HsqlList localSet = null;

                for (int i = 0; i < nodes.length; i++) {
                    if (nodes[i] == null) {
                        continue;
                    }

                    localSet = nodes[i].resolveColumnReferences(
                        RangeVariable.emptyArray, localSet);
                }

                if (localSet != null) {
                    isCorrelated = true;

                    if (subQuery != null) {
                        subQuery.setCorrelated();
                    }

                    for (int i = 0; i < localSet.size(); i++) {
                        Expression e = (Expression) localSet.get(i);

                        unresolvedSet =
                            e.resolveColumnReferences(rangeVarArray,
                                                      unresolvedSet);
                    }

                    unresolvedSet = Expression.resolveColumnSet(rangeVarArray,
                            localSet, unresolvedSet);
                }

                return unresolvedSet;
            }
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            unresolvedSet = nodes[i].resolveColumnReferences(rangeVarArray,
                    rangeCount, unresolvedSet, acceptsSequences);
        }

        switch (opType) {

            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY : {
                QueryExpression queryExpression = subQuery.queryExpression;

                if (!queryExpression.areColumnsResolved()) {
                    isCorrelated = true;

                    subQuery.setCorrelated();

                    // take to enclosing context
                    if (unresolvedSet == null) {
                        unresolvedSet = new ArrayListIdentity();
                    }

                    unresolvedSet.addAll(
                        queryExpression.getUnresolvedExpressions());
                }

                break;
            }
            default :
        }

        return unresolvedSet;
    }

    public OrderedHashSet getUnkeyedColumns(OrderedHashSet unresolvedSet) {

        if (opType == OpTypes.VALUE) {
            return unresolvedSet;
        }

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] == null) {
                continue;
            }

            unresolvedSet = nodes[i].getUnkeyedColumns(unresolvedSet);
        }

        switch (opType) {

            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY :
                if (subQuery != null) {
                    if (unresolvedSet == null) {
                        unresolvedSet = new OrderedHashSet();
                    }

                    unresolvedSet.add(this);
                }
                break;
        }

        return unresolvedSet;
    }

    public void resolveTypes(Session session, Expression parent) {

        for (int i = 0; i < nodes.length; i++) {
            if (nodes[i] != null) {
                nodes[i].resolveTypes(session, this);
            }
        }

        switch (opType) {

            case OpTypes.VALUE :
                break;

            case OpTypes.TABLE :

                /** @todo - should it fall through */
                break;

            case OpTypes.ROW :
                nodeDataTypes = new Type[nodes.length];

                for (int i = 0; i < nodes.length; i++) {
                    if (nodes[i] != null) {
                        nodeDataTypes[i] = nodes[i].dataType;
                    }
                }
                break;

            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY : {
                QueryExpression queryExpression = subQuery.queryExpression;

                queryExpression.resolveTypes(session);
                subQuery.prepareTable(session);

                nodeDataTypes = queryExpression.getColumnTypes();
                dataType      = nodeDataTypes[0];

                break;
            }
            default :
                throw Error.runtimeError(ErrorCode.U_S0500,
                                         "Expression.resolveTypes()");
        }
    }

    void setAsConstantValue(Session session) {

        valueData = getConstantValue(session);
        opType    = OpTypes.VALUE;
        nodes     = emptyExpressionArray;
    }

    void setAsConstantValue(Object value) {

        valueData = value;
        opType    = OpTypes.VALUE;
        nodes     = emptyExpressionArray;
    }

    void prepareTable(Session session, Expression row, int degree) {

        if (nodeDataTypes != null) {
            return;
        }

        for (int i = 0; i < nodes.length; i++) {
            Expression e = nodes[i];

            if (e.opType == OpTypes.ROW) {
                if (degree != e.nodes.length) {
                    throw Error.error(ErrorCode.X_42564);
                }
            } else if (degree == 1) {
                nodes[i]       = new Expression(OpTypes.ROW);
                nodes[i].nodes = new Expression[]{ e };
            } else {
                throw Error.error(ErrorCode.X_42564);
            }
        }

        nodeDataTypes = new Type[degree];

        for (int j = 0; j < degree; j++) {
            Type type = row == null ? null
                                    : row.nodes[j].dataType;

            for (int i = 0; i < nodes.length; i++) {
                type = Type.getAggregateType(nodes[i].nodes[j].dataType, type);
            }

            if (type == null) {
                throw Error.error(ErrorCode.X_42567);
            }

            nodeDataTypes[j] = type;

            if (row != null && row.nodes[j].isParam) {
                row.nodes[j].dataType = type;
            }

            for (int i = 0; i < nodes.length; i++) {
                if (nodes[i].nodes[j].isParam) {
                    nodes[i].nodes[j].dataType = nodeDataTypes[j];

                    continue;
                }

                if (nodes[i].nodes[j].opType == OpTypes.VALUE) {
                    if (nodes[i].nodes[j].valueData == null) {
                        nodes[i].nodes[j].dataType = nodeDataTypes[j];
                    }
                }
            }

            if (nodeDataTypes[j].isCharacterType()
                    && !((CharacterType) nodeDataTypes[j])
                        .isEqualIdentical()) {

                // collation issues
            }
        }
    }

    /**
     * Details of IN condition optimisation for 1.9.0
     * Predicates with SELECT are QUERY expressions
     *
     * Predicates with IN list
     *
     * Parser adds a SubQuery to the list for each predicate
     * At type resolution IN lists that are entirely fixed constant or parameter
     * values are selected for possible optimisation. The flags:
     *
     * IN expression right side isCorrelated == true if there are non-constant,
     * non-param expressions in the list (Expressions may have to be resolved
     * against the full set of columns of the query, so must be re-evaluated
     * for each row and evaluated after all the joins have been made)
     *
     * VALUELIST expression isFixedConstantValueList == true when all
     * expressions are fixed constant and none is a param. With this flag,
     * a single-column VALUELIST can be accessed as a HashMap.
     *
     * Predicates may be optimised as joins if isCorrelated == false
     *
     */
    void insertValuesIntoSubqueryTable(Session session,
                                       PersistentStore store) {

        TableDerived table = subQuery.getTable();

        for (int i = 0; i < nodes.length; i++) {
            Object[] data = nodes[i].getRowValue(session);

            for (int j = 0; j < nodeDataTypes.length; j++) {
                data[j] = nodeDataTypes[j].convertToType(session, data[j],
                        nodes[i].nodes[j].dataType);
            }

            Row row = (Row) store.getNewCachedObject(session, data);

            try {
                store.indexRow(session, row);
            } catch (HsqlException e) {}
        }
    }

    /**
     * Returns the name of a column as string
     *
     * @return column name
     */
    String getColumnName() {
        return getAlias();
    }

    ColumnSchema getColumn() {
        return null;
    }

    /**
     * Returns the column index in the table
     */
    int getColumnIndex() {
        return columnIndex;
    }

    /**
     * Returns the data type
     */
    Type getDataType() {
        return dataType;
    }

    int getDegree() {
        return opType == OpTypes.ROW ? nodes.length
                                     : 1;
    }

    public Object[] getRowValue(Session session) {

        switch (opType) {

            case OpTypes.ROW : {
                Object[] data = new Object[nodes.length];

                for (int i = 0; i < nodes.length; i++) {
                    data[i] = nodes[i].getValue(session);
                }

                return data;
            }
            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY : {
                return subQuery.queryExpression.getValues(session);
            }
            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "Expression");
        }
    }

    Object getValue(Session session, Type type) {

        Object o = getValue(session);

        if (o == null || dataType == type) {
            return o;
        }

        return type.convertToType(session, o, dataType);
    }

    public Object getConstantValue(Session session) {
        return getValue(session);
    }

    public Object getConstantValueNoCheck(Session session) {

        try {
            return getValue(session);
        } catch (HsqlException e) {
            return null;
        }
    }

    public Object getValue(Session session) {

        switch (opType) {

            case OpTypes.VALUE :
                return valueData;

            case OpTypes.SIMPLE_COLUMN : {
                Object[] data =
                    session.sessionContext.rangeIterators[rangePosition]
                        .getCurrent();

                return data[columnIndex];
            }
            case OpTypes.ROW : {
                if (nodes.length == 1) {
                    return nodes[0].getValue(session);
                }

                Object[] row = new Object[nodes.length];

                for (int i = 0; i < nodes.length; i++) {
                    row[i] = nodes[i].getValue(session);
                }

                return row;
            }
            case OpTypes.ROW_SUBQUERY :
            case OpTypes.TABLE_SUBQUERY : {
                subQuery.materialiseCorrelated(session);

                Object value = subQuery.getValue(session);

                return value;
            }
            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "Expression");
        }
    }

    boolean testCondition(Session session) {
        return Boolean.TRUE.equals(getValue(session));
    }

    static int countNulls(Object[] a) {

        int nulls = 0;

        for (int i = 0; i < a.length; i++) {
            if (a[i] == null) {
                nulls++;
            }
        }

        return nulls;
    }

    static void convertToType(Session session, Object[] data, Type[] dataType,
                              Type[] newType) {

        for (int i = 0; i < data.length; i++) {
            data[i] = newType[i].convertToType(session, data[i], dataType[i]);
        }
    }

    /**
     * Returns a Select object that can be used for checking the contents
     * of an existing table against the given CHECK search condition.
     */
    static QuerySpecification getCheckSelect(Session session, Table t,
            Expression e) {

        CompileContext     compileContext = new CompileContext(session);
        QuerySpecification s = new QuerySpecification(compileContext);

        s.exprColumns    = new Expression[1];
        s.exprColumns[0] = EXPR_TRUE;

        RangeVariable range = new RangeVariable(t, null, null, null,
            compileContext);

        s.rangeVariables = new RangeVariable[]{ range };

        HsqlList unresolved = e.resolveColumnReferences(s.rangeVariables,
            null);

        ExpressionColumn.checkColumnsResolved(unresolved);
        e.resolveTypes(session, null);

        if (Type.SQL_BOOLEAN != e.getDataType()) {
            throw Error.error(ErrorCode.X_42568);
        }

        Expression condition = new ExpressionLogical(OpTypes.NOT, e);

        s.queryCondition = condition;

        s.resolveReferences(session);
        s.resolveTypes(session);

        return s;
    }

    boolean isParam() {
        return isParam;
    }

    void setAttributesAsColumn(ColumnSchema column, boolean isWritable) {
        throw Error.runtimeError(ErrorCode.U_S0500,
                                 "Expression.setAttributesAsColumn");
    }

    String getValueClassName() {

        Type type = dataType == null ? NullType.getNullType()
                                     : dataType;

        return type.getJDBCClassName();
    }

    public void collectAllFunctionExpressions(HsqlList set) {

        Expression.collectAllExpressions(set, this,
                                         Expression.emptyExpressionSet,
                                         Expression.emptyExpressionSet);
    }

    /**
     * collect all extrassions of a set of expression types appearing anywhere
     * in a select statement and its subselects, etc.
     */
    static void collectAllExpressions(HsqlList set, Expression e,
                                      OrderedIntHashSet typeSet,
                                      OrderedIntHashSet stopAtTypeSet) {

        if (e == null) {
            return;
        }

        if (stopAtTypeSet.contains(e.opType)) {
            return;
        }

        for (int i = 0; i < e.nodes.length; i++) {
            collectAllExpressions(set, e.nodes[i], typeSet, stopAtTypeSet);
        }

        if (typeSet.contains(e.opType)) {
            set.add(e);
        }

        if (e.subQuery != null && e.subQuery.queryExpression != null) {
            e.subQuery.queryExpression.collectAllExpressions(set, typeSet,
                    stopAtTypeSet);
        }
    }

    /**
     * isCorrelated
     */
    public boolean isCorrelated() {

        if (opType == OpTypes.TABLE_SUBQUERY && subQuery != null
                && subQuery.isCorrelated()) {
            return true;
        }

        return false;
    }

    /**
     * checkValidCheckConstraint
     */
    public void checkValidCheckConstraint() {

        HsqlArrayList set = new HsqlArrayList();

        Expression.collectAllExpressions(set, this, subqueryExpressionSet,
                                         emptyExpressionSet);

        if (!set.isEmpty()) {
            throw Error.error(ErrorCode.X_0A000,
                              "subquery in check constraint");
        }
    }

    static HsqlList resolveColumnSet(RangeVariable[] rangeVars,
                                     HsqlList sourceSet, HsqlList targetSet) {

        if (sourceSet == null) {
            return targetSet;
        }

        for (int i = 0; i < sourceSet.size(); i++) {
            Expression e = (Expression) sourceSet.get(i);

            targetSet = e.resolveColumnReferences(rangeVars, targetSet);
        }

        return targetSet;
    }

    Expression getIndexableExpression(RangeVariable rangeVar) {
        return null;
    }

    /************************* Volt DB Extensions *************************/

    // A VoltDB extension to support indexed expressions
    public void collectAllColumnExpressions(HsqlList set) {

        Expression.collectAllExpressions(set, this,
                                         Expression.columnExpressionSet,
                                         Expression.emptyExpressionSet);
    }

    static Map<Integer, VoltXMLElement> prototypes = new HashMap<Integer, VoltXMLElement>();

    static {
        prototypes.put(OpTypes.VALUE,         new VoltXMLElement("value")); // constant value
        prototypes.put(OpTypes.COLUMN,        new VoltXMLElement("columnref")); // reference
        prototypes.put(OpTypes.COALESCE,      new VoltXMLElement("columnref")); // for now, another reference form?
        prototypes.put(OpTypes.DEFAULT,       new VoltXMLElement("columnref")); // uninteresting!? ExpressionColumn
        prototypes.put(OpTypes.SIMPLE_COLUMN, (new VoltXMLElement("simplecolumn")));

        prototypes.put(OpTypes.VARIABLE,      null); // Some kind of HSQL session parameter? --paul
        prototypes.put(OpTypes.PARAMETER,     null); // Some kind of HSQL session parameter? --paul
        prototypes.put(OpTypes.DYNAMIC_PARAM, (new VoltXMLElement("value")).withValue("isparam", "true")); // param
        prototypes.put(OpTypes.ASTERISK,      new VoltXMLElement("asterisk"));
        prototypes.put(OpTypes.SEQUENCE,      null); // not yet supported sequence type
        prototypes.put(OpTypes.SCALAR_SUBQUERY,null); // not yet supported subquery feature, query based row/table
        prototypes.put(OpTypes.ROW_SUBQUERY,  null); // not yet supported subquery feature
        prototypes.put(OpTypes.TABLE_SUBQUERY,new VoltXMLElement("tablesubquery"));
        prototypes.put(OpTypes.ROW,           new VoltXMLElement("row")); // rows
        prototypes.put(OpTypes.TABLE,         new VoltXMLElement("table")); // not yet supported subquery feature, but needed for "in"
        prototypes.put(OpTypes.FUNCTION,      null); // not used (HSQL user-defined functions).
        prototypes.put(OpTypes.SQL_FUNCTION,  new VoltXMLElement("function"));
        prototypes.put(OpTypes.ROUTINE_FUNCTION, null); // not used

        //arithmetic operations
        prototypes.put(OpTypes.NEGATE,        (new VoltXMLElement("operation")).withValue("optype", "negate"));

        prototypes.put(OpTypes.ADD,           (new VoltXMLElement("operation")).withValue("optype", "add"));
        prototypes.put(OpTypes.SUBTRACT,      (new VoltXMLElement("operation")).withValue("optype", "subtract"));
        prototypes.put(OpTypes.MULTIPLY,      (new VoltXMLElement("operation")).withValue("optype", "multiply"));
        prototypes.put(OpTypes.DIVIDE,        (new VoltXMLElement("operation")).withValue("optype", "divide"));

        prototypes.put(OpTypes.CONCAT,        (new VoltXMLElement("function")) // concatenation
                                               .withValue("function_id", FunctionCustom.FUNC_CONCAT_ID_STRING)
                                               .withValue("name", Tokens.T_CONCAT_WORD)
                                               .withValue("valuetype", Type.SQL_VARCHAR.getNameString()));

        // logicals - comparisons
        prototypes.put(OpTypes.EQUAL,         (new VoltXMLElement("operation")).withValue("optype", "equal"));
        prototypes.put(OpTypes.GREATER_EQUAL, (new VoltXMLElement("operation")).withValue("optype", "greaterthanorequalto"));
        prototypes.put(OpTypes.GREATER,       (new VoltXMLElement("operation")).withValue("optype", "greaterthan"));
        prototypes.put(OpTypes.SMALLER,       (new VoltXMLElement("operation")).withValue("optype", "lessthan"));
        prototypes.put(OpTypes.SMALLER_EQUAL, (new VoltXMLElement("operation")).withValue("optype", "lessthanorequalto"));
        prototypes.put(OpTypes.NOT_EQUAL,     (new VoltXMLElement("operation")).withValue("optype", "notequal"));
        prototypes.put(OpTypes.IS_NULL,       (new VoltXMLElement("operation")).withValue("optype", "is_null"));

        // logicals - operations
        prototypes.put(OpTypes.NOT,           (new VoltXMLElement("operation")).withValue("optype", "not"));
        prototypes.put(OpTypes.AND,           (new VoltXMLElement("operation")).withValue("optype", "and"));
        prototypes.put(OpTypes.OR,            (new VoltXMLElement("operation")).withValue("optype", "or"));

        // logicals - quantified comparison
        prototypes.put(OpTypes.ALL_QUANTIFIED,null); // not used -- an ExpressionLogical exprSubType value only
        prototypes.put(OpTypes.ANY_QUANTIFIED,null); // not used -- an ExpressionLogical exprSubType value only

        // logicals - other predicates
        prototypes.put(OpTypes.LIKE,          (new VoltXMLElement("operation")).withValue("optype", "like"));
        prototypes.put(OpTypes.IN,            null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.EXISTS,        (new VoltXMLElement("operation")).withValue("optype", "exists"));
        prototypes.put(OpTypes.OVERLAPS,      null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.UNIQUE,        null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.NOT_DISTINCT,  null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_SIMPLE,  null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_PARTIAL, null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_FULL,    null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_UNIQUE_SIMPLE,  null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_UNIQUE_PARTIAL, null); // not yet supported ExpressionLogical
        prototypes.put(OpTypes.MATCH_UNIQUE_FULL,    null); // not yet supported ExpressionLogical
        // aggregate functions
        prototypes.put(OpTypes.COUNT,         (new VoltXMLElement("aggregation")).withValue("optype", "count"));
        // A VoltDB extension APPROX_COUNT_DISTINCT
        prototypes.put(OpTypes.APPROX_COUNT_DISTINCT, (new VoltXMLElement("aggregation")).withValue("optype", "approx_count_distinct"));
        // End of VoltDB extension
        prototypes.put(OpTypes.SUM,           (new VoltXMLElement("aggregation")).withValue("optype", "sum"));
        prototypes.put(OpTypes.MIN,           (new VoltXMLElement("aggregation")).withValue("optype", "min"));
        prototypes.put(OpTypes.MAX,           (new VoltXMLElement("aggregation")).withValue("optype", "max"));
        prototypes.put(OpTypes.AVG,           (new VoltXMLElement("aggregation")).withValue("optype", "avg"));
        prototypes.put(OpTypes.EVERY,         (new VoltXMLElement("aggregation")).withValue("optype", "every"));
        prototypes.put(OpTypes.SOME,          (new VoltXMLElement("aggregation")).withValue("optype", "some"));
        prototypes.put(OpTypes.STDDEV_POP,    (new VoltXMLElement("aggregation")).withValue("optype", "stddevpop"));
        prototypes.put(OpTypes.STDDEV_SAMP,   (new VoltXMLElement("aggregation")).withValue("optype", "stddevsamp"));
        prototypes.put(OpTypes.VAR_POP,       (new VoltXMLElement("aggregation")).withValue("optype", "varpop"));
        prototypes.put(OpTypes.VAR_SAMP,      (new VoltXMLElement("aggregation")).withValue("optype", "varsamp"));
        // other operations
        prototypes.put(OpTypes.CAST,          (new VoltXMLElement("operation")).withValue("optype", "cast"));
        prototypes.put(OpTypes.ZONE_MODIFIER, null); // ???
        prototypes.put(OpTypes.CASEWHEN,      (new VoltXMLElement("operation")).withValue("optype", "operator_case_when"));
        prototypes.put(OpTypes.ORDER_BY,      new VoltXMLElement("orderby"));
        prototypes.put(OpTypes.LIMIT,         new VoltXMLElement("limit"));
        prototypes.put(OpTypes.ALTERNATIVE,   (new VoltXMLElement("operation")).withValue("optype", "operator_alternative"));
        prototypes.put(OpTypes.MULTICOLUMN,   null); // an uninteresting!? ExpressionColumn case
    }

    /**
     * @param session
     * @return
     * @throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
     */
    VoltXMLElement voltGetXML(Session session)
            throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
    {
        return voltGetXML(session, null, null, -1);
    }

    VoltXMLElement voltGetXML(Session session, List<Expression> displayCols,
            java.util.Set<Integer> ignoredDisplayColIndexes, int startKey)
            throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
    {
        return voltGetXML(session, displayCols, ignoredDisplayColIndexes, startKey, null);
    }

    /**
     * VoltDB added method to get a non-catalog-dependent
     * representation of this HSQLDB object.
     * @param session The current Session object may be needed to resolve
     * some names.
     * @return XML, correctly indented, representing this object.
     * @throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
     */
    VoltXMLElement voltGetXML(Session session, List<Expression> displayCols,
            java.util.Set<Integer> ignoredDisplayColIndexes, int startKey, String realAlias)
        throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
    {
        // The voltXML representations of expressions tends to be driven much more by the expression's opType
        // than its Expression class.
        int exprOp = getType();

        // The opType value of "SIMPLE_COLUMN" is a special case that spans Expression classes and seems to
        // need to use the Expression's exact class to be able to correctly determine its VoltXMLElement
        // representation.
        // Last minute "SIMPLE_COLUMN" substitutions can blast a new opType into an Expression of a class
        // other than ExpressionColumn as an optimization for duplicated expressions.
        // VoltDB currently uses "alias" matching to navigate to the correct (duplicate) expression structure
        // typically an ExpressionAggregate.
        // The prototypes dictionary is set up to handle a SIMPLE_COLUMN of any class EXCEPT ExpressionColumn.
        // A SIMPLE_COLUMN ExpressionColumn can be treated as a normal "COLUMN" ExpressionColumn.
        // That case gets explicitly enabled here by fudging the opType from SIMPLE_COLUMN to COLUMN.
        if (exprOp == OpTypes.SIMPLE_COLUMN) {
            if (displayCols == null) {
                if (this instanceof ExpressionColumn == false) {
                    throw new org.hsqldb_voltpatches.HSQLInterface.HSQLParseException(
                            "VoltDB does not support this complex query currently.");
                }
                // convert the SIMPLE_COLUMN into a COLUMN
                opType = OpTypes.COLUMN;
                exprOp = OpTypes.COLUMN;
            } else {
                // find the substitue from displayCols list
                for (int ii=startKey+1; ii < displayCols.size(); ++ii)
                {
                    Expression otherCol = displayCols.get(ii);
                    // This mechanism of finding the expression that a SIMPLE_COLUMN
                    // is referring to is inherently fragile---columnIndex is an
                    // offset into different things depending on context!
                    if (otherCol != null && (otherCol.opType != OpTypes.SIMPLE_COLUMN) &&
                             (otherCol.columnIndex == this.columnIndex)  &&
                             !(otherCol instanceof ExpressionColumn))
                    {
                        ignoredDisplayColIndexes.add(ii);
                        // serialize the column this simple column stands-in for.
                        // Prepare to skip displayCols that are the referent of a SIMPLE_COLUMN."
                        // quit seeking simple_column's replacement.
                        return otherCol.voltGetXML(session, displayCols, ignoredDisplayColIndexes, startKey, getAlias());
                    }
                }
                assert(false);
            }
        }

        // Use the opType to find a pre-initialized prototype VoltXMLElement with the correct
        // name and any required hard-coded values pre-set.
        VoltXMLElement exp = prototypes.get(exprOp);
        if (exp == null) {
            // Must have found an unsupported opType.
            throwForUnsupportedExpression(exprOp);
        }

        // Duplicate the prototype and add any expression particulars needed for the specific opType value,
        // as well as a unique identifier, a possible alias, and child nodes.
        exp = exp.duplicate();
        exp.attributes.put("id", this.getUniqueId(session));

        if (realAlias != null) {
            exp.attributes.put("alias", realAlias);
        } else if ((alias != null) && (getAlias().length() > 0)) {
            exp.attributes.put("alias", getAlias());
        }

        // Add expresion sub type
        if (exprSubType == OpTypes.ANY_QUANTIFIED) {
            exp.attributes.put("opsubtype", "any");
        } else if (exprSubType == OpTypes.ALL_QUANTIFIED) {
            exp.attributes.put("opsubtype", "all");
        }

        for (Expression expr : nodes) {
            if (expr != null) {
                VoltXMLElement vxmle = expr.voltGetXML(session, displayCols, ignoredDisplayColIndexes, startKey);
                exp.children.add(vxmle);
                assert(vxmle != null);
            }
        }

        // Few opTypes need additional special case detailing or special case error detection.
        // Very few need access to members defined on specific Expression classes, but they
        // can usually be accessed via down-casting.
        // Even fewer need private members, and they are accessed by delegation to a
        // class-specific voltAnnotate... member function that directly manipulates the
        // VoltXMLElement.
        switch (exprOp) {
        case OpTypes.VALUE:
            // Apparently at this stage, all valid non-NULL values must have a type determined by HSQL.
            // I'm not sure why this must be the case --paul.
            // if the actual value is null, make sure the type is null as well
            if (valueData == null) {
                if (dataType == null) {
                    exp.attributes.put("valuetype", "NULL");
                    return exp;
                }
                exp.attributes.put("valuetype", Types.getTypeName(dataType.typeCode));
                return exp;
            }

            if (dataType.isBooleanType()) {
                // FIXME: Since BOOLEAN is not a valid user data type a BOOLEAN VALUE is always the result of a constant logical
                // expression (WHERE clause) like "2 > 1" that HSQL has optimized to a constant value.
                // VoltDB could someday be enabled to support a Boolean-valued ConstantExpression.
                // OR VoltDB's native representation for logical values (BIG INT 1 or 0) could be substituted here
                // and MAYBE that would solve this whole problem.
                // There used to be VoltDB code to deserialize an expression into a (BIGINT 1 or 0) ConstantExpression.
                // BIGINT IS the VoltDB planner's native type for logical expressions.
                // That code was only triggered by an impossible case of (essentially) optype=="boolean"
                // -- a victim of past ambiguity in the "type" attributes -- sometimes meaning "optype" sometimes "valuetype"
                // -- so that code got dropped.
                // Going forward, it seems to make more sense to leverage the surviving VoltDB code path by hard-wiring here:
                // valueType="BIGINT", value="1"/"0".
                throw new org.hsqldb_voltpatches.HSQLInterface.HSQLParseException(
                        "VoltDB does not support WHERE clauses containing only constants");
            }

            exp.attributes.put("valuetype", Types.getTypeName(dataType.typeCode));

            if (valueData instanceof TimestampData) {
                // When we get the default from the DDL,
                // it gets jammed into a TimestampData object.  If we
                // don't do this, we get a Java class/reference
                // string in the output schema for the DDL.
                // EL HACKO: I'm just adding in the timezone seconds
                // at the moment, hope this is right --izzy
                TimestampData time = (TimestampData) valueData;
                exp.attributes.put("value", Long.toString(Math.round((time.getSeconds() +
                                                                      time.getZone()) * 1e6) +
                                                          time.getNanos() / 1000));
                return exp;
            }

            // convert binary values to hex
            if (valueData instanceof BinaryData) {
                BinaryData bd = (BinaryData) valueData;
                exp.attributes.put("value", hexEncode(bd.getBytes()));
                return exp;
            }

            // Otherwise just string format the value.
            if (dataType instanceof NumberType && ! dataType.isIntegralType()) {
                // remove the scentific exponent notation
                exp.attributes.put("value", new BigDecimal(valueData.toString()).toPlainString());
                return exp;
            }
            exp.attributes.put("value", valueData.toString());
            return exp;

        case OpTypes.COLUMN:
        case OpTypes.COALESCE:
            ExpressionColumn ec = (ExpressionColumn)this;
            return ec.voltAnnotateColumnXML(exp);

        case OpTypes.SQL_FUNCTION:
            FunctionSQL fn = (FunctionSQL)this;
            return fn.voltAnnotateFunctionXML(exp);

        case OpTypes.COUNT:
        // A VoltDB extension APPROX_COUNT_DISTINCT
        case OpTypes.APPROX_COUNT_DISTINCT:
        // End of VoltDB extension
        case OpTypes.SUM:
        case OpTypes.AVG:
            if (((ExpressionAggregate)this).isDistinctAggregate) {
                exp.attributes.put("distinct", "true");
            }
            return exp;

        case OpTypes.ORDER_BY:
            if (((ExpressionOrderBy)this).isDescending()) {
                exp.attributes.put("desc", "true");
            }
            return exp;

        case OpTypes.CAST:
            if (dataType == null) {
                throw new org.hsqldb_voltpatches.HSQLInterface.HSQLParseException(
                        "VoltDB could not determine the type in a CAST operation");
            }
            exp.attributes.put("valuetype", dataType.getNameString());
            return exp;

        case OpTypes.TABLE_SUBQUERY:
            if (subQuery == null || subQuery.queryExpression == null) {
                throw new HSQLParseException("VoltDB could not determine the subquery");
            }
            ExpressionColumn parameters[] = new ExpressionColumn[0];
            exp.children.add(StatementQuery.voltGetXMLExpression(subQuery.queryExpression, parameters, session));
            return exp;

        case OpTypes.ALTERNATIVE:
            assert(nodes.length == 2);
            // If with ELSE clause, pad NULL with it.
            if (nodes[RIGHT] instanceof ExpressionValue) {
                ExpressionValue val = (ExpressionValue) nodes[RIGHT];
                if (val.valueData == null && val.dataType == Type.SQL_ALL_TYPES) {
                    exp.children.get(RIGHT).attributes.put("valuetype", dataType.getNameString());
                }
            }
        case OpTypes.CASEWHEN:
            // Hsql has check dataType can not be null.
            assert(dataType != null);
            exp.attributes.put("valuetype", dataType.getNameString());
            return exp;

        default:
            return exp;
        }
    }

    private static final int caseDiff = ('a' - 'A');
    /**
     *
     * @param data A binary array of bytes.
     * @return A hex-encoded string with double length.
     */
    public static String hexEncode(byte[] data) {
        if (data == null)
            return null;

        StringBuilder sb = new StringBuilder();
        for (byte b : data) {
            // hex encoding same way as java.net.URLEncoder.
            char ch = Character.forDigit((b >> 4) & 0xF, 16);
            // to uppercase
            if (Character.isLetter(ch)) {
                ch -= caseDiff;
            }
            sb.append(ch);
            ch = Character.forDigit(b & 0xF, 16);
            if (Character.isLetter(ch)) {
                ch -= caseDiff;
            }
            sb.append(ch);
        }
        return sb.toString();
    }

    private static void throwForUnsupportedExpression(int exprOp)
            throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException
    {
        String opAsString;
        switch (exprOp) {
        //case OpTypes.COALESCE:
        //    opAsString = "the COALESCE operator. Consider using DECODE."; break; //MAY require ExpressionColumn state

        case OpTypes.VARIABLE:
            opAsString = "HSQL session variables"; break; // Some kind of HSQL session parameter? --paul
        case OpTypes.PARAMETER:
            opAsString = "HSQL session parameters"; break; // Some kind of HSQL session parameter? --paul

        case OpTypes.SEQUENCE:
            opAsString = "sequence types"; break; // not yet supported sequence type

        case OpTypes.SCALAR_SUBQUERY:
        case OpTypes.ROW_SUBQUERY:
        case OpTypes.TABLE_SUBQUERY:
        case OpTypes.ROW:
        case OpTypes.TABLE:
        case OpTypes.EXISTS:
            throw new HSQLParseException("Unsupported subquery syntax within an expression. Consider using a join or multiple statements instead");

        case OpTypes.FUNCTION:             opAsString = "HSQL-style user-defined Java SQL functions"; break;

        case OpTypes.ROUTINE_FUNCTION:     opAsString = "HSQL routine functions"; break; // not used

        case OpTypes.ALL_QUANTIFIED:
        case OpTypes.ANY_QUANTIFIED:
            opAsString = "sequences or subqueries"; break; // not used -- an ExpressionLogical exprSubType value only

        case OpTypes.IN:
            opAsString = "the IN operator. Consider using an OR expression"; break; // not yet supported

        case OpTypes.OVERLAPS:
        case OpTypes.UNIQUE:
        case OpTypes.NOT_DISTINCT:
            opAsString = "sequences or subqueries"; break; // not yet supported ExpressionLogical

        case OpTypes.MATCH_SIMPLE:
        case OpTypes.MATCH_PARTIAL:
        case OpTypes.MATCH_FULL:
        case OpTypes.MATCH_UNIQUE_SIMPLE:
        case OpTypes.MATCH_UNIQUE_PARTIAL:
        case OpTypes.MATCH_UNIQUE_FULL:
            opAsString = "the MATCH operator"; break; // not yet supported ExpressionLogical

        case OpTypes.ZONE_MODIFIER:
            opAsString = "ZONE modifier operations"; break; // ???
        case OpTypes.MULTICOLUMN:
            opAsString = "a MULTICOLUMN operation"; break; // an uninteresting!? ExpressionColumn case

        default:
            opAsString = " the unknown operator with numeric code (" + String.valueOf(exprOp) + ")";
        }
        throw new org.hsqldb_voltpatches.HSQLInterface.HSQLParseException(
                "VoltDB does not support " + opAsString);
    }

    /**
     * VoltDB added method to simplify an expression by eliminating identical subexpressions (same id)
     * The original expression must be a logical conjunction of form e1 AND e2 AND e3 AND e4.
     * If subexpression e1 is identical to the subexpression e2 the simplified expression would be
     * e1 AND e3 AND e4.
     * @param session The current Session object may be needed to resolve
     * some names.
     * @return simplified expression.
     */
    public Expression eliminateDuplicates(final Session session) {
        // First build the map of child expressions joined by the logical AND
        // The key is the expression id and the value is the expression itself
        Map<String, Expression> subExprMap = new HashMap<String, Expression>();
        extractAndSubExpressions(session, this, subExprMap);
        // Reconstruct the expression
        if (!subExprMap.isEmpty()) {
            Iterator<Map.Entry<String, Expression>> itExpr = subExprMap.entrySet().iterator();
            Expression finalExpr = itExpr.next().getValue();
            while (itExpr.hasNext()) {
                finalExpr = new ExpressionLogical(OpTypes.AND, finalExpr, itExpr.next().getValue());
            }
            return finalExpr;
        }
        return this;
    }

    protected void extractAndSubExpressions(final Session session, Expression expr,
            Map<String, Expression> subExprMap) {
        // If it is a logical expression AND then traverse down the tree
        if (expr instanceof ExpressionLogical && ((ExpressionLogical) expr).opType == OpTypes.AND) {
            extractAndSubExpressions(session, expr.nodes[LEFT], subExprMap);
            extractAndSubExpressions(session, expr.nodes[RIGHT], subExprMap);
        } else {
            String id = expr.getUniqueId(session);
            subExprMap.put(id, expr);
       }
    }

    protected String cached_id = null;

    /**
     * Get the hex address of this Expression Object in memory,
     * to be used as a unique identifier.
     * @return The hex address of the pointer to this object.
     */
    protected String getUniqueId(final Session session) {
        if (cached_id != null) {
            return cached_id;
        }

        //
        // Calculated an new Id
        //

        // this line ripped from the "describe" method
        // seems to help with some types like "equal"
        cached_id = new String();
        int hashCode = 0;
        //
        // If object is a leaf node, then we'll use John's original code...
        //
        if (getType() == OpTypes.VALUE || getType() == OpTypes.COLUMN) {
            hashCode = super.hashCode();
        //
        // Otherwise we need to generate and Id based on what our children are
        //
        } else {
            //
            // Horribly inefficient, but it works for now...
            //
            final List<String> id_list = new Vector<String>();
            new Object() {
                public void traverse(Expression exp) {
                    for (Expression expr : exp.nodes) {
                        if (expr != null)
                            id_list.add(expr.getUniqueId(session));
                    }
                }
            }.traverse(this);

            if (id_list.size() > 0) {
                // Flatten the id list, intern it, and then do the same trick from above
                for (String temp : id_list)
                    this.cached_id += "+" + temp;
                hashCode = this.cached_id.intern().hashCode();
            }
            else
                hashCode = super.hashCode();
        }

        long id = session.getNodeIdForExpression(hashCode);
        cached_id = Long.toString(id);
        return cached_id;
    }

    // A VoltDB extension to support indexed expressions
    public VoltXMLElement voltGetExpressionXML(Session session, Table table)
            throws org.hsqldb_voltpatches.HSQLInterface.HSQLParseException {
        resolveTableColumns(table);
        Expression parent = null; // As far as I can tell, this argument just gets passed around but never used !?
        resolveTypes(session, parent);
        return voltGetXML(session);
    }

    // A VoltDB extension to support indexed expressions
    private void resolveTableColumns(Table table) {
        HsqlList set = new HsqlArrayList();
        collectAllColumnExpressions(set);
        for (int i = 0; i < set.size(); i++) {
            ExpressionColumn array_element = (ExpressionColumn)set.get(i);
            ColumnSchema column = table.getColumn(table.getColumnIndex(array_element.getAlias()));
            array_element.setAttributesAsColumn(column, false);

        }
    }

    /**
     * This ugly code is never called by HSQL or VoltDB
     * explicitly, but it does make debugging in eclipse
     * easier because it makes expressions display their
     * type when you mouse over them.
     */
    @Override
    public String toString() {
        String type = null;

        // iterate through all optypes, looking for
        // a match...
        // sadly do this with reflection
        Field[] fields = OpTypes.class.getFields();
        for (Field f : fields) {
            if (f.getType() != int.class) continue;
            int value = 0;
            try {
                value = f.getInt(null);
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            // found a match
            if (value == opType) {
                type = f.getName();
                break;
            }
        }
        assert(type != null);

        // return the original default impl + the type
        String str = super.toString() + " with opType " + type +
                ", isAggregate: " + isAggregate +
                ", columnIndex: " + columnIndex;
        if (this instanceof ExpressionOrderBy) {
            str += "\n  " + this.nodes[LEFT].toString();
        }
        return str;
    }
    /**********************************************************************/
}


File: src/hsqldb19b3/org/hsqldb_voltpatches/SetFunction.java
/* Copyright (c) 2001-2009, The HSQL Development Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the HSQL Development Group nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package org.hsqldb_voltpatches;

import java.math.BigDecimal;
import java.math.BigInteger;

import org.hsqldb_voltpatches.lib.HashSet;
import org.hsqldb_voltpatches.store.ValuePool;
import org.hsqldb_voltpatches.types.DTIType;
import org.hsqldb_voltpatches.types.IntervalMonthData;
import org.hsqldb_voltpatches.types.IntervalSecondData;
import org.hsqldb_voltpatches.types.IntervalType;
import org.hsqldb_voltpatches.types.NumberType;
import org.hsqldb_voltpatches.types.Type;

import java.io.Serializable;

/**
 * Implementation of SQL set functions (currently only aggregate functions).
 * This reduces temporary Object creation by SUM and AVG functions for
 * INTEGER and narrower types.
 *
 * @author Campbell Boucher-Burnett (boucherb@users dot sourceforge.net)
 * @author Fred Toussi (fredt@users dot sourceforge.net)
 * @version 1.9.0
 * @since 1.7.2
 *
 */
public class SetFunction implements Serializable {

    private HashSet distinctValues;
    private boolean isDistinct;

    //
    private int  setType;
    private int  dataType;
    private Type type;

    //
    private int count;

    //
    private boolean    hasNull;
    private boolean    every = true;
    private boolean    some  = false;
    private long       currentLong;
    private double     currentDouble;
    private BigDecimal currentBigDecimal;
    private Object     currentValue;

    SetFunction(int setType, Type type, boolean isDistinct) {

        this.setType = setType;
        this.type    = type;

        if (isDistinct) {
            this.isDistinct = true;
            distinctValues  = new HashSet();
        }

        if (setType == OpTypes.VAR_SAMP || setType == OpTypes.STDDEV_SAMP) {
            this.sample = true;
        }

        if (type != null) {
            dataType = type.typeCode;

            if (type.isIntervalType()) {
                dataType = Types.SQL_INTERVAL;
            }
        }
    }

    void add(Session session, Object item) {

        if (item == null) {
            hasNull = true;

            session.addWarning(Error.error(ErrorCode.W_01003));

            return;
        }

        if (isDistinct && !distinctValues.add(item)) {
            return;
        }

        count++;

        switch (setType) {

            case OpTypes.COUNT :
                return;
            // A VoltDB extension APPROC_COUNT_DISTINCT
            case OpTypes.APPROX_COUNT_DISTINCT:
                // Return "unexpected token" error
                throw Error.error(ErrorCode.X_42581, Tokens.T_APPROX_COUNT_DISTINCT);
            // End of VoltDB extension
            case OpTypes.AVG :
            case OpTypes.SUM : {
                switch (dataType) {

                    case Types.TINYINT :
                    case Types.SQL_SMALLINT :
                    case Types.SQL_INTEGER :
                        currentLong += ((Number) item).intValue();

                        return;

                    case Types.SQL_INTERVAL :
                        if (item instanceof IntervalSecondData) {
                            addLong(((IntervalSecondData) item).units);

                            currentLong += ((IntervalSecondData) item).nanos;

                            if (Math.abs(currentLong)
                                    >= DTIType.nanoScaleFactors[0]) {
                                addLong(currentLong
                                        / DTIType.nanoScaleFactors[0]);

                                currentLong %= DTIType.nanoScaleFactors[0];
                            }
                        } else if (item instanceof IntervalMonthData) {
                            addLong(((IntervalMonthData) item).units);
                        }

                        return;

                    case Types.SQL_BIGINT :
                        addLong(((Number) item).longValue());

                        return;

                    case Types.SQL_REAL :
                    case Types.SQL_FLOAT :
                    case Types.SQL_DOUBLE :
                        currentDouble += ((Number) item).doubleValue();

                        return;

                    case Types.SQL_NUMERIC :
                    case Types.SQL_DECIMAL :
                        if (currentBigDecimal == null) {
                            currentBigDecimal = (BigDecimal) item;
                        } else {
                            currentBigDecimal =
                                currentBigDecimal.add((BigDecimal) item);
                        }

                        return;

                    default :
                        throw Error.error(ErrorCode.X_42565);
                }
            }
            case OpTypes.MIN : {
                if (currentValue == null) {
                    currentValue = item;

                    return;
                }

                if (type.compare(currentValue, item) > 0) {
                    currentValue = item;
                }

                return;
            }
            case OpTypes.MAX : {
                if (currentValue == null) {
                    currentValue = item;

                    return;
                }

                if (type.compare(currentValue, item) < 0) {
                    currentValue = item;
                }

                return;
            }
            case OpTypes.EVERY :
                if (!(item instanceof Boolean)) {
                    throw Error.error(ErrorCode.X_42565);
                }

                every = every && ((Boolean) item).booleanValue();

                return;

            case OpTypes.SOME :
                if (!(item instanceof Boolean)) {
                    throw Error.error(ErrorCode.X_42565);
                }

                some = some || ((Boolean) item).booleanValue();

                return;

            case OpTypes.STDDEV_POP :
            case OpTypes.STDDEV_SAMP :
            case OpTypes.VAR_POP :
            case OpTypes.VAR_SAMP :
                addDataPoint((Number) item);

                return;

            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "SetFunction");
        }
    }

    Object getValue() {

        if (setType == OpTypes.COUNT) {
            return ValuePool.getInt(count);
        }

        // A VoltDB extension APPROX_COUNT_DISTINCT
        if (setType == OpTypes.APPROX_COUNT_DISTINCT) {
            throw Error.error(ErrorCode.X_42581, Tokens.T_APPROX_COUNT_DISTINCT);
        }
        // End of VoltDB extension
        if (count == 0) {
            return null;
        }

        switch (setType) {

            case OpTypes.AVG : {
                switch (dataType) {

                    case Types.TINYINT :
                    case Types.SQL_SMALLINT :
                    case Types.SQL_INTEGER :
                        return new Long(currentLong / count);

                    case Types.SQL_BIGINT : {
                        long value = getLongSum().divide(
                            BigInteger.valueOf(count)).longValue();

                        return new Long(value);
                    }
                    case Types.SQL_REAL :
                    case Types.SQL_FLOAT :
                    case Types.SQL_DOUBLE :
                        return new Double(currentDouble / count);

                    case Types.SQL_NUMERIC :
                    case Types.SQL_DECIMAL :
                        return currentBigDecimal.divide(new BigDecimal(count),
                                                        BigDecimal.ROUND_DOWN);

                    case Types.SQL_INTERVAL : {
                        BigInteger bi =
                            getLongSum().divide(BigInteger.valueOf(count));

                        if (!NumberType.isInLongLimits(bi)) {
                            throw Error.error(ErrorCode.X_22015);
                        }

                        if (((IntervalType) type).isDaySecondIntervalType()) {
                            return new IntervalSecondData(bi.longValue(),
                                                          currentLong,
                                                          (IntervalType) type,
                                                          true);
                        } else {
                            return IntervalMonthData.newIntervalMonth(
                                bi.longValue(), (IntervalType) type);
                        }
                    }
                    default :
                        throw Error.runtimeError(ErrorCode.U_S0500,
                                                 "SetFunction");
                }
            }
            case OpTypes.SUM : {
                switch (dataType) {

                    case Types.TINYINT :
                    case Types.SQL_SMALLINT :
                    case Types.SQL_INTEGER :
                        return new Long(currentLong);

                    case Types.SQL_BIGINT :
                        return new BigDecimal(getLongSum());

                    case Types.SQL_REAL :
                    case Types.SQL_FLOAT :
                    case Types.SQL_DOUBLE :
                        return new Double(currentDouble);

                    case Types.SQL_NUMERIC :
                    case Types.SQL_DECIMAL :
                        return currentBigDecimal;

                    case Types.SQL_INTERVAL : {
                        BigInteger bi = getLongSum();

                        if (!NumberType.isInLongLimits(bi)) {
                            throw Error.error(ErrorCode.X_22015);
                        }

                        if (((IntervalType) type).isDaySecondIntervalType()) {
                            return new IntervalSecondData(bi.longValue(),
                                                          currentLong,
                                                          (IntervalType) type,
                                                          true);
                        } else {
                            return IntervalMonthData.newIntervalMonth(
                                bi.longValue(), (IntervalType) type);
                        }
                    }
                    default :
                        throw Error.runtimeError(ErrorCode.U_S0500,
                                                 "SetFunction");
                }
            }
            case OpTypes.MIN :
            case OpTypes.MAX :
                return currentValue;

            case OpTypes.EVERY :
                return every ? Boolean.TRUE
                             : Boolean.FALSE;

            case OpTypes.SOME :
                return some ? Boolean.TRUE
                            : Boolean.FALSE;

            case OpTypes.STDDEV_POP :
            case OpTypes.STDDEV_SAMP :
                return getStdDev();

            case OpTypes.VAR_POP :
            case OpTypes.VAR_SAMP :
                return getVariance();

            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "SetFunction");
        }
    }

    /**
     * During parsing and before an instance of SetFunction is created,
     * getType is called with type parameter set to correct type when main
     * SELECT statements contain aggregates.
     *
     */
    static Type getType(int setType, Type type) {

        if (setType == OpTypes.COUNT) {
            return Type.SQL_INTEGER;
        }

        // A VoltDB extension to handle aggfnc(*) syntax errors.
        // If the argument node does not have
        // a data type, it may be '*'.  If the
        // operation is COUNT (optype == 71) this is
        // just fine.  But if it's anything else this
        // is a syntax error.
        if (type == null) {
            throw Error.error(ErrorCode.U_S0500);
        }
        // End of VoltDB extension
        int dataType = type.isIntervalType() ? Types.SQL_INTERVAL
                                             : type.typeCode;

        switch (setType) {

            case OpTypes.AVG : {
                switch (dataType) {

                    case Types.TINYINT :
                    case Types.SQL_SMALLINT :
                    case Types.SQL_INTEGER :
                    case Types.SQL_BIGINT :
                    case Types.SQL_REAL :
                    case Types.SQL_FLOAT :
                    case Types.SQL_DOUBLE :
                    case Types.SQL_NUMERIC :
                    case Types.SQL_DECIMAL :
                    case Types.SQL_INTERVAL :
                        return type;

                    default :
                        throw Error.error(ErrorCode.X_42565);
                }
            }
            case OpTypes.SUM : {
                switch (dataType) {

                    case Types.TINYINT :
                    case Types.SQL_SMALLINT :
                    case Types.SQL_INTEGER :
                        return Type.SQL_BIGINT;

                    case Types.SQL_BIGINT :
                        return Type.SQL_DECIMAL_BIGINT_SQR;

                    case Types.SQL_REAL :
                    case Types.SQL_FLOAT :
                    case Types.SQL_DOUBLE :
                        return Type.SQL_DOUBLE;

                    case Types.SQL_NUMERIC :
                    case Types.SQL_DECIMAL :
                        return Type.getType(type.typeCode, 0,
                                            type.precision * 2, type.scale);

                    case Types.SQL_INTERVAL :
                        return IntervalType.newIntervalType(
                            type.typeCode, DTIType.maxIntervalPrecision,
                            type.scale);

                    default :
                        throw Error.error(ErrorCode.X_42565);
                }
            }
            case OpTypes.MIN :
            case OpTypes.MAX :
                return type;

            case OpTypes.EVERY :
            case OpTypes.SOME :
                if (type.isBooleanType()) {
                    return Type.SQL_BOOLEAN;
                }
                break;

            case OpTypes.STDDEV_POP :
            case OpTypes.STDDEV_SAMP :
            case OpTypes.VAR_POP :
            case OpTypes.VAR_SAMP :
                if (type.isNumberType()) {
                    return Type.SQL_DOUBLE;
                }
                break;

            // A VoltDB extension for APPROX_COUNT_DISTINCT
            case OpTypes.APPROX_COUNT_DISTINCT :
                switch (dataType) {
                case Types.TINYINT :
                case Types.SQL_SMALLINT :
                case Types.SQL_INTEGER :
                case Types.SQL_BIGINT :
                case Types.SQL_DECIMAL :
                case Types.SQL_TIMESTAMP :
                    return Type.SQL_DOUBLE;
                default:
                    throw Error.error(ErrorCode.X_42565);
                }
            // End of VoltDB extension for APPROX_COUNT_DISTINCT
            default :
                throw Error.runtimeError(ErrorCode.U_S0500, "SetFunction");
        }

        throw Error.error(ErrorCode.X_42565);
    }

    // long sum - originally a separate class

    /**
     * Maintain the sum of multiple long values without creating a new
     * BigInteger object for each addition.
     */
    static final BigInteger multiplier =
        BigInteger.valueOf(0x0000000100000000L);

//        BigInteger bigint = BigInteger.ZERO;
    long hi;
    long lo;

    void addLong(long value) {

        if (value == 0) {}
        else if (value > 0) {
            hi += value >> 32;
            lo += value & 0x00000000ffffffffL;
        } else {
            if (value == Long.MIN_VALUE) {
                hi -= 0x000000080000000L;
            } else {
                long temp = ~value + 1;

                hi -= temp >> 32;
                lo -= temp & 0x00000000ffffffffL;
            }
        }

//            bigint = bigint.add(BigInteger.valueOf(value));
    }

    BigInteger getLongSum() {

        BigInteger biglo  = BigInteger.valueOf(lo);
        BigInteger bighi  = BigInteger.valueOf(hi);
        BigInteger result = (bighi.multiply(multiplier)).add(biglo);

/*
            if ( result.compareTo(bigint) != 0 ){
                 throw Trace.error(Trace.GENERAL_ERROR, "longSum mismatch");
            }
*/
        return result;
    }

    // end long sum
    // statistics support - written by Campbell
    // this section was orginally an independent class
    private double  sk;
    private double  vk;
    private long    n;
    private boolean initialized;
    private boolean sample;

    private void addDataPoint(Number x) {    // optimized

        double xi;
        double xsi;
        long   nm1;

        if (x == null) {
            return;
        }

        xi = x.doubleValue();

        if (!initialized) {
            n           = 1;
            sk          = xi;
            vk          = 0.0;
            initialized = true;

            return;
        }

        n++;

        nm1 = (n - 1);
        xsi = (sk - (xi * nm1));
        vk  += ((xsi * xsi) / n) / nm1;
        sk  += xi;
    }

    private Number getVariance() {

        if (!initialized) {
            return null;
        }

        return sample ? (n == 1) ? null    // NULL (not NaN) is correct in this case
                                 : new Double(vk / (double) (n - 1))
                      : new Double(vk / (double) (n));
    }

    private Number getStdDev() {

        if (!initialized) {
            return null;
        }

        return sample ? (n == 1) ? null    // NULL (not NaN) is correct in this case
                                 : new Double(Math.sqrt(vk / (double) (n - 1)))
                      : new Double(Math.sqrt(vk / (double) (n)));
    }

    // end statistics support
}


File: src/hsqldb19b3/org/hsqldb_voltpatches/Tokens.java
/* Copyright (c) 2001-2009, The HSQL Development Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the HSQL Development Group nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package org.hsqldb_voltpatches;

import org.hsqldb_voltpatches.lib.IntValueHashMap;
import org.hsqldb_voltpatches.lib.OrderedIntHashSet;

/**
 * Defines and enumerates reserved and non-reserved SQL keywords.<p>
 *
 * @author  Nitin Chauhan (initial work)
 * @author Fred Toussi (fredt@users dot sourceforge.net)
 * @version 1.9.0
 * @since 1.7.2
 */
public class Tokens {

    //
    // SQL 200n reserved words full set
    static final String        T_ABS              = "ABS";
    public static final String T_ALL              = "ALL";
    static final String        T_ALLOCATE         = "ALLOCATE";
    public static final String T_ALTER            = "ALTER";
    static final String        T_AND              = "AND";
    static final String        T_ANY              = "ANY";
    static final String        T_ARE              = "ARE";
    static final String        T_ARRAY            = "ARRAY";
    public static final String T_AS               = "AS";
    static final String        T_ASENSITIVE       = "ASENSITIVE";
    static final String        T_ASYMMETRIC       = "ASYMMETRIC";
    static final String        T_AT               = "AT";
    static final String        T_ATOMIC           = "ATOMIC";
    public static final String T_AUTHORIZATION    = "AUTHORIZATION";
    static final String        T_AVG              = "AVG";
    static final String        T_BEGIN            = "BEGIN";
    static final String        T_BETWEEN          = "BETWEEN";
    public static final String T_BIGINT           = "BIGINT";
    public static final String T_BINARY           = "BINARY";
    static final String        T_BIT_LENGTH       = "BIT_LENGTH";
    // A VoltDB extension to support varchar column in bytes.
    static final String        T_BYTES            = "BYTES"; // For VoltDB
    // End of VoltDB extension
    public static final String T_BLOB             = "BLOB";
    public static final String T_BOOLEAN          = "BOOLEAN";
    static final String        T_BOTH             = "BOTH";
    static final String        T_BY               = "BY";
    static final String        T_CALL             = "CALL";
    static final String        T_CALLED           = "CALLED";
    static final String        T_CARDINALITY      = "CARDINALITY";
    public static final String T_CASCADED         = "CASCADED";
    static final String        T_CASE             = "CASE";
    static final String        T_CAST             = "CAST";
    static final String        T_CEIL             = "CEIL";
    static final String        T_CEILING          = "CEILING";
    static final String        T_CHAR             = "CHAR";
    static final String        T_CHAR_LENGTH      = "CHAR_LENGTH";
    public static final String T_CHARACTER        = "CHARACTER";
    static final String        T_CHARACTER_LENGTH = "CHARACTER_LENGTH";
    public static final String T_CHECK            = "CHECK";
    public static final String T_CLOB             = "CLOB";
    static final String        T_CLOSE            = "CLOSE";
    static final String        T_COALESCE         = "COALESCE";
    static final String        T_COLLATE          = "COLLATE";
    static final String        T_COLLECT          = "COLLECT";
    static final String        T_COLUMN           = "COLUMN";
    public static final String T_COMMIT           = "COMMIT";
    static final String        T_CONDITION        = "CONDIITON";
    public static final String T_CONNECT          = "CONNECT";
    public static final String T_CONSTRAINT       = "CONSTRAINT";
    static final String        T_CONVERT          = "CONVERT";
    static final String        T_CORR             = "CORR";
    static final String        T_CORRESPONDING    = "CORRESPONDING";
    static final String        T_COUNT            = "COUNT";
    // A VoltDB extension APPROX_COUNT_DISTINCT
    static final String        T_APPROX_COUNT_DISTINCT = "APPROX_COUNT_DISTINCT";
    // End of VoltDB extension
    static final String        T_COVAR_POP        = "COVAR_POP";
    static final String        T_COVAR_SAMP       = "COVAR_SAMP";
    public static final String T_CREATE           = "CREATE";
    static final String        T_CROSS            = "CROSS";
    static final String        T_CUBE             = "CUBE";
    static final String        T_CUME_DIST        = "CUME_DIST";
    static final String        T_CURRENT          = "CURRENT";
    static final String        T_CURRENT_CATALOG  = "CURRENT_CATALOG";
    static final String        T_CURRENT_DATE     = "CURRENT_DATE";
    static final String T_CURRENT_DEFAULT_TRANSFORM_GROUP =
        "CURRENT_DEFAULT_TRANSFORM_GROUP";
    static final String T_CURRENT_PATH      = "CURRENT_PATH";
    static final String T_CURRENT_ROLE      = "CURRENT_ROLE";
    static final String T_CURRENT_SCHEMA    = "CURRENT_SCHEMA";
    static final String T_CURRENT_TIME      = "CURRENT_TIME";
    static final String T_CURRENT_TIMESTAMP = "CURRENT_TIMESTAMP";
    static final String T_CURRENT_TRANSFORM_GROUP_FOR_TYPE =
        "CURRENT_TRANSFORM_GROUP_FOR_TYPE";
    static final String        T_CURRENT_USER      = "CURRENT_USER";
    static final String        T_CURSOR            = "CURSOR";
    static final String        T_CYCLE             = "CYCLE";
    public static final String T_DATE              = "DATE";
    public static final String T_DAY               = "DAY";
    static final String        T_DEALLOCATE        = "DEALLOCATE";
    static final String        T_DEC               = "DEC";
    public static final String T_DECIMAL           = "DECIMAL";
    static final String        T_DECLARE           = "DECLARE";
    public static final String T_DEFAULT           = "DEFAULT";
    public static final String T_DELETE            = "DELETE";
    static final String        T_DENSE_RANK        = "DENSE_RANK";
    static final String        T_DEREF             = "DEREF";
    static final String        T_DESCRIBE          = "DESCRIBE";
    static final String        T_DETERMINISTIC     = "DETERMINISTIC";
    static final String        T_DISCONNECT        = "DISCONNECT";
    static final String        T_DISTINCT          = "DISTINCT";
    public static final String T_DO                = "DO";
    // A VoltDB extension to use FLOAT as the official DOUBLE type name
    public static final String T_DOUBLE            = "FLOAT";
    /* disable 1 line ...
    public static final String T_DOUBLE            = "DOUBLE";
    ... disabled 1 line */
    // End of VoltDB extension
    static final String        T_DROP              = "DROP";
    static final String        T_DYNAMIC           = "DYNAMIC";
    static final String        T_EACH              = "EACH";
    static final String        T_ELEMENT           = "ELEMENT";
    static final String        T_ELSE              = "ELSE";
    static final String        T_ELSEIF            = "ELSEIF";
    static final String        T_END               = "END";
    static final String        T_END_EXEC          = "END_EXEC";
    static final String        T_ESCAPE            = "ESCAPE";
    static final String        T_EVERY             = "EVERY";
    static final String        T_EXCEPT            = "EXCEPT";
    static final String        T_EXEC              = "EXEC";
    public static final String T_EXECUTE           = "EXECUTE";
    static final String        T_EXISTS            = "EXISTS";
    static final String        T_EXP               = "EXP";
    static final String        T_EXTERNAL          = "EXTERNAL";
    static final String        T_EXTRACT           = "EXTRACT";
    static final String        T_FALSE             = "FALSE";
    static final String        T_FETCH             = "FETCH";
    static final String        T_FILTER            = "FILTER";
    static final String        T_FIRST_VALUE       = "FIRST_VALUE";
    public static final String T_FLOAT             = "FLOAT";
    static final String        T_FLOOR             = "FLOOR";
    static final String        T_FOR               = "FOR";
    static final String        T_FOREIGN           = "FOREIGN";
    static final String        T_FREE              = "FREE";
    static final String        T_FROM              = "FROM";
    static final String        T_FULL              = "FULL";
    static final String        T_FUNCTION          = "FUNCTION";
    static final String        T_FUSION            = "FUSION";
    public static final String T_GET               = "GET";
    static final String        T_GLOBAL            = "GLOBAL";
    public static final String T_GRANT             = "GRANT";
    static final String        T_GROUP             = "GROUP";
    static final String        T_GROUPING          = "GROUPING";
    static final String        T_HANDLER           = "HANDLER";
    static final String        T_HAVING            = "HAVING";
    static final String        T_HOLD              = "HOLD";
    public static final String T_HOUR              = "HOUR";
    static final String        T_IDENTITY          = "IDENTITY";
    static final String        T_IF                = "IF";
    static final String        T_IN                = "IN";
    static final String        T_INDICATOR         = "INDICATOR";
    static final String        T_INNER             = "INNER";
    static final String        T_INOUT             = "INOUT";
    static final String        T_INSENSITIVE       = "INSENSITIVE";
    public static final String T_INSERT            = "INSERT";
    static final String        T_INT               = "INT";
    public static final String T_INTEGER           = "INTEGER";
    static final String        T_INTERSECT         = "INTERSECT";
    static final String        T_INTERSECTION      = "INTERSECTION";
    public static final String T_INTERVAL          = "INTERVAL";
    static final String        T_INTO              = "INTO";
    static final String        T_ITERATE           = "ITERATE";
    static final String        T_IS                = "IS";
    static final String        T_JAR               = "JAR";             // SQL/JRT
    static final String        T_JOIN              = "JOIN";
    static final String        T_LAG               = "LAG";
    static final String        T_LANGUAGE          = "LANGUAGE";
    static final String        T_LARGE             = "LARGE";
    static final String        T_LAST_VALUE        = "LAST_VALUE";
    static final String        T_LATERAL           = "LATERAL";
    static final String        T_LEAD              = "LEAD";
    static final String        T_LEADING           = "LEADING";
    static final String        T_LEAVE             = "LEAVE";
    static final String        T_LEFT              = "LEFT";
    static final String        T_LIKE              = "LIKE";
    static final String        T_LIKE_REGX         = "LIKE_REGX";
    static final String        T_LN                = "LN";
    public static final String T_LOCAL             = "LOCAL";
    static final String        T_LOCALTIME         = "LOCALTIME";
    static final String        T_LOCALTIMESTAMP    = "LOCALTIMESTAMP";
    public static final String T_LOOP              = "LOOP";
    static final String        T_LOWER             = "LOWER";
    static final String        T_MATCH             = "MATCH";
    static final String        T_MAX               = "MAX";
    static final String        T_MAX_CARDINALITY   = "MAX_CARDINALITY";
    static final String        T_MEMBER            = "MEMBER";
    static final String        T_MERGE             = "MERGE";
    static final String        T_METHOD            = "METHOD";
    static final String        T_MIN               = "MIN";
    public static final String T_MINUTE            = "MINUTE";
    static final String        T_MOD               = "MOD";
    static final String        T_MODIFIES          = "MODIFIES";
    static final String        T_MODULE            = "MODULE";
    public static final String T_MONTH             = "MONTH";
    static final String        T_MULTISET          = "MULTISET";
    static final String        T_NATIONAL          = "NATIONAL";
    static final String        T_NATURAL           = "NATURAL";
    static final String        T_NCHAR             = "NCHAR";
    static final String        T_NCLOB             = "NCLOB";
    static final String        T_NEW               = "NEW";
    public static final String T_NO                = "NO";
    public static final String T_NONE              = "NONE";
    static final String        T_NORMALIZE         = "NORMALIZE";
    static final String        T_NOT               = "NOT";
    static final String        T_NTH_VALUE         = "NTH_VALUE";
    static final String        T_NTILE             = "NTILE";
    public static final String T_NULL              = "NULL";
    public static final String T_NULLIF            = "NULLIF";
    public static final String T_NUMERIC           = "NUMERIC";
    static final String        T_OCCURRENCES_REGEX = "OCCURRENCES_REGEX";
    static final String        T_OCTET_LENGTH      = "OCTET_LENGTH";
    static final String        T_OF                = "OF";
    static final String        T_OFFSET            = "OFFSET";
    static final String        T_OLD               = "OLD";
    public static final String T_ON                = "ON";
    static final String        T_ONLY              = "ONLY";
    static final String        T_OPEN              = "OPEN";
    static final String        T_OR                = "OR";
    static final String        T_ORDER             = "ORDER";
    static final String        T_OUT               = "OUT";
    static final String        T_OUTER             = "OUTER";
    static final String        T_OVER              = "OVER";
    static final String        T_OVERLAPS          = "OVERLAPS";
    static final String        T_OVERLAY           = "OVERLAY";
    static final String        T_PARAMETER         = "PARAMETER";
    static final String        T_PARTITION         = "PARTITION";
    static final String        T_PERCENT_RANK      = "PERCENT_RANK";
    static final String        T_PERCENTILE_CONT   = "PERCENTILE_CONT";
    static final String        T_PERCENTILE_DISC   = "PERCENTILE_DISC";
    static final String        T_POSITION          = "POSITION";
    static final String        T_POSITION_REGEX    = "POSITION_REGEX";
    static final String        T_POWER             = "POWER";
    static final String        T_PRECISION         = "PRECISION";
    static final String        T_PREPARE           = "PREPARE";
    static final String        T_PRIMARY           = "PRIMARY";
    static final String        T_PROCEDURE         = "PROCEDURE";
    static final String        T_RANGE             = "RANGE";
    static final String        T_RANK              = "RANK";
    static final String        T_READS             = "READS";
    public static final String T_REAL              = "REAL";
    static final String        T_RECURSIVE         = "RECURSIVE";
    static final String        T_REF               = "REF";
    public static final String T_REFERENCES        = "REFERENCES";
    static final String        T_REFERENCING       = "REFERENCING";
    static final String        T_REGR_AVGX         = "REGR_AVGX";
    static final String        T_REGR_AVGY         = "REGR_AVGY";
    static final String        T_REGR_COUNT        = "REGR_COUNT";
    static final String        T_REGR_INTERCEPT    = "REGR_INTERCEPT";
    static final String        T_REGR_R2           = "REGR_R2";
    static final String        T_REGR_SLOPE        = "REGR_SLOPE";
    static final String        T_REGR_SXX          = "REGR_SXX";
    static final String        T_REGR_SXY          = "REGR_SXY";
    static final String        T_REGR_SYY          = "REGR_SYY";
    static final String        T_RELEASE           = "RELEASE";
    static final String        T_REPEAT            = "REPEAT";
    static final String        T_RESIGNAL          = "RESIGNAL";
    static final String        T_RESULT            = "RESULT";
    static final String        T_RETURN            = "RETURN";
    static final String        T_RETURNS           = "RETURNS";
    static final String        T_REVOKE            = "REVOKE";
    static final String        T_RIGHT             = "RIGHT";
    static final String        T_ROLLBACK          = "ROLLBACK";
    static final String        T_ROLLUP            = "ROLLUP";
    static final String        T_ROW               = "ROW";
    static final String        T_ROW_NUMBER        = "ROW_NUMBER";
    static final String        T_ROWS              = "ROWS";
    static final String        T_SAVEPOINT         = "SAVEPOINT";
    static final String        T_SCOPE             = "SCOPE";
    static final String        T_SCROLL            = "SCROLL";
    static final String        T_SEARCH            = "SEARCH";
    public static final String T_SECOND            = "SECOND";
    public static final String T_SELECT            = "SELECT";
    static final String        T_SENSITIVE         = "SENSITIVE";
    static final String        T_SESSION_USER      = "SESSION_USER";
    public static final String T_SET               = "SET";
    static final String        T_SIGNAL            = "SIGNAL";
    static final String        T_SIMILAR           = "SIMILAR";
    public static final String T_SMALLINT          = "SMALLINT";
    static final String        T_SOME              = "SOME";
    static final String        T_SPECIFIC          = "SPECIFIC";
    static final String        T_SPECIFICTYPE      = "SPECIFICTYPE";
    static final String        T_SQL               = "SQL";
    static final String        T_SQLEXCEPTION      = "SQLEXCEPTION";
    static final String        T_SQLSTATE          = "SQLSTATE";
    static final String        T_SQLWARNING        = "SQLWARNING";
    static final String        T_SQRT              = "SQRT";
    static final String        T_START             = "START";
    static final String        T_STATIC            = "STATIC";
    static final String        T_STDDEV_POP        = "STDDEV_POP";
    static final String        T_STDDEV_SAMP       = "STDDEV_SAMP";
    static final String        T_SUBMULTISET       = "SUBMULTISET";
    static final String        T_SUBSTRING         = "SUBSTRING";
    static final String        T_SUBSTRING_REGEX   = "SUBSTRING_REGEX";
    static final String        T_SUM               = "SUM";
    static final String        T_SYMMETRIC         = "SYMMETRIC";
    static final String        T_SYSTEM            = "SYSTEM";
    static final String        T_SYSTEM_USER       = "SYSTEM_USER";
    static final String        T_TABLE             = "TABLE";
    static final String        T_TABLESAMPLE       = "TABLESAMPLE";
    static final String        T_THEN              = "THEN";
    public static final String T_TIME              = "TIME";
    public static final String T_TIMESTAMP         = "TIMESTAMP";
    public static final String T_TIMEZONE_HOUR     = "TIMEZONE_HOUR";
    public static final String T_TIMEZONE_MINUTE   = "TIMEZONE_MINUTE";
    public static final String T_TO                = "TO";
    static final String        T_TRAILING          = "TRAILING";
    static final String        T_TRANSLATE         = "TRANSLATE";
    static final String        T_TRANSLATE_REGEX   = "TRANSLATE_REGEX";
    static final String        T_TRANSLATION       = "TRANSLATION";
    static final String        T_TREAT             = "TREAT";
    public static final String T_TRIGGER           = "TRIGGER";
    static final String        T_TRIM              = "TRIM";
    static final String        T_TRIM_ARRAY        = "TRIM_ARRAY";
    static final String        T_TRUE              = "TRUE";
    static final String        T_TRUNCATE          = "TRUNCATE";
    static final String        T_UESCAPE           = "UESCAPE";
    static final String        T_UNION             = "UNION";
    // A VoltDB extension to support the assume unique index attribute
    static final String        T_ASSUMEUNIQUE      = "ASSUMEUNIQUE";     // For VoltDB
    // End of VoltDB extension
    public static final String T_UNIQUE            = "UNIQUE";
    static final String        T_UNKNOWN           = "UNKNOWN";
    static final String        T_UNNEST            = "UNNEST";
    static final String        T_UNTIL             = "UNTIL";
    public static final String T_UPDATE            = "UPDATE";
    static final String        T_UPPER             = "UPPER";
    public static final String T_USER              = "USER";
    static final String        T_USING             = "USING";
    static final String        T_VALUE             = "VALUE";
    static final String        T_VALUES            = "VALUES";
    static final String        T_VAR_POP           = "VAR_POP";
    static final String        T_VAR_SAMP          = "VAR_SAMP";
    public static final String T_VARBINARY         = "VARBINARY";
    public static final String T_VARCHAR           = "VARCHAR";
    static final String        T_VARYING           = "VARYING";
    static final String        T_WHEN              = "WHEN";
    static final String        T_WHENEVER          = "WHENEVER";
    static final String        T_WHERE             = "WHERE";
    public static final String T_WHILE             = "WHILE";
    static final String        T_WIDTH_BUCKET      = "WIDTH_BUCKET";
    static final String        T_WINDOW            = "WINDOW";
    public static final String T_WITH              = "WITH";
    static final String        T_WITHIN            = "WITHIN";
    static final String        T_WITHOUT           = "WITHOUT";
    public static final String T_YEAR              = "YEAR";

    // ops
    static final String        T_ASTERISK       = "*";
    static final String        T_COMMA          = ",";
    static final String        T_CIRCUMFLEX     = "^";
    static final String        T_CLOSEBRACKET   = ")";
    static final String        T_COLON          = ":";
    static final String        T_CONCAT         = "||";
    public static final String T_DIVIDE         = "/";
    static final String        T_EQUALS         = "=";
    static final String        T_GREATER        = ">";
    static final String        T_GREATER_EQUALS = ">=";
    static final String        T_LESS           = "<";
    static final String        T_LESS_EQUALS    = "<=";
    static final String        T_PERCENT        = "%";
    static final String        T_PLUS           = "+";
    static final String        T_MINUS          = "-";
    static final String        T_NOT_EQUALS     = "<>";
    static final String        T_NOT_EQUALS_ALT = "!=";
    static final String        T_OPENBRACKET    = "(";
    static final String        T_QUESTION       = "?";
    static final String        T_SEMICOLON      = ";";
    static final String        T_DOUBLE_COLON   = "::";

    // SQL:200n non-reserved word list
    static final String T_A                      = "A";
    static final String T_ABSOLUTE               = "ABSOLUTE";
    static final String T_ACTION                 = "ACTION";
    static final String T_ADA                    = "ADA";
    static final String T_ADMIN                  = "ADMIN";
    static final String T_AFTER                  = "AFTER";
    static final String T_ALWAYS                 = "ALWAYS";
    static final String T_ASC                    = "ASC";
    static final String T_ASSERTION              = "ASSERTION";
    static final String T_ASSIGNMENT             = "ASSIGNMENT";
    static final String T_ATTRIBUTE              = "ATTRIBUTE";
    static final String T_ATTRIBUTES             = "ATTRIBUTES";
    static final String T_BEFORE                 = "BEFORE";
    static final String T_BERNOULLI              = "BERNOULLI";
    static final String T_BREADTH                = "BREADTH";
    static final String T_C                      = "C";
    static final String T_CASCADE                = "CASCADE";
    static final String T_CATALOG                = "CATALOG";
    static final String T_CATALOG_NAME           = "CATALOG_NAME";
    static final String T_CHAIN                  = "CHAIN";
    static final String T_CHARACTER_SET_CATALOG  = "CHARACTER_SET_CATALOG";
    static final String T_CHARACTER_SET_NAME     = "CHARACTER_SET_NAME";
    static final String T_CHARACTER_SET_SCHEMA   = "CHARACTER_SET_SCHEMA";
    static final String T_CHARACTERISTICS        = "CHARACTERISTICS";
    static final String T_CHARACTERS             = "CHARACTERS";
    static final String T_CLASS_ORIGIN           = "CLASS_ORIGIN";
    static final String T_COBOL                  = "COBOL";
    static final String T_COLLATION              = "COLLATION";
    static final String T_COLLATION_CATALOG      = "COLLATION_CATALOG";
    static final String T_COLLATION_NAME         = "COLLATION_NAME";
    static final String T_COLLATION_SCHEMA       = "COLLATION_SCHEMA";
    static final String T_COLUMN_NAME            = "COLUMN_NAME";
    static final String T_COMMAND_FUNCTION       = "COMMAND_FUNCTION";
    static final String T_COMMAND_FUNCTION_CODE  = "COMMAND_FUNCTION_CODE";
    static final String T_COMMITTED              = "COMMITTED";
    static final String T_COMPARABLE             = "COMPARABLE";        // SQL/JRT
    static final String T_CONDITION_IDENTIFIER   = "CONDIITON_IDENTIFIER";
    static final String T_CONDITION_NUMBER       = "CONDITION_NUMBER";
    static final String T_CONNECTION_NAME        = "CONNECTION_NAME";
    static final String T_CONSTRAINT_CATALOG     = "CONSTRAINT_CATALOG";
    static final String T_CONSTRAINT_NAME        = "CONSTRAINT_NAME";
    static final String T_CONSTRAINT_SCHEMA      = "CONSTRAINT_SCHEMA";
    static final String T_CONSTRAINTS            = "CONSTRAINTS";
    static final String T_CONSTRUCTOR            = "CONSTRUCTOR";
    static final String T_CONTAINS               = "CONTAINS";
    static final String T_CONTINUE               = "CONTINUE";
    static final String T_CURRENT_COLLATION      = "CURRENT_COLLATION";
    static final String T_CURSOR_NAME            = "CURSOR_NAME";
    static final String T_DATA                   = "DATA";
    static final String T_DATETIME_INTERVAL_CODE = "DATETIME_INTERVAL_CODE";
    static final String T_DATETIME_INTERVAL_PRECISION =
        "DATETIME_INTERVAL_PRECISION";
    static final String        T_DEFAULTS             = "DEFAULTS";
    static final String        T_DEFERRABLE           = "DEFERRABLE";
    static final String        T_DEFERRED             = "DEFERRED";
    static final String        T_DEFINED              = "DEFINED";
    static final String        T_DEFINER              = "DEFINER";
    static final String        T_DEGREE               = "DEGREE";
    static final String        T_DEPTH                = "DEPTH";
    static final String        T_DERIVED              = "DERIVED";
    static final String        T_DESC                 = "DESC";
    static final String        T_DESCRIPTOR           = "DESCRIPTOR";
    static final String        T_DIAGNOSTICS          = "DIAGNOSTICS";
    static final String        T_DISPATCH             = "DISPATCH";
    public static final String T_DOMAIN               = "DOMAIN";
    static final String        T_DYNAMIC_FUNCTION     = "DYNAMIC_FUNCTION";
    static final String T_DYNAMIC_FUNCTION_CODE = "DYNAMIC_FUNCTION_CODE";
    static final String        T_EXCEPTION            = "EXCEPTION";
    static final String        T_EXCLUDE              = "EXCLUDE";
    static final String        T_EXCLUDING            = "EXCLUDING";
    static final String        T_EXIT                 = "EXIT";
    static final String        T_FINAL                = "FINAL";
    static final String        T_FIRST                = "FIRST";
    static final String        T_FOLLOWING            = "FOLLOWING";
    static final String        T_FORTRAN              = "FORTRAN";
    static final String        T_FOUND                = "FOUND";
    public static final String T_G_FACTOR             = "G";
    static final String        T_GENERAL              = "GENERAL";
    static final String        T_GO                   = "GO";
    static final String        T_GOTO                 = "GOTO";
    static final String        T_GRANTED              = "GRANTED";
    static final String        T_HIERARCHY            = "HIERARCHY";
    static final String        T_IMPLEMENTATION       = "IMPLEMENTATION";
    static final String        T_INCLUDING            = "INCLUDING";
    static final String        T_INCREMENT            = "INCREMENT";
    static final String        T_INITIALLY            = "INITIALLY";
    static final String        T_INPUT                = "INPUT";
    static final String        T_INSTANCE             = "INSTANCE";
    static final String        T_INSTANTIABLE         = "INSTANTIABLE";
    static final String        T_INSTEAD              = "INSTEAD";
    static final String        T_INTERFACE            = "INTERFACE";    // SQL/JRT
    static final String        T_INVOKER              = "INVOKER";
    static final String        T_ISOLATION            = "ISOLATION";
    static final String        T_JAVA                 = "JAVA";         // SQL/JRT
    public static final String T_K_FACTOR             = "K";
    static final String        T_KEY                  = "KEY";
    static final String        T_KEY_MEMBER           = "KEY_MEMBER";
    static final String        T_KEY_TYPE             = "KEY_TYPE";
    static final String        T_LAST                 = "LAST";
    static final String        T_LENGTH               = "LENGTH";
    static final String        T_LEVEL                = "LEVEL";
    static final String        T_LOCATOR              = "LOCATOR";
    public static final String T_M_FACTOR             = "M";
    static final String        T_MAP                  = "MAP";
    static final String        T_MATCHED              = "MATCHED";
    static final String        T_MAXVALUE             = "MAXVALUE";
    static final String        T_MESSAGE_LENGTH       = "MESSAGE_LENGTH";
    static final String        T_MESSAGE_OCTET_LENGTH = "MESSAGE_OCTET_LENGTH";
    static final String        T_MESSAGE_TEXT         = "MESSAGE_TEXT";
    static final String        T_MINVALUE             = "MINVALUE";
    static final String        T_MORE                 = "MORE";
    static final String        T_MUMPS                = "MUMPS";
    static final String        T_NAME                 = "NAME";
    static final String        T_NAMES                = "NAMES";
    static final String        T_NESTING              = "NESTING";
    static final String        T_NEXT                 = "NEXT";
    static final String        T_NORMALIZED           = "NORMALIZED";
    static final String        T_NULLABLE             = "NULLABLE";
    static final String        T_NULLS                = "NULLS";
    static final String        T_NUMBER               = "NUMBER";
    public static final String T_OBJECT               = "OBJECT";
    static final String        T_OCTETS               = "OCTETS";
    static final String        T_OPTION               = "OPTION";
    static final String        T_OPTIONS              = "OPTIONS";
    static final String        T_ORDERING             = "ORDERING";
    static final String        T_ORDINALITY           = "ORDINALITY";
    static final String        T_OTHERS               = "OTHERS";
    static final String        T_OVERRIDING           = "OVERRIDING";
    public static final String T_P_FACTOR             = "P";
    static final String        T_PAD                  = "PAD";
    static final String        T_PARAMETER_MODE       = "PARAMETER_MODE";
    static final String        T_PARAMETER_NAME       = "PARAMETER_NAME";
    static final String T_PARAMETER_ORDINAL_POSITION =
        "PARAMETER_ORDINAL_POSITION";
    static final String T_PARAMETER_SPECIFIC_CATALOG =
        "PARAMETER_SPECIFIC_CATALOG";
    static final String T_PARAMETER_SPEC_NAME = "PARAMETER_SPECIFIC_NAME";
    static final String T_PARAMETER_SPEC_SCHEMA = "PARAMETER_SPECIFIC_SCHEMA";
    static final String        T_PARTIAL              = "PARTIAL";
    static final String        T_PASCAL               = "PASCAL";
    static final String        T_PATH                 = "PATH";
    static final String        T_PLACING              = "PLACING";
    static final String        T_PLI                  = "PLI";
    static final String        T_PRECEDING            = "PRECEDING";
    static final String        T_PRESERVE             = "PRESERVE";
    static final String        T_PRIOR                = "PRIOR";
    static final String        T_PRIVILEGES           = "PRIVILEGES";
    static final String        T_PUBLIC               = "PUBLIC";
    static final String        T_READ                 = "READ";
    static final String        T_RELATIVE             = "RELATIVE";
    static final String        T_REPEATABLE           = "REPEATABLE";
    static final String        T_RESTART              = "RESTART";
    static final String        T_RETURNED_CARDINALITY = "RETURNED_CARDINALITY";
    static final String        T_RETURNED_LENGTH      = "RETURNED_LENGTH";
    static final String T_RETURNED_OCTET_LENGTH = "RETURNED_OCTET_LENGTH";
    static final String        T_RETURNED_SQLSTATE    = "RETURNED_SQLSTATE";
    public static final String T_ROLE                 = "ROLE";
    static final String        T_ROUTINE              = "ROUTINE";
    static final String        T_ROUTINE_CATALOG      = "ROUTINE_CATALOG";
    static final String        T_ROUTINE_NAME         = "ROUTINE_NAME";
    static final String        T_ROUTINE_SCHEMA       = "ROUTINE_SCHEMA";
    static final String        T_ROW_COUNT            = "ROW_COUNT";
    static final String        T_SCALE                = "SCALE";
    public static final String T_SCHEMA               = "SCHEMA";
    static final String        T_SCHEMA_NAME          = "SCHEMA_NAME";
    static final String        T_SCOPE_CATALOG        = "SCOPE_CATALOG";
    static final String        T_SCOPE_NAME           = "SCOPE_NAME";
    static final String        T_SCOPE_SCHEMA         = "SCOPE_SCHEMA";
    static final String        T_SECTION              = "SECTION";
    static final String        T_SECURITY             = "SECURITY";
    static final String        T_SELF                 = "SELF";
    static final String        T_SEQUENCE             = "SEQUENCE";
    static final String        T_SERIALIZABLE         = "SERIALIZABLE";
    static final String        T_SERVER_NAME          = "SERVER_NAME";
    public static final String T_SESSION              = "SESSION";
    static final String        T_SETS                 = "SETS";
    static final String        T_SIMPLE               = "SIMPLE";
    static final String        T_SIZE                 = "SIZE";
    static final String        T_SOURCE               = "SOURCE";
    static final String        T_SPACE                = "SPACE";
    static final String        T_SPECIFIC_NAME        = "SPECIFIC_NAME";
    static final String        T_SQLDATA              = "SQLDATA";      // SQL/JRT
    static final String        T_STACKED              = "STACKED";
    static final String        T_STATE                = "STATE";
    static final String        T_STATEMENT            = "STATEMENT";
    static final String        T_STRUCTURE            = "STRUCTURE";
    static final String        T_STYLE                = "STYLE";
    static final String        T_SUBCLASS_ORIGIN      = "SUBCLASS_ORIGIN";
    public static final String T_T_FACTOR             = "T";
    static final String        T_TABLE_NAME           = "TABLE_NAME";
    static final String        T_TEMPORARY            = "TEMPORARY";
    static final String        T_TIES                 = "TIES";
    static final String        T_TOP_LEVEL_COUNT      = "TOP_LEVEL_COUNT";
    static final String        T_TRANSACTION          = "TRANSACTION";
    static final String        T_TRANSACT_COMMITTED = "TRANSACTIONS_COMMITTED";
    static final String T_TRANSACTION_ROLLED_BACK = "TRANSACTIONS_ROLLED_BACK";
    static final String        T_TRANSACT_ACTIVE      = "TRANSACTION_ACTIVE";
    static final String        T_TRANSFORM            = "TRANSFORM";
    static final String        T_TRANSFORMS           = "TRANSFORMS";
    static final String        T_TRIGGER_CATALOG      = "TRIGGER_CATALOG";
    static final String        T_TRIGGER_NAME         = "TRIGGER_NAME";
    static final String        T_TRIGGER_SCHEMA       = "TRIGGER_SCHEMA";
    public static final String T_TYPE                 = "TYPE";
    static final String        T_UNBOUNDED            = "UNBOUNDED";
    static final String        T_UNCOMMITTED          = "UNCOMMITTED";
    static final String        T_UNDER                = "UNDER";
    static final String        T_UNDO                 = "UNDO";
    static final String        T_UNNAMED              = "UNNAMED";
    public static final String T_USAGE                = "USAGE";
    static final String T_USER_DEFINED_TYPE_CATALOG =
        "USER_DEFINED_TYPE_CATALOG";
    static final String T_USER_DEFINED_TYPE_CODE = "USER_DEFINED_TYPE_CODE";
    static final String T_USER_DEFINED_TYPE_NAME = "USER_DEFINED_TYPE_NAME";
    static final String T_USER_DEFINED_TYPE_SCHEMA =
        "USER_DEFINED_TYPE_SCHEMA";
    static final String        T_VIEW  = "VIEW";
    static final String        T_WORK  = "WORK";
    static final String        T_WRITE = "WRITE";
    public static final String T_ZONE  = "ZONE";

    // other tokens
    static final String        T_ADD                 = "ADD";
    static final String        T_ALIAS               = "ALIAS";
    static final String        T_AUTOCOMMIT          = "AUTOCOMMIT";
    static final String        T_BACKUP              = "BACKUP";
    public static final String T_BIT                 = "BIT";
    static final String        T_BITLENGTH           = "BITLENGTH";
    static final String        T_CACHE               = "CACHE";
    static final String        T_CACHED              = "CACHED";
    static final String        T_CASEWHEN            = "CASEWHEN";
    static final String        T_CHECKPOINT          = "CHECKPOINT";
    static final String        T_CLASS               = "CLASS";
    static final String        T_COMPACT             = "COMPACT";
    public static final String T_COMPRESSED          = "COMPRESSED";
    static final String        T_CONTROL             = "CONTROL";
    static final String        T_CURDATE             = "CURDATE";
    static final String        T_CURTIME             = "CURTIME";
    static final String        T_DATABASE            = "DATABASE";
    static final String        T_DEFRAG              = "DEFRAG";
    static final String        T_EXPLAIN             = "EXPLAIN";
    static final String        T_EVENT               = "EVENT";
    static final String        T_FILE                = "FILE";
    static final String        T_FILES               = "FILES";
    static final String        T_FOLD                = "FOLD";
    static final String        T_GENERATED           = "GENERATED";
    static final String        T_HEADER              = "HEADER";
    static final String        T_IFNULL              = "IFNULL";
    static final String        T_IGNORECASE          = "IGNORECASE";
    static final String        T_IMMEDIATELY         = "IMMEDIATELY";
    public static final String T_INDEX               = "INDEX";
    public static final String T_INITIAL             = "INITIAL";
    static final String        T_ISAUTOCOMMIT        = "ISAUTOCOMMIT";
    static final String        T_ISREADONLYDATABASE  = "ISREADONLYDATABASE";
    static final String T_ISREADONLYDATABASEFILES = "ISREADONLYDATABASEFILES";
    static final String        T_ISREADONLYSESSION   = "ISREADONLYSESSION";
    static final String        T_LIMIT               = "LIMIT";
    static final String        T_LOCK                = "LOCK";
    static final String        T_LOCKS               = "LOCKS";
    static final String        T_LOGSIZE             = "LOGSIZE";
    static final String        T_MAXROWS             = "MAXROWS";
    static final String        T_MEMORY              = "MEMORY";
    // A VoltDB extension to support more units for timestamp functions
    static final String        T_MICROS              = "MICROS";         // For VoltDB
    static final String        T_MICROSECOND         = "MICROSECOND";    // For VoltDB
    // End of VoltDB extension
    static final String        T_MILLIS              = "MILLIS";
    // A VoltDB extension to support more units for timestamp functions
    static final String        T_MILLISECOND         = "MILLISECOND";    // For VoltDB
    // End of VoltDB extension
    static final String        T_MINUS_EXCEPT        = "MINUS";
    static final String        T_MVCC                = "MVCC";
    static final String        T_NIO                 = "NIO";
    static final String        T_NOW                 = "NOW";
    static final String        T_NOWAIT              = "NOWAIT";
    static final String        T_NVL                 = "NVL";
    static final String        T_OCTETLENGTH         = "OCTETLENGTH";
    static final String        T_OFF                 = "OFF";
    public static final String T_OTHER               = "OTHER";
    public static final String T_PASSWORD            = "PASSWORD";
    static final String        T_PLAN                = "PLAN";
    static final String        T_PROPERTY            = "PROPERTY";
    static final String        T_QUEUE               = "QUEUE";
    static final String        T_READONLY            = "READONLY";
    static final String T_REFERENTIAL_INTEGRITY      = "REFERENTIAL_INTEGRITY";
    static final String        T_RENAME              = "RENAME";
    static final String        T_RESTRICT            = "RESTRICT";
    static final String        T_SCRIPT              = "SCRIPT";
    static final String        T_SCRIPTFORMAT        = "SCRIPTFORMAT";
    static final String        T_BLOCKING            = "BLOCKING";
    static final String        T_SHUTDOWN            = "SHUTDOWN";
    static final String        T_SQL_TSI_DAY         = "SQL_TSI_DAY";
    static final String        T_SQL_TSI_FRAC_SECOND = "SQL_TSI_FRAC_SECOND";
    static final String        T_SQL_TSI_HOUR        = "SQL_TSI_HOUR";
    static final String        T_SQL_TSI_MINUTE      = "SQL_TSI_MINUTE";
    static final String        T_SQL_TSI_MONTH       = "SQL_TSI_MONTH";
    static final String        T_SQL_TSI_QUARTER     = "SQL_TSI_QUARTER";
    static final String        T_SQL_TSI_SECOND      = "SQL_TSI_SECOND";
    static final String        T_SQL_TSI_WEEK        = "SQL_TSI_WEEK";
    static final String        T_SQL_TSI_YEAR        = "SQL_TSI_YEAR";
    static final String        T_SQL_BIGINT          = "SQL_BIGINT";
    static final String        T_SQL_BINARY          = "SQL_BINARY";
    static final String        T_SQL_BIT             = "SQL_BIT";
    static final String        T_SQL_BLOB            = "SQL_BLOB";
    static final String        T_SQL_BOOLEAN         = "SQL_BOOLEAN";
    static final String        T_SQL_CHAR            = "SQL_CHAR";
    static final String        T_SQL_CLOB            = "SQL_CLOB";
    static final String        T_SQL_DATE            = "SQL_DATE";
    static final String        T_SQL_DECIMAL         = "SQL_DECIMAL";
    static final String        T_SQL_DATALINK        = "SQL_DATALINK";
    static final String        T_SQL_DOUBLE          = "SQL_DOUBLE";
    static final String        T_SQL_FLOAT           = "SQL_FLOAT";
    static final String        T_SQL_INTEGER         = "SQL_INTEGER";
    static final String        T_SQL_LONGVARBINARY   = "SQL_LONGVARBINARY";
    static final String        T_SQL_LONGNVARCHAR    = "SQL_LONGNVARCHAR";
    static final String        T_SQL_LONGVARCHAR     = "SQL_LONGVARCHAR";
    static final String        T_SQL_NCHAR           = "SQL_NCHAR";
    static final String        T_SQL_NCLOB           = "SQL_NCLOB";
    static final String        T_SQL_NUMERIC         = "SQL_NUMERIC";
    static final String        T_SQL_NVARCHAR        = "SQL_NVARCHAR";
    static final String        T_SQL_REAL            = "SQL_REAL";
    static final String        T_SQL_ROWID           = "SQL_ROWID";
    static final String        T_SQL_SQLXML          = "SQL_SQLXML";
    static final String        T_SQL_SMALLINT        = "SQL_SMALLINT";
    static final String        T_SQL_TIME            = "SQL_TIME";
    static final String        T_SQL_TIMESTAMP       = "SQL_TIMESTAMP";
    static final String        T_SQL_TINYINT         = "SQL_TINYINT";
    static final String        T_SQL_VARBINARY       = "SQL_VARBINARY";
    static final String        T_SQL_VARCHAR         = "SQL_VARCHAR";
    static final String        T_SYSDATE             = "SYSDATE";
    static final String        T_TEMP                = "TEMP";
    public static final String T_TEXT                = "TEXT";
    static final String        T_TIMESTAMPADD        = "TIMESTAMPADD";
    static final String        T_TIMESTAMPDIFF       = "TIMESTAMPDIFF";
    public static final String T_TINYINT             = "TINYINT";
    static final String        T_TO_CHAR             = "TO_CHAR";
    static final String        T_TODAY               = "TODAY";
    static final String        T_TOP                 = "TOP";
    public static final String T_VARCHAR_IGNORECASE  = "VARCHAR_IGNORECASE";
    static final String        T_WRITE_DELAY         = "WRITE_DELAY";
    public static final String T_YES                 = "YES";
    public static final String T_DAY_NAME            = "DAY_NAME";
    public static final String T_MONTH_NAME          = "MONTH_NAME";
    public static final String T_QUARTER             = "QUARTER";
    public static final String T_DAY_OF_WEEK         = "DAY_OF_WEEK";
    public static final String T_DAY_OF_MONTH        = "DAY_OF_MONTH";
    public static final String T_DAY_OF_YEAR         = "DAY_OF_YEAR";
    public static final String T_WEEK_OF_YEAR        = "WEEK_OF_YEAR";
    static final String        T_DAYNAME             = "DAYNAME";
    static final String        T_NONTHNAME           = "NONTHNAME";
    static final String        T_DAYOFMONTH          = "DAYOFMONTH";
    static final String        T_DAYOFWEEK           = "DAYOFWEEK";
    static final String        T_DAYOFYEAR           = "DAYOFYEAR";
    static final String        T_WEEK                = "WEEK";
    // A VoltDB extension to support WEEKOFYEAR, WEEKDAY function
    static final String        T_WEEKOFYEAR          = "WEEKOFYEAR"; // for compliant with MySQL
    static final String        T_WEEKDAY             = "WEEKDAY";    // for compliant with MySQL
    // End of VoltDB extension

    //
    static final String        T_ACOS             = "ACOS";
    static final String        T_ASIN             = "ASIN";
    static final String        T_ATAN             = "ATAN";
    static final String        T_ATAN2            = "ATAN2";
    static final String        T_COS              = "COS";
    static final String        T_COT              = "COT";
    static final String        T_DEGREES          = "DEGREES";
    static final String        T_DMOD             = "DMOD";
    static final String        T_LOG              = "LOG";
    static final String        T_LOG10            = "LOG10";
    static final String        T_PI               = "PI";
    static final String        T_RADIANS          = "RADIANS";
    static final String        T_RAND             = "RAND";
    static final String        T_ROUND            = "ROUND";
    static final String        T_SIGN             = "SIGN";
    static final String        T_SIN              = "SIN";
    static final String        T_TAN              = "TAN";
    static final String        T_BITAND           = "BITAND";
    static final String        T_BITOR            = "BITOR";
    static final String        T_BITXOR           = "BITXOR";
    // CHERRY PICK -- mysterious
    static final String        T_CONCAT_WORD      = "CONCAT";
    // End of CHERRY PICK
    static final String        T_ROUNDMAGIC       = "ROUNDMAGIC";
    static final String        T_ASCII            = "ASCII";
    // CHERRY PICK -- mysterious
    /* disable 1 line ...
    static final String        T_CONCAT_WORD      = "CONCAT_WORD";
    ... disabled 1 line */
    // End of CHERRY PICK
    static final String        T_DIFFERENCE       = "DIFFERENCE";
    static final String        T_HEXTORAW         = "HEXTORAW";
    static final String        T_LCASE            = "LCASE";
    static final String        T_LOCATE           = "LOCATE";
    static final String        T_LTRIM            = "LTRIM";
    static final String        T_RAWTOHEX         = "RAWTOHEX";
    static final String        T_REPLACE          = "REPLACE";
    static final String        T_RTRIM            = "RTRIM";
    static final String        T_SOUNDEX          = "SOUNDEX";
    static final String        T_SPACE_WORD       = "SPACE_WORD";
    static final String        T_SUBSTR           = "SUBSTR";
    static final String        T_UCASE            = "UCASE";
    static final String        T_DATEDIFF         = "DATEDIFF";
    public static final String T_SECONDS_MIDNIGHT = "SECONDS_SINCE_MIDNIGHT";

    //
    //
    //SQL 200n Standard reserved keywords - full set
    public static final int ABS                              = 1;
    public static final int ALL                              = 2;
    public static final int ALLOCATE                         = 3;
    public static final int ALTER                            = 4;
    public static final int AND                              = 5;
    public static final int ANY                              = 6;
    public static final int ARE                              = 7;
    public static final int ARRAY                            = 8;
    public static final int AS                               = 9;
    public static final int ASENSITIVE                       = 10;
    public static final int ASYMMETRIC                       = 11;
    public static final int AT                               = 12;
    public static final int ATOMIC                           = 13;
    public static final int AUTHORIZATION                    = 14;
    public static final int AVG                              = 15;
    public static final int BEGIN                            = 16;
    public static final int BETWEEN                          = 17;
    public static final int BIGINT                           = 18;
    public static final int BINARY                           = 19;
    public static final int BLOB                             = 20;
    public static final int BOOLEAN                          = 21;
    public static final int BOTH                             = 22;
    public static final int BY                               = 23;
    public static final int CALL                             = 24;
    public static final int CALLED                           = 25;
    public static final int CARDINALITY                      = 26;
    public static final int CASCADED                         = 27;
    public static final int CASE                             = 28;
    public static final int CAST                             = 29;
    public static final int CEIL                             = 30;
    public static final int CEILING                          = 31;
    public static final int CHAR                             = 32;
    public static final int CHAR_LENGTH                      = 33;
    public static final int CHARACTER                        = 34;
    public static final int CHARACTER_LENGTH                 = 35;
    public static final int CHECK                            = 36;
    public static final int CLOB                             = 37;
    public static final int CLOSE                            = 38;
    public static final int COALESCE                         = 39;
    public static final int COLLATE                          = 40;
    public static final int COLLECT                          = 41;
    public static final int COLUMN                           = 42;
    public static final int COMMIT                           = 43;
    public static final int COMPARABLE                       = 44;
    public static final int CONDITION                        = 45;
    public static final int CONNECT                          = 46;
    public static final int CONSTRAINT                       = 47;
    public static final int CONVERT                          = 48;
    public static final int CORR                             = 49;
    public static final int CORRESPONDING                    = 50;
    public static final int COUNT                            = 51;
    // A VoltDB extension APPROX_COUNT_DISTINCT
    public static final int APPROX_COUNT_DISTINCT            = 1304;
    // End of VoltDB extension
    public static final int COVAR_POP                        = 52;
    public static final int COVAR_SAMP                       = 53;
    public static final int CREATE                           = 54;
    public static final int CROSS                            = 55;
    public static final int CUBE                             = 56;
    public static final int CUME_DIST                        = 57;
    public static final int CURRENT                          = 58;
    public static final int CURRENT_CATALOG                  = 59;
    public static final int CURRENT_DATE                     = 60;
    public static final int CURRENT_DEFAULT_TRANSFORM_GROUP  = 61;
    public static final int CURRENT_PATH                     = 62;
    public static final int CURRENT_ROLE                     = 63;
    public static final int CURRENT_SCHEMA                   = 64;
    public static final int CURRENT_TIME                     = 65;
    public static final int CURRENT_TIMESTAMP                = 66;
    public static final int CURRENT_TRANSFORM_GROUP_FOR_TYPE = 67;
    public static final int CURRENT_USER                     = 68;
    public static final int CURSOR                           = 69;
    public static final int CYCLE                            = 70;
    public static final int DATE                             = 71;
    public static final int DAY                              = 72;
    public static final int DEALLOCATE                       = 73;
    public static final int DEC                              = 74;
    public static final int DECIMAL                          = 75;
    public static final int DECLARE                          = 76;
    public static final int DEFAULT                          = 77;
    public static final int DELETE                           = 78;
    public static final int DENSE_RANK                       = 79;
    public static final int DEREF                            = 80;
    public static final int DESCRIBE                         = 81;
    public static final int DETERMINISTIC                    = 82;
    public static final int DISCONNECT                       = 83;
    public static final int DISTINCT                         = 84;
    public static final int DO                               = 85;
    public static final int DOUBLE                           = 86;
    public static final int DROP                             = 87;
    public static final int DYNAMIC                          = 88;
    public static final int EACH                             = 89;
    public static final int ELEMENT                          = 90;
    public static final int ELSE                             = 91;
    public static final int ELSEIF                           = 92;
    public static final int END                              = 93;
    public static final int END_EXEC                         = 94;
    public static final int ESCAPE                           = 95;
    public static final int EVERY                            = 96;
    public static final int EXCEPT                           = 97;
    public static final int EXEC                             = 98;
    public static final int EXECUTE                          = 99;
    public static final int EXISTS                           = 100;
    public static final int EXIT                             = 101;
    public static final int EXP                              = 102;
    public static final int EXTERNAL                         = 103;
    public static final int EXTRACT                          = 104;
    public static final int FALSE                            = 105;
    public static final int FETCH                            = 106;
    public static final int FILTER                           = 107;
    public static final int FIRST_VALUE                      = 108;
    public static final int FLOAT                            = 109;
    public static final int FLOOR                            = 110;
    public static final int FOR                              = 111;
    public static final int FOREIGN                          = 112;
    public static final int FREE                             = 113;
    public static final int FROM                             = 114;
    public static final int FULL                             = 115;
    public static final int FUNCTION                         = 116;
    public static final int FUSION                           = 117;
    public static final int GET                              = 118;
    public static final int GLOBAL                           = 119;
    public static final int GRANT                            = 120;
    public static final int GROUP                            = 121;
    public static final int GROUPING                         = 122;
    public static final int HANDLER                          = 123;
    public static final int HAVING                           = 124;
    public static final int HOLD                             = 125;
    public static final int HOUR                             = 126;
    public static final int IDENTITY                         = 127;
    public static final int IN                               = 128;
    public static final int INDICATOR                        = 129;
    public static final int INNER                            = 130;
    public static final int INOUT                            = 131;
    public static final int INSENSITIVE                      = 132;
    public static final int INSERT                           = 133;
    public static final int INT                              = 134;
    public static final int INTEGER                          = 135;
    public static final int INTERSECT                        = 136;
    public static final int INTERSECTION                     = 137;
    public static final int INTERVAL                         = 138;
    public static final int INTO                             = 139;
    public static final int IS                               = 140;
    public static final int ITERATE                          = 141;
    public static final int JOIN                             = 142;
    public static final int LAG                              = 143;
    public static final int LANGUAGE                         = 144;
    public static final int LARGE                            = 145;
    public static final int LAST_VALUE                       = 146;
    public static final int LATERAL                          = 147;
    public static final int LEAD                             = 148;
    public static final int LEADING                          = 149;
    public static final int LEAVE                            = 150;
    public static final int LEFT                             = 151;
    public static final int LIKE                             = 152;
    public static final int LIKE_REGEX                       = 153;
    public static final int LN                               = 154;
    public static final int LOCAL                            = 155;
    public static final int LOCALTIME                        = 156;
    public static final int LOCALTIMESTAMP                   = 157;
    public static final int LOOP                             = 158;
    public static final int LOWER                            = 159;
    public static final int MATCH                            = 160;
    public static final int MAX                              = 161;
    public static final int MAX_CARDINALITY                  = 162;
    public static final int MEMBER                           = 163;
    public static final int MERGE                            = 164;
    public static final int METHOD                           = 165;
    public static final int MIN                              = 166;
    public static final int MINUTE                           = 167;
    public static final int MOD                              = 168;
    public static final int MODIFIES                         = 169;
    public static final int MODULE                           = 170;
    public static final int MONTH                            = 171;
    public static final int MULTISET                         = 172;
    public static final int NATIONAL                         = 173;
    public static final int NATURAL                          = 174;
    public static final int NCHAR                            = 175;
    public static final int NCLOB                            = 176;
    public static final int NEW                              = 177;
    public static final int NO                               = 178;
    public static final int NONE                             = 179;
    public static final int NORMALIZE                        = 180;
    public static final int NOT                              = 181;
    public static final int NTH_VALUE                        = 182;
    public static final int NTILE                            = 183;
    public static final int NULL                             = 184;
    public static final int NULLIF                           = 185;
    public static final int NUMERIC                          = 186;
    public static final int OCCURRENCES_REGEX                = 187;
    public static final int OCTET_LENGTH                     = 188;
    public static final int OF                               = 189;
    public static final int OFFSET                           = 190;
    public static final int OLD                              = 191;
    public static final int ON                               = 192;
    public static final int ONLY                             = 193;
    public static final int OPEN                             = 194;
    public static final int OR                               = 195;
    public static final int ORDER                            = 196;
    public static final int OUT                              = 197;
    public static final int OUTER                            = 198;
    public static final int OVER                             = 199;
    public static final int OVERLAPS                         = 200;
    public static final int OVERLAY                          = 201;
    public static final int PARAMETER                        = 202;
    public static final int PARTITION                        = 203;
    public static final int PERCENT_RANK                     = 204;
    public static final int PERCENTILE_CONT                  = 205;
    public static final int PERCENTILE_DISC                  = 206;
    public static final int POSITION                         = 207;
    public static final int POSITION_REGEX                   = 208;
    public static final int POWER                            = 209;
    public static final int PRECISION                        = 210;
    public static final int PREPARE                          = 211;
    public static final int PRIMARY                          = 212;
    public static final int PROCEDURE                        = 213;
    public static final int RANGE                            = 214;
    public static final int RANK                             = 215;
    public static final int READS                            = 216;
    public static final int REAL                             = 217;
    public static final int RECURSIVE                        = 218;
    public static final int REF                              = 219;
    public static final int REFERENCES                       = 220;
    public static final int REFERENCING                      = 221;
    public static final int REGR_AVGX                        = 222;
    public static final int REGR_AVGY                        = 223;
    public static final int REGR_COUNT                       = 224;
    public static final int REGR_INTERCEPT                   = 225;
    public static final int REGR_R2                          = 226;
    public static final int REGR_SLOPE                       = 227;
    public static final int REGR_SXX                         = 228;
    public static final int REGR_SXY                         = 229;
    public static final int REGR_SYY                         = 230;
    public static final int RELEASE                          = 231;
    public static final int REPEAT                           = 232;
    public static final int RESIGNAL                         = 233;
    public static final int RESULT                           = 234;
    public static final int RETURN                           = 235;
    public static final int RETURNS                          = 236;
    public static final int REVOKE                           = 237;
    public static final int RIGHT                            = 238;
    public static final int ROLLBACK                         = 239;
    public static final int ROLLUP                           = 240;
    public static final int ROW                              = 241;
    public static final int ROW_NUMBER                       = 242;
    public static final int ROWS                             = 243;
    public static final int SAVEPOINT                        = 244;
    public static final int SCOPE                            = 245;
    public static final int SCROLL                           = 246;
    public static final int SEARCH                           = 247;
    public static final int SECOND                           = 248;
    public static final int SELECT                           = 249;
    public static final int SENSITIVE                        = 250;
    public static final int SESSION_USER                     = 251;
    public static final int SET                              = 252;
    public static final int SIGNAL                           = 253;
    public static final int SIMILAR                          = 254;
    public static final int SMALLINT                         = 255;
    public static final int SOME                             = 256;
    public static final int SPECIFIC                         = 257;
    public static final int SPECIFICTYPE                     = 258;
    public static final int SQL                              = 259;
    public static final int SQLEXCEPTION                     = 260;
    public static final int SQLSTATE                         = 261;
    public static final int SQLWARNING                       = 262;
    public static final int SQRT                             = 263;
    public static final int STACKED                          = 264;
    public static final int START                            = 265;
    public static final int STATIC                           = 266;
    public static final int STDDEV_POP                       = 267;
    public static final int STDDEV_SAMP                      = 268;
    public static final int SUBMULTISET                      = 269;
    public static final int SUBSTRING                        = 270;
    public static final int SUBSTRING_REGEX                  = 271;
    public static final int SUM                              = 272;
    public static final int SYMMETRIC                        = 273;
    public static final int SYSTEM                           = 274;
    public static final int SYSTEM_USER                      = 275;
    public static final int TABLE                            = 276;
    public static final int TABLESAMPLE                      = 277;
    public static final int THEN                             = 278;
    public static final int TIME                             = 279;
    public static final int TIMESTAMP                        = 280;
    public static final int TIMEZONE_HOUR                    = 281;
    public static final int TIMEZONE_MINUTE                  = 282;
    public static final int TO                               = 283;
    public static final int TRAILING                         = 284;
    public static final int TRANSLATE                        = 285;
    public static final int TRANSLATE_REGEX                  = 286;
    public static final int TRANSLATION                      = 287;
    public static final int TREAT                            = 288;
    public static final int TRIGGER                          = 289;
    public static final int TRIM                             = 290;
    public static final int TRIM_ARRAY                       = 291;
    public static final int TRUE                             = 292;
    public static final int TRUNCATE                         = 293;
    public static final int UESCAPE                          = 294;
    public static final int UNDO                             = 295;
    public static final int UNION                            = 296;
    public static final int UNIQUE                           = 297;
    // A VoltDB extension to support the assume unique index attribute
    public static final int ASSUMEUNIQUE                     = 1303;    // For VoltDB
    // End of VoltDB extension
    public static final int UNKNOWN                          = 298;
    public static final int UNNEST                           = 299;
    public static final int UNTIL                            = 300;
    public static final int UPDATE                           = 301;
    public static final int UPPER                            = 302;
    public static final int USER                             = 303;
    public static final int USING                            = 304;
    public static final int VALUE                            = 305;
    public static final int VALUES                           = 306;
    public static final int VAR_POP                          = 307;
    public static final int VAR_SAMP                         = 308;
    public static final int VARBINARY                        = 309;
    public static final int VARCHAR                          = 310;
    public static final int VARYING                          = 311;
    public static final int WHEN                             = 312;
    public static final int WHENEVER                         = 313;
    public static final int WHERE                            = 314;
    public static final int WIDTH_BUCKET                     = 315;
    public static final int WINDOW                           = 316;
    public static final int WITH                             = 317;
    public static final int WITHIN                           = 318;
    public static final int WITHOUT                          = 319;
    public static final int WHILE                            = 320;
    public static final int YEAR                             = 321;

    //SQL 200n Standard non-reserved keywords - full set
    public static final int A                           = 330;
    public static final int ABSOLUTE                    = 331;
    public static final int ACTION                      = 332;
    public static final int ADA                         = 333;
    public static final int ADD                         = 334;
    public static final int ADMIN                       = 335;
    public static final int AFTER                       = 336;
    public static final int ALWAYS                      = 337;
    public static final int ASC                         = 338;
    public static final int ASSERTION                   = 339;
    public static final int ASSIGNMENT                  = 340;
    public static final int ATTRIBUTE                   = 341;
    public static final int ATTRIBUTES                  = 342;
    public static final int BEFORE                      = 343;
    public static final int BERNOULLI                   = 344;
    public static final int BREADTH                     = 345;
    public static final int C                           = 346;
    public static final int CASCADE                     = 347;
    public static final int CATALOG                     = 348;
    public static final int CATALOG_NAME                = 349;
    public static final int CHAIN                       = 350;
    public static final int CHARACTER_SET_CATALOG       = 351;
    public static final int CHARACTER_SET_NAME          = 352;
    public static final int CHARACTER_SET_SCHEMA        = 353;
    public static final int CHARACTERISTICS             = 354;
    public static final int CHARACTERS                  = 355;
    public static final int CLASS_ORIGIN                = 356;
    public static final int COBOL                       = 357;
    public static final int COLLATION                   = 358;
    public static final int COLLATION_CATALOG           = 359;
    public static final int COLLATION_NAME              = 360;
    public static final int COLLATION_SCHEMA            = 361;
    public static final int COLUMN_NAME                 = 362;
    public static final int COMMAND_FUNCTION            = 363;
    public static final int COMMAND_FUNCTION_CODE       = 364;
    public static final int COMMITTED                   = 365;
    public static final int CONDITION_IDENTIFIER        = 366;
    public static final int CONDITION_NUMBER            = 367;
    public static final int CONNECTION                  = 368;
    public static final int CONNECTION_NAME             = 369;
    public static final int CONSTRAINT_CATALOG          = 370;
    public static final int CONSTRAINT_NAME             = 371;
    public static final int CONSTRAINT_SCHEMA           = 372;
    public static final int CONSTRAINTS                 = 373;
    public static final int CONSTRUCTOR                 = 374;
    public static final int CONTAINS                    = 375;
    public static final int CONTINUE                    = 376;
    public static final int CURSOR_NAME                 = 377;
    public static final int DATA                        = 378;
    public static final int DATETIME_INTERVAL_CODE      = 379;
    public static final int DATETIME_INTERVAL_PRECISION = 380;
    public static final int DEFAULTS                    = 381;
    public static final int DEFERRABLE                  = 382;
    public static final int DEFERRED                    = 383;
    public static final int DEFINED                     = 384;
    public static final int DEFINER                     = 385;
    public static final int DEGREE                      = 386;
    public static final int DEPTH                       = 387;
    public static final int DERIVED                     = 388;
    public static final int DESC                        = 389;
    public static final int DESCRIPTOR                  = 390;
    public static final int DIAGNOSTICS                 = 391;
    public static final int DISPATCH                    = 392;
    public static final int DOMAIN                      = 393;
    public static final int DYNAMIC_FUNCTION            = 394;
    public static final int DYNAMIC_FUNCTION_CODE       = 395;
    public static final int EQUALS                      = 396;
    public static final int EXCEPTION                   = 397;
    public static final int EXCLUDE                     = 398;
    public static final int EXCLUDING                   = 399;
    public static final int FINAL                       = 400;
    public static final int FIRST                       = 401;
    public static final int FOLLOWING                   = 402;
    public static final int FORTRAN                     = 403;
    public static final int FOUND                       = 404;
    public static final int G                           = 405;
    public static final int GENERAL                     = 406;
    public static final int GENERATED                   = 407;
    public static final int GO                          = 408;
    public static final int GOTO                        = 409;
    public static final int GRANTED                     = 410;
    public static final int HIERARCHY                   = 411;
    public static final int IF                          = 412;
    public static final int IGNORE                      = 413;
    public static final int IMMEDIATE                   = 414;
    public static final int IMPLEMENTATION              = 415;
    public static final int INCLUDING                   = 416;
    public static final int INCREMENT                   = 417;
    public static final int INITIALLY                   = 418;
    public static final int INPUT                       = 419;
    public static final int INSTANCE                    = 420;
    public static final int INSTANTIABLE                = 421;
    public static final int INSTEAD                     = 422;
    public static final int INVOKER                     = 423;
    public static final int ISOLATION                   = 424;
    public static final int JAVA                        = 425;
    public static final int K                           = 426;
    public static final int KEY                         = 427;
    public static final int KEY_MEMBER                  = 428;
    public static final int KEY_TYPE                    = 429;
    public static final int LAST                        = 430;
    public static final int LENGTH                      = 431;
    public static final int LEVEL                       = 432;
    public static final int LOCATOR                     = 433;
    public static final int M                           = 434;
    public static final int MAP                         = 435;
    public static final int MATCHED                     = 436;
    public static final int MAXVALUE                    = 437;
    public static final int MESSAGE_LENGTH              = 438;
    public static final int MESSAGE_OCTET_LENGTH        = 439;
    public static final int MESSAGE_TEXT                = 440;
    public static final int MINVALUE                    = 441;
    public static final int MORE                        = 442;
    public static final int MUMPS                       = 443;
    public static final int NAME                        = 444;
    public static final int NAMES                       = 445;
    public static final int NESTING                     = 446;
    public static final int NEXT                        = 447;
    public static final int NORMALIZED                  = 448;
    public static final int NULLABLE                    = 449;
    public static final int NULLS                       = 450;
    public static final int NUMBER                      = 451;
    public static final int OBJECT                      = 452;
    public static final int OCTETS                      = 453;
    public static final int OPTION                      = 454;
    public static final int OPTIONS                     = 455;
    public static final int ORDERING                    = 456;
    public static final int ORDINALITY                  = 457;
    public static final int OTHERS                      = 458;
    public static final int OUTPUT                      = 459;
    public static final int OVERRIDING                  = 460;
    public static final int PAD                         = 461;
    public static final int PARAMETER_MODE              = 462;
    public static final int PARAMETER_NAME              = 463;
    public static final int PARAMETER_ORDINAL_POSITION  = 464;
    public static final int PARAMETER_SPECIFIC_CATALOG  = 465;
    public static final int PARAMETER_SPECIFIC_NAME     = 466;
    public static final int PARAMETER_SPECIFIC_SCHEMA   = 467;
    public static final int PARTIAL                     = 468;
    public static final int PASCAL                      = 469;
    public static final int PATH                        = 470;
    public static final int PLACING                     = 471;
    public static final int PLI                         = 472;
    public static final int PRECEDING                   = 473;
    public static final int PRESERVE                    = 474;
    public static final int PRIOR                       = 475;
    public static final int PRIVILEGES                  = 476;
    public static final int PUBLIC                      = 477;
    public static final int READ                        = 478;
    public static final int RELATIVE                    = 479;
    public static final int REPEATABLE                  = 480;
    public static final int RESPECT                     = 481;
    public static final int RESTART                     = 482;
    public static final int RESTRICT                    = 483;
    public static final int RETURNED_CARDINALITY        = 484;
    public static final int RETURNED_LENGTH             = 485;
    public static final int RETURNED_OCTET_LENGTH       = 486;
    public static final int RETURNED_SQLSTATE           = 487;
    public static final int ROLE                        = 488;
    public static final int ROUTINE                     = 489;
    public static final int ROUTINE_CATALOG             = 490;
    public static final int ROUTINE_NAME                = 491;
    public static final int ROUTINE_SCHEMA              = 492;
    public static final int ROW_COUNT                   = 493;
    public static final int SCALE                       = 494;
    public static final int SCHEMA                      = 495;
    public static final int SCHEMA_NAME                 = 496;
    public static final int SCOPE_CATALOG               = 497;
    public static final int SCOPE_NAME                  = 498;
    public static final int SCOPE_SCHEMA                = 499;
    public static final int SECTION                     = 500;
    public static final int SECURITY                    = 501;
    public static final int SELF                        = 502;
    public static final int SEQUENCE                    = 503;
    public static final int SERIALIZABLE                = 504;
    public static final int SERVER_NAME                 = 505;
    public static final int SESSION                     = 506;
    public static final int SETS                        = 507;
    public static final int SIMPLE                      = 508;
    public static final int SIZE                        = 509;
    public static final int SOURCE                      = 510;
    public static final int SPACE                       = 511;
    public static final int SPECIFIC_NAME               = 512;
    public static final int STATE                       = 513;
    public static final int STATEMENT                   = 514;
    public static final int STRUCTURE                   = 515;
    public static final int STYLE                       = 516;
    public static final int SUBCLASS_ORIGIN             = 517;
    public static final int TABLE_NAME                  = 518;
    public static final int TEMPORARY                   = 519;
    public static final int TIES                        = 520;
    public static final int TOP_LEVEL_COUNT             = 521;
    public static final int TRANSACTION                 = 522;
    public static final int TRANSACTION_ACTIVE          = 523;
    public static final int TRANSACTIONS_COMMITTED      = 524;
    public static final int TRANSACTIONS_ROLLED_BACK    = 525;
    public static final int TRANSFORM                   = 526;
    public static final int TRANSFORMS                  = 527;
    public static final int TRIGGER_CATALOG             = 528;
    public static final int TRIGGER_NAME                = 529;
    public static final int TRIGGER_SCHEMA              = 530;
    public static final int TYPE                        = 531;
    public static final int UNBOUNDED                   = 532;
    public static final int UNCOMMITTED                 = 533;
    public static final int UNDER                       = 534;
    public static final int UNNAMED                     = 535;
    public static final int USAGE                       = 536;
    public static final int USER_DEFINED_TYPE_CATALOG   = 537;
    public static final int USER_DEFINED_TYPE_CODE      = 538;
    public static final int USER_DEFINED_TYPE_NAME      = 539;
    public static final int USER_DEFINED_TYPE_SCHEMA    = 540;
    public static final int VIEW                        = 541;
    public static final int WORK                        = 542;
    public static final int WRITE                       = 543;
    public static final int ZONE                        = 544;

    //
    public static final int P = 545;
    public static final int T = 546;

    // other token values used as switch cases
    static final int        ALIAS                 = 551;
    static final int        AUTOCOMMIT            = 552;
    static final int        BIT                   = 553;
    static final int        BIT_LENGTH            = 554;
    // A VoltDB extension to support varchar column in bytes.
    static final int        BYTES                 = 1010; // For VoltDB
    // End of VoltDB extension
    static final int        CACHED                = 555;
    static final int        CASEWHEN              = 556;
    static final int        CHECKPOINT            = 557;
    static final int        COMPACT               = 558;
    static final int        DATABASE              = 559;
    public static final int DAY_OF_WEEK           = 560;
    static final int        DEFRAG                = 561;
    static final int        EXPLAIN               = 562;
    static final int        HEADER                = 563;
    static final int        IGNORECASE            = 564;
    static final int        IFNULL                = 565;
    static final int        INDEX                 = 566;
    static final int        IMMEDIATELY           = 567;
    static final int        INITIAL               = 568;
    static final int        LIMIT                 = 569;
    static final int        LOGSIZE               = 570;
    static final int        MAXROWS               = 571;
    static final int        MEMORY                = 572;
    // A VoltDB extension to support more units for timestamp functions
    static final int        MICROS                = 1000; // For VoltDB
    static final int        MICROSECOND           = 1001; // For VoltDB
    // End of VoltDB extension
    static final int        MILLIS                = 573;
    // A VoltDB extension to support more units for timestamp functions
    static final int        MILLISECOND           = 1002; // For VoltDB
    // End of VoltDB extension
    static final int        MINUS_EXCEPT          = 574;
    static final int        NOW                   = 575;
    static final int        OFF                   = 576;
    static final int        PASSWORD              = 577;
    static final int        PLAN                  = 578;
    static final int        PROPERTY              = 579;
    static final int        READONLY              = 580;
    static final int        REFERENTIAL_INTEGRITY = 581;
    static final int        RENAME                = 582;
    static final int        SCRIPT                = 583;
    static final int        SCRIPTFORMAT          = 584;
    static final int        SEMICOLON             = 585;
    static final int        SHUTDOWN              = 586;
    static final int        TEMP                  = 587;
    static final int        TEXT                  = 588;
    static final int        TO_CHAR               = 589;
    static final int        TODAY                 = 590;
    static final int        TOP                   = 591;
    public static final int WEEK_OF_YEAR          = 592;
    static final int        WRITE_DELAY           = 593;
    static final int        COMPRESSED            = 594;
    static final int        EVENT                 = 595;
    static final int        BACKUP                = 596;
    static final int        BLOCKING              = 597;

    //
    static final int        CURDATE                 = 598;
    static final int        CURTIME                 = 599;
    static final int        TIMESTAMPADD            = 600;
    static final int        TIMESTAMPDIFF           = 601;
    static final int        SYSDATE                 = 602;
    static final int        ISAUTOCOMMIT            = 603;
    static final int        ISREADONLYSESSION       = 604;
    static final int        ISREADONLYDATABASE      = 605;
    static final int        ISREADONLYDATABASEFILES = 606;
    public static final int DAY_NAME                = 607;
    public static final int MONTH_NAME              = 608;
    public static final int QUARTER                 = 609;
    public static final int DAY_OF_MONTH            = 610;
    public static final int DAY_OF_YEAR             = 611;
    static final int        DAYNAME                 = 612;
    static final int        NONTHNAME               = 613;
    static final int        DAYOFMONTH              = 614;
    static final int        DAYOFWEEK               = 615;
    static final int        DAYOFYEAR               = 616;
    // A VoltDB extension to make WEEK public
    public static final int WEEK                    = 617;
    /* disable 1 line ...
    static final int WEEK                           = 617;
    ... disabled 1 line */
    // End of VoltDB extension
    static final int        OCTETLENGTH             = 618;
    static final int        BITLENGTH               = 619;

    //
    static final int        ACOS             = 620;
    static final int        ASIN             = 621;
    static final int        ATAN             = 622;
    static final int        ATAN2            = 623;
    static final int        COS              = 624;
    static final int        COT              = 625;
    static final int        DEGREES          = 626;
    static final int        DMOD             = 627;
    static final int        LOG              = 628;
    static final int        LOG10            = 629;
    static final int        PI               = 630;
    static final int        RADIANS          = 631;
    static final int        RAND             = 632;
    static final int        ROUND            = 633;
    static final int        SIGN             = 634;
    static final int        SIN              = 635;
    static final int        TAN              = 636;
    static final int        BITAND           = 637;
    static final int        BITOR            = 638;
    static final int        BITXOR           = 639;
    static final int        ROUNDMAGIC       = 640;
    static final int        ASCII            = 641;
    static final int        CONCAT_WORD      = 642;
    static final int        DIFFERENCE       = 643;
    static final int        HEXTORAW         = 644;
    static final int        LCASE            = 645;
    static final int        LOCATE           = 646;
    static final int        LTRIM            = 647;
    static final int        RAWTOHEX         = 648;
    static final int        REPLACE          = 649;
    static final int        RTRIM            = 650;
    static final int        SOUNDEX          = 651;
    static final int        SPACE_WORD       = 652;
    static final int        SUBSTR           = 653;
    static final int        UCASE            = 654;
    static final int        DATEDIFF         = 655;
    public static final int SECONDS_MIDNIGHT = 656;

    //
    static final int CONTROL = 657;
    static final int LOCK    = 658;
    static final int LOCKS   = 659;
    static final int MVCC    = 660;

    //
    static final int        ASTERISK         = 661;
    static final int        CLOSEBRACKET     = 662;
    static final int        COLON            = 663;
    static final int        COMMA            = 664;
    static final int        CONCAT           = 665;
    static final int        DIVIDE           = 666;
    static final int        DOUBLE_COLON_OP  = 667;
    static final int        DOUBLE_PERIOD_OP = 668;
    static final int        DOUBLE_COLUMN_OP = 669;
    static final int        GREATER          = 670;
    static final int        GREATER_EQUALS   = 671;
    static final int        LESS             = 672;
    static final int        LESS_EQUALS      = 673;
    public static final int MINUS            = 674;
    static final int        NOT_EQUALS       = 675;
    static final int        OPENBRACKET      = 676;
    static final int        PLUS             = 677;
    static final int        QUESTION         = 678;
    static final int        RIGHT_ARROW_OP   = 679;
    static final int        DOUBLE_COLON     = 680;

    //
    static final int SQL_TSI_FRAC_SECOND = 681;
    static final int SQL_TSI_SECOND      = 682;
    static final int SQL_TSI_MINUTE      = 683;
    static final int SQL_TSI_HOUR        = 684;
    static final int SQL_TSI_DAY         = 685;
    static final int SQL_TSI_WEEK        = 686;
    static final int SQL_TSI_MONTH       = 687;
    static final int SQL_TSI_QUARTER     = 688;
    static final int SQL_TSI_YEAR        = 689;

    // todo - goes into general hsqldb list
    static final int FILE  = 691;
    static final int FILES = 692;
    static final int CACHE = 693;
    static final int NIO = 694;

    //
    static final int SQL_BIGINT        = 701;
    static final int SQL_BINARY        = 702;
    static final int SQL_BIT           = 703;
    static final int SQL_BLOB          = 704;
    static final int SQL_BOOLEAN       = 705;
    static final int SQL_CHAR          = 706;
    static final int SQL_CLOB          = 707;
    static final int SQL_DATE          = 708;
    static final int SQL_DECIMAL       = 709;
    static final int SQL_DATALINK      = 710;
    static final int SQL_DOUBLE        = 711;
    static final int SQL_FLOAT         = 712;
    static final int SQL_INTEGER       = 713;
    static final int SQL_LONGVARBINARY = 714;
    static final int SQL_LONGNVARCHAR  = 715;
    static final int SQL_LONGVARCHAR   = 716;
    static final int SQL_NCHAR         = 717;
    static final int SQL_NCLOB         = 718;
    static final int SQL_NUMERIC       = 719;
    static final int SQL_NVARCHAR      = 720;
    static final int SQL_REAL          = 721;
    static final int SQL_ROWID         = 722;
    static final int SQL_SQLXML        = 723;
    static final int SQL_SMALLINT      = 724;
    static final int SQL_TIME          = 725;
    static final int SQL_TIMESTAMP     = 726;
    static final int SQL_TINYINT       = 727;
    static final int SQL_VARBINARY     = 728;
    static final int SQL_VARCHAR       = 729;

    //
    static final int X_KEYSET      = 730;
    static final int X_OPTION      = 731;
    static final int X_REPEAT      = 732;
    static final int X_POS_INTEGER = 733;

    //
    public static final int X_VALUE                    = 734;
    public static final int X_IDENTIFIER               = 735;
    public static final int X_DELIMITED_IDENTIFIER     = 736;
    public static final int X_ENDPARSE                 = 737;
    public static final int X_STARTPARSE               = 738;
    public static final int X_REMARK                   = 739;
    public static final int X_NULL                     = 730;
    public static final int X_LOB_SIZE                 = 731;
    public static final int X_MALFORMED_STRING         = 732;
    public static final int X_MALFORMED_NUMERIC        = 733;
    public static final int X_MALFORMED_BIT_STRING     = 734;
    public static final int X_MALFORMED_BINARY_STRING  = 735;
    public static final int X_MALFORMED_UNICODE_STRING = 736;
    public static final int X_MALFORMED_COMMENT        = 737;
    public static final int X_MALFORMED_IDENTIFIER     = 738;
    public static final int X_MALFORMED_UNICODE_ESCAPE = 739;
    // A VoltDB extension to support WEEKOFYEAR, WEEKDAY
    public static final int WEEKOFYEAR                 = 740; // for compliant with MySQL
    public static final int WEEKDAY                    = 741; // for compliant with MySQL
    // End of VoltDB extension

    //
    public static final int X_UNKNOWN_TOKEN = -1;
    private static final IntValueHashMap reservedKeys =
        new IntValueHashMap(351);

    static {
        reservedKeys.put(Tokens.T_ABS, ABS);
        reservedKeys.put(Tokens.T_ALL, ALL);
        reservedKeys.put(Tokens.T_ALLOCATE, ALLOCATE);
        reservedKeys.put(Tokens.T_ALTER, ALTER);
        reservedKeys.put(Tokens.T_AND, AND);
        reservedKeys.put(Tokens.T_ANY, ANY);
        reservedKeys.put(Tokens.T_ARE, ARE);
        reservedKeys.put(Tokens.T_ARRAY, ARRAY);
        reservedKeys.put(Tokens.T_AS, AS);
        reservedKeys.put(Tokens.T_ASENSITIVE, ASENSITIVE);
        reservedKeys.put(Tokens.T_ASYMMETRIC, ASYMMETRIC);
        reservedKeys.put(Tokens.T_AT, AT);
        reservedKeys.put(Tokens.T_ATOMIC, ATOMIC);
        reservedKeys.put(Tokens.T_AUTHORIZATION, AUTHORIZATION);
        reservedKeys.put(Tokens.T_AVG, AVG);
        reservedKeys.put(Tokens.T_BEGIN, BEGIN);
        reservedKeys.put(Tokens.T_BETWEEN, BETWEEN);
        reservedKeys.put(Tokens.T_BIGINT, BIGINT);
        reservedKeys.put(Tokens.T_BINARY, BINARY);
        reservedKeys.put(Tokens.T_BIT_LENGTH, BIT_LENGTH);
        // A VoltDB extension to support varchar column in bytes.
        reservedKeys.put(Tokens.T_BYTES, BYTES); // For VoltDB
        // End of VoltDB extension
        reservedKeys.put(Tokens.T_BLOB, BLOB);
        reservedKeys.put(Tokens.T_BOOLEAN, BOOLEAN);
        reservedKeys.put(Tokens.T_BOTH, BOTH);
        reservedKeys.put(Tokens.T_BY, BY);
        reservedKeys.put(Tokens.T_CALL, CALL);
        reservedKeys.put(Tokens.T_CALLED, CALLED);
        reservedKeys.put(Tokens.T_CARDINALITY, CARDINALITY);
        reservedKeys.put(Tokens.T_CASCADED, CASCADED);
        reservedKeys.put(Tokens.T_CASE, CASE);
        reservedKeys.put(Tokens.T_CAST, CAST);
        reservedKeys.put(Tokens.T_CEIL, CEIL);
        reservedKeys.put(Tokens.T_CEILING, CEILING);
        reservedKeys.put(Tokens.T_CHAR, CHAR);
        reservedKeys.put(Tokens.T_CHAR_LENGTH, CHAR_LENGTH);
        reservedKeys.put(Tokens.T_CHARACTER, CHARACTER);
        reservedKeys.put(Tokens.T_CHARACTER_LENGTH, CHARACTER_LENGTH);
        reservedKeys.put(Tokens.T_CHECK, CHECK);
        reservedKeys.put(Tokens.T_CLOB, CLOB);
        reservedKeys.put(Tokens.T_CLOSE, CLOSE);
        reservedKeys.put(Tokens.T_COALESCE, COALESCE);
        reservedKeys.put(Tokens.T_COLLATE, COLLATE);
        reservedKeys.put(Tokens.T_COLLECT, COLLECT);
        reservedKeys.put(Tokens.T_COLUMN, COLUMN);
        reservedKeys.put(Tokens.T_COMMIT, COMMIT);
        reservedKeys.put(Tokens.T_COMPARABLE, COMPARABLE);
        // A VoltDB extension -- mysterious
        reservedKeys.put(Tokens.T_CONCAT, CONCAT);
        // End of VoltDB extension
        reservedKeys.put(Tokens.T_CONDITION, CONDITION);
        reservedKeys.put(Tokens.T_CONNECT, CONNECT);
        reservedKeys.put(Tokens.T_CONSTRAINT, CONSTRAINT);
        reservedKeys.put(Tokens.T_CONVERT, CONVERT);
        reservedKeys.put(Tokens.T_CORR, CORR);
        reservedKeys.put(Tokens.T_CORRESPONDING, CORRESPONDING);
        reservedKeys.put(Tokens.T_COUNT, COUNT);
        // A VoltDB extension APPROX_COUNT_DISTINCT
        reservedKeys.put(Tokens.T_APPROX_COUNT_DISTINCT, APPROX_COUNT_DISTINCT);
        // End of VoltDB extension
        reservedKeys.put(Tokens.T_COVAR_POP, COVAR_POP);
        reservedKeys.put(Tokens.T_COVAR_SAMP, COVAR_SAMP);
        reservedKeys.put(Tokens.T_CREATE, CREATE);
        reservedKeys.put(Tokens.T_CROSS, CROSS);
        reservedKeys.put(Tokens.T_CUBE, CUBE);
        reservedKeys.put(Tokens.T_CUME_DIST, CUME_DIST);
        reservedKeys.put(Tokens.T_CURRENT, CURRENT);
        reservedKeys.put(Tokens.T_CURRENT_CATALOG, CURRENT_CATALOG);
        reservedKeys.put(Tokens.T_CURRENT_DATE, CURRENT_DATE);
        reservedKeys.put(Tokens.T_CURRENT_DEFAULT_TRANSFORM_GROUP,
                         CURRENT_DEFAULT_TRANSFORM_GROUP);
        reservedKeys.put(Tokens.T_CURRENT_PATH, CURRENT_PATH);
        reservedKeys.put(Tokens.T_CURRENT_ROLE, CURRENT_ROLE);
        reservedKeys.put(Tokens.T_CURRENT_SCHEMA, CURRENT_SCHEMA);
        reservedKeys.put(Tokens.T_CURRENT_TIME, CURRENT_TIME);
        reservedKeys.put(Tokens.T_CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);
        reservedKeys.put(Tokens.T_DO, DO);
        reservedKeys.put(Tokens.T_CURRENT_TRANSFORM_GROUP_FOR_TYPE,
                         CURRENT_TRANSFORM_GROUP_FOR_TYPE);
        reservedKeys.put(Tokens.T_CURRENT_USER, CURRENT_USER);
        reservedKeys.put(Tokens.T_CURSOR, CURSOR);
        reservedKeys.put(Tokens.T_CYCLE, CYCLE);
        reservedKeys.put(Tokens.T_DATE, DATE);
        reservedKeys.put(Tokens.T_DAY, DAY);
        reservedKeys.put(Tokens.T_DEALLOCATE, DEALLOCATE);
        reservedKeys.put(Tokens.T_DEC, DEC);
        reservedKeys.put(Tokens.T_DECIMAL, DECIMAL);
        reservedKeys.put(Tokens.T_DECLARE, DECLARE);
        reservedKeys.put(Tokens.T_DEFAULT, DEFAULT);
        reservedKeys.put(Tokens.T_DELETE, DELETE);
        reservedKeys.put(Tokens.T_DENSE_RANK, DENSE_RANK);
        reservedKeys.put(Tokens.T_DEREF, DEREF);
        reservedKeys.put(Tokens.T_DESCRIBE, DESCRIBE);
        reservedKeys.put(Tokens.T_DETERMINISTIC, DETERMINISTIC);
        reservedKeys.put(Tokens.T_DISCONNECT, DISCONNECT);
        reservedKeys.put(Tokens.T_DISTINCT, DISTINCT);
        reservedKeys.put(Tokens.T_DOUBLE, DOUBLE);
        reservedKeys.put(Tokens.T_DROP, DROP);
        reservedKeys.put(Tokens.T_DYNAMIC, DYNAMIC);
        reservedKeys.put(Tokens.T_EACH, EACH);
        reservedKeys.put(Tokens.T_ELEMENT, ELEMENT);
        reservedKeys.put(Tokens.T_ELSE, ELSE);
        reservedKeys.put(Tokens.T_ELSEIF, ELSEIF);
        reservedKeys.put(Tokens.T_END, END);
        reservedKeys.put(Tokens.T_END_EXEC, END_EXEC);
        reservedKeys.put(Tokens.T_ESCAPE, ESCAPE);
        reservedKeys.put(Tokens.T_EVERY, EVERY);
        reservedKeys.put(Tokens.T_EXCEPT, EXCEPT);
        reservedKeys.put(Tokens.T_EXEC, EXEC);
        reservedKeys.put(Tokens.T_EXECUTE, EXECUTE);
        reservedKeys.put(Tokens.T_EXISTS, EXISTS);
        reservedKeys.put(Tokens.T_EXIT, EXIT);
        reservedKeys.put(Tokens.T_EXP, EXP);
        reservedKeys.put(Tokens.T_EXTERNAL, EXTERNAL);
        reservedKeys.put(Tokens.T_EXTRACT, EXTRACT);
        reservedKeys.put(Tokens.T_FALSE, FALSE);
        reservedKeys.put(Tokens.T_FETCH, FETCH);
        reservedKeys.put(Tokens.T_FILTER, FILTER);
        reservedKeys.put(Tokens.T_FIRST_VALUE, FIRST_VALUE);
        reservedKeys.put(Tokens.T_FLOAT, FLOAT);
        reservedKeys.put(Tokens.T_FLOOR, FLOOR);
        reservedKeys.put(Tokens.T_FOR, FOR);
        reservedKeys.put(Tokens.T_FOREIGN, FOREIGN);
        reservedKeys.put(Tokens.T_FREE, FREE);
        reservedKeys.put(Tokens.T_FROM, FROM);
        reservedKeys.put(Tokens.T_FULL, FULL);
        reservedKeys.put(Tokens.T_FUNCTION, FUNCTION);
        reservedKeys.put(Tokens.T_FUSION, FUSION);
        reservedKeys.put(Tokens.T_GET, GET);
        reservedKeys.put(Tokens.T_GLOBAL, GLOBAL);
        reservedKeys.put(Tokens.T_GRANT, GRANT);
        reservedKeys.put(Tokens.T_GROUP, GROUP);
        reservedKeys.put(Tokens.T_GROUPING, GROUPING);
        reservedKeys.put(Tokens.T_HANDLER, HANDLER);
        reservedKeys.put(Tokens.T_HAVING, HAVING);
        reservedKeys.put(Tokens.T_HOLD, HOLD);
        reservedKeys.put(Tokens.T_HOUR, HOUR);
        reservedKeys.put(Tokens.T_IDENTITY, IDENTITY);
        reservedKeys.put(Tokens.T_IF, IF);
        reservedKeys.put(Tokens.T_IN, IN);
        reservedKeys.put(Tokens.T_INDICATOR, INDICATOR);
        reservedKeys.put(Tokens.T_INNER, INNER);
        reservedKeys.put(Tokens.T_INOUT, INOUT);
        reservedKeys.put(Tokens.T_INSENSITIVE, INSENSITIVE);
        reservedKeys.put(Tokens.T_INSERT, INSERT);
        reservedKeys.put(Tokens.T_INT, INT);
        reservedKeys.put(Tokens.T_INTEGER, INTEGER);
        reservedKeys.put(Tokens.T_INTERSECT, INTERSECT);
        reservedKeys.put(Tokens.T_INTERSECTION, INTERSECTION);
        reservedKeys.put(Tokens.T_INTERVAL, INTERVAL);
        reservedKeys.put(Tokens.T_INTO, INTO);
        reservedKeys.put(Tokens.T_IS, IS);
        reservedKeys.put(Tokens.T_ITERATE, ITERATE);
        reservedKeys.put(Tokens.T_JOIN, JOIN);
        reservedKeys.put(Tokens.T_LAG, LAG);
        reservedKeys.put(Tokens.T_LANGUAGE, LANGUAGE);
        reservedKeys.put(Tokens.T_LARGE, LARGE);
        reservedKeys.put(Tokens.T_LAST_VALUE, LAST_VALUE);
        reservedKeys.put(Tokens.T_LATERAL, LATERAL);
        reservedKeys.put(Tokens.T_LEAD, LEAD);
        reservedKeys.put(Tokens.T_LEADING, LEADING);
        reservedKeys.put(Tokens.T_LEAVE, LEAVE);
        reservedKeys.put(Tokens.T_LEFT, LEFT);
        reservedKeys.put(Tokens.T_LIKE, LIKE);
        reservedKeys.put(Tokens.T_LIKE_REGX, LIKE_REGEX);
        reservedKeys.put(Tokens.T_LN, LN);
        reservedKeys.put(Tokens.T_LOCAL, LOCAL);
        reservedKeys.put(Tokens.T_LOCALTIME, LOCALTIME);
        reservedKeys.put(Tokens.T_LOCALTIMESTAMP, LOCALTIMESTAMP);
        reservedKeys.put(Tokens.T_LOOP, LOOP);
        reservedKeys.put(Tokens.T_LOWER, LOWER);
        reservedKeys.put(Tokens.T_MATCH, MATCH);
        reservedKeys.put(Tokens.T_MAX, MAX);
        reservedKeys.put(Tokens.T_MAX_CARDINALITY, MAX_CARDINALITY);
        reservedKeys.put(Tokens.T_MEMBER, MEMBER);
        reservedKeys.put(Tokens.T_MERGE, MERGE);
        reservedKeys.put(Tokens.T_METHOD, METHOD);
        reservedKeys.put(Tokens.T_MIN, MIN);
        reservedKeys.put(Tokens.T_MINUTE, MINUTE);
        reservedKeys.put(Tokens.T_MOD, MOD);
        reservedKeys.put(Tokens.T_MODIFIES, MODIFIES);
        reservedKeys.put(Tokens.T_MODULE, MODULE);
        reservedKeys.put(Tokens.T_MONTH, MONTH);
        reservedKeys.put(Tokens.T_MULTISET, MULTISET);
        reservedKeys.put(Tokens.T_NATIONAL, NATIONAL);
        reservedKeys.put(Tokens.T_NATURAL, NATURAL);
        reservedKeys.put(Tokens.T_NCHAR, NCHAR);
        reservedKeys.put(Tokens.T_NCLOB, NCLOB);
        reservedKeys.put(Tokens.T_NEW, NEW);
        reservedKeys.put(Tokens.T_NO, NO);
        reservedKeys.put(Tokens.T_NONE, NONE);
        reservedKeys.put(Tokens.T_NORMALIZE, NORMALIZE);
        reservedKeys.put(Tokens.T_NOT, NOT);
        reservedKeys.put(Tokens.T_NTH_VALUE, NTH_VALUE);
        reservedKeys.put(Tokens.T_NTILE, NTILE);
        reservedKeys.put(Tokens.T_NULL, NULL);
        reservedKeys.put(Tokens.T_NULLIF, NULLIF);
        reservedKeys.put(Tokens.T_NUMERIC, NUMERIC);
        reservedKeys.put(Tokens.T_OCCURRENCES_REGEX, OCCURRENCES_REGEX);
        reservedKeys.put(Tokens.T_OCTET_LENGTH, OCTET_LENGTH);
        reservedKeys.put(Tokens.T_OF, OF);
        reservedKeys.put(Tokens.T_OFFSET, OFFSET);
        reservedKeys.put(Tokens.T_OLD, OLD);
        reservedKeys.put(Tokens.T_ON, ON);
        reservedKeys.put(Tokens.T_ONLY, ONLY);
        reservedKeys.put(Tokens.T_OPEN, OPEN);
        reservedKeys.put(Tokens.T_OR, OR);
        reservedKeys.put(Tokens.T_ORDER, ORDER);
        reservedKeys.put(Tokens.T_OUT, OUT);
        reservedKeys.put(Tokens.T_OUTER, OUTER);
        reservedKeys.put(Tokens.T_OVER, OVER);
        reservedKeys.put(Tokens.T_OVERLAPS, OVERLAPS);
        reservedKeys.put(Tokens.T_OVERLAY, OVERLAY);
        reservedKeys.put(Tokens.T_PARAMETER, PARAMETER);
        reservedKeys.put(Tokens.T_PARTITION, PARTITION);
        reservedKeys.put(Tokens.T_PERCENT_RANK, PERCENT_RANK);
        reservedKeys.put(Tokens.T_PERCENTILE_CONT, PERCENTILE_CONT);
        reservedKeys.put(Tokens.T_PERCENTILE_DISC, PERCENTILE_DISC);
        reservedKeys.put(Tokens.T_POSITION, POSITION);
        reservedKeys.put(Tokens.T_POSITION_REGEX, POSITION_REGEX);
        reservedKeys.put(Tokens.T_POWER, POWER);
        reservedKeys.put(Tokens.T_PRECISION, PRECISION);
        reservedKeys.put(Tokens.T_PREPARE, PREPARE);
        reservedKeys.put(Tokens.T_PRIMARY, PRIMARY);
        reservedKeys.put(Tokens.T_PROCEDURE, PROCEDURE);
        reservedKeys.put(Tokens.T_RANGE, RANGE);
        reservedKeys.put(Tokens.T_RANK, RANK);
        reservedKeys.put(Tokens.T_READS, READS);
        reservedKeys.put(Tokens.T_REAL, REAL);
        reservedKeys.put(Tokens.T_RECURSIVE, RECURSIVE);
        reservedKeys.put(Tokens.T_REF, REF);
        reservedKeys.put(Tokens.T_REFERENCES, REFERENCES);
        reservedKeys.put(Tokens.T_REFERENCING, REFERENCING);
        reservedKeys.put(Tokens.T_REGR_AVGX, REGR_AVGX);
        reservedKeys.put(Tokens.T_REGR_AVGY, REGR_AVGY);
        reservedKeys.put(Tokens.T_REGR_COUNT, REGR_COUNT);
        reservedKeys.put(Tokens.T_REGR_INTERCEPT, REGR_INTERCEPT);
        reservedKeys.put(Tokens.T_REGR_R2, REGR_R2);
        reservedKeys.put(Tokens.T_REGR_SLOPE, REGR_SLOPE);
        reservedKeys.put(Tokens.T_REGR_SXX, REGR_SXX);
        reservedKeys.put(Tokens.T_REGR_SXY, REGR_SXY);
        reservedKeys.put(Tokens.T_REGR_SYY, REGR_SYY);
        reservedKeys.put(Tokens.T_RELEASE, RELEASE);
        reservedKeys.put(Tokens.T_REPEAT, REPEAT);
        reservedKeys.put(Tokens.T_RESIGNAL, RESIGNAL);
        reservedKeys.put(Tokens.T_RETURN, RETURN);
        reservedKeys.put(Tokens.T_RETURNS, RETURNS);
        reservedKeys.put(Tokens.T_REVOKE, REVOKE);
        reservedKeys.put(Tokens.T_RIGHT, RIGHT);
        reservedKeys.put(Tokens.T_ROLLBACK, ROLLBACK);
        reservedKeys.put(Tokens.T_ROLLUP, ROLLUP);
        reservedKeys.put(Tokens.T_ROW, ROW);
        reservedKeys.put(Tokens.T_ROW_NUMBER, ROW_NUMBER);
        reservedKeys.put(Tokens.T_ROWS, ROWS);
        reservedKeys.put(Tokens.T_SAVEPOINT, SAVEPOINT);
        reservedKeys.put(Tokens.T_SCOPE, SCOPE);
        reservedKeys.put(Tokens.T_SCROLL, SCROLL);
        reservedKeys.put(Tokens.T_SEARCH, SEARCH);
        reservedKeys.put(Tokens.T_SECOND, SECOND);
        reservedKeys.put(Tokens.T_SELECT, SELECT);
        reservedKeys.put(Tokens.T_SENSITIVE, SENSITIVE);
        reservedKeys.put(Tokens.T_SESSION_USER, SESSION_USER);
        reservedKeys.put(Tokens.T_SET, SET);
        reservedKeys.put(Tokens.T_SIGNAL, SIGNAL);
        reservedKeys.put(Tokens.T_SIMILAR, SIMILAR);
        reservedKeys.put(Tokens.T_SMALLINT, SMALLINT);
        reservedKeys.put(Tokens.T_SOME, SOME);
        // A VoltDB extension to augment the set of SQL functions supported
        reservedKeys.put(Tokens.T_SPACE, SPACE);
        // End of VoltDB extension
        reservedKeys.put(Tokens.T_SPECIFIC, SPECIFIC);
        reservedKeys.put(Tokens.T_SPECIFICTYPE, SPECIFICTYPE);
        reservedKeys.put(Tokens.T_SQL, SQL);
        reservedKeys.put(Tokens.T_SQLEXCEPTION, SQLEXCEPTION);
        reservedKeys.put(Tokens.T_SQLSTATE, SQLSTATE);
        reservedKeys.put(Tokens.T_SQLWARNING, SQLWARNING);
        reservedKeys.put(Tokens.T_SQRT, SQRT);
        reservedKeys.put(Tokens.T_STACKED, STACKED);
        reservedKeys.put(Tokens.T_START, START);
        reservedKeys.put(Tokens.T_STATIC, STATIC);
        reservedKeys.put(Tokens.T_STDDEV_POP, STDDEV_POP);
        reservedKeys.put(Tokens.T_STDDEV_SAMP, STDDEV_SAMP);
        reservedKeys.put(Tokens.T_SUBMULTISET, SUBMULTISET);
        reservedKeys.put(Tokens.T_SUBSTRING, SUBSTRING);
        reservedKeys.put(Tokens.T_SUBSTRING_REGEX, SUBSTRING_REGEX);
        reservedKeys.put(Tokens.T_SUM, SUM);
        reservedKeys.put(Tokens.T_SYMMETRIC, SYMMETRIC);
        reservedKeys.put(Tokens.T_SYSTEM, SYSTEM);
        reservedKeys.put(Tokens.T_SYSTEM_USER, SYSTEM_USER);
        reservedKeys.put(Tokens.T_TABLE, TABLE);
        reservedKeys.put(Tokens.T_TABLESAMPLE, TABLESAMPLE);
        reservedKeys.put(Tokens.T_THEN, THEN);
        reservedKeys.put(Tokens.T_TIME, TIME);
        reservedKeys.put(Tokens.T_TIMESTAMP, TIMESTAMP);
        reservedKeys.put(Tokens.T_TIMEZONE_HOUR, TIMEZONE_HOUR);
        reservedKeys.put(Tokens.T_TIMEZONE_MINUTE, TIMEZONE_MINUTE);
        reservedKeys.put(Tokens.T_TO, TO);
        reservedKeys.put(Tokens.T_TRAILING, TRAILING);
        reservedKeys.put(Tokens.T_TRANSLATE, TRANSLATE);
        reservedKeys.put(Tokens.T_TRANSLATE_REGEX, TRANSLATE_REGEX);
        reservedKeys.put(Tokens.T_TRANSLATION, TRANSLATION);
        reservedKeys.put(Tokens.T_TREAT, TREAT);
        reservedKeys.put(Tokens.T_TRIGGER, TRIGGER);
        reservedKeys.put(Tokens.T_TRIM, TRIM);
        reservedKeys.put(Tokens.T_TRIM_ARRAY, TRIM_ARRAY);
        reservedKeys.put(Tokens.T_TRUE, TRUE);
        reservedKeys.put(Tokens.T_TRUNCATE, TRUNCATE);
        reservedKeys.put(Tokens.T_UESCAPE, UESCAPE);
        reservedKeys.put(Tokens.T_UNDO, UNDO);
        reservedKeys.put(Tokens.T_UNION, UNION);
        reservedKeys.put(Tokens.T_UNIQUE, UNIQUE);
        // A VoltDB extension to support the assume unique index attribute
        reservedKeys.put(Tokens.T_ASSUMEUNIQUE, ASSUMEUNIQUE);    // For VoltDB
        // End of VoltDB extension
        reservedKeys.put(Tokens.T_UNKNOWN, UNKNOWN);
        reservedKeys.put(Tokens.T_UNNEST, UNNEST);
        reservedKeys.put(Tokens.T_UNTIL, UNTIL);
        reservedKeys.put(Tokens.T_UPDATE, UPDATE);
        reservedKeys.put(Tokens.T_UPPER, UPPER);
        reservedKeys.put(Tokens.T_USER, USER);
        reservedKeys.put(Tokens.T_USING, USING);
        reservedKeys.put(Tokens.T_VALUE, VALUE);
        reservedKeys.put(Tokens.T_VALUES, VALUES);
        reservedKeys.put(Tokens.T_VAR_POP, VAR_POP);
        reservedKeys.put(Tokens.T_VAR_SAMP, VAR_SAMP);
        reservedKeys.put(Tokens.T_VARBINARY, VARBINARY);
        reservedKeys.put(Tokens.T_VARCHAR, VARCHAR);
        reservedKeys.put(Tokens.T_VARYING, VARYING);
        reservedKeys.put(Tokens.T_WHEN, WHEN);
        reservedKeys.put(Tokens.T_WHENEVER, WHENEVER);
        reservedKeys.put(Tokens.T_WHERE, WHERE);
        reservedKeys.put(Tokens.T_WIDTH_BUCKET, WIDTH_BUCKET);
        reservedKeys.put(Tokens.T_WINDOW, WINDOW);
        reservedKeys.put(Tokens.T_WITH, WITH);
        reservedKeys.put(Tokens.T_WITHIN, WITHIN);
        reservedKeys.put(Tokens.T_WITHOUT, WITHOUT);
        reservedKeys.put(Tokens.T_WHILE, WHILE);
        reservedKeys.put(Tokens.T_YEAR, YEAR);
        // A VoltDB extension to support WEEKOFYEAR and WEEKDAY function
        reservedKeys.put(Tokens.T_WEEKOFYEAR, WEEKOFYEAR);    // For compliant with MySQL
        reservedKeys.put(Tokens.T_WEEKDAY, WEEKDAY);          // For compliant with MySQL
        // End of VoltDB extension
    }

    private static final IntValueHashMap commandSet = new IntValueHashMap(251);

    static {
        commandSet.put(T_IF, Tokens.IF);
        commandSet.put(T_IFNULL, Tokens.IFNULL);
        commandSet.put(T_NVL, Tokens.IFNULL);
        commandSet.put(T_CASEWHEN, Tokens.CASEWHEN);

        //
        commandSet.put(T_ADD, ADD);
        commandSet.put(T_ADMIN, ADMIN);
        commandSet.put(T_ACTION, ACTION);
        commandSet.put(T_AFTER, AFTER);
        commandSet.put(T_ALIAS, ALIAS);
        commandSet.put(T_ALWAYS, ALWAYS);
        commandSet.put(T_ASC, ASC);
        commandSet.put(T_AUTOCOMMIT, AUTOCOMMIT);
        commandSet.put(T_BACKUP, BACKUP);
        commandSet.put(T_BEFORE, BEFORE);
        commandSet.put(T_BIT, BIT);
        commandSet.put(T_BLOCKING, BLOCKING);
        commandSet.put(T_CACHE, CACHE);
        commandSet.put(T_CACHED, CACHED);
        commandSet.put(T_CASCADE, CASCADE);
        commandSet.put(T_CATALOG, CATALOG);
        commandSet.put(T_CHARACTERISTICS, CHARACTERISTICS);
        commandSet.put(T_CHECKPOINT, CHECKPOINT);
        commandSet.put(T_COLLATE, COLLATE);
        commandSet.put(T_COLLATION, COLLATION);
        commandSet.put(T_COMMITTED, COMMITTED);
        commandSet.put(T_COMPACT, COMPACT);
        commandSet.put(T_COMPRESSED, COMPRESSED);
        commandSet.put(T_CONDITION_IDENTIFIER, Tokens.CONDITION_IDENTIFIER);
        commandSet.put(T_CONTAINS, CONTAINS);
        commandSet.put(T_CONTINUE, CONTINUE);
        commandSet.put(T_CONTROL, CONTROL);
        commandSet.put(T_CURDATE, CURDATE);
        commandSet.put(T_CURTIME, CURTIME);
        commandSet.put(T_DATA, DATA);
        commandSet.put(T_DATABASE, DATABASE);
        commandSet.put(T_DEFAULTS, DEFAULTS);
        commandSet.put(T_DEFRAG, DEFRAG);
        commandSet.put(T_DESC, DESC);
        commandSet.put(T_DOMAIN, DOMAIN);
        commandSet.put(T_EXCLUDING, EXCLUDING);
        commandSet.put(T_EXPLAIN, EXPLAIN);
        commandSet.put(T_EVENT, EVENT);
        commandSet.put(T_FILE, FILE);
        commandSet.put(T_FILES, FILES);
        commandSet.put(T_FINAL, FINAL);
        commandSet.put(T_FIRST, FIRST);
        commandSet.put(T_G_FACTOR, G);
        commandSet.put(T_GENERATED, GENERATED);
        commandSet.put(T_GRANTED, GRANTED);
        commandSet.put(T_HEADER, HEADER);
        commandSet.put(T_IGNORECASE, IGNORECASE);
        commandSet.put(T_IMMEDIATELY, IMMEDIATELY);
        commandSet.put(T_INCLUDING, INCLUDING);
        commandSet.put(T_INCREMENT, INCREMENT);
        commandSet.put(T_INDEX, INDEX);
        commandSet.put(T_INITIAL, INITIAL);
        commandSet.put(T_INPUT, INPUT);
        commandSet.put(T_INSTEAD, INSTEAD);
        commandSet.put(T_ISOLATION, ISOLATION);
        commandSet.put(T_ISAUTOCOMMIT, ISAUTOCOMMIT);
        commandSet.put(T_ISREADONLYDATABASE, ISREADONLYDATABASE);
        commandSet.put(T_ISREADONLYDATABASEFILES, ISREADONLYDATABASEFILES);
        commandSet.put(T_ISREADONLYSESSION, ISREADONLYSESSION);
        commandSet.put(T_JAVA, JAVA);
        commandSet.put(T_K_FACTOR, K);
        commandSet.put(T_KEY, KEY);
        commandSet.put(T_LAST, LAST);
        commandSet.put(T_LENGTH, LENGTH);
        commandSet.put(T_LEVEL, LEVEL);
        commandSet.put(T_LIMIT, LIMIT);
        commandSet.put(T_LOGSIZE, LOGSIZE);
        commandSet.put(T_LOCK, LOCK);
        commandSet.put(T_LOCKS, LOCKS);
        commandSet.put(T_M_FACTOR, M);
        commandSet.put(T_MATCHED, MATCHED);
        commandSet.put(T_MAXROWS, MAXROWS);
        commandSet.put(T_MAXVALUE, MAXVALUE);
        commandSet.put(T_MEMORY, MEMORY);
        // A VoltDB extension to support more units for timestamp functions
        commandSet.put(T_MICROS, MICROS);                // For VoltDB
        commandSet.put(T_MICROSECOND, MICROSECOND);      // For VoltDB
        // End of VoltDB extension
        commandSet.put(T_MILLIS, MILLIS);
        // A VoltDB extension to support more units for timestamp functions
        commandSet.put(T_MILLISECOND, MILLISECOND);      // For VoltDB
        // End of VoltDB extension
        commandSet.put(T_MINUS_EXCEPT, MINUS_EXCEPT);
        commandSet.put(T_MINVALUE, MINVALUE);
        commandSet.put(T_MVCC, MVCC);
        commandSet.put(T_NAME, NAME);
        commandSet.put(T_NEXT, NEXT);
        commandSet.put(T_NIO, NIO);
        commandSet.put(T_NOW, NOW);
        commandSet.put(T_NULLS, NULLS);
        commandSet.put(T_OFF, OFF);
        commandSet.put(T_OPTION, OPTION);
        commandSet.put(T_OVERRIDING, OVERRIDING);
        commandSet.put(T_P_FACTOR, P);
        commandSet.put(T_PARTIAL, PARTIAL);
        commandSet.put(T_PASSWORD, PASSWORD);
        commandSet.put(T_PLACING, PLACING);
        commandSet.put(T_PLAN, PLAN);
        commandSet.put(T_PRESERVE, PRESERVE);
        commandSet.put(T_PRIVILEGES, PRIVILEGES);
        commandSet.put(T_PROPERTY, PROPERTY);
        commandSet.put(T_READ, READ);
        commandSet.put(T_READONLY, READONLY);
        commandSet.put(T_REFERENTIAL_INTEGRITY, REFERENTIAL_INTEGRITY);
        commandSet.put(T_RENAME, RENAME);
        commandSet.put(T_REPEATABLE, REPEATABLE);
        commandSet.put(T_RESTART, RESTART);
        commandSet.put(T_RESTRICT, RESTRICT);
        commandSet.put(T_ROLE, ROLE);
        commandSet.put(T_SCHEMA, SCHEMA);
        commandSet.put(T_SCRIPT, SCRIPT);
        commandSet.put(T_SCRIPTFORMAT, SCRIPTFORMAT);
        commandSet.put(T_SEQUENCE, SEQUENCE);
        commandSet.put(T_SESSION, SESSION);
        commandSet.put(T_SERIALIZABLE, SERIALIZABLE);
        commandSet.put(T_SHUTDOWN, SHUTDOWN);
        commandSet.put(T_SIMPLE, SIMPLE);
        commandSet.put(T_SIZE, SIZE);
        commandSet.put(T_SOURCE, SOURCE);
        commandSet.put(T_SQL_BIGINT, SQL_BIGINT);
        commandSet.put(T_SQL_BINARY, SQL_BINARY);
        commandSet.put(T_SQL_BIT, SQL_BIT);
        commandSet.put(T_SQL_BLOB, SQL_BLOB);
        commandSet.put(T_SQL_BOOLEAN, SQL_BOOLEAN);
        commandSet.put(T_SQL_CHAR, SQL_CHAR);
        commandSet.put(T_SQL_CLOB, SQL_CLOB);
        commandSet.put(T_SQL_DATE, SQL_DATE);
        commandSet.put(T_SQL_DECIMAL, SQL_DECIMAL);
        commandSet.put(T_SQL_DATALINK, SQL_DATALINK);
        commandSet.put(T_SQL_DOUBLE, SQL_DOUBLE);
        commandSet.put(T_SQL_FLOAT, SQL_FLOAT);
        commandSet.put(T_SQL_INTEGER, SQL_INTEGER);
        commandSet.put(T_SQL_LONGVARBINARY, SQL_LONGVARBINARY);
        commandSet.put(T_SQL_LONGNVARCHAR, SQL_LONGNVARCHAR);
        commandSet.put(T_SQL_LONGVARCHAR, SQL_LONGVARCHAR);
        commandSet.put(T_SQL_NCHAR, SQL_NCHAR);
        commandSet.put(T_SQL_NCLOB, SQL_NCLOB);
        commandSet.put(T_SQL_NUMERIC, SQL_NUMERIC);
        commandSet.put(T_SQL_NVARCHAR, SQL_NVARCHAR);
        commandSet.put(T_SQL_REAL, SQL_REAL);
        commandSet.put(T_SQL_ROWID, SQL_ROWID);
        commandSet.put(T_SQL_SQLXML, SQL_SQLXML);
        commandSet.put(T_SQL_SMALLINT, SQL_SMALLINT);
        commandSet.put(T_SQL_TIME, SQL_TIME);
        commandSet.put(T_SQL_TIMESTAMP, SQL_TIMESTAMP);
        commandSet.put(T_SQL_TINYINT, SQL_TINYINT);
        commandSet.put(T_SQL_VARBINARY, SQL_VARBINARY);
        commandSet.put(T_SQL_VARCHAR, SQL_VARCHAR);
        commandSet.put(T_SQL_TSI_FRAC_SECOND, SQL_TSI_FRAC_SECOND);
        commandSet.put(T_SQL_TSI_SECOND, SQL_TSI_SECOND);
        commandSet.put(T_SQL_TSI_MINUTE, SQL_TSI_MINUTE);
        commandSet.put(T_SQL_TSI_HOUR, SQL_TSI_HOUR);
        commandSet.put(T_SQL_TSI_DAY, SQL_TSI_DAY);
        commandSet.put(T_SQL_TSI_WEEK, SQL_TSI_WEEK);
        commandSet.put(T_SQL_TSI_MONTH, SQL_TSI_MONTH);
        commandSet.put(T_SQL_TSI_QUARTER, SQL_TSI_QUARTER);
        commandSet.put(T_SQL_TSI_YEAR, SQL_TSI_YEAR);
        commandSet.put(T_STYLE, STYLE);
        commandSet.put(T_T_FACTOR, T);
        commandSet.put(T_TEMP, TEMP);
        commandSet.put(T_TEMPORARY, TEMPORARY);
        commandSet.put(T_TEXT, TEXT);
        commandSet.put(T_TIMESTAMPADD, TIMESTAMPADD);
        commandSet.put(T_TIMESTAMPDIFF, TIMESTAMPDIFF);
        commandSet.put(T_TO_CHAR, TO_CHAR);
        commandSet.put(T_TODAY, TODAY);
        commandSet.put(T_TOP, TOP);
        commandSet.put(T_TRANSACTION, TRANSACTION);
        commandSet.put(T_TYPE, TYPE);
        commandSet.put(T_UNCOMMITTED, UNCOMMITTED);
        commandSet.put(T_USAGE, USAGE);
        commandSet.put(T_VIEW, VIEW);
        commandSet.put(T_WRITE, WRITE);
        commandSet.put(T_WRITE_DELAY, WRITE_DELAY);
        commandSet.put(T_WORK, WORK);
        commandSet.put(T_ZONE, ZONE);

        //
        // A VoltDB extension to extract timestamp field function
        commandSet.put(T_DAYOFWEEK, DAYOFWEEK);
        commandSet.put(T_DAYOFYEAR, DAYOFYEAR);
        commandSet.put(T_WEEK, WEEK);
        commandSet.put(T_WEEKOFYEAR, WEEKOFYEAR);
        commandSet.put(T_WEEK_OF_YEAR, WEEK_OF_YEAR);
        commandSet.put(T_WEEKDAY, WEEKDAY);
        // End of VoltDB extension
        commandSet.put(T_DAY_NAME, DAY_NAME);
        commandSet.put(T_MONTH_NAME, MONTH_NAME);
        commandSet.put(T_QUARTER, QUARTER);
        commandSet.put(T_DAY_OF_WEEK, DAY_OF_WEEK);
        commandSet.put(T_DAY_OF_MONTH, DAY_OF_MONTH);
        commandSet.put(T_DAY_OF_YEAR, DAY_OF_YEAR);
        commandSet.put(T_DAYOFMONTH, DAYOFMONTH);
        commandSet.put(T_BITLENGTH, BITLENGTH);
        commandSet.put(T_OCTETLENGTH, OCTETLENGTH);
        commandSet.put(T_ACOS, ACOS);
        commandSet.put(T_ASIN, ASIN);
        commandSet.put(T_ATAN, ATAN);
        commandSet.put(T_ATAN2, ATAN2);
        commandSet.put(T_COS, COS);
        commandSet.put(T_COT, COT);
        commandSet.put(T_DEGREES, DEGREES);
        commandSet.put(T_DMOD, DMOD);
        commandSet.put(T_LOG, LOG);
        commandSet.put(T_LOG10, LOG10);
        commandSet.put(T_PI, PI);
        commandSet.put(T_RADIANS, RADIANS);
        commandSet.put(T_RAND, RAND);
        commandSet.put(T_ROUND, ROUND);
        commandSet.put(T_SIGN, SIGN);
        commandSet.put(T_SIN, SIN);
        commandSet.put(T_TAN, TAN);
        commandSet.put(T_BITAND, BITAND);
        commandSet.put(T_BITOR, BITOR);
        commandSet.put(T_BITXOR, BITXOR);
        commandSet.put(T_ROUNDMAGIC, ROUNDMAGIC);
        commandSet.put(T_ASCII, ASCII);
        commandSet.put(T_CONCAT_WORD, CONCAT_WORD);
        commandSet.put(T_DIFFERENCE, DIFFERENCE);
        commandSet.put(T_HEXTORAW, HEXTORAW);
        commandSet.put(T_LCASE, LCASE);
        commandSet.put(T_LOCATE, LOCATE);
        commandSet.put(T_LTRIM, LTRIM);
        commandSet.put(T_RAWTOHEX, RAWTOHEX);
        commandSet.put(T_REPLACE, REPLACE);
        commandSet.put(T_RTRIM, RTRIM);
        commandSet.put(T_SOUNDEX, SOUNDEX);
        commandSet.put(T_SPACE_WORD, SPACE_WORD);
        commandSet.put(T_SUBSTR, SUBSTR);
        commandSet.put(T_UCASE, UCASE);
        commandSet.put(T_DATEDIFF, DATEDIFF);
        commandSet.put(T_SECONDS_MIDNIGHT, SECONDS_MIDNIGHT);

        //
        commandSet.put(T_COLON, Tokens.COLON);
        commandSet.put(T_COMMA, Tokens.COMMA);
        commandSet.put(T_SEMICOLON, SEMICOLON);
        commandSet.put(T_EQUALS, Tokens.EQUALS);
        commandSet.put(T_NOT_EQUALS_ALT, Tokens.NOT_EQUALS);
        commandSet.put(T_NOT_EQUALS, Tokens.NOT_EQUALS);
        commandSet.put(T_LESS, Tokens.LESS);
        commandSet.put(T_GREATER, Tokens.GREATER);
        commandSet.put(T_LESS_EQUALS, Tokens.LESS_EQUALS);
        commandSet.put(T_GREATER_EQUALS, Tokens.GREATER_EQUALS);
        commandSet.put(T_PLUS, Tokens.PLUS);
        commandSet.put(T_MINUS, Tokens.MINUS);
        commandSet.put(T_ASTERISK, Tokens.ASTERISK);
        commandSet.put(T_DIVIDE, Tokens.DIVIDE);
        commandSet.put(T_CONCAT, Tokens.CONCAT);
        commandSet.put(T_QUESTION, Tokens.QUESTION);
        commandSet.put(T_OPENBRACKET, OPENBRACKET);
        commandSet.put(T_CLOSEBRACKET, CLOSEBRACKET);
    }

    static int get(String token) {

        int type = reservedKeys.get(token, -1);

        if (type == -1) {
            return commandSet.get(token, -1);
        }

        return type;
    }

    public static boolean isCoreKeyword(int token) {
        return coreReservedWords.contains(token);
    }

    public static boolean isKeyword(String token) {
        return reservedKeys.containsKey(token);
    }

    public static int getKeywordID(String token, int defaultValue) {
        return reservedKeys.get(token, defaultValue);
    }

    public static int getNonKeywordID(String token, int defaultValue) {
        return commandSet.get(token, defaultValue);
    }

    public static String getKeyword(int token) {

        String key = (String) reservedKeys.getKey(token);

        if (key != null) {
            return key;
        }

        key = (String) commandSet.getKey(token);

        return key;
    }

    private static final OrderedIntHashSet coreReservedWords;

    static {

        // minimal set of identifier not allowed as table / column / alias names
        // these are in effect interpreted as reserved words used by HSQLDB
        coreReservedWords = new OrderedIntHashSet(128);

        short[] keyword = {
            ADMIN, AS, AND, ALL, ANY, AT, AVG, BY, BETWEEN, BOTH, CALL, CASE,
            CAST, CORRESPONDING, CONVERT, COUNT, COALESCE, CREATE, CROSS,
            DISTINCT, DROP, ELSE, END, EVERY, EXISTS, EXCEPT, FOR, FROM, FULL,
            GRANT, GROUP, HAVING, INTO, IS, IN, INTERSECT, JOIN, INNER, LEFT,
            LEADING, LIKE, MAX, MIN, NATURAL, NULLIF, NOT, ON, ORDER, OR,
            OUTER, PRIMARY, REFERENCES, RIGHT, SELECT, SET, SOME, STDDEV_POP,
            STDDEV_SAMP, SUM, TABLE, THEN, TO, TRAILING, TRIGGER, UNION,
            UNIQUE, USING, VALUES, VAR_POP, VAR_SAMP, WHEN, WHERE, WITH,
            // A VoltDB extension to support the assume unique index attribute.
            ASSUMEUNIQUE, // For VoltDB
            // End of VoltDB extension
            // A VoltDB extension APPROX_COUNT_DISTINCT
            APPROX_COUNT_DISTINCT,
            // End of VoltDB extension
        };

        for (int i = 0; i < keyword.length; i++) {
            coreReservedWords.add(keyword[i]);
        }
    }

    public static final short[] SQL_INTERVAL_FIELD_CODES = new short[] {
        Tokens.YEAR, Tokens.MONTH, Tokens.DAY, Tokens.HOUR, Tokens.MINUTE,
        Tokens.SECOND
    };
    public static final String[] SQL_INTERVAL_FIELD_NAMES = new String[] {
        Tokens.T_YEAR, Tokens.T_MONTH, Tokens.T_DAY, Tokens.T_HOUR,
        Tokens.T_MINUTE, Tokens.T_SECOND
    };
}


File: tests/frontend/org/voltdb/planner/PlannerTestCase.java
/* This file is part of VoltDB.
 * Copyright (C) 2008-2015 VoltDB Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package org.voltdb.planner;

import java.net.URL;
import java.util.List;

import junit.framework.TestCase;

import org.apache.commons.lang3.StringUtils;
import org.voltdb.catalog.Database;
import org.voltdb.compiler.DeterminismMode;
import org.voltdb.plannodes.AbstractPlanNode;

public class PlannerTestCase extends TestCase {

    private PlannerTestAideDeCamp m_aide;
    private boolean m_byDefaultInferPartitioning = true;
    private boolean m_byDefaultPlanForSinglePartition;

    /**
     * @param sql
     * @return
     */
    private int countQuestionMarks(String sql) {
        int paramCount = 0;
        int skip = 0;
        while (true) {
            // Yes, we ARE assuming that test queries don't contain quoted question marks.
            skip = sql.indexOf('?', skip);
            if (skip == -1) {
                break;
            }
            skip++;
            paramCount++;
        }
        return paramCount;
    }

    protected void failToCompile(String sql, String... patterns)
    {
        int paramCount = countQuestionMarks(sql);
        try {
            m_aide.compile(sql, paramCount,
                    m_byDefaultInferPartitioning, m_byDefaultPlanForSinglePartition, null);
            fail("Expected planner failure, but found success.");
        }
        catch (Exception ex) {
            String result = ex.toString();
            for (String pattern : patterns) {
                if ( ! result.contains(pattern)) {
                    fail("Did not find pattern '" + pattern + "' in error string '" + result + "'");
                }
            }
        }
    }

    protected CompiledPlan compileAdHocPlan(String sql) {
        return compileAdHocPlan(sql, DeterminismMode.SAFER);
    }

    protected CompiledPlan compileAdHocPlan(String sql, DeterminismMode detMode) {
        CompiledPlan cp = null;
        try {
            cp = m_aide.compileAdHocPlan(sql, detMode);
            assertTrue(cp != null);
        }
        catch (Exception ex) {
            ex.printStackTrace();
            fail();
        }
        return cp;
    }

    final int paramCount = 0;
    String noJoinOrder = null;
    /** A helper here where the junit test can assert success */
    protected List<AbstractPlanNode> compileToFragments(String sql)
    {
        boolean planForSinglePartitionFalse = false;
        return compileWithJoinOrderToFragments(sql, planForSinglePartitionFalse, noJoinOrder);
    }

    protected List<AbstractPlanNode> compileToFragmentsForSinglePartition(String sql)
    {
        boolean planForSinglePartitionFalse = false;
        return compileWithJoinOrderToFragments(sql, planForSinglePartitionFalse, noJoinOrder);
    }


    /** A helper here where the junit test can assert success */
    protected List<AbstractPlanNode> compileWithJoinOrderToFragments(String sql, String joinOrder)
    {
        boolean planForSinglePartitionFalse = false;
        return compileWithJoinOrderToFragments(sql, planForSinglePartitionFalse, joinOrder);
    }

    /** A helper here where the junit test can assert success */
    private List<AbstractPlanNode> compileWithJoinOrderToFragments(String sql,
                                                                   boolean planForSinglePartition,
                                                                   String joinOrder)
    {
        // Yes, we ARE assuming that test queries don't contain quoted question marks.
        int paramCount = StringUtils.countMatches(sql, "?");
        return compileWithJoinOrderToFragments(sql, paramCount, planForSinglePartition, joinOrder);
    }

    /** A helper here where the junit test can assert success */
    private List<AbstractPlanNode> compileWithJoinOrderToFragments(String sql, int paramCount,
                                                                   boolean planForSinglePartition,
                                                                   String joinOrder)
    {
        List<AbstractPlanNode> pn = m_aide.compile(sql, paramCount, m_byDefaultInferPartitioning, m_byDefaultPlanForSinglePartition, joinOrder);
        assertTrue(pn != null);
        assertFalse(pn.isEmpty());
        assertTrue(pn.get(0) != null);
        if (planForSinglePartition) {
            assertTrue(pn.size() == 1);
        }
        return pn;
    }

    protected AbstractPlanNode compileSPWithJoinOrder(String sql, String joinOrder)
    {
        try {
            return compileWithCountedParamsAndJoinOrder(sql, joinOrder);
        }
        catch (Exception ex) {
            ex.printStackTrace();
            fail();
            return null;
        }
    }

    protected void compileWithInvalidJoinOrder(String sql, String joinOrder) throws Exception
    {
        compileWithJoinOrderToFragments(sql, paramCount, m_byDefaultPlanForSinglePartition, joinOrder);
    }


    private AbstractPlanNode compileWithCountedParamsAndJoinOrder(String sql, String joinOrder) throws Exception
    {
        // Yes, we ARE assuming that test queries don't contain quoted question marks.
        int paramCount = StringUtils.countMatches(sql, "?");
        return compileSPWithJoinOrder(sql, paramCount, joinOrder);
    }

    /** A helper here where the junit test can assert success */
    protected AbstractPlanNode compile(String sql)
    {
        // Yes, we ARE assuming that test queries don't contain quoted question marks.
        int paramCount = StringUtils.countMatches(sql, "?");
        return compileSPWithJoinOrder(sql, paramCount, null);
    }

    /** A helper here where the junit test can assert success */
    protected AbstractPlanNode compileForSinglePartition(String sql)
    {
        // Yes, we ARE assuming that test queries don't contain quoted question marks.
        int paramCount = StringUtils.countMatches(sql, "?");
        boolean m_infer = m_byDefaultInferPartitioning;
        boolean m_forceSP = m_byDefaultInferPartitioning;
        m_byDefaultInferPartitioning = false;
        m_byDefaultPlanForSinglePartition = true;

        AbstractPlanNode pn = compileSPWithJoinOrder(sql, paramCount, null);
        m_byDefaultInferPartitioning = m_infer;
        m_byDefaultPlanForSinglePartition = m_forceSP;
        return pn;
    }

    /** A helper here where the junit test can assert success */
    protected AbstractPlanNode compileSPWithJoinOrder(String sql, int paramCount, String joinOrder)
    {
        List<AbstractPlanNode> pns = null;
        try {
            pns = compileWithJoinOrderToFragments(sql, paramCount, m_byDefaultPlanForSinglePartition, joinOrder);
        }
        catch (Exception ex) {
            ex.printStackTrace();
            fail(ex.getMessage());
        }
        assertTrue(pns.get(0) != null);
        return pns.get(0);
    }


    protected void setupSchema(URL ddlURL, String basename,
                               boolean planForSinglePartition) throws Exception
    {
        m_aide = new PlannerTestAideDeCamp(ddlURL, basename);
        m_byDefaultPlanForSinglePartition = planForSinglePartition;
    }

    protected void setupSchema(boolean inferPartitioning, URL ddlURL, String basename) throws Exception
    {
        m_byDefaultInferPartitioning = inferPartitioning;
        m_aide = new PlannerTestAideDeCamp(ddlURL, basename);
    }


    Database getDatabase() {
        return m_aide.getDatabase();
    }

    protected void printExplainPlan(List<AbstractPlanNode> planNodes) {
        for (AbstractPlanNode apn: planNodes) {
            System.out.println(apn.toExplainPlanString());
        }
    }

    protected String buildExplainPlan(List<AbstractPlanNode> planNodes) {
        String explain = "";
        for (AbstractPlanNode apn: planNodes) {
            explain += apn.toExplainPlanString() + '\n';
        }
        return explain;
    }

    protected void checkQueriesPlansAreTheSame(String sql1, String sql2) {
        String explainStr1, explainStr2;
        List<AbstractPlanNode> pns = compileToFragments(sql1);
        explainStr1 = buildExplainPlan(pns);
        pns = compileToFragments(sql2);
        explainStr2 = buildExplainPlan(pns);

        assertEquals(explainStr1, explainStr2);
    }

    /** Given a list of Class objects for plan node subclasses, asserts
     * if the given plan doesn't contain instances of those classes.
     */
    static protected void assertClassesMatchNodeChain(
            List<Class<? extends AbstractPlanNode>> expectedClasses,
            AbstractPlanNode actualPlan) {
        AbstractPlanNode pn = actualPlan;
        for (Class<? extends AbstractPlanNode> c : expectedClasses) {
            assertFalse("Actual plan shorter than expected",
                    pn == null);
            assertTrue("Expected plan to contain an instance of " + c.getSimpleName() +", "
                    + "instead found " + pn.getClass().getSimpleName(),
                    c.isInstance(pn));
            if (pn.getChildCount() > 0)
                pn = pn.getChild(0);
            else
                pn = null;
        }

        assertTrue("Actual plan longer than expected", pn == null);
    }
}


File: tests/frontend/org/voltdb/planner/TestPlansApproxCountDistinct.java
/* This file is part of VoltDB.
 * Copyright (C) 2008-2015 VoltDB Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package org.voltdb.planner;

import java.util.List;

import org.voltdb.plannodes.AbstractPlanNode;
import org.voltdb.plannodes.AggregatePlanNode;
import org.voltdb.types.ExpressionType;
import static org.voltdb.types.ExpressionType.*;
import org.voltdb.types.PlanNodeType;

/**
 * Mostly here we're concerned that an APPROX_COUNT_DISTINCT aggregate function is
 * handled correctly in both single- and multi-partition contexts.  In a single partition context,
 * we expect APPROX_COUNT_DISTINCT to be appear in the plan.  This is the simplest case.
 *
 * For multi-part plans, there are two possibilities:
 * - APPROX_COUNT_DISTINCT is accompanied by other aggregates that cannot be pushed down
 *   (e.g., count(distinct col)), in this case, we must ship all the rows to the coordinator,
 *   so we expect to just evaluate APPROX_COUNT_DISTINCT on the coordinator.
 * - APPROX_COUNT_DISTINCT appears as the only aggregate on the select list, or all the other
 *   aggregates can be pushed down.  In this case, we "split" the aggregate function to two:
 *   - ROWS_TO_HYPERLOGLOG, which produces a hyperloglog for each partition
 *   - One coordinator, HYPERLOGLOGS_TO_CARD which produces the estimate (as a double)
 * @author cwolff
 *
 */
public class TestPlansApproxCountDistinct extends PlannerTestCase {

    private static final int COORDINATOR_FRAG = 0;
    private static final int PARTITION_FRAG = 1;

    @Override
    protected void setUp() throws Exception {
        setupSchema(getClass().getResource("testplans-count-ddl.sql"),
                    "testcount", false);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    // Find all the aggregate nodes in a fragment, whether they are hash, serial or partial.
    private static List<AbstractPlanNode> findAllAggPlanNodes(AbstractPlanNode node) {
        List<AbstractPlanNode> aggNodes = node.findAllNodesOfType(PlanNodeType.AGGREGATE);
        List<AbstractPlanNode> hashAggNodes = node.findAllNodesOfType(PlanNodeType.HASHAGGREGATE);
        List<AbstractPlanNode> partialAggNodes = node.findAllNodesOfType(PlanNodeType.PARTIALAGGREGATE);

        aggNodes.addAll(hashAggNodes);
        aggNodes.addAll(partialAggNodes);
        return aggNodes;
    }

    private void assertAggPlanNodeContainsFunctions(AggregatePlanNode node, ExpressionType[] expectedAggFns) {
        List<ExpressionType> actualAggFns = node.getAggregateTypes();

        assertEquals("Wrong number of aggregate functions in plan", expectedAggFns.length, actualAggFns.size());

        int i = 0;
        for (ExpressionType expectedAggFn : expectedAggFns) {
            assertEquals("Found unexpected agg function", expectedAggFn, actualAggFns.get(i));
            ++i;
        }
    }

    private void assertFragContainsAggWithFunctions(AbstractPlanNode frag, ExpressionType... expectedAggFns) {
        List<AbstractPlanNode> aggNodes = findAllAggPlanNodes(frag);
        assertFalse("No aggregation node in fragment!", 0 == aggNodes.size());
        assertEquals("More than one aggregation node in fragment!", 1, aggNodes.size());

        AggregatePlanNode aggNode = (AggregatePlanNode)aggNodes.get(0);
        assertAggPlanNodeContainsFunctions(aggNode, expectedAggFns);
    }

    private void assertFragContainsTwoAggsWithFunctions(AbstractPlanNode frag,
            ExpressionType[] expectedAggFnsFirst,
            ExpressionType[] expectedAggFnsSecond) {
        List<AbstractPlanNode> aggNodes = findAllAggPlanNodes(frag);
        assertEquals("Wrong number of aggregation nodes in fragment!", 2, aggNodes.size());

        assertAggPlanNodeContainsFunctions((AggregatePlanNode)aggNodes.get(0), expectedAggFnsFirst);
        assertAggPlanNodeContainsFunctions((AggregatePlanNode)aggNodes.get(1), expectedAggFnsSecond);
    }

    private void assertFragContainsNoAggPlanNodes(AbstractPlanNode node) {
        List<AbstractPlanNode> aggNodes = findAllAggPlanNodes(node);
        assertEquals("Found an aggregation node in fragment, but didn't expect to!", 0, aggNodes.size());
    }

    public void testSinglePartitionTableAgg() throws Exception {
        List<AbstractPlanNode> pn = compileToFragments("SELECT approx_count_distinct(age) from T1");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG), AGGREGATE_APPROX_COUNT_DISTINCT);

        pn = compileToFragments("select approx_count_distinct(age), sum(points) from t1");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_SUM);

        pn = compileToFragments("select approx_count_distinct(age), sum(distinct points) from t1");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_SUM);

    }

    public void testSinglePartitionWithGroupBy() throws Exception {
        List<AbstractPlanNode> pn = compileToFragments(
                "SELECT id, approx_count_distinct(age) "
                + "from T1 "
                + "group by id");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG), AGGREGATE_APPROX_COUNT_DISTINCT);

        pn = compileToFragments(
                "select age, approx_count_distinct(points), max(username) "
                + "from t2 "
                + "group by age");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_MAX);

        pn = compileToFragments(
                "select username, approx_count_distinct(age), avg(distinct points) "
                + "from t2 "
                + "group by username");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_AVG);
    }

    public void testMultiPartitionTableAgg() throws Exception {
        List<AbstractPlanNode> pn = compileToFragments("SELECT approx_count_distinct(num) from P1");
        assertEquals(2,  pn.size());

        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG), AGGREGATE_HYPERLOGLOGS_TO_CARD);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG), AGGREGATE_VALS_TO_HYPERLOGLOG);

        // Two push-down-able aggs.
        pn = compileToFragments("SELECT approx_count_distinct(num), count(ratio) from P1");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // Three push-down-able aggs.
        pn = compileToFragments("SELECT approx_count_distinct(num), min(desc), max(ratio) from P1");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_MIN, AGGREGATE_MAX);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_MIN, AGGREGATE_MAX);

        // With an agg that can be pushed down, but only because its argument is a partition key.
        pn = compileToFragments("SELECT approx_count_distinct(num), count(distinct id) from P1");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // With an agg that can be pushed down, but only because its argument is a partition key.
        // Also, with approx count distinct with partition key as argument.
        pn = compileToFragments("SELECT approx_count_distinct(id), count(distinct id) from P1");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // With an agg that cannot be pushed down,
        pn = compileToFragments("SELECT sum(distinct ratio), approx_count_distinct(num) from P1");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_SUM,
                AGGREGATE_APPROX_COUNT_DISTINCT);
        assertFragContainsNoAggPlanNodes(pn.get(PARTITION_FRAG));
    }

    public void testMultiPartitionWithGroupBy() throws Exception {
        List<AbstractPlanNode> pn = compileToFragments(
                "SELECT desc as modid, approx_count_distinct(num) "
                + "from P1 "
                + "group by desc");
        assertEquals(2,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG), AGGREGATE_HYPERLOGLOGS_TO_CARD);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG), AGGREGATE_VALS_TO_HYPERLOGLOG);

        // Two push-down-able aggs.
        pn = compileToFragments("SELECT desc, approx_count_distinct(num), count(ratio) "
                + "from P1 "
                + "group by desc");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // A case similar to above.
        pn = compileToFragments(
                "SELECT desc, approx_count_distinct(num), max(ratio) "
                + "from P1 "
                + "group by desc");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_MAX);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_MAX);

        // With an agg that can be pushed down, but only because its argument is a partition key.
        pn = compileToFragments(
                "SELECT ratio, approx_count_distinct(num), count(distinct id) "
                + "from P1 "
                + "group by ratio");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // With an agg that can be pushed down, but only because its argument is a partition key.
        // Also, with approx count distinct with partition key as argument.
        pn = compileToFragments(
                "SELECT desc, approx_count_distinct(id), count(distinct id) "
                + "from P1 "
                + "group by desc");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG,
                AGGREGATE_COUNT);

        // With partition key as group by key.
        // In this case, all aggregation can be done on partitions,
        // coordinator just concatenates result
        pn = compileToFragments(
                "SELECT id, sum(distinct ratio), approx_count_distinct(num) "
                + "from P1 "
                + "group by id");
        assertFragContainsNoAggPlanNodes(pn.get(COORDINATOR_FRAG));
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_SUM,
                AGGREGATE_APPROX_COUNT_DISTINCT);
    }

    public void testWithSubqueries() throws Exception {

        // Single-partition statement with a subquery (table agg)
        List<AbstractPlanNode> pn = compileToFragments(
                "select * "
                + "from "
                + "  T1, "
                + "  (select approx_count_distinct(age) from t1) as subq");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT);

        // Single-partition statement with a subquery (with group by)
        pn = compileToFragments(
                "select * "
                + "from "
                + "  (select username, approx_count_distinct(age), avg(distinct points) "
                + "   from t2 "
                + "   group by username) as subq"
                + "  inner join t2 "
                + "  on t2.username = subq.username;");
        assertEquals(1,  pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_AVG);

        // multi-partition table agg
        pn = compileToFragments(
                "select * "
                + "from "
                + "t1, "
                + "(SELECT sum(distinct ratio), approx_count_distinct(num) from P1) as subq");
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_SUM,
                AGGREGATE_APPROX_COUNT_DISTINCT);
        assertFragContainsNoAggPlanNodes(pn.get(PARTITION_FRAG));

        // single-part plan on partitioned tables, with GB in subquery
        pn = compileToFragments(
                "select * "
                + "from p1 "
                + "inner join "
                + "(SELECT id, sum(distinct ratio), approx_count_distinct(num) "
                + "from P1 "
                + "where id = 10 "
                + "group by id) as subq "
                + "on subq.id = p1.id");
        assertEquals(1, pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_SUM,
                AGGREGATE_APPROX_COUNT_DISTINCT);

        // multi-part plan on partitioned tables, with GB in subquery
        pn = compileToFragments(
                "select * "
                + "from t1 "
                + "inner join "
                + "(SELECT id, approx_count_distinct(num) "
                + "from P1 "
                + "group by id) as subq "
                + "on subq.id = t1.id");
        for (AbstractPlanNode n : pn) {
            System.out.println(n.toExplainPlanString());
        }
        assertEquals(2, pn.size());
        assertFragContainsNoAggPlanNodes(pn.get(COORDINATOR_FRAG));
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT);
    }

    public void testSubqueriesWithMultipleAggs() throws Exception {
        List<AbstractPlanNode> pn;

        // In this query, one agg plan node is distributed across fragments (p1),
        // but the other is not (t1).
        pn = compileToFragments("select approx_count_distinct(num) "
                + "from (select approx_count_distinct(points) from t1) as repl_subquery,"
                + "  p1");
        assertEquals(2, pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_HYPERLOGLOGS_TO_CARD);
        assertFragContainsTwoAggsWithFunctions(pn.get(PARTITION_FRAG),
                new ExpressionType[] {AGGREGATE_APPROX_COUNT_DISTINCT},
                new ExpressionType[] {AGGREGATE_VALS_TO_HYPERLOGLOG});

        // Like above but with some more aggregate functions
        // (which breaks the push-down-ability of distributed agg)
        pn = compileToFragments("select approx_count_distinct(num), sum(distinct num) "
                + "from (select approx_count_distinct(points) from t1) as repl_subquery,"
                + "  p1");
        assertEquals(2, pn.size());
        assertFragContainsAggWithFunctions(pn.get(COORDINATOR_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT,
                AGGREGATE_SUM);
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_APPROX_COUNT_DISTINCT);

        // As above but partitioned and replicated tables are swapped.
        pn = compileToFragments("select approx_count_distinct(points) "
                + "from (select approx_count_distinct(num) from p1) as repl_subquery,"
                + "  t1");
        assertEquals(2, pn.size());
        assertFragContainsTwoAggsWithFunctions(pn.get(COORDINATOR_FRAG),
                new ExpressionType[] {AGGREGATE_HYPERLOGLOGS_TO_CARD},
                new ExpressionType[] {AGGREGATE_APPROX_COUNT_DISTINCT});
        assertFragContainsAggWithFunctions(pn.get(PARTITION_FRAG),
                AGGREGATE_VALS_TO_HYPERLOGLOG);

        // Like above but with some more aggregate functions
        // (which breaks the push-down-ability of distributed agg)
        pn = compileToFragments("select approx_count_distinct(points) "
                + "from (select approx_count_distinct(num), sum(distinct num) from p1) as repl_subquery,"
                + "  t1");
        assertEquals(2, pn.size());
        assertFragContainsTwoAggsWithFunctions(pn.get(COORDINATOR_FRAG),
                new ExpressionType[] {AGGREGATE_APPROX_COUNT_DISTINCT, AGGREGATE_SUM},
                new ExpressionType[] {AGGREGATE_APPROX_COUNT_DISTINCT});
        assertFragContainsNoAggPlanNodes(pn.get(PARTITION_FRAG));
    }
}
