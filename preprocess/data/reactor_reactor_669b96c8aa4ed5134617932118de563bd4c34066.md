Refactoring Types: ['Rename Package', 'Move Class']
java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package reactor.bus;

import reactor.core.alloc.Recyclable;
import reactor.core.support.Assert;
import reactor.core.support.UUIDUtils;
import reactor.fn.Consumer;
import reactor.fn.tuple.Tuple;
import reactor.fn.tuple.Tuple2;

import java.io.Serializable;
import java.util.*;

/**
 * Wrapper for an object that needs to be processed by {@link reactor.fn.Consumer}s.
 *
 * @param <T>
 *     The type of the wrapped object
 *
 * @author Jon Brisbin
 * @author Stephane Maldini
 * @author Andy Wilkinson
 */
public class Event<T> implements Serializable, Recyclable {

  private static final long serialVersionUID = -2476263092040373361L;
  private final transient Consumer<Throwable> errorConsumer;
  private volatile        UUID                id;
  private volatile        Headers             headers;
  private volatile        Object              replyTo;
  private volatile        Object              key;
  private volatile        T                   data;

  /**
   * Creates a new Event based on the type T of {@data data}
   *
   * @param klass
   */
  public Event(Class<T> klass) {
    this.headers = null;
    this.data = null;
    this.errorConsumer = null;
  }

  /**
   * Creates a new Event with the given {@code headers} and {@code data}.
   *
   * @param headers
   *     The headers
   * @param data
   *     The data
   */
  public Event(Headers headers, T data) {
    this.headers = headers;
    this.data = data;
    this.errorConsumer = null;
  }

  /**
   * Creates a new Event with the given {@code headers}, {@code data} and {@link reactor.fn.Consumer <java.lang.Throwable>}.
   *
   * @param headers
   *     The headers
   * @param data
   *     The data
   * @param errorConsumer
   *     error consumer callback
   */
  public Event(Headers headers, T data, Consumer<Throwable> errorConsumer) {
    this.headers = headers;
    this.data = data;
    this.errorConsumer = errorConsumer;
  }

  /**
   * Creates a new Event with the given {@code data}. The event will have empty headers.
   *
   * @param data
   *     The data
   */
  public Event(T data) {
    this.data = data;
    this.errorConsumer = null;
  }

  /**
   * Wrap the given object with an {@link Event}.
   *
   * @param obj
   *     The object to wrap.
   *
   * @return The new {@link Event}.
   */
  public static <T> Event<T> wrap(T obj) {
    return new Event<T>(obj);
  }

  /**
   * Wrap the given object with an {@link Event} and set the {@link Event#getReplyTo() replyTo} to the given {@code
   * replyToKey}.
   *
   * @param obj
   *     The object to wrap.
   * @param replyToKey
   *     The key to use as a {@literal replyTo}.
   * @param <T>
   *     The type of the given object.
   *
   * @return The new {@link Event}.
   */
  public static <T> Event<T> wrap(T obj, Object replyToKey) {
    return new Event<T>(obj).setReplyTo(replyToKey);
  }

  /**
   * Get the globally-unique id of this event.
   *
   * @return Unique {@link UUID} of this event.
   */
  public synchronized UUID getId() {
    if (null == id) {
      id = UUIDUtils.create();
    }
    return id;
  }

  /**
   * Get the {@link Headers} attached to this event.
   *
   * @return The Event's Headers
   */
  public synchronized Headers getHeaders() {
    if (null == headers) {
      headers = new Headers();
    }
    return headers;
  }

  /**
   * Get the key to send replies to.
   *
   * @return The reply-to key
   */
  public Object getReplyTo() {
    return replyTo;
  }

  /**
   * Set the {@code key} that interested parties should send replies to.
   *
   * @param replyTo
   *     The key to use to notify sender of replies.
   *
   * @return {@literal this}
   */
  public Event<T> setReplyTo(Object replyTo) {
    Assert.notNull(replyTo, "ReplyTo cannot be null.");
    this.replyTo = replyTo;
    return this;
  }

  /**
   * Get the key this event was notified on.
   *
   * @return The key used to notify consumers of this event.
   */
  public Object getKey() {
    return key;
  }

  /**
   * Set the key this event is being notified with.
   *
   * @param key
   *     The key used to notify consumers of this event.
   *
   * @return {@literal this}
   */
  public Event<T> setKey(Object key) {
    this.key = key;
    return this;
  }

  /**
   * Get the internal data being wrapped.
   *
   * @return The data.
   */
  public T getData() {
    return data;
  }

  /**
   * Set the internal data to wrap.
   *
   * @param data
   *     Data to wrap.
   *
   * @return {@literal this}
   */
  public Event<T> setData(T data) {
    this.data = data;
    return this;
  }

  /**
   * Get the internal error consumer callback being wrapped.
   *
   * @return the consumer.
   */
  public Consumer<Throwable> getErrorConsumer() {
    return errorConsumer;
  }

  /**
   * Create a copy of this event, reusing same headers, data and replyTo
   *
   * @return {@literal event copy}
   */
  public Event<T> copy() {
    return copy(data);
  }

  /**
   * Create a copy of this event, reusing same headers and replyTo
   *
   * @return {@literal event copy}
   */
  public <E> Event<E> copy(E data) {
    if (null != replyTo) {
      return new Event<E>(headers, data, errorConsumer).setReplyTo(replyTo);
    } else {
      return new Event<E>(headers, data, errorConsumer);
    }
  }

  /**
   * Consumes error, using a producer defined callback
   *
   * @param throwable
   *     The error to consume
   */
  public void consumeError(Throwable throwable) {
    if (null != errorConsumer) {
      errorConsumer.accept(throwable);
    }
  }

  @Override
  public void recycle() {
    this.id = null;
    if (null != this.headers) {
      this.headers.headers.clear();
    }
    this.replyTo = null;
    this.key = null;
    this.data = null;
  }

  public void override(Event<T> ev) {
    this.id = ev.id;
    this.headers = ev.headers;
    this.replyTo = ev.replyTo;
    this.data = ev.data;
  }

  @Override
  public String toString() {
    return "Event{" +
        "id=" + id +
        ", headers=" + headers +
        ", replyTo=" + replyTo +
        ", key=" + key +
        ", data=" + data +
        '}';
  }

  /**
   * Headers are a Map-like structure of name-value pairs. Header names are case-insensitive, as determined by {@link
   * String#CASE_INSENSITIVE_ORDER}. A header can be removed by setting its value to {@code null}.
   */
  public static class Headers implements Serializable, Iterable<Tuple2<String, Object>> {

    /**
     * The name of the origin header
     *
     * @see #setOrigin(String)
     * @see #setOrigin(UUID)
     * @see #getOrigin()
     */
    public static final String ORIGIN = "x-reactor-origin";

    private static final long serialVersionUID = 4984692586458514948L;

    private final Object monitor = UUIDUtils.create();
    private final Map<String, Object> headers;

    private Headers(boolean sealed, Map<String, Object> headers) {
      Map<String, Object> copy = new TreeMap<String, Object>(String.CASE_INSENSITIVE_ORDER);
      copyHeaders(headers, copy);
      if (sealed) {
        this.headers = Collections.unmodifiableMap(copy);
      } else {
        this.headers = copy;
      }
    }

    /**
     * Creates a new Headers instance by copying the contents of the given {@code headers} Map. Note that, as the map is
     * copied, subsequent changes to its contents will have no effect upon the Headers.
     *
     * @param headers
     *     The map to copy.
     */
    public Headers(Map<String, Object> headers) {
      this(false, headers);
    }

    /**
     * Create an empty Headers
     */
    public Headers() {
      this(false, null);
    }

    /**
     * Sets all of the headers represented by entries in the given {@code headers} Map. Any entry with a null value will
     * cause the header matching the entry's name to be removed.
     *
     * @param headers
     *     The map of headers to set.
     *
     * @return {@code this}
     */
    public Headers setAll(Map<String, Object> headers) {
      if (null == headers || headers.isEmpty()) {
        return this;
      } else {
        synchronized (this.monitor) {
          copyHeaders(headers, this.headers);
        }
      }
      return this;
    }

    /**
     * Set the header value. If {@code value} is {@code null} the header with the given {@code name} will be removed.
     *
     * @param name
     *     The name of the header.
     * @param value
     *     The header's value.
     *
     * @return {@code this}
     */
    public <V> Headers set(String name, V value) {
      synchronized (this.monitor) {
        setHeader(name, value, headers);
      }
      return this;
    }

    /**
     * Set the origin header. The origin is simply a unique id to indicate to consumers where it should send replies. If
     * {@code id} is {@code null} the origin header will be removed.
     *
     * @param id
     *     The id of the origin component.
     *
     * @return {@code this}
     */
    public Headers setOrigin(UUID id) {
      String idString = id == null ? null : id.toString();
      return setOrigin(idString);
    }

    /**
     * Get the origin header
     *
     * @return The origin header, may be {@code null}.
     */
    public String getOrigin() {
      synchronized (this.monitor) {
        return (String) headers.get(ORIGIN);
      }
    }

    /**
     * Set the origin header. The origin is simply a unique id to indicate to consumers where it should send replies. If
     * {@code id} is {@code null} this origin header will be removed.
     *
     * @param id
     *     The id of the origin component.
     *
     * @return {@code this}
     */
    public Headers setOrigin(String id) {
      synchronized (this.monitor) {
        setHeader(ORIGIN, id, headers);
      }
      return this;
    }

    /**
     * Get the value for the given header.
     *
     * @param name
     *     The header name.
     *
     * @return The value of the header, or {@code null} if none exists.
     */
    @SuppressWarnings("unchecked")
    public <V> V get(String name) {
      synchronized (monitor) {
        return (V) headers.get(name);
      }
    }

    /**
     * Determine whether the headers contain a value for the given name.
     *
     * @param name
     *     The header name.
     *
     * @return {@code true} if a value exists, {@code false} otherwise.
     */
    public boolean contains(String name) {
      synchronized (monitor) {
        return headers.containsKey(name);
      }
    }

    /**
     * Get these headers as an unmodifiable {@link Map}.
     *
     * @return The unmodifiable header map
     */
    public Map<String, Object> asMap() {
      synchronized (monitor) {
        return Collections.unmodifiableMap(headers);
      }
    }

    /**
     * Get the headers as a read-only version
     *
     * @return A read-only version of the headers.
     */
    public Headers readOnly() {
      synchronized (monitor) {
        return new Headers(true, headers);
      }
    }

    /**
     * Returns an unmodifiable Iterator over a copy of this Headers' contents.
     */
    @Override
    public Iterator<Tuple2<String, Object>> iterator() {
      synchronized (this.monitor) {
        List<Tuple2<String, Object>> headers = new ArrayList<Tuple2<String, Object>>(this.headers.size());
        for (Map.Entry<String, Object> header : this.headers.entrySet()) {
          headers.add(Tuple.of(header.getKey(), header.getValue()));
        }
        return Collections.unmodifiableList(headers).iterator();
      }
    }

    @Override
    public String toString() {
      return headers.toString();
    }

    private void copyHeaders(Map<String, Object> source, Map<String, Object> target) {
      if (source != null) {
        for (Map.Entry<String, Object> entry : source.entrySet()) {
          setHeader(entry.getKey(), entry.getValue(), target);
        }
      }
    }

    private void setHeader(String name, Object value, Map<String, Object> target) {
      if (value == null) {
        target.remove(name);
      } else {
        target.put(name, value);
      }
    }
  }

}


File: reactor-bus/src/main/java/reactor/bus/alloc/EventFactorySupplier.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package reactor.bus.alloc;

import reactor.bus.Event;
import reactor.fn.Supplier;

/**
 * A {@link reactor.fn.Supplier} implementation that instantiates Events
 * based on Event data type.
 *
 * @param <T> type of {@link reactor.bus.Event} data
 * @author Oleksandr Petrov
 * @since 1.1
 */
public class EventFactorySupplier<T> implements Supplier<Event<T>> {

  private final Class<T> klass;

  public EventFactorySupplier(Class<T> klass) {
    this.klass = klass;
  }

  @Override
  public Event<T> get() {
    return new Event<T>(klass);
  }
}


File: reactor-core/src/main/java/reactor/core/alloc/RecyclableString.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package reactor.core.alloc;

/**
 * @author Jon Brisbin
 */
public class RecyclableString implements Recyclable {

	private volatile String value = "";

	public void setValue(String value) {
		this.value = (null == value ? "" : value);
	}

	@Override
	public void recycle() {
		this.value = "";
	}

	@Override
	public String toString() {
		return value;
	}

}


File: reactor-core/src/main/java/reactor/core/alloc/package-info.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * Pooling provides lower GC requirements by re-using components.
 */
package reactor.core.alloc;

File: reactor-core/src/main/java/reactor/core/dispatch/AbstractLifecycleDispatcher.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package reactor.core.dispatch;

import reactor.Environment;
import reactor.core.Dispatcher;
import reactor.core.alloc.Recyclable;
import reactor.core.support.Assert;
import reactor.fn.Consumer;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * A {@code Dispatcher} that has a lifecycle.
 *
 * @author Jon Brisbin
 * @author Stephane Maldini
 */
public abstract class AbstractLifecycleDispatcher implements Dispatcher {

	protected static final int DEFAULT_BUFFER_SIZE = 1024;

	private final AtomicBoolean alive   = new AtomicBoolean(true);
	public final  ClassLoader   context = new ClassLoader(Thread.currentThread()
			.getContextClassLoader()) {
	};

	protected AbstractLifecycleDispatcher() {
		super();
	}

	@Override
	public boolean alive() {
		return alive.get();
	}

	@Override
	public boolean awaitAndShutdown() {
		return awaitAndShutdown(Integer.MAX_VALUE, TimeUnit.SECONDS);
	}

	@Override
	public void shutdown() {
		alive.compareAndSet(true, false);
	}

	@Override
	public void forceShutdown() {
		alive.compareAndSet(true, false);
	}

	/**
	 * Dispatchers can be traced through a {@code contextClassLoader} to let producers adapting their dispatching
	 * strategy
	 *
	 * @return boolean true if the programs is already run by this dispatcher
	 */
	@Override
	public boolean inContext() {
		return context == Thread.currentThread().getContextClassLoader();
	}

	protected final ClassLoader getContext() {
		return context;
	}

	@Override
	public final <E> void tryDispatch(E event, Consumer<E> eventConsumer, Consumer<Throwable> errorConsumer)
			throws InsufficientCapacityException {
		Assert.isTrue(alive(), "This Dispatcher has been shut down.");
		boolean isInContext = inContext();
		Task task;
		if (isInContext) {
			task = allocateRecursiveTask();
		} else {
			task = tryAllocateTask();
		}

		task.setData(event)
				.setErrorConsumer(errorConsumer)
				.setEventConsumer(eventConsumer);

		if (!isInContext) {
			execute(task);
		} else {
			scheduleLater(task);
		}
	}

	@Override
	public final <E> void dispatch(E event,
	                               Consumer<E> eventConsumer,
	                               Consumer<Throwable> errorConsumer) {

		Assert.isTrue(alive(), "This Dispatcher has been shut down.");
		Assert.isTrue(eventConsumer != null, "The signal consumer has not been passed.");
		boolean isInContext = inContext();
		Task task;
		if (isInContext) {
			task = allocateRecursiveTask();
		} else {
			task = allocateTask();
		}

		task.setData(event)
				.setErrorConsumer(errorConsumer)
				.setEventConsumer(eventConsumer);

		if (!isInContext) {
			execute(task);
		} else {
			scheduleLater(task);
		}
	}

	@Override
	public void execute(final Runnable command) {
		dispatch(null, new Consumer<Object>() {
			@Override
			public void accept(Object ev) {
				command.run();
			}
		}, null);
	}

	protected void scheduleLater(final Task task){
	}

	protected Task tryAllocateTask() throws InsufficientCapacityException {
		return allocateTask();
	}

	protected abstract Task allocateTask();

	protected abstract Task allocateRecursiveTask();

	protected abstract void execute(Task task);

	@SuppressWarnings("unchecked")
	protected static void route(Task task) {
		try {
			if (task.eventConsumer == null) return;

			task.eventConsumer.accept(task.data);

		} catch (Exception e) {
			if (task.errorConsumer != null) {

				task.errorConsumer.accept(e);

			} else if (Environment.alive()) {

				Environment.get().routeError(e);

			}
		} finally {
			task.recycle();
		}
	}

	@Override
	public String toString() {
		return getClass().getSimpleName().replaceAll("Dispatcher", "");
	}

	public abstract class Task implements Runnable, Recyclable {

		protected volatile Object              data;
		protected volatile Consumer            eventConsumer;
		protected volatile Consumer<Throwable> errorConsumer;

		public Task setData(Object data) {
			this.data = data;
			return this;
		}

		public Task setEventConsumer(Consumer<?> eventConsumer) {
			this.eventConsumer = eventConsumer;
			return this;
		}

		public Task setErrorConsumer(Consumer<Throwable> errorConsumer) {
			this.errorConsumer = errorConsumer;
			return this;
		}

		@Override
		public void recycle() {
			data = null;
			errorConsumer = null;
			eventConsumer = null;
		}

	}

}


File: reactor-core/src/main/java/reactor/io/buffer/Buffer.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package reactor.io.buffer;

import reactor.core.alloc.Recyclable;
import reactor.core.support.Assert;
import reactor.fn.Supplier;

import javax.annotation.concurrent.NotThreadSafe;
import java.io.IOException;
import java.io.InputStream;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/**
 * A {@literal Buffer} is a general-purpose IO utility class that wraps a {@link ByteBuffer}. It provides optional
 * dynamic expansion of the buffer to accommodate additional content. It also provides convenience methods for
 * operating
 * on buffers.
 *
 * @author Jon Brisbin
 * @author Stephane Maldini
 */
@NotThreadSafe
public class Buffer implements Recyclable,
		Comparable<Buffer>,
		Iterable<Byte>,
		ReadableByteChannel,
		WritableByteChannel {

	/**
	 * The size, in bytes, of a small buffer. Can be configured using the {@code reactor.io.defaultBufferSize} system
	 * property. Default to 16384 bytes.
	 */
	public static int SMALL_BUFFER_SIZE = Integer.parseInt(
			System.getProperty("reactor.io.defaultBufferSize", "" + 1024 * 16)
	);

	/**
	 * The maximum allowed buffer size in bytes. Can be configured using the {@code reactor.io.maxBufferSize} system
	 * property. Defaults to 16384000 bytes.
	 */
	public static int MAX_BUFFER_SIZE = Integer.parseInt(
			System.getProperty("reactor.io.maxBufferSize", "" + 1024 * 1000 * 16)
	);

	private static final Charset UTF8 = Charset.forName("UTF-8");
	private final boolean        dynamic;
	private       ByteBuffer     buffer;
	private       CharsetDecoder decoder;
	private       CharBuffer     chars;
	private       int            position;
	private       int            limit;

	/**
	 * Create an empty {@literal Buffer} that is dynamic.
	 */
	public Buffer() {
		this.dynamic = true;
	}

	/**
	 * Create an {@literal Buffer} that has an internal {@link ByteBuffer} allocated to the given size and optional make
	 * this buffer fixed-length.
	 *
	 * @param atLeast Allocate this many bytes immediately.
	 * @param fixed   {@literal true} to make this buffer fixed-length, {@literal false} otherwise.
	 */
	public Buffer(int atLeast, boolean fixed) {
		if (fixed) {
			if (atLeast <= MAX_BUFFER_SIZE) {
				this.buffer = ByteBuffer.allocate(atLeast);
			} else {
				throw new IllegalArgumentException("Requested buffer size exceeds maximum allowed (" + MAX_BUFFER_SIZE + ")");
			}
		} else {
			ensureCapacity(atLeast);
		}
		this.dynamic = !fixed;
	}

	/**
	 * Copy constructor that creates a shallow copy of the given {@literal Buffer} by calling {@link
	 * java.nio.ByteBuffer#duplicate()} on the underlying {@link ByteBuffer}.
	 *
	 * @param bufferToCopy The {@literal Buffer} to copy.
	 */
	public Buffer(Buffer bufferToCopy) {
		this.dynamic = bufferToCopy.dynamic;
		this.buffer = bufferToCopy.buffer.duplicate();
	}

	/**
	 * Create a {@literal Buffer} using the given {@link ByteBuffer} as the inital source.
	 *
	 * @param bufferToStartWith The {@link ByteBuffer} to start with.
	 */
	public Buffer(ByteBuffer bufferToStartWith) {
		this.dynamic = true;
		this.buffer = bufferToStartWith;
	}

	/**
	 * Convenience method to create a new, fixed-length {@literal Buffer} and putting the given byte array into the
	 * buffer.
	 *
	 * @param bytes The bytes to create a buffer from.
	 * @return The new {@literal Buffer}.
	 */
	@SuppressWarnings("resource")
	public static Buffer wrap(byte[] bytes) {
		return new Buffer(bytes.length, true)
				.append(bytes)
				.flip();
	}

	/**
	 * Convenience method to create a new {@literal Buffer} from the given String and optionally specify whether the new
	 * {@literal Buffer} should be a fixed length or not.
	 *
	 * @param str   The String to create a buffer from.
	 * @param fixed {@literal true} to create a fixed-length {@literal Buffer}, {@literal false} otherwise.
	 * @return The new {@literal Buffer}.
	 */
	@SuppressWarnings("resource")
	public static Buffer wrap(String str, boolean fixed) {
		if(fixed){
			return wrap(str.getBytes());
		}else {
			return new Buffer(str.length(), false)
			  .append(str)
			  .flip();
		}
	}

	/**
	 * Convenience method to create a new, fixed-length {@literal Buffer} from the given String.
	 *
	 * @param str The String to create a buffer from.
	 * @return The new fixed-length {@literal Buffer}.
	 */
	public static Buffer wrap(String str) {
		return wrap(str, true);
	}

	/**
	 * Very efficient method for parsing an {@link Integer} from the given {@literal Buffer} range. Much faster than
	 * {@link Integer#parseInt(String)}.
	 *
	 * @param b     The {@literal Buffer} to slice.
	 * @param start start of the range.
	 * @param end   end of the range.
	 * @return The int value or {@literal null} if the {@literal Buffer} could not be read.
	 */
	public static Integer parseInt(Buffer b, int start, int end) {
		b.snapshot();

		b.buffer.limit(end);
		b.buffer.position(start);

		Integer i = parseInt(b);

		b.reset();

		return i;
	}

	/**
	 * Very efficient method for parsing an {@link Integer} from the given {@literal Buffer}. Much faster than {@link
	 * Integer#parseInt(String)}.
	 *
	 * @param b The {@literal Buffer} to slice.
	 * @return The int value or {@literal null} if the {@literal Buffer} could not be read.
	 */
	public static Integer parseInt(Buffer b) {
		if (b.remaining() == 0) {
			return null;
		}

		b.snapshot();
		int len = b.remaining();

		int num = 0;
		int dec = 1;
		for (int i = (b.position + len); i > b.position; ) {
			char c = (char) b.buffer.get(--i);
			num += Character.getNumericValue(c) * dec;
			dec *= 10;
		}

		b.reset();

		return num;
	}

	/**
	 * Very efficient method for parsing a {@link Long} from the given {@literal Buffer} range. Much faster than {@link
	 * Long#parseLong(String)}.
	 *
	 * @param b     The {@literal Buffer} to slice.
	 * @param start start of the range.
	 * @param end   end of the range.
	 * @return The long value or {@literal null} if the {@literal Buffer} could not be read.
	 */
	public static Long parseLong(Buffer b, int start, int end) {
		int origPos = b.buffer.position();
		int origLimit = b.buffer.limit();

		b.buffer.position(start);
		b.buffer.limit(end);

		Long l = parseLong(b);

		b.buffer.position(origPos);
		b.buffer.limit(origLimit);

		return l;
	}

	/**
	 * Very efficient method for parsing a {@link Long} from the given {@literal Buffer}. Much faster than {@link
	 * Long#parseLong(String)}.
	 *
	 * @param b The {@literal Buffer} to slice.
	 * @return The long value or {@literal null} if the {@literal Buffer} could not be read.
	 */
	public static Long parseLong(Buffer b) {
		if (b.remaining() == 0) {
			return null;
		}
		ByteBuffer bb = b.buffer;
		int origPos = bb.position();
		int len = bb.remaining();

		long num = 0;
		int dec = 1;
		for (int i = len; i > 0; ) {
			char c = (char) bb.get(--i);
			num += Character.getNumericValue(c) * dec;
			dec *= 10;
		}

		bb.position(origPos);

		return num;
	}

	@Override
	public void recycle() {
		if (null != buffer) {
			buffer.position(0);
			position = 0;
			limit = buffer.capacity();
			buffer.limit(limit);
		}
	}

	/**
	 * Whether this {@literal Buffer} is fixed-length or not.
	 *
	 * @return {@literal true} if this {@literal Buffer} is not fixed-length, {@literal false} otherwise.
	 */
	public final boolean isDynamic() {
		return dynamic;
	}

	/**
	 * Provides the current position in the internal {@link ByteBuffer}.
	 *
	 * @return The current position.
	 */
	public final int position() {
		return (null == buffer ? 0 : buffer.position());
	}

	/**
	 * Sets this buffer's position.
	 *
	 * @param pos the new position
	 * @return this buffer
	 */
	public Buffer position(int pos) {
		if (null != buffer) {
			buffer.position(pos);
		}
		return this;
	}

	/**
	 * Sets this buffer's limit.
	 *
	 * @param limit the new limit
	 * @return this buffer
	 */
	public Buffer limit(int limit) {
		if (null != buffer) {
			buffer.limit(limit);
		}
		return this;
	}

	/**
	 * Skips {@code len} bytes.
	 *
	 * @param len the number of bytes to skip
	 * @return this buffer
	 * @throws BufferUnderflowException if the skip exceeds the available bytes
	 * @throws IllegalArgumentException if len is negative
	 */
	public Buffer skip(int len) {
		if (len < 0) {
			throw new IllegalArgumentException("len must >= 0");
		}
		if (null != buffer) {
			int pos = buffer.position();
			buffer.position(pos + len);
		}
		return this;
	}

	/**
	 * Provides the current limit of the internal {@link ByteBuffer}.
	 *
	 * @return The current limit.
	 */
	public int limit() {
		return (null == buffer ? 0 : buffer.limit());
	}

	/**
	 * Provides the current capacity of the internal {@link ByteBuffer}.
	 *
	 * @return The current capacity.
	 */
	public int capacity() {
		return (null == buffer ? SMALL_BUFFER_SIZE : buffer.capacity());
	}

	/**
	 * How many bytes available in this {@literal Buffer}. If reading, it is the number of bytes available to read. If
	 * writing, it is the number of bytes available for writing.
	 *
	 * @return The number of bytes available in this {@literal Buffer}.
	 */
	public int remaining() {
		return (null == buffer ? SMALL_BUFFER_SIZE : buffer.remaining());
	}

	/**
	 * Clear the internal {@link ByteBuffer} by setting the {@link ByteBuffer#position(int)} to 0 and the limit to the
	 * current capacity.
	 *
	 * @return {@literal this}
	 */
	public Buffer clear() {
		if (null != buffer) {
			buffer.position(0);
			buffer.limit(buffer.capacity());
		}
		return this;
	}

	/**
	 * Compact the underlying {@link ByteBuffer}.
	 *
	 * @return {@literal this}
	 */
	public Buffer compact() {
		if (null != buffer) {
			buffer.compact();
		}
		return this;
	}

	/**
	 * Flip this {@literal Buffer}. Used after a write to prepare this {@literal Buffer} for reading.
	 *
	 * @return {@literal this}
	 */
	public Buffer flip() {
		if (null != buffer) {
			buffer.flip();
		}
		return this;
	}

	/**
	 * Rewind this {@literal Buffer} to the beginning. Prepares the {@literal Buffer} for reuse.
	 *
	 * @return {@literal this}
	 */
	public Buffer rewind() {
		if (null != buffer) {
			buffer.rewind();
		}
		return this;
	}

	/**
	 * Rewinds this buffer by {@code len} bytes.
	 *
	 * @param len The number of bytes the rewind by
	 * @return this buffer
	 * @throws BufferUnderflowException if the rewind would move past the start of the buffer
	 * @throws IllegalArgumentException if len is negative
	 */
	public Buffer rewind(int len) {
		if (len < 0) {
			throw new IllegalArgumentException("len must >= 0");
		}
		if (null != buffer) {
			int pos = buffer.position();
			buffer.position(pos - len);
		}
		return this;
	}

	/**
	 * Create a new {@code Buffer} by calling {@link java.nio.ByteBuffer#duplicate()} on the underlying {@code
	 * ByteBuffer}.
	 *
	 * @return the new {@code Buffer}
	 */
	public Buffer duplicate() {
		return new Buffer(buffer.duplicate());
	}

	/**
	 * Create a new {@code Buffer} by copying the underlying {@link ByteBuffer} into a newly-allocated {@code Buffer}.
	 *
	 * @return the new {@code Buffer}
	 */
	public Buffer copy() {
		if (buffer == null) return new Buffer();
		snapshot();
		Buffer b = new Buffer(buffer.remaining(), false);
		b.append(buffer);
		reset();

		return b.flip();
	}

	/**
	 * Prepend the given {@link Buffer} to this {@literal Buffer}.
	 *
	 * @param b The {@link Buffer} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(Buffer b) {
		if (null == b) {
			return this;
		}
		return prepend(b.buffer);
	}

	/**
	 * Prepend the given {@link String } to this {@literal Buffer}.
	 *
	 * @param s The {@link String} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(String s) {
		if (null == s) {
			return this;
		}
		return prepend(s.getBytes());
	}

	/**
	 * Prepend the given {@code byte[]} array to this {@literal Buffer}.
	 *
	 * @param bytes The {@code byte[]} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(byte[] bytes) {
		shift(bytes.length);
		buffer.put(bytes);
		reset();
		return this;
	}

	/**
	 * Prepend the given {@link ByteBuffer} to this {@literal Buffer}.
	 *
	 * @param b The {@link ByteBuffer} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(ByteBuffer b) {
		if (null == b) {
			return this;
		}
		shift(b.remaining());
		this.buffer.put(b);
		reset();
		return this;

	}

	/**
	 * Prepend the given {@code byte} to this {@literal Buffer}.
	 *
	 * @param b The {@code byte} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(byte b) {
		shift(1);
		this.buffer.put(b);
		reset();
		return this;
	}

	/**
	 * Prepend the given {@code char} to this existing {@literal Buffer}.
	 *
	 * @param c The {@code char} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(char c) {
		shift(2);
		this.buffer.putChar(c);
		reset();
		return this;
	}

	/**
	 * Prepend the given {@code short} to this {@literal Buffer}.
	 *
	 * @param s The {@code short} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(short s) {
		shift(2);
		this.buffer.putShort(s);
		reset();
		return this;
	}

	/**
	 * Prepend the given {@code int} to this {@literal Buffer}.
	 *
	 * @param i The {@code int} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(int i) {
		shift(4);
		this.buffer.putInt(i);
		reset();
		return this;
	}

	/**
	 * Prepend the given {@code long} to this {@literal Buffer}.
	 *
	 * @param l The {@code long} to prepend.
	 * @return {@literal this}
	 */
	public Buffer prepend(long l) {
		shift(8);
		this.buffer.putLong(l);
		reset();
		return this;
	}

	/**
	 * Append the given String to this {@literal Buffer}.
	 *
	 * @param s The String to append.
	 * @return {@literal this}
	 */
	public Buffer append(String s) {
		ensureCapacity(s.length());
		buffer.put(s.getBytes());
		return this;
	}

	/**
	 * Append the given {@code short} to this {@literal Buffer}.
	 *
	 * @param s The {@code short} to append.
	 * @return {@literal this}
	 */
	public Buffer append(short s) {
		ensureCapacity(2);
		buffer.putShort(s);
		return this;
	}

	/**
	 * Append the given {@code int} to this {@literal Buffer}.
	 *
	 * @param i The {@code int} to append.
	 * @return {@literal this}
	 */
	public Buffer append(int i) {
		ensureCapacity(4);
		buffer.putInt(i);
		return this;
	}

	/**
	 * Append the given {@code long} to this {@literal Buffer}.
	 *
	 * @param l The {@code long} to append.
	 * @return {@literal this}
	 */
	public Buffer append(long l) {
		ensureCapacity(8);
		buffer.putLong(l);
		return this;
	}

	/**
	 * Append the given {@code char} to this {@literal Buffer}.
	 *
	 * @param c The {@code char} to append.
	 * @return {@literal this}
	 */
	public Buffer append(char c) {
		ensureCapacity(2);
		buffer.putChar(c);
		return this;
	}

	/**
	 * Append the given {@link ByteBuffer} to this {@literal Buffer}.
	 *
	 * @param buffers The {@link ByteBuffer ByteBuffers} to append.
	 * @return {@literal this}
	 */
	public Buffer append(ByteBuffer... buffers) {
		for (ByteBuffer bb : buffers) {
			if (bb != null) {
				ensureCapacity(bb.remaining());
				buffer.put(bb);
			}
		}
		return this;
	}

	/**
	 * Append the given {@link Buffer} to this {@literal Buffer}.
	 *
	 * @param buffers The {@link Buffer Buffers} to append.
	 * @return {@literal this}
	 */
	public Buffer append(Buffer... buffers) {
		for (Buffer b : buffers) {
			int pos = position();
			int len = b.remaining();
			ensureCapacity(len);
			if (b.byteBuffer() != null) {
				buffer.put(b.byteBuffer());
				buffer.position(pos + len);
			}
		}
		return this;
	}

	/**
	 * Append the given {@code byte} to this {@literal Buffer}.
	 *
	 * @param b The {@code byte} to append.
	 * @return {@literal this}
	 */
	public Buffer append(byte b) {
		ensureCapacity(1);
		buffer.put(b);
		return this;
	}

	/**
	 * Append the given {@code byte[]} to this {@literal Buffer}.
	 *
	 * @param b The {@code byte[]} to append.
	 * @return {@literal this}
	 */
	public Buffer append(byte[] b) {
		ensureCapacity(b.length);
		buffer.put(b);
		return this;
	}

	/**
	 * Append the given {@code byte[]} to this {@literal Buffer}, starting at the given index and continuing for the
	 * given
	 * length.
	 *
	 * @param b     the bytes to append
	 * @param start the index of where to start copying bytes
	 * @param len   the len of the bytes to copy
	 * @return {@literal this}
	 */
	public Buffer append(byte[] b, int start, int len) {
		ensureCapacity(b.length);
		buffer.put(b, start, len);
		return this;
	}

	/**
	 * Get the first {@code byte} from this {@literal Buffer}.
	 *
	 * @return The first {@code byte}.
	 */
	public byte first() {
		snapshot();
		if (this.position > 0) {
			buffer.position(0); // got to the 1st position
		}
		byte b = buffer.get(); // get the 1st byte
		reset(); // go back to original pos
		return b;
	}

	/**
	 * Get the last {@code byte} from this {@literal Buffer}.
	 *
	 * @return The last {@code byte}.
	 */
	public byte last() {
		int pos = buffer.position();
		int limit = buffer.limit();
		buffer.position(limit - 1); // go to right before last position
		byte b = buffer.get(); // get the last byte
		buffer.position(pos); // go back to original pos
		return b;
	}

	/**
	 * Read a single {@code byte} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code byte}.
	 */
	public byte read() {
		if (null != buffer) {
			return buffer.get();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read at least {@code b.length} bytes from the underlying {@link ByteBuffer}.
	 *
	 * @param b The buffer to fill.
	 * @return {@literal this}
	 */
	public Buffer read(byte[] b) {
		if (null != buffer) {
			buffer.get(b);
		}
		return this;
	}

	/**
	 * Read the next {@code short} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code short}.
	 */
	public short readShort() {
		if (null != buffer) {
			return buffer.getShort();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read the next {@code int} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code int}.
	 */
	public int readInt() {
		if (null != buffer) {
			return buffer.getInt();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read the next {@code float} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code float}.
	 */
	public float readFloat() {
		if (null != buffer) {
			return buffer.getFloat();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read the next {@code double} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code double}.
	 */
	public double readDouble() {
		if (null != buffer) {
			return buffer.getDouble();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read the next {@code long} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code long}.
	 */
	public long readLong() {
		if (null != buffer) {
			return buffer.getLong();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Read the next {@code char} from the underlying {@link ByteBuffer}.
	 *
	 * @return The next {@code char}.
	 */
	public char readChar() {
		if (null != buffer) {
			return buffer.getChar();
		}
		throw new BufferUnderflowException();
	}

	/**
	 * Save the current buffer position and limit.
	 */
	public void snapshot() {
		this.position = buffer.position();
		this.limit = buffer.limit();
	}

	/**
	 * Reset the buffer to the previously-saved position and limit.
	 *
	 * @return {@literal this}
	 */
	public Buffer reset() {
		buffer.limit(limit);
		buffer.position(position);
		return this;
	}

	@Override
	public Iterator<Byte> iterator() {
		return new Iterator<Byte>() {
			@Override
			public boolean hasNext() {
				return buffer.remaining() > 0;
			}

			@Override
			public Byte next() {
				return buffer.get();
			}

			@Override
			public void remove() {
				// NO-OP
			}
		};
	}

	@Override
	public int read(ByteBuffer dst) throws IOException {
		snapshot();
		if (dst.remaining() < this.limit) {
			buffer.limit(dst.remaining());
		}
		int pos = dst.position();
		dst.put(buffer);
		buffer.limit(this.limit);
		return dst.position() - pos;
	}

	@Override
	public int write(ByteBuffer src) throws IOException {
		int pos = src.position();
		append(src);
		return src.position() - pos;
	}

	@Override
	public boolean isOpen() {
		return isDynamic();
	}

	@Override
	public void close() throws IOException {
		clear();
	}

	/**
	 * Convert the contents of this buffer into a String using a UTF-8 {@link CharsetDecoder}.
	 *
	 * @return The contents of this {@literal Buffer} as a String.
	 */
	public String asString() {
		if (null != buffer) {
			return decode();
		} else {
			return null;
		}
	}

	/**
	 * Slice a portion of this buffer and convert it to a String.
	 *
	 * @param start start of the range.
	 * @param end   end of the range.
	 * @return The contents of the given range as a String.
	 */
	public String substring(int start, int end) {
		snapshot();

		buffer.limit((end > start ? end : this.limit));
		buffer.position(start);
		String s = asString();

		reset();
		return s;
	}

	/**
	 * Return the contents of this buffer copied into a {@code byte[]}.
	 *
	 * @return The contents of this buffer as a {@code byte[]}.
	 */
	public byte[] asBytes() {
		if (null != buffer) {
			snapshot();
			byte[] b = new byte[buffer.remaining()];
			buffer.get(b);
			reset();
			return b;
		} else {
			return null;
		}
	}

	/**
	 * Create an {@link InputStream} capable of reading the bytes from the internal {@link ByteBuffer}.
	 *
	 * @return A new {@link InputStream}.
	 */
	public InputStream inputStream() {
		return new BufferInputStream();
	}

	/**
	 * Create a copy of the given range.
	 *
	 * @param start start of the range.
	 * @param len   end of the range.
	 * @return A new {@link Buffer}, constructed from the contents of the given range.
	 */
	public Buffer slice(int start, int len) {
		snapshot();
		ByteBuffer bb = ByteBuffer.allocate(len);
		buffer.position(start);
		bb.put(buffer);
		reset();
		bb.flip();
		return new Buffer(bb);
	}

	/**
	 * Split this buffer on the given delimiter.
	 *
	 * @param delimiter The delimiter on which to split this buffer.
	 * @return A {@link List} of {@link View Views} that point to the segments of this buffer.
	 */
	public List<View> split(int delimiter) {
		return split(new ArrayList<View>(), delimiter, false);
	}

	/**
	 * Split this buffer on the given delimiter but save memory by reusing the given {@link List}.
	 *
	 * @param views     The list to store {@link View Views} in.
	 * @param delimiter The delimiter on which to split this buffer.
	 * @return A {@link List} of {@link View Views} that point to the segments of this buffer.
	 */
	public List<View> split(List<View> views, int delimiter) {
		return split(views, delimiter, false);
	}

	/**
	 * Split this buffer on the given delimiter and optionally leave the delimiter intact rather than stripping it.
	 *
	 * @param delimiter      The delimiter on which to split this buffer.
	 * @param stripDelimiter {@literal true} to ignore the delimiter, {@literal false} to leave it in the returned data.
	 * @return A {@link List} of {@link View Views} that point to the segments of this buffer.
	 */
	public List<View> split(int delimiter, boolean stripDelimiter) {
		return split(new ArrayList<View>(), delimiter, stripDelimiter);
	}

	/**
	 * Split this buffer on the given delimiter, save memory by reusing the given {@link List}, and optionally leave the
	 * delimiter intact rather than stripping it.
	 *
	 * @param views          The list to store {@link View Views} in.
	 * @param delimiter      The delimiter on which to split this buffer.
	 * @param stripDelimiter {@literal true} to ignore the delimiter, {@literal false} to leave it in the returned data.
	 * @return A {@link List} of {@link View Views} that point to the segments of this buffer.
	 */
	public List<View> split(List<View> views, int delimiter, boolean stripDelimiter) {
		snapshot();

		int start = this.position;
		for (byte b : this) {
			if (b == delimiter) {
				int end = stripDelimiter ? buffer.position() - 1 : buffer.position();
				views.add(createView(start, end));
				start = end + (stripDelimiter ? 1 : 0);
			}
		}
		if (start != buffer.position()) {
			buffer.position(start);
		}

		reset();

		return views;
	}

	/**
	 * Split this buffer on the given delimiter and leave the delimiter on the end of each segment.
	 *
	 * @param delimiter the multi-byte delimiter
	 * @return An {@link Iterable} of {@link View Views} that point to the segments of this buffer.
	 */
	public Iterable<View> split(Buffer delimiter) {
		return split(new ArrayList<View>(), delimiter, false);
	}

	/**
	 * Split this buffer on the given delimiter. The delimiter is stripped from the end of the segment if {@code
	 * stripDelimiter} is {@code true}.
	 *
	 * @param delimiter      The multi-byte delimiter.
	 * @param stripDelimiter {@literal true} to ignore the delimiter, {@literal false} to leave it in the returned data.
	 * @return An {@link Iterable} of {@link View Views} that point to the segments of this buffer.
	 */
	public Iterable<View> split(Buffer delimiter, boolean stripDelimiter) {
		return split(new ArrayList<View>(), delimiter, stripDelimiter);
	}

	/**
	 * Split this buffer on the given delimiter. Save memory by reusing the provided {@code List}. The delimiter is
	 * stripped from the end of the segment if {@code
	 * stripDelimiter} is {@code true}.
	 *
	 * @param views          The already-allocated List to reuse.
	 * @param delimiter      The multi-byte delimiter.
	 * @param stripDelimiter {@literal true} to ignore the delimiter, {@literal false} to leave it in the returned data.
	 * @return An {@link Iterable} of {@link View Views} that point to the segments of this buffer.
	 */
	public Iterable<View> split(List<View> views, Buffer delimiter, boolean stripDelimiter) {
		snapshot();

		byte[] delimBytes = delimiter.asBytes();
		if (delimBytes.length == 0) {
			return Collections.emptyList();
		}

		int start = this.position;
		for (byte b : this) {
			if (b != delimBytes[0]) {
				continue;
			}
			int end = -1;
			for (int i = 1; i < delimBytes.length; i++) {
				if (read() == delimBytes[i]) {
					end = stripDelimiter ? buffer.position() - delimBytes.length : buffer.position();
				} else {
					end = -1;
					break;
				}
			}
			if (end > 0) {
				views.add(createView(start, end));
				start = end + (stripDelimiter ? delimBytes.length : 0);
			}
		}
		if (start != buffer.position()) {
			buffer.position(start);
		}

		reset();

		return views;
	}

	/**
	 * Search the buffer and find the position of the first occurrence of the given {@code byte}.
	 *
	 * @param b the {@code byte} to search for
	 * @return the position of the char in the buffer or {@code -1} if not found
	 */
	public int indexOf(byte b) {
		return indexOf(b, buffer.position(), buffer.remaining());
	}

	/**
	 * Search the buffer and find the position of the first occurrence of the given {@code byte} staring at the start
	 * position and searching until (and including) the end position.
	 *
	 * @param b     the {@code byte} to search for
	 * @param start the position to start searching
	 * @param end   the position at which to stop searching
	 * @return the position of the char in the buffer or {@code -1} if not found
	 */
	public int indexOf(byte b, int start, int end) {
		snapshot();
		if (buffer.position() != start) {
			buffer.position(start);
		}
		int pos = -1;
		while (buffer.hasRemaining() && buffer.position() < end) {
			if (buffer.get() == b) {
				pos = buffer.position();
				break;
			}
		}
		reset();
		return pos;
	}

	/**
	 * Create a {@link View} of the current range of this {@link Buffer}.
	 *
	 * @return The view of the buffer
	 * @see #position()
	 * @see #limit()
	 */
	public View createView() {
		snapshot();
		return new View(position, limit);
	}

	/**
	 * Create a {@link View} of the given range of this {@literal Buffer}.
	 *
	 * @param start start of the range.
	 * @param end   end of the range.
	 * @return A new {@link View} object that represents the given range.
	 */
	public View createView(int start, int end) {
		snapshot();
		return new View(start, end);
	}

	/**
	 * Slice this buffer at the given positions. Useful for extracting multiple segments of data from a buffer when the
	 * exact indices of that data is already known.
	 *
	 * @param positions The start and end positions of the slices.
	 * @return A list of {@link View Views} pointing to the slices.
	 */
	public List<View> slice(int... positions) {
		Assert.notNull(positions, "Positions cannot be null.");
		if (positions.length == 0) {
			return Collections.emptyList();
		}

		snapshot();

		List<View> views = new ArrayList<View>();
		int len = positions.length;
		for (int i = 0; i < len; i++) {
			int start = positions[i];
			int end = (i + 1 < len ? positions[++i] : this.limit);
			views.add(createView(start, end));
			reset();
		}

		return views;
	}

	/**
	 * Return the underlying {@link ByteBuffer}.
	 *
	 * @return The {@link ByteBuffer} in use.
	 */
	public ByteBuffer byteBuffer() {
		return buffer;
	}

	/**
	 * Is this instance a delimiting Buffer
	 *
	 * @return true if delimiter
	 * @since 2.0.4
	 */
	public boolean isDelimitingBuffer(){
		return this == DELIMITING_BUFFER;
	}

	@Override
	public String toString() {
		return (null != buffer ? buffer.toString() : "<EMPTY>");
	}

	@Override
	public int compareTo(Buffer buffer) {
		return (null != buffer ? this.buffer.compareTo(buffer.buffer) : -1);
	}

	private synchronized void ensureCapacity(int atLeast) {
		if (null == buffer) {
			buffer = ByteBuffer.allocate(Math.max(atLeast, SMALL_BUFFER_SIZE));
			return;
		}
		int pos = buffer.position();
		int cap = buffer.capacity();
		if (dynamic) {
			int neededCapacity = pos + atLeast;
			if (neededCapacity > cap) {
				// There's not enough capacity to handle atLeast
				expand(neededCapacity - cap);
			}
			buffer.limit(Math.max(neededCapacity, buffer.limit()));
		} else if (pos + SMALL_BUFFER_SIZE > MAX_BUFFER_SIZE) {
			throw new BufferOverflowException();
		}
	}

	private void expand(int expandSize) {
		snapshot();
		ByteBuffer newBuff = (buffer.isDirect()
				? ByteBuffer.allocateDirect(buffer.capacity() + expandSize)
				: ByteBuffer.allocate(buffer.capacity() + expandSize));
		buffer.flip();
		newBuff.put(buffer);
		buffer = newBuff;
		reset();
	}

	private String decode() {
		if (null == decoder) {
			decoder = UTF8.newDecoder();
		}
		snapshot();
		try {
			if (null == chars || chars.remaining() < buffer.remaining()) {
				chars = CharBuffer.allocate(buffer.remaining());
			} else {
				chars.rewind();
			}
			decoder.reset();
			CoderResult cr = decoder.decode(buffer, chars, true);
			if (cr.isUnderflow()) {
				decoder.flush(chars);
			}
			chars.flip();

			return chars.toString();
		} finally {
			reset();
		}
	}

	private void shift(int right) {
		ByteBuffer currentBuffer;
		if (null == buffer) {
			ensureCapacity(right);
			currentBuffer = buffer;
		} else {
			currentBuffer = buffer.slice();
		}

		int len = buffer.remaining();
		int pos = buffer.position();
		ensureCapacity(right + len);

		buffer.position(pos + right);
		buffer.put(currentBuffer);
		buffer.position(pos);

		snapshot();
	}

	private class BufferInputStream extends InputStream {
		ByteBuffer buffer = Buffer.this.buffer.slice();

		@Override
		public int read(byte[] b) throws IOException {
			int pos = buffer.position();
			buffer.get(b);
			syncPos();
			return buffer.position() - pos;
		}

		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			if (null == buffer || buffer.remaining() == 0) {
				return -1;
			}
			byte[] bytes = asBytes();
			int bytesLen = bytes.length;
			System.arraycopy(bytes, 0, b, off, bytesLen);
			if (len < bytesLen) {
				buffer.position(position + len);
			}
			syncPos();
			return bytesLen;
		}

		@Override
		public long skip(long n) throws IOException {
			if (n < buffer.remaining()) {
				throw new IOException(new BufferUnderflowException());
			}
			int pos = buffer.position();
			buffer.position((int) (pos + n));
			syncPos();
			return buffer.position() - pos;
		}

		@Override
		public int available() throws IOException {
			return buffer.remaining();
		}

		@Override
		public void close() throws IOException {
			buffer.position(buffer.limit());
			syncPos();
		}

		@Override
		public synchronized void mark(int readlimit) {
			buffer.mark();
			int pos = buffer.position();
			int max = buffer.capacity() - pos;
			int newLimit = Math.min(max, pos + readlimit);
			buffer.limit(newLimit);
		}

		@Override
		public synchronized void reset() throws IOException {
			buffer.reset();
			syncPos();
		}

		@Override
		public boolean markSupported() {
			return true;
		}

		@Override
		public int read() throws IOException {
			int b = buffer.get();
			syncPos();
			return b;
		}

		private void syncPos() {
			int oldPos = Buffer.this.buffer.position();
			Buffer.this.buffer.position(buffer.position() + oldPos);
		}
	}

	/**
	 * A {@literal View} represents a segment of a buffer. When {@link #get()} is called, the {@literal Buffer} is set to
	 * the correct start and end points as given at creation time. After the view has been used, it is the responsibility
	 * of the caller to {@link #reset()} the buffer if more manipulation is required. Otherwise, multiple views can be
	 * created from a single buffer and used consecutively to extract portions of a buffer without expensive substrings.
	 */
	public class View implements Supplier<Buffer> {
		private final int start;
		private final int end;

		private View(int start, int end) {
			this.start = start;
			this.end = end;
		}

		/**
		 * Get the start of this range.
		 *
		 * @return start of the range.
		 */
		public int getStart() {
			return start;
		}

		/**
		 * Get the end of this range.
		 *
		 * @return end of the range.
		 */
		public int getEnd() {
			return end;
		}

		@Override
		public Buffer get() {
			buffer.limit(end);
			buffer.position(start);
			return Buffer.this;
		}
	}

	/**
	 * A delimiting buffer is sent to {@link reactor.io.codec.BufferCodec} and other components to signal the end of a sequence of Buffer.
	 * @since 2.0.4
	 */
	public static final Buffer DELIMITING_BUFFER = new Buffer();

}


File: reactor-stream/src/main/java/reactor/rx/action/Action.java
/*
 * Copyright (c) 2011-2014 Pivotal Software, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package reactor.rx.action;

import org.reactivestreams.Processor;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.Environment;
import reactor.core.Dispatcher;
import reactor.core.alloc.Recyclable;
import reactor.core.dispatch.SynchronousDispatcher;
import reactor.core.dispatch.TailRecurseDispatcher;
import reactor.core.processor.CancelException;
import reactor.core.queue.CompletableLinkedQueue;
import reactor.core.queue.CompletableQueue;
import reactor.core.support.Exceptions;
import reactor.core.support.NonBlocking;
import reactor.core.support.SpecificationExceptions;
import reactor.fn.Consumer;
import reactor.fn.Supplier;
import reactor.fn.tuple.Tuple;
import reactor.fn.tuple.Tuple2;
import reactor.rx.Stream;
import reactor.rx.StreamUtils;
import reactor.rx.action.combination.FanInAction;
import reactor.rx.broadcast.Broadcaster;
import reactor.rx.subscription.DropSubscription;
import reactor.rx.subscription.FanOutSubscription;
import reactor.rx.subscription.PushSubscription;
import reactor.rx.subscription.ReactiveSubscription;

/**
 * An Action is a reactive component to subscribe to a {@link org.reactivestreams.Publisher} and in particular
 * to a {@link reactor.rx.Stream}. Stream is usually the place where actions are created.
 * <p>
 * An Action is also a data producer, and therefore implements {@link org.reactivestreams.Processor}.
 * An imperative programming equivalent of an action is a method or function. The main difference is that it also
 * reacts on various {@link org.reactivestreams.Subscriber} signals and produce an output data {@param O} for
 * any downstream subscription.
 * <p>
 * The implementation specifics of an Action lies in two core features:
 * - Its signal scheduler on {@link reactor.core.Dispatcher}
 * - Its smart capacity awareness to prevent {@link reactor.core.Dispatcher} overflow
 * <p>
 * Up to a maximum capacity defined with {@link this#capacity(long)} will be allowed to be dispatched by requesting
 * the tracked remaining slots to the upstream {@link org.reactivestreams.Subscription}. This maximum in-flight data
 * is a value to tune accordingly with the system and the requirements. An Action will bypass this feature anytime it is
 * not the root of stream processing chain e.g.:
 * <p>
 * stream.filter(..).map(..) :
 * <p>
 * In that Stream, filter is a FilterAction and has no upstream action, only the publisher it is attached to.
 * The FilterAction will decide to be capacity aware and will track demand.
 * The MapAction will however behave like a firehose and will not track the demand, passing any request upstream.
 * <p>
 * Implementing an Action is highly recommended to work with Stream without dealing with tracking issues and other
 * threading matters. Usually an implementation will override any doXXXXX method where 'do' is an hint that logic will
 * safely be dispatched to avoid race-conditions.
 *
 * @param <I> The input {@link this#onNext(Object)} signal
 * @param <O> The output type to listen for with {@link this#subscribe(org.reactivestreams.Subscriber)}
 * @author Stephane Maldini
 * @since 1.1, 2.0
 */
public abstract class Action<I, O> extends Stream<O>
		implements Processor<I, O>, Consumer<I>, Recyclable, Control {

	/**
	 * onComplete, onError, request, onSubscribe are dispatched events, therefore up to capacity + 4 events can be
	 * in-flight
	 * stacking into a Dispatcher.
	 */
	public static final int RESERVED_SLOTS = 4;
	public static final int NO_CAPACITY    = -1;

	/**
	 * The upstream request tracker to avoid dispatcher overrun, based on the current {@link this#capacity}
	 */
	protected PushSubscription<I> upstreamSubscription;
	protected PushSubscription<O> downstreamSubscription;

	protected long capacity;

	public static void checkRequest(long n) {
		if (n <= 0l) {
			throw SpecificationExceptions.spec_3_09_exception(n);
		}
	}

	public static long evaluateCapacity(long n) {
		return n != Long.MAX_VALUE ?
				Math.max(Action.RESERVED_SLOTS, n - Action.RESERVED_SLOTS) :
				Long.MAX_VALUE;
	}

	public Action() {
		this(Long.MAX_VALUE);
	}

	public Action(long batchSize) {
		this.capacity = batchSize;
	}

	/**
	 * --------------------------------------------------------------------------------------------------------
	 * ACTION SIGNAL HANDLING
	 * --------------------------------------------------------------------------------------------------------
	 */


	@Override
	public void subscribe(final Subscriber<? super O> subscriber) {
		try {
			final NonBlocking asyncSubscriber = NonBlocking.class.isAssignableFrom(subscriber.getClass()) ?
					(NonBlocking) subscriber :
					null;

			boolean isReactiveCapacity = null == asyncSubscriber || asyncSubscriber.isReactivePull(getDispatcher(),
					capacity);

			final PushSubscription<O> subscription = createSubscription(subscriber,
					isReactiveCapacity);

			if (subscription == null)
				return;

			if (null != asyncSubscriber && isReactiveCapacity) {
				subscription.maxCapacity(asyncSubscriber.getCapacity());
			}

			subscribeWithSubscription(subscriber, subscription);

		}catch (Throwable throwable){
			Exceptions.throwIfFatal(throwable);
			subscriber.onError(throwable);
		}
	}

	@Override
	public void onSubscribe(Subscription subscription) {
		if (subscription == null) {
			throw new NullPointerException("Spec 2.13: Subscription cannot be null");
		}

		final boolean hasRequestTracker = upstreamSubscription != null;

		//if request tracker was connected to another subscription
		if (hasRequestTracker) {
			subscription.cancel();
			return;
		}

		upstreamSubscription = createTrackingSubscription(subscription);
		upstreamSubscription.maxCapacity(getCapacity());

		try {
			doOnSubscribe(subscription);
			doStart();
		} catch (Throwable t) {
			Exceptions.throwIfFatal(t);
			doError(t);
		}
	}

	protected final void doStart() {
		final PushSubscription<O> downSub = downstreamSubscription;
		if (downSub != null) {
				downSub.start();
		}
	}

	@Override
	public final void accept(I i) {
		onNext(i);
	}

	@Override
	public void onNext(I ev) {
		if (ev == null) {
			throw new NullPointerException("Spec 2.13: Signal cannot be null");
		}

		if (upstreamSubscription == null && downstreamSubscription == null) {
			throw CancelException.get();
		}

		try {
			doNext(ev);
		} catch (CancelException uae){
			throw uae;
		} catch (Throwable cause) {
			doError(Exceptions.addValueAsLastCause(cause, ev));
		}
	}

	@Override
	public void onComplete() {
		try {
			doComplete();
			doShutdown();
		} catch (Throwable t) {
			doError(t);
		}
	}

	@Override
	public void onError(Throwable cause) {
		if (cause == null) {
			throw new NullPointerException("Spec 2.13: Signal cannot be null");
		}
		if (upstreamSubscription != null) upstreamSubscription.updatePendingRequests(0l);
		doError(cause);
		doShutdown();
	}

	/**
	 * --------------------------------------------------------------------------------------------------------
	 * ACTION MODIFIERS
	 * --------------------------------------------------------------------------------------------------------
	 */

	@Override
	public Action<I, O> capacity(long elements) {
		Dispatcher dispatcher = getDispatcher();
		if (dispatcher != SynchronousDispatcher.INSTANCE && dispatcher.getClass() != TailRecurseDispatcher.class) {
			long dispatcherCapacity = evaluateCapacity(dispatcher.backlogSize());
			capacity = elements > dispatcherCapacity ? dispatcherCapacity : elements;
		} else {
			capacity = elements;
		}

		if (upstreamSubscription != null) {
			upstreamSubscription.maxCapacity(capacity);
		}
		return this;
	}

	/**
	 * Send an element of parameterized type {link O} to all the attached {@link Subscriber}.
	 * A Stream must be in READY state to dispatch signals and will fail fast otherwise (IllegalStateException).
	 *
	 * @param ev the data to forward
	 * @since 2.0
	 */
	protected void broadcastNext(final O ev) {
		//log.debug("event [" + ev + "] by: " + getClass().getSimpleName());
		PushSubscription<O> downstreamSubscription = this.downstreamSubscription;
		if (downstreamSubscription == null) {
				throw CancelException.get();
		}

		try {
			downstreamSubscription.onNext(ev);
		} catch(CancelException ce){
			throw ce;
		} catch (Throwable throwable) {
			doError(Exceptions.addValueAsLastCause(throwable, ev));
		}
	}

	/**
	 * Send an error to all the attached {@link Subscriber}.
	 * A Stream must be in READY state to dispatch signals and will fail fast otherwise (IllegalStateException).
	 *
	 * @param throwable the error to forward
	 * @since 2.0
	 */
	protected void broadcastError(final Throwable throwable) {
		//log.debug("event [" + throwable + "] by: " + getClass().getSimpleName());
		/*if (!isRunning()) {
			if (log.isTraceEnabled()) {
				log.trace("error dropped by: " + getClass().getSimpleName() + ":" + this, throwable);
			}
		}*/

		if (downstreamSubscription == null) {
			if (Environment.alive()) {
				Environment.get().routeError(throwable);
			}
			return;
		}

		downstreamSubscription.onError(throwable);
	}

	/**
	 * Send a complete event to all the attached {@link Subscriber} ONLY IF the underlying state is READY.
	 * Unlike {@link #broadcastNext(Object)} and {@link #broadcastError(Throwable)} it will simply ignore the signal.
	 *
	 * @since 2.0
	 */
	protected void broadcastComplete() {
		//log.debug("event [complete] by: " + getClass().getSimpleName());
		if (downstreamSubscription == null) {
			return;
		}

		try {
			downstreamSubscription.onComplete();
		} catch (Throwable throwable) {
			doError(throwable);
		}
	}

	@Override
	public boolean isPublishing() {
		PushSubscription<I> parentSubscription = upstreamSubscription;
		return parentSubscription != null && !parentSubscription.isComplete();
	}


	public void cancel() {
		PushSubscription<I> parentSub = upstreamSubscription;
		if (parentSub != null) {
			upstreamSubscription = null;
			parentSub.cancel();
		}
	}

	@Override
	public void requestAll() {
		if (downstreamSubscription == null) {
			requestMore(Long.MAX_VALUE);
		}
	}

	/**
	 * Print a debugged form of the root action relative to this one. The output will be an acyclic directed graph of
	 * composed actions.
	 *
	 * @since 2.0
	 */
	@SuppressWarnings("unchecked")
	public StreamUtils.StreamVisitor debug() {
		return StreamUtils.browse(findOldestUpstream(Action.class));
	}

	/**
	 * --------------------------------------------------------------------------------------------------------
	 * STREAM ACTION-SPECIFIC EXTENSIONS
	 * --------------------------------------------------------------------------------------------------------
	 */

	/**
	 * Consume a Stream to allow for dynamic {@link Action} update. Everytime
	 * the {@param controlStream} receives a next signal, the current Action and the input data will be published as a
	 * {@link reactor.fn.tuple.Tuple2} to the attached {@param controller}.
	 * <p>
	 * This is particulary useful to dynamically adapt the {@link Stream} instance : capacity(), pause(), resume()...
	 *
	 * @param controlStream The consumed stream, each signal will trigger the passed controller
	 * @param controller    The consumer accepting a pair of Stream and user-provided signal type
	 * @return the current {@link Stream} instance
	 * @since 2.0
	 */
	public final <E> Action<I, O> control(Stream<E> controlStream, final Consumer<Tuple2<Action<I, O>,
			? super E>> controller) {
		final Action<I, O> thiz = this;
		controlStream.consume(new Consumer<E>() {
			@Override
			public void accept(E e) {
				controller.accept(Tuple.of(thiz, e));
			}
		});
		return this;
	}

	@Override
	public final Stream<O> onOverflowBuffer(final Supplier<? extends CompletableQueue<O>> queueSupplier) {
		return lift(new Supplier<Action<O, O>>() {
			@Override
			public Action<O, O> get() {
				Broadcaster<O> newStream = Broadcaster.<O>create(getEnvironment(), getDispatcher()).capacity(capacity);
				if (queueSupplier == null) {
					subscribeWithSubscription(newStream, new DropSubscription<O>(Action.this, newStream) {
						@Override
						public void request(long elements) {
							super.request(elements);
							requestUpstream(capacity, isComplete(), elements);
						}
					});
				} else {
					subscribeWithSubscription(newStream,
							createSubscription(newStream, queueSupplier.get()));
				}
				return newStream;
			}
		});
	}

	@SuppressWarnings("unchecked")
	@Override
	public final <E> CompositeAction<E, O> combine() {
		final Action<E, ?> subscriber = (Action<E, ?>) findOldestUpstream(Action.class);
		subscriber.upstreamSubscription = null;
		return new CompositeAction<E, O>(subscriber, this);
	}

	/**
	 * Create a consumer that broadcast complete signal from any accepted value.
	 *
	 * @return a new {@link Consumer} ready to forward complete signal to this stream
	 * @since 2.0
	 */
	public final Consumer<?> toBroadcastCompleteConsumer() {
		return new Consumer<Object>() {
			@Override
			public void accept(Object o) {
				broadcastComplete();
			}
		};
	}


	/**
	 * Create a consumer that broadcast next signal from accepted values.
	 *
	 * @return a new {@link Consumer} ready to forward values to this stream
	 * @since 2.0
	 */
	public final Consumer<O> toBroadcastNextConsumer() {
		return new Consumer<O>() {
			@Override
			public void accept(O o) {
				broadcastNext(o);
			}
		};
	}

	/**
	 * Create a consumer that broadcast error signal from any accepted value.
	 *
	 * @return a new {@link Consumer} ready to forward error to this stream
	 * @since 2.0
	 */
	public final Consumer<Throwable> toBroadcastErrorConsumer() {
		return new Consumer<Throwable>() {
			@Override
			public void accept(Throwable o) {
				broadcastError(o);
			}
		};
	}

	/**
	 * Utility to find the most ancient subscribed Action.
	 * Also used by debug() operation to render the complete flow from upstream.
	 *
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public <P extends Publisher<?>> P findOldestUpstream(Class<P> clazz) {
		Action<?, ?> that = this;

		while (inspectPublisher(that, Action.class)) {

			that = (Action<?, ?>) that.upstreamSubscription.getPublisher();

			if (that != null) {

				if (FanInAction.class.isAssignableFrom(that.getClass())) {
					that = ((FanInAction) that).dynamicMergeAction() != null ? ((FanInAction) that).dynamicMergeAction() : that;
				}
			}
		}

		if (inspectPublisher(that, clazz)) {
			return (P) ((PushSubscription<?>) that.upstreamSubscription).getPublisher();
		} else {
			return (P) that;
		}
	}

	/**
	 * --------------------------------------------------------------------------------------------------------
	 * ACTION STATE
	 * --------------------------------------------------------------------------------------------------------
	 */

	@Override
	public final long getCapacity() {
		return capacity;
	}

	/**
	 * Get the current upstream subscription if any
	 *
	 * @return current {@link org.reactivestreams.Subscription}
	 */
	public PushSubscription<I> getSubscription() {
		return upstreamSubscription;
	}


	/**
	 * Get the current action child subscription
	 *
	 * @return current child {@link reactor.rx.subscription.PushSubscription}
	 */
	public final PushSubscription<O> downstreamSubscription() {
		return downstreamSubscription;
	}

	/**
	 * --------------------------------------------------------------------------------------------------------
	 * INTERNALS
	 * --------------------------------------------------------------------------------------------------------
	 */

	@Override
	public boolean cancelSubscription(final PushSubscription<O> subscription) {
		if (this.downstreamSubscription == null) return false;

		if (subscription == this.downstreamSubscription) {
			this.downstreamSubscription = null;
			cancel();
			return true;
		} else {
			PushSubscription<O> dsub = this.downstreamSubscription;
			if (FanOutSubscription.class.isAssignableFrom(dsub.getClass())) {
				FanOutSubscription<O> fsub =
						((FanOutSubscription<O>) this.downstreamSubscription);

				if (fsub.remove(subscription) && fsub.isEmpty()) {
					cancel();
					return true;
				}
			}
			return false;
		}
	}

	protected PushSubscription<O> createSubscription(final Subscriber<? super O> subscriber, boolean reactivePull) {
		return createSubscription(subscriber, reactivePull ? new CompletableLinkedQueue<O>() : null);
	}

	protected PushSubscription<O> createSubscription(final Subscriber<? super O> subscriber, CompletableQueue<O> queue) {
		if (queue != null) {
			return new ReactiveSubscription<O>(this, subscriber, queue) {

				@Override
				protected void onRequest(long elements) {
					requestUpstream(capacity, buffer.isComplete(), elements);
				}
			};
		} else {
			return new PushSubscription<O>(this, subscriber) {
				@Override
				protected void onRequest(long elements) {
					requestUpstream(NO_CAPACITY, isComplete(), elements);
				}
			};
		}
	}

	protected void requestUpstream(long capacity, boolean terminated, long elements) {
		if (upstreamSubscription != null && !terminated) {
			requestMore(elements);
		} else {
			PushSubscription<O> _downstreamSubscription = downstreamSubscription;
			if (_downstreamSubscription != null) {
				_downstreamSubscription.updatePendingRequests(elements);
			}
		}
	}

	@SuppressWarnings("unchecked")
	protected PushSubscription<I> createTrackingSubscription(Subscription subscription) {
		//If not a reactor push subscription, wrap within one
		if (!PushSubscription.class.isAssignableFrom(subscription.getClass())) {
			return PushSubscription.wrap(subscription, this);
		} else {
			return ((PushSubscription<I>) subscription);
		}
	}

	protected void doOnSubscribe(Subscription subscription) {
	}

	protected void doComplete() {
		broadcastComplete();
	}

	abstract protected void doNext(I ev);

	protected void doError(Throwable ev) {
		if (downstreamSubscription != null) {
			try {
				downstreamSubscription.onError(ev);
				return;
			} catch (Throwable t) {
				Environment.get().routeError(t);
			}
		}

		if (Environment.alive()) {
			Environment.get().routeError(ev);
		}
	}

	@Override
	public void requestMore(final long n) {
		checkRequest(n);
		if (upstreamSubscription != null) {
			upstreamSubscription.request(n);
		}
	}

	/**
	 * Subscribe a given subscriber and pairs it with a given subscription instead of letting the Stream pick it
	 * automatically.
	 * <p>
	 * This is mainly useful for libraries implementors, usually {@link this#lift(reactor.fn.Supplier)} and
	 * {@link this#subscribe(org.reactivestreams.Subscriber)} are just fine.
	 *
	 * @param subscriber
	 * @param subscription
	 */
	protected void subscribeWithSubscription(final Subscriber<? super O> subscriber, final PushSubscription<O>
			subscription) {
		try {
			if (!addSubscription(subscription)) {
				subscriber.onError(new IllegalStateException("The subscription cannot be linked to this Stream"));
			} else {
				subscription.markAsDeferredStart();
				if (upstreamSubscription != null) {
					subscription.start();
				}
			}
		} catch (Exception e) {
			Exceptions.throwIfFatal(e);
			subscriber.onError(e);
		}
	}


	@SuppressWarnings("unchecked")
	protected boolean addSubscription(final PushSubscription<O> subscription) {
		PushSubscription<O> currentSubscription = this.downstreamSubscription;
		if (currentSubscription == null) {
			this.downstreamSubscription = subscription;
			return true;
		} else if (currentSubscription.equals(subscription)) {
			subscription.onError(SpecificationExceptions.spec_2_12_exception());
			return false;
		} else if (FanOutSubscription.class.isAssignableFrom(currentSubscription.getClass())) {
			if (((FanOutSubscription<O>) currentSubscription).contains(subscription)) {
				subscription.onError(SpecificationExceptions.spec_2_12_exception());
				return false;
			} else {
				return ((FanOutSubscription<O>) currentSubscription).add(subscription);
			}
		} else {
			this.downstreamSubscription = new FanOutSubscription<O>(this, currentSubscription, subscription);
			return true;
		}
	}

	protected void doShutdown() {
		//recycle();
	}

	private boolean inspectPublisher(Action<?, ?> that, Class<?> actionClass) {
		return that.upstreamSubscription != null
				&& ((PushSubscription<?>) that.upstreamSubscription).getPublisher() != null
				&& actionClass.isAssignableFrom(((PushSubscription<?>) that.upstreamSubscription).getPublisher().getClass());
	}

	@Override
	public void recycle() {
		downstreamSubscription = null;
		upstreamSubscription = null;
	}

	@Override
	@SuppressWarnings("unchecked")
	public String toString() {
		return "{" +
				(capacity != Long.MAX_VALUE || upstreamSubscription == null ?
						"{dispatcher=" + getDispatcher() +
								((!SynchronousDispatcher.class.isAssignableFrom(getDispatcher().getClass()) ? (":" + getDispatcher()
										.remainingSlots()) :
										"")) +
								", max-capacity=" + (capacity == Long.MAX_VALUE ? "infinite" : capacity) + "}"
						: "") +
				(upstreamSubscription != null ? upstreamSubscription : "") + '}';
	}

}
