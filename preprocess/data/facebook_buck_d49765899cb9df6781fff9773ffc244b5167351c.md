Refactoring Types: ['Extract Method']
FilterResourcesStep.java
/*
 * Copyright 2012-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.log.Logger;
import com.facebook.buck.rules.RuleKey;
import com.facebook.buck.rules.RuleKeyAppendable;
import com.facebook.buck.shell.BashStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.facebook.buck.util.Console;
import com.facebook.buck.util.DefaultFilteredDirectoryCopier;
import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.Filters.Density;
import com.facebook.buck.util.HumanReadableException;
import com.facebook.buck.util.Verbosity;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;

/**
 * This {@link com.facebook.buck.step.Step} copies {@code res} directories to a different location,
 * while filtering out certain resources.
 */
public class FilterResourcesStep implements Step {

  private static final Pattern DRAWABLE_PATH_PATTERN = Pattern.compile(
      ".*drawable.*/.*(png|jpg|jpeg|gif|webp)", Pattern.CASE_INSENSITIVE);
  // Android doesn't scale these, so we don't need to scale or filter them either.
  private static final Pattern DRAWABLE_EXCLUDE_PATTERN = Pattern.compile(
      ".*-nodpi.*", Pattern.CASE_INSENSITIVE);

  private static final Logger LOG = Logger.get(FilterResourcesStep.class);

  @VisibleForTesting
  static final Pattern NON_ENGLISH_STRINGS_FILE_PATH = Pattern.compile(
      "(\\b|.*/)res/values-.+/strings.xml", Pattern.CASE_INSENSITIVE);

  @VisibleForTesting
  static final Pattern VALUES_DIR_PATTERN = Pattern.compile(
      "\\b|.*/res/values-([a-z]{2})(?:-r([A-Z]{2}))*/.*");

  private final ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
  private final boolean filterDrawables;
  private final boolean filterStrings;
  private final ImmutableSet<Path> whitelistedStringDirs;
  private final ImmutableSet<String> locales;
  private final FilteredDirectoryCopier filteredDirectoryCopier;
  @Nullable
  private final Set<Filters.Density> targetDensities;
  @Nullable
  private final DrawableFinder drawableFinder;
  @Nullable
  private final ImageScaler imageScaler;

  /**
   * Creates a command that filters a specified set of directories.
   * @param inResDirToOutResDirMap set of {@code res} directories to filter
   * @param filterDrawables whether to filter drawables (images)
   * @param filterStrings whether to filter non-english strings
   * @param whitelistedStringDirs set of directories containing string resource files that must not
   *     be filtered out.
   * @param filteredDirectoryCopier refer {@link FilteredDirectoryCopier}
   * @param targetDensities densities we're interested in keeping (e.g. {@code mdpi}, {@code hdpi}
   *     etc.) Only applicable if filterDrawables is true
   * @param drawableFinder refer {@link DrawableFinder}. Only applicable if filterDrawables is true.
   * @param imageScaler if not null, use the {@link ImageScaler} to downscale higher-density
   *     drawables for which we weren't able to find an image file of the proper density (as opposed
   *     to allowing Android to do it at runtime). Only applicable if filterDrawables. is true.
   */
  @VisibleForTesting
  FilterResourcesStep(
      ImmutableBiMap<Path, Path> inResDirToOutResDirMap,
      boolean filterDrawables,
      boolean filterStrings,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      FilteredDirectoryCopier filteredDirectoryCopier,
      @Nullable Set<Filters.Density> targetDensities,
      @Nullable DrawableFinder drawableFinder,
      @Nullable ImageScaler imageScaler) {

    Preconditions.checkArgument(filterDrawables || filterStrings || !locales.isEmpty());
    Preconditions.checkArgument(!filterDrawables ||
        (targetDensities != null && drawableFinder != null));
    this.inResDirToOutResDirMap = inResDirToOutResDirMap;
    this.filterDrawables = filterDrawables;
    this.filterStrings = filterStrings;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.filteredDirectoryCopier = filteredDirectoryCopier;
    this.targetDensities = targetDensities;
    this.drawableFinder = drawableFinder;
    this.imageScaler = imageScaler;
    LOG.info(
        "FilterResourcesStep: filterDrawables: %s; filterStrings: %s",
        filterDrawables,
        filterStrings);
  }

  @Override
  public int execute(ExecutionContext context) {
    try {
      return doExecute(context);
    } catch (Exception e) {
      context.logError(e, "There was an error filtering resources.");
      return 1;
    }
  }

  private int doExecute(ExecutionContext context) throws IOException, InterruptedException {
    List<Predicate<Path>> pathPredicates = Lists.newArrayList();

    boolean canDownscale = imageScaler != null && imageScaler.isAvailable(context);
    LOG.info(
        "FilterResourcesStep: canDownscale: %s. imageScalar non-null: %s.",
        canDownscale,
        imageScaler != null);

    if (filterDrawables) {
      Preconditions.checkNotNull(drawableFinder);
      Set<Path> drawables = drawableFinder.findDrawables(
          inResDirToOutResDirMap.keySet(),
          context.getProjectFilesystem());
      pathPredicates.add(
          Filters.createImageDensityFilter(
              drawables,
              Preconditions.checkNotNull(targetDensities),
              canDownscale));
    }

    if (!locales.isEmpty()) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path input) {
              Matcher matcher = VALUES_DIR_PATTERN.matcher(MorePaths.pathWithUnixSeparators(input));
              if (!matcher.matches() || isPathWhitelisted(input)) {
                return true;
              }
              String locale = matcher.group(1);
              if (matcher.group(2) != null) {
                locale += "_" + matcher.group(2);
              }
              return locales.contains(locale);
            }
          });
    }

    if (filterStrings) {
      pathPredicates.add(
          new Predicate<Path>() {
            @Override
            public boolean apply(Path pathRelativeToProjectRoot) {
              if (!NON_ENGLISH_STRINGS_FILE_PATH.matcher(MorePaths.pathWithUnixSeparators(
                      pathRelativeToProjectRoot))
                  .matches()) {
                return true;
              }

              return isPathWhitelisted(pathRelativeToProjectRoot);
            }
          });
    }

    // Create filtered copies of all resource directories. These will be passed to aapt instead.
    filteredDirectoryCopier.copyDirs(
        context.getProjectFilesystem(),
        inResDirToOutResDirMap,
        Predicates.and(pathPredicates));

    // If an ImageScaler was specified, but only if it is available, try to apply it.
    if (canDownscale && filterDrawables) {
      scaleUnmatchedDrawables(context);
    }

    return 0;
  }

  private boolean isPathWhitelisted(Path path) {
    for (Path whitelistedStringDir : whitelistedStringDirs) {
      if (path.startsWith(whitelistedStringDir)) {
        return true;
      }
    }

    return false;
  }

  @Override
  public String getShortName() {
    return "resource_filtering";
  }

  @Override
  public String getDescription(ExecutionContext context) {
    return "Filtering drawable and string resources.";
  }

  /**
   * Looks through filtered drawables for files not of the target density and replaces them with
   * scaled versions.
   * <p/>
   * Any drawables found by this step didn't have equivalents in the target density. If they are of
   * a higher density, we can replicate what Android does and downscale them at compile-time.
   */
  private void scaleUnmatchedDrawables(ExecutionContext context)
      throws IOException, InterruptedException {
    ProjectFilesystem filesystem = context.getProjectFilesystem();
    Filters.Density targetDensity = Filters.Density.ORDERING.max(targetDensities);

    // Go over all the images that remain after filtering.
    Preconditions.checkNotNull(drawableFinder);
    Collection<Path> drawables = drawableFinder.findDrawables(
        inResDirToOutResDirMap.values(),
        context.getProjectFilesystem());
    for (Path drawable : drawables) {
      if (drawable.toString().endsWith(".9.png")) {
        // Skip nine-patch for now.
        continue;
      }

      Filters.Qualifiers qualifiers = new Filters.Qualifiers(drawable);
      Filters.Density density = qualifiers.density;

      // If the image has a qualifier but it's not the right one.
      Preconditions.checkNotNull(targetDensities);
      if (!targetDensities.contains(density)) {

        // Replace density qualifier with target density using regular expression to match
        // the qualifier in the context of a path to a drawable.
        String fromDensity = (density == Density.NO_QUALIFIER ? "" : "-") + density.toString();
        Path destination = Paths.get(MorePaths.pathWithUnixSeparators(drawable).replaceFirst(
            "((?:^|/)drawable[^/]*)" + Pattern.quote(fromDensity) + "(-|$|/)",
            "$1-" + targetDensity + "$2"));

        double factor = targetDensity.value() / density.value();
        if (factor >= 1.0) {
          // There is no point in up-scaling, or converting between drawable and drawable-mdpi.
          continue;
        }

        // Make sure destination folder exists and perform downscaling.
        filesystem.createParentDirs(destination);
        Preconditions.checkNotNull(imageScaler);
        imageScaler.scale(factor, drawable, destination, context);

        // Delete source file.
        filesystem.deleteFileAtPath(drawable);

        // Delete newly-empty directories to prevent missing resources errors in apkbuilder.
        Path parent = drawable.getParent();
        if (filesystem.listFiles(parent).length == 0) {
          filesystem.deleteFileAtPath(parent);
        }

      }
    }
  }

  public interface DrawableFinder {
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException;
  }

  public static class DefaultDrawableFinder implements DrawableFinder {

    private static final DefaultDrawableFinder instance = new DefaultDrawableFinder();

    public static DefaultDrawableFinder getInstance() {
      return instance;
    }

    @Override
    public Set<Path> findDrawables(Collection<Path> dirs, ProjectFilesystem filesystem)
        throws IOException {
      final ImmutableSet.Builder<Path> drawableBuilder = ImmutableSet.builder();
      for (Path dir : dirs) {
        filesystem.walkRelativeFileTree(dir, new SimpleFileVisitor<Path>() {
              @Override
              public FileVisitResult visitFile(Path path, BasicFileAttributes attributes) {
                String unixPath = MorePaths.pathWithUnixSeparators(path);
                if (DRAWABLE_PATH_PATTERN.matcher(unixPath).matches() &&
                    !DRAWABLE_EXCLUDE_PATTERN.matcher(unixPath).matches()) {
                  // The path is normalized so that the value can be matched against patterns.
                  drawableBuilder.add(path);
                }
                return FileVisitResult.CONTINUE;
              }
            });
      }
      return drawableBuilder.build();
    }
  }

  public interface ImageScaler {
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException;
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException;
  }

  /**
   * Implementation of {@link ImageScaler} that uses ImageMagick's {@code convert} command.
   *
   * @see <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a>
   */
  public static class ImageMagickScaler implements ImageScaler {

    private static final ImageMagickScaler instance = new ImageMagickScaler();

    public static ImageMagickScaler getInstance() {
      return instance;
    }

    private ExecutionContext getContextWithSilentConsole(ExecutionContext context) {
      // Using the normal console results in the super console freezing.
      Console console = context.getConsole();
      return ExecutionContext.builder()
          .setExecutionContext(context)
          .setConsole(new Console(
              Verbosity.SILENT,
              console.getStdOut(),
              console.getStdErr(),
              console.getAnsi()
          ))
          .build();
    }

    @Override
    public boolean isAvailable(ExecutionContext context) throws IOException, InterruptedException {
      try (ExecutionContext silentContext = getContextWithSilentConsole(context)) {
        return 0 == new BashStep("which convert").execute(silentContext);
      }
    }

    @Override
    public void scale(double factor, Path source, Path destination, ExecutionContext context)
        throws IOException, InterruptedException {
      Step convertStep = new BashStep(
          "convert",
          "-adaptive-resize", (int) (factor * 100) + "%",
          Escaper.escapeAsBashString(source),
          Escaper.escapeAsBashString(destination));

      if (0 != convertStep.execute(context)) {
        throw new HumanReadableException("Cannot scale " + source + " to " + destination);
      }
    }
  }

  /**
   * Helper class for interpreting the resource_filter argument to android_binary().
   */
  public static class ResourceFilter implements RuleKeyAppendable {

    static final ResourceFilter EMPTY_FILTER = new ResourceFilter(ImmutableList.<String>of());

    private final Set<String> filter;
    private final Set<Filters.Density> densities;
    private final boolean downscale;

    public ResourceFilter(List<String> resourceFilter) {
      this.filter = ImmutableSet.copyOf(resourceFilter);
      this.densities = Sets.newHashSet();

      boolean downscale = false;
      for (String component : filter) {
        if ("downscale".equals(component)) {
          downscale = true;
        } else {
          densities.add(Filters.Density.from(component));
        }
      }

      this.downscale = downscale;
    }

    public boolean shouldDownscale() {
      return isEnabled() && downscale;
    }

    @Nullable
    public Set<Filters.Density> getDensities() {
      return densities;
    }

    public boolean isEnabled() {
      return !densities.isEmpty();
    }

    public String getDescription() {
      return filter.toString();
    }

    @Override
    public RuleKey.Builder appendToRuleKey(RuleKey.Builder builder) {
      return builder.setReflectively("filter", getDescription());
    }

    @VisibleForTesting
    Set<String> getFilter() {
      return filter;
    }
  }

  public static Builder builder() {
    return new Builder();
  }

  public static class Builder {

    @Nullable
    private ImmutableBiMap<Path, Path> inResDirToOutResDirMap;
    @Nullable
    private ResourceFilter resourceFilter;
    private boolean filterStrings = false;
    private ImmutableSet<Path> whitelistedStringDirs = ImmutableSet.of();
    private ImmutableSet<String> locales = ImmutableSet.of();

    private Builder() {
    }

    public Builder setInResToOutResDirMap(ImmutableBiMap<Path, Path> inResDirToOutResDirMap) {
      this.inResDirToOutResDirMap = inResDirToOutResDirMap;
      return this;
    }

    public Builder setResourceFilter(ResourceFilter resourceFilter) {
      this.resourceFilter = resourceFilter;
      return this;
    }

    public Builder enableStringsFilter() {
      this.filterStrings = true;
      return this;
    }

    public Builder setWhitelistedStringDirs(ImmutableSet<Path> whitelistedStringDirs) {
      this.whitelistedStringDirs = whitelistedStringDirs;
      return this;
    }

    public Builder setLocales(ImmutableSet<String> locales) {
      this.locales = locales;
      return this;
    }

    public FilterResourcesStep build() {
      Preconditions.checkNotNull(resourceFilter);
      LOG.info("FilterResourcesStep.Builder: resource filter: %s", resourceFilter);
      Preconditions.checkNotNull(inResDirToOutResDirMap);
      return new FilterResourcesStep(
          inResDirToOutResDirMap,
          resourceFilter.isEnabled(),
          filterStrings,
          whitelistedStringDirs,
          locales,
          DefaultFilteredDirectoryCopier.getInstance(),
          resourceFilter.getDensities(),
          DefaultDrawableFinder.getInstance(),
          resourceFilter.shouldDownscale() ? ImageMagickScaler.getInstance() : null);
    }
  }
}


File: src/com/facebook/buck/android/ResourcesFilter.java
/*
 * Copyright 2014-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.android;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.model.BuildTargets;
import com.facebook.buck.rules.AbstractBuildRule;
import com.facebook.buck.rules.AddToRuleKey;
import com.facebook.buck.rules.BuildContext;
import com.facebook.buck.rules.BuildOutputInitializer;
import com.facebook.buck.rules.BuildRuleParams;
import com.facebook.buck.rules.BuildableContext;
import com.facebook.buck.rules.InitializableFromDisk;
import com.facebook.buck.rules.OnDiskBuildInfo;
import com.facebook.buck.rules.SourcePath;
import com.facebook.buck.rules.SourcePathResolver;
import com.facebook.buck.rules.SourcePaths;
import com.facebook.buck.step.AbstractExecutionStep;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.Step;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Functions;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;

import java.nio.file.Path;
import java.nio.file.Paths;

import javax.annotation.Nullable;

/**
 * Buildable that is responsible for taking a set of res/ directories and applying an optional
 * resource filter to them, ultimately generating the final set of res/ directories whose contents
 * should be included in an APK.
 * <p>
 * Clients of this Buildable may need to know:
 * <ul>
 *   <li>The set of res/ directories that was used to calculate the R.java file. (These are needed
 *       as arguments to aapt to create the unsigned APK, as well as arguments to create a
 *       ProGuard config, if appropriate.)
 *   <li>The set of non-english {@code strings.xml} files identified by the resource filter.
 * </ul>
 */
public class ResourcesFilter extends AbstractBuildRule
    implements FilteredResourcesProvider, InitializableFromDisk<ResourcesFilter.BuildOutput> {

  private static final String RES_DIRECTORIES_KEY = "res_directories";
  private static final String STRING_FILES_KEY = "string_files";

  static enum ResourceCompressionMode {
    DISABLED(/* isCompressResources */ false, /* isStoreStringsAsAssets */ false),
    ENABLED(/* isCompressResources */ true, /* isStoreStringsAsAssets */ false),
    ENABLED_WITH_STRINGS_AS_ASSETS(
      /* isCompressResources */ true,
      /* isStoreStringsAsAssets */ true),
    ;

    private final boolean isCompressResources;
    private final boolean isStoreStringsAsAssets;

    private ResourceCompressionMode(boolean isCompressResources, boolean isStoreStringsAsAssets) {
      this.isCompressResources = isCompressResources;
      this.isStoreStringsAsAssets = isStoreStringsAsAssets;
    }

    public boolean isCompressResources() {
      return isCompressResources;
    }

    public boolean isStoreStringsAsAssets() {
      return isStoreStringsAsAssets;
    }
  }

  // Rule key correctness is ensured by depping on all android_resource rules in
  // Builder.setAndroidResourceDepsFinder()
  private final ImmutableList<SourcePath> resDirectories;
  private final ImmutableSet<SourcePath> whitelistedStringDirs;
  @AddToRuleKey
  private final ImmutableSet<String> locales;
  @AddToRuleKey
  private final ResourceCompressionMode resourceCompressionMode;
  @AddToRuleKey
  private final FilterResourcesStep.ResourceFilter resourceFilter;
  private final BuildOutputInitializer<BuildOutput> buildOutputInitializer;

  public ResourcesFilter(
      BuildRuleParams params,
      SourcePathResolver resolver,
      ImmutableList<SourcePath> resDirectories,
      ImmutableSet<SourcePath> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ResourceCompressionMode resourceCompressionMode,
      FilterResourcesStep.ResourceFilter resourceFilter) {
    super(params, resolver);
    this.resDirectories = resDirectories;
    this.whitelistedStringDirs = whitelistedStringDirs;
    this.locales = locales;
    this.resourceCompressionMode = resourceCompressionMode;
    this.resourceFilter = resourceFilter;
    this.buildOutputInitializer = new BuildOutputInitializer<>(params.getBuildTarget(), this);
  }

  @Override
  public ImmutableList<SourcePath> getResDirectories() {
    return buildOutputInitializer.getBuildOutput().resDirectories;
  }

  @Override
  public ImmutableList<SourcePath> getStringFiles() {
    return buildOutputInitializer.getBuildOutput().stringFiles;
  }

  @Override
  public ImmutableList<Step> getBuildSteps(
      BuildContext context,
      final BuildableContext buildableContext) {
    ImmutableList.Builder<Step> steps = ImmutableList.builder();

    final ImmutableList.Builder<Path> filteredResDirectoriesBuilder = ImmutableList.builder();
    ImmutableSet<Path> whitelistedStringPaths =
        ImmutableSet.copyOf(getResolver().getAllPaths(whitelistedStringDirs));
    ImmutableList<Path> resPaths = getResolver().getAllPaths(resDirectories);
    final FilterResourcesStep filterResourcesStep = createFilterResourcesStep(
        resPaths,
        whitelistedStringPaths,
        locales,
        filteredResDirectoriesBuilder);
    steps.add(filterResourcesStep);

    final ImmutableList.Builder<Path> stringFilesBuilder = ImmutableList.builder();
    // The list of strings.xml files is only needed to build string assets
    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      GetStringsFilesStep getStringsFilesStep = new GetStringsFilesStep(
          resPaths,
          stringFilesBuilder,
          whitelistedStringPaths);
      steps.add(getStringsFilesStep);
    }

    final ImmutableList<Path> filteredResDirectories = filteredResDirectoriesBuilder.build();
    for (Path outputResourceDir : filteredResDirectories) {
      buildableContext.recordArtifact(outputResourceDir);
    }

    steps.add(new AbstractExecutionStep("record_build_output") {
      @Override
      public int execute(ExecutionContext context) {
        buildableContext.addMetadata(
            RES_DIRECTORIES_KEY,
            Iterables.transform(filteredResDirectories, Functions.toStringFunction()));
        buildableContext.addMetadata(
            STRING_FILES_KEY,
            Iterables.transform(stringFilesBuilder.build(), Functions.toStringFunction()));
        return 0;
      }
    });

    return steps.build();
  }

  /**
   * Sets up filtering of resources, images/drawables and strings in particular, based on build
   * rule parameters {@link #resourceFilter} and {@link #resourceCompressionMode}.
   *
   * {@link com.facebook.buck.android.FilterResourcesStep.ResourceFilter} {@code resourceFilter}
   * determines which drawables end up in the APK (based on density - mdpi, hdpi etc), and also
   * whether higher density drawables get scaled down to the specified density (if not present).
   *
   * {@link #resourceCompressionMode} determines whether non-english string resources are packaged
   * separately as assets (and not bundled together into the {@code resources.arsc} file).
   *
   * @param whitelistedStringDirs overrides storing non-english strings as assets for resources
   *     inside these directories.
   */
  @VisibleForTesting
  FilterResourcesStep createFilterResourcesStep(
      ImmutableList<Path> resourceDirectories,
      ImmutableSet<Path> whitelistedStringDirs,
      ImmutableSet<String> locales,
      ImmutableList.Builder<Path> filteredResDirectories) {
    ImmutableBiMap.Builder<Path, Path> filteredResourcesDirMapBuilder = ImmutableBiMap.builder();
    String resDestinationBasePath = getResDestinationBasePath();
    int count = 0;
    for (Path resDir : resourceDirectories) {
      Path filteredResourceDir = Paths.get(resDestinationBasePath, String.valueOf(count++));
      filteredResourcesDirMapBuilder.put(resDir, filteredResourceDir);
      filteredResDirectories.add(filteredResourceDir);
    }

    ImmutableBiMap<Path, Path> resSourceToDestDirMap = filteredResourcesDirMapBuilder.build();
    FilterResourcesStep.Builder filterResourcesStepBuilder = FilterResourcesStep.builder()
        .setInResToOutResDirMap(resSourceToDestDirMap)
        .setResourceFilter(resourceFilter);

    if (resourceCompressionMode.isStoreStringsAsAssets()) {
      filterResourcesStepBuilder.enableStringsFilter();
      filterResourcesStepBuilder.setWhitelistedStringDirs(whitelistedStringDirs);
    }

    filterResourcesStepBuilder.setLocales(locales);

    return filterResourcesStepBuilder.build();
  }

  private String getResDestinationBasePath() {
    return BuildTargets.getScratchPath(getBuildTarget(), "__filtered__%s__").toString();
  }

  @Override
  public BuildOutput initializeFromDisk(OnDiskBuildInfo onDiskBuildInfo) {
    ImmutableList<SourcePath> resDirectories =
        FluentIterable.from(onDiskBuildInfo.getValues(RES_DIRECTORIES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();
    ImmutableList<SourcePath> stringFiles =
        FluentIterable.from(onDiskBuildInfo.getValues(STRING_FILES_KEY).get())
            .transform(MorePaths.TO_PATH)
            .transform(
                SourcePaths.getToBuildTargetSourcePath(getProjectFilesystem(), getBuildTarget()))
            .toList();

    return new BuildOutput(resDirectories, stringFiles);
  }

  @Override
  public BuildOutputInitializer<BuildOutput> getBuildOutputInitializer() {
    return buildOutputInitializer;
  }

  public static class BuildOutput {
    private final ImmutableList<SourcePath> resDirectories;
    private final ImmutableList<SourcePath> stringFiles;

    public BuildOutput(
        ImmutableList<SourcePath> resDirectories,
        ImmutableList<SourcePath> stringFiles) {
      this.resDirectories = resDirectories;
      this.stringFiles = stringFiles;
    }
  }

  @Nullable
  @Override
  public Path getPathToOutput() {
    return null;
  }
}


File: test/com/facebook/buck/android/FilterResourcesStepTest.java
/*
 * Copyright 2012-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.android;

import static org.easymock.EasyMock.newCapture;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import com.facebook.buck.android.FilterResourcesStep.ImageScaler;
import com.facebook.buck.io.ProjectFilesystem;
import com.facebook.buck.step.ExecutionContext;
import com.facebook.buck.step.TestExecutionContext;
import com.facebook.buck.util.FilteredDirectoryCopier;
import com.facebook.buck.util.Filters;
import com.facebook.buck.util.ProcessExecutor;
import com.facebook.buck.util.Verbosity;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import org.easymock.Capture;
import org.easymock.EasyMock;
import org.easymock.IAnswer;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class FilterResourcesStepTest {

  private static final String first = "/first-path/res";
  private static final String second = "/second-path/res";
  private static final String third = "/third-path/res";

  private static final ImmutableBiMap<Path, Path> inResDirToOutResDirMap =
      ImmutableBiMap.of(
          Paths.get(first), Paths.get("/dest/1"),
          Paths.get(second), Paths.get("/dest/2"),
          Paths.get(third), Paths.get("/dest/3"));
  private static Set<String> qualifiers = ImmutableSet.of("mdpi", "hdpi", "xhdpi");
  private final Filters.Density targetDensity = Filters.Density.MDPI;
  private final File baseDestination = new File("/dest");

  private final Path scaleSource = getDrawableFile(first, "xhdpi", "other.png");
  private final Path scaleDest = getDrawableFile(first, "mdpi", "other.png");

  private Path getDrawableFile(String dir, String qualifier, String filename) {
    return Paths.get(dir, String.format("drawable-%s", qualifier), filename);
  }

  @Test
  public void testFilterDrawables() throws IOException, InterruptedException {

    // Mock a ProjectFilesystem. This will be called into by the image downscaling step.
    ProjectFilesystem filesystem = EasyMock.createMock(ProjectFilesystem.class);
    EasyMock.expect(filesystem.getRootPath()).andStubReturn(Paths.get("."));
    EasyMock
      .expect(filesystem.getFileForRelativePath(EasyMock.<Path>anyObject()))
      .andAnswer(new IAnswer<File>(){
          @Override
          public File answer() throws Throwable {
             return ((Path) EasyMock.getCurrentArguments()[0]).toFile();
          }})
      .anyTimes();
    filesystem.createParentDirs(scaleDest);
    filesystem.deleteFileAtPath(scaleSource);
    Path scaleSourceDir = scaleSource.getParent();
    EasyMock.expect(filesystem.listFiles(scaleSourceDir)).andReturn(new File[0]);
    filesystem.deleteFileAtPath(scaleSourceDir);
    EasyMock.replay(filesystem);

    // Mock an ExecutionContext.
    ExecutionContext context = EasyMock.createMock(ExecutionContext.class);
    ProcessExecutor processExecutor = EasyMock.createMock(ProcessExecutor.class);
    EasyMock.expect(context.getProcessExecutor()).andReturn(processExecutor).anyTimes();
    EasyMock.expect(context.getVerbosity()).andReturn(Verbosity.SILENT).anyTimes();
    EasyMock.expect(context.getProjectFilesystem()).andReturn(filesystem).anyTimes();
    EasyMock.replay(context);

    // Create a mock DrawableFinder, just creates one drawable/density/resource dir.
    FilterResourcesStep.DrawableFinder finder = EasyMock.createMock(
        FilterResourcesStep.DrawableFinder.class);

    // Create mock FilteredDirectoryCopier to find what we're calling on it.
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    // We'll want to see what the filtering command passes to the copier.
    Capture<Map<Path, Path>> dirMapCapture = newCapture();
    Capture<Predicate<Path>> predCapture = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.capture(dirMapCapture),
        EasyMock.capture(predCapture));
    EasyMock.replay(copier);

    ImageScaler scaler = EasyMock.createMock(ImageScaler.class);
    scaler.scale(
        0.5,
        scaleSource,
        scaleDest,
        context);

    EasyMock.expect(scaler.isAvailable(context)).andReturn(true);
    EasyMock.replay(scaler);

    FilterResourcesStep command = new FilterResourcesStep(
        inResDirToOutResDirMap,
        /* filterDrawables */ true,
        /* filterStrings */ true,
        /* whitelistedStringDirs */ ImmutableSet.<Path>of(),
        /* locales */ ImmutableSet.<String>of(),
        copier,
        ImmutableSet.of(targetDensity),
        finder,
        scaler);

    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            for (String qualifier : qualifiers) {
              builder.add(getDrawableFile(dir.toString(), qualifier, "some.png"));
            }
          }

          builder.add(scaleSource);

          return builder.build();
        }
      })
      .times(2); // We're calling it in the test as well.

    // Called by the downscaling step.
    EasyMock
      .expect(finder.findDrawables(inResDirToOutResDirMap.values(), filesystem))
      .andAnswer(new IAnswer<Set<Path>>() {
        @SuppressWarnings("unchecked")
        @Override
        public Set<Path> answer() throws Throwable {
          ImmutableSet.Builder<Path> builder = ImmutableSet.builder();
          for (Path dir : (Iterable<Path>) EasyMock.getCurrentArguments()[0]) {
            builder.add(getDrawableFile(dir.toString(), targetDensity.toString(), "some.png"));
          }

          builder.add(scaleSource);
          return builder.build();
        }
      })
      .once();
    EasyMock.replay(finder);

    // We'll use this to verify the source->destination mappings created by the command.
    ImmutableMap.Builder<Path, Path> dirMapBuilder = ImmutableMap.builder();

    Iterator<Path> destIterator = inResDirToOutResDirMap.values().iterator();
    for (Path dir : inResDirToOutResDirMap.keySet()) {
      Path nextDestination = destIterator.next();
      dirMapBuilder.put(dir, nextDestination);

      // Verify that destination path requirements are observed.
      assertEquals(baseDestination, nextDestination.getParent().toFile());
    }

    // Execute command.
    command.execute(context);

    // Ensure resources are copied to the right places.
    assertEquals(dirMapBuilder.build(), dirMapCapture.getValue());

    // Ensure the right filter is created.
    Set<Path> drawables = finder.findDrawables(inResDirToOutResDirMap.keySet(), filesystem);
    Predicate<Path> expectedPred =
        Filters.createImageDensityFilter(drawables, ImmutableSet.of(targetDensity), false);
    Predicate<Path> capturedPred = predCapture.getValue();
    for (Path drawablePath : drawables) {
      assertEquals(expectedPred.apply(drawablePath), capturedPred.apply(drawablePath));
    }

    // We shouldn't need the execution context, should call copyDirs once on the copier,
    // and we're calling finder.findDrawables twice.
    EasyMock.verify(copier, context, finder, filesystem, scaler);
  }

  @Test
  public void testFilterStrings() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
        /* inResDirToOutResDirMap */ ImmutableBiMap.<Path, Path>of(),
        /* filterDrawables */ false,
        /* filterStrings */ true,
        /* whitelistedStringDirs */ ImmutableSet.of(Paths.get("com/whitelisted/res")),
        /* locales */ ImmutableSet.<String>of(),
        copier,
        /* targetDensities */ null,
        /* drawableFinder */ null,
        /* imageScaler */ null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-af/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-af/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testFilterStringsIncludingEnglishStrings() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
        /* inResDirToOutResDirMap */ ImmutableBiMap.<Path, Path>of(),
        /* filterDrawables */ false,
        /* filterStrings */ true,
        /* whitelistedStringDirs */ ImmutableSet.of(Paths.get("com/whitelisted/res")),
        /* locales */ ImmutableSet.<String>of(),
        copier,
        /* targetDensities */ null,
        /* drawableFinder */ null,
        /* imageScaler */ null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-af/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-af/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testFilterLocales() throws IOException {
    FilteredDirectoryCopier copier = EasyMock.createMock(FilteredDirectoryCopier.class);
    Capture<Predicate<Path>> capturedPredicate = newCapture();
    copier.copyDirs(EasyMock.<ProjectFilesystem>anyObject(),
        EasyMock.<Map<Path, Path>>anyObject(),
        EasyMock.capture(capturedPredicate));
    EasyMock.replay(copier);

    FilterResourcesStep step = new FilterResourcesStep(
        /* inResDirToOutResDirMap */ ImmutableBiMap.<Path, Path>of(),
        /* filterDrawables */ false,
        /* filterStrings */ false,
        /* whitelistedStringDirs */ ImmutableSet.<Path>of(Paths.get("com/whitelisted/res")),
        ImmutableSet.of("es", "es_US"),
        copier,
        /* targetDensities */ null,
        /* drawableFinder */ null,
        /* imageScaler */ null);

    assertEquals(0, step.execute(TestExecutionContext.newInstance()));
    Predicate<Path> filePredicate = capturedPredicate.getValue();

    assertTrue(filePredicate.apply(Paths.get("com/example/res/drawables/image.png")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/example/res/values-es-rUS/strings.xml")));
    assertTrue(filePredicate.apply(Paths.get("com/whitelisted/res/values-es-rES/strings.xml")));

    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-en/strings.xml")));
    assertFalse(filePredicate.apply(Paths.get("com/example/res/values-es-rES/strings.xml")));

    EasyMock.verify(copier);
  }

  @Test
  public void testNonEnglishStringsPathRegex() {
    assertTrue(matchesRegex("res/values-es/strings.xml"));
    assertFalse(matchesRegex("res/values/strings.xml"));
    assertFalse(matchesRegex("res/values-/strings.xml"));
    assertTrue(matchesRegex("/res/values-es/strings.xml"));
    assertFalse(matchesRegex("rootres/values-es/strings.xml"));
    assertTrue(matchesRegex("root/res/values-es-rUS/strings.xml"));
  }

  private static boolean matchesRegex(String input) {
    return FilterResourcesStep.NON_ENGLISH_STRINGS_FILE_PATH.matcher(input).matches();
  }
}
