Refactoring Types: ['Extract Method']
e/hive/hplsql/Conn.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hive.hplsql;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;
import java.sql.DriverManager;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;

public class Conn {
 
  public enum Type {DB2, HIVE, MYSQL, TERADATA};
  
  HashMap<String, Stack<Connection>> connections = new HashMap<String, Stack<Connection>>();
  HashMap<String, String> connStrings = new HashMap<String, String>();
  HashMap<String, Type> connTypes = new HashMap<String, Type>();
  
  HashMap<String, ArrayList<String>> connInits = new HashMap<String, ArrayList<String>>();
  HashMap<String, ArrayList<String>> preSql = new HashMap<String, ArrayList<String>>();
  
  Exec exec;
  Timer timer = new Timer();
  boolean trace = false;  
  boolean info = false;
  
  Conn(Exec e) {
    exec = e;  
    trace = exec.getTrace();
    info = exec.getInfo();
  }
  
  /**
   * Execute a SQL query
   */
  public Query executeQuery(Query query, String connName) {
    try {
      Connection conn = getConnection(connName);
      runPreSql(connName, conn);
      Statement stmt = conn.createStatement();
      timer.start();
      ResultSet rs = stmt.executeQuery(query.sql);
      timer.stop();
      query.set(conn, stmt, rs);      
      if (info) {
        exec.info(null, "Query executed successfully (" + timer.format() + ")");
      }      
    } catch (Exception e) {
      query.setError(e);
    }
    return query;
  }
  
  public Query executeQuery(String sql, String connName) {
    return executeQuery(new Query(sql), connName);
  }
  
  /**
   * Execute a SQL statement
   */
  public Query executeSql(String sql, String connName) {
    Query query = new Query(sql);
    try {
      Connection conn = getConnection(connName);
      runPreSql(connName, conn);
      Statement stmt = conn.createStatement();
      ResultSet rs = null;
      if (stmt.execute(sql)) {
        rs = stmt.getResultSet();        
      } 
      query.set(conn, stmt, rs);
    } catch (Exception e) {
      query.setError(e);
    }
    return query;
  }
  
  /**
   * Close the query object
   */
  public void closeQuery(Query query, String connName) {
    query.closeStatement(); 
    returnConnection(connName, query.getConnection());
  }
  
  /**
   * Run pre-SQL statements 
   * @throws SQLException 
   */
  void runPreSql(String connName, Connection conn) throws SQLException {
    ArrayList<String> sqls = preSql.get(connName);  
    if (sqls != null) {
      Statement s = conn.createStatement();
      for (String sql : sqls) {
        s.execute(sql);
      }
      s.close();
      preSql.remove(connName);
    }
  }
  
  /** 
   * Get a connection
   * @throws Exception 
   */
  synchronized Connection getConnection(String connName) throws Exception {
    Stack<Connection> connStack = connections.get(connName);
    String connStr = connStrings.get(connName);
    if (connStr == null) {
      throw new Exception("Unknown connection profile: " + connName);
    }
    if (connStack != null && !connStack.empty()) {        // Reuse an existing connection
      return connStack.pop();
    }
    Connection c = openConnection(connStr);
    ArrayList<String> sqls = connInits.get(connName);     // Run initialization statements on the connection
    if (sqls != null) {
      Statement s = c.createStatement();
      for (String sql : sqls) {
        s.execute(sql);
      }
      s.close();
    }
    return c;
  }
  
  /**
   * Open a new connection
   * @throws Exception 
   */
  Connection openConnection(String connStr) throws Exception {
    String driver = "org.apache.hadoop.hive.jdbc.HiveDriver";
    String url = "jdbc:hive://";
    String usr = "";
    String pwd = "";
    if (connStr != null) {
      String[] c = connStr.split(";");
      if (c.length >= 1) {
        driver = c[0];
      } 
      if (c.length >= 2) {
        url = c[1];
      }
      if (c.length >= 3) {
        usr = c[2];
      }
      if (c.length >= 4) {
        pwd = c[3];
      }
    }
    Class.forName(driver);
    timer.start();
    Connection conn = DriverManager.getConnection(url, usr, pwd);
    timer.stop();
    if (info) {
      exec.info(null, "Open connection: " + url + " (" + timer.format() + ")");
    }
    return conn;
  }
  
  /**
   * Get the database type by profile name
   */
  Conn.Type getTypeByProfile(String name) {
    return connTypes.get(name);
  }
  
  /**
   * Get the database type by connection string
   */
  Conn.Type getType(String connStr) {
    if (connStr.contains("hive.")) {
      return Type.HIVE;
    }
    else if (connStr.contains("db2.")) {
      return Type.DB2;
    }
    else if (connStr.contains("mysql.")) {
      return Type.MYSQL;
    }
    else if (connStr.contains("teradata.")) {
      return Type.TERADATA;
    }
    return Type.HIVE;
  }
  
  /**
   * Return the connection to the pool
   */
  void returnConnection(String name, Connection conn) {
    if (conn != null) {
      connections.get(name).push(conn);
    }
  }
  
  /**
   * Add a new connection string
   */
  public void addConnection(String name, String connStr) {
    connections.put(name, new Stack<Connection>());
    connStrings.put(name, connStr);
    connTypes.put(name, getType(connStr));
  }
  
  /**
   * Add initialization statements for the specified connection
   */
  public void addConnectionInit(String name, String connInit) {
    ArrayList<String> a = new ArrayList<String>(); 
    String[] sa = connInit.split(";");
    for (String s : sa) {
      s = s.trim();
      if (!s.isEmpty()) {
        a.add(s);
      }
    }    
    connInits.put(name, a);
  }
  
  /**
   * Add SQL statements to be executed before executing the next SQL statement (pre-SQL)
   */
  public void addPreSql(String name, ArrayList<String> sql) {
    preSql.put(name, sql); 
  }
}


File: hplsql/src/main/java/org/apache/hive/hplsql/Exec.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
package org.apache.hive.hplsql;

import java.math.BigDecimal;
import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Stack;
import java.util.Iterator;
import java.sql.Connection;
import java.sql.SQLException;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.commons.io.FileUtils;
import org.apache.hive.hplsql.Var.Type;
import org.apache.hive.hplsql.functions.*;

/**
 * HPL/SQL script executor
 *
 */
public class Exec extends HplsqlBaseVisitor<Integer> {
  
  public static final String VERSION = "HPL/SQL 0.3.11";
  public static final String SQLCODE = "SQLCODE";
  public static final String SQLSTATE = "SQLSTATE";
  public static final String HOSTCODE = "HOSTCODE";
  
  Exec exec = null;
  ParseTree tree = null;
  
  public enum OnError {EXCEPTION, SETERROR, STOP}; 

  // Scopes of execution (code blocks) with own local variables, parameters and exception handlers
  Stack<Scope> scopes = new Stack<Scope>();
  Scope currentScope;
  
  Stack<Var> stack = new Stack<Var>();
  Stack<String> labels = new Stack<String>();
  Stack<String> callStack = new Stack<String>();
  
  Stack<Signal> signals = new Stack<Signal>();
  Signal currentSignal;
  Scope currentHandlerScope;
  boolean resignal = false;
  
  HashMap<String, String> managedTables = new HashMap<String, String>();
  HashMap<String, String> objectMap = new HashMap<String, String>(); 
  HashMap<String, String> objectConnMap = new HashMap<String, String>();
  HashMap<String, ArrayList<Var>> returnCursors = new HashMap<String, ArrayList<Var>>();
  
  public ArrayList<String> stmtConnList = new ArrayList<String>();
      
  Arguments arguments = new Arguments();
  public Conf conf;
  Expression expr;
  Function function;  
  Converter converter;
  Select select;
  Stmt stmt;
  Conn conn;  
  
  int rowCount = 0;  
  
  String execString;
  String execFile;  
  String execMain;
  StringBuilder localUdf = new StringBuilder();
  boolean initRoutines = false;
  public boolean buildSql = false;
  boolean udfRegistered = false;
  boolean udfRun = false;
    
  boolean dotHplsqlrcExists = false;
  boolean hplsqlrcExists = false;
  
  boolean trace = false; 
  boolean info = true;
  boolean offline = false;
  
  Exec() {
    exec = this;
  }
  
  Exec(Exec exec) {
    this.exec = exec;
  }

  /** 
   * Set a variable using a value from the parameter or the stack 
   */
  public Var setVariable(String name, Var value) {
    if (value == null || value == Var.Empty) {
      if (exec.stack.empty()) {
        return Var.Empty;
      }
      value = exec.stack.pop();
    }
    if (name.startsWith("hplsql.")) {
      exec.conf.setOption(name, value.toString());
      return Var.Empty;
    }
    Var var = findVariable(name);
    if (var != null) {
      var.cast(value);
    }
    else {
      var = new Var(value);
      var.setName(name);
      exec.currentScope.addVariable(var);
    }    
    return var;
  }
  
  public Var setVariable(String name) {
    return setVariable(name, Var.Empty);
  }
  
  public Var setVariable(String name, String value) {
    return setVariable(name, new Var(value));
  }

  public Var setVariable(String name, int value) {
    return setVariable(name, new Var(new Long(value)));
  }

  /** 
   * Set variable to NULL 
   */
  public Var setVariableToNull(String name) {
    Var var = findVariable(name);
    if (var != null) {
      var.removeValue();
    }
    else {
      var = new Var();
      var.setName(name);
      exec.currentScope.addVariable(var);
    }    
    return var;
  }
  
  /**
   * Add a local variable to the current scope
   */
  public void addVariable(Var var) {
    if (exec.currentScope != null) {
      exec.currentScope.addVariable(var);
    }
  }
  
  /**
   * Add a condition handler to the current scope
   */
  public void addHandler(Handler handler) {
    if (exec.currentScope != null) {
      exec.currentScope.addHandler(handler);
    }
  }
  
  /**
   * Add a return cursor visible to procedure callers and clients
   */
  public void addReturnCursor(Var var) {
    String routine = callStackPeek();
    ArrayList<Var> cursors = returnCursors.get(routine);
    if (cursors == null) {
      cursors = new ArrayList<Var>();
      returnCursors.put(routine, cursors);
    }
    cursors.add(var);
  }
  
  /**
   * Get the return cursor defined in the specified procedure
   */
  public Var consumeReturnCursor(String routine) {
    ArrayList<Var> cursors = returnCursors.get(routine.toUpperCase());
    if (cursors == null) {
      return null;
    }
    Var var = cursors.get(0);
    cursors.remove(0);
    return var;
  }
  
  /**
   * Push a value to the stack
   */
  public void stackPush(Var var) {
    exec.stack.push(var);  
  }
  
  /**
   * Push a string value to the stack
   */
  public void stackPush(String val) {
    exec.stack.push(new Var(val));  
  }
  
  public void stackPush(StringBuilder val) {
    stackPush(val.toString());  
  }
  
  /**
   * Push a boolean value to the stack
   */
  public void stackPush(boolean val) {
    exec.stack.push(new Var(val));  
  }

  /**
   * Select a value from the stack, but not remove
   */
  public Var stackPeek() {
    return exec.stack.peek();  
  }
  
  /**
   * Pop a value from the stack
   */
  public Var stackPop() {
    if (!exec.stack.isEmpty()) {
      return exec.stack.pop();
    }
    return null;
  }    
  
  /**
   * Push a value to the call stack
   */
  public void callStackPush(String val) {
    exec.callStack.push(val.toUpperCase());  
  }
  
  /**
   * Select a value from the call stack, but not remove
   */
  public String callStackPeek() {
    if (!exec.callStack.isEmpty()) {
      return exec.callStack.peek();
    }
    return null;
  }
  
  /**
   * Pop a value from the call stack
   */
  public String callStackPop() {
    if (!exec.callStack.isEmpty()) {
      return exec.callStack.pop();
    }
    return null;
  }  
  
  /** 
   * Find an existing variable by name 
   */
  public Var findVariable(String name) {
    Scope cur = exec.currentScope;    
    String name2 = null;
    if (name.startsWith(":")) {
      name2 = name.substring(1);
    }
    while (cur != null) {
      for (Var v : cur.vars) {
        if (name.equalsIgnoreCase(v.getName()) ||
            (name2 != null && name2.equalsIgnoreCase(v.getName()))) {
          return v;
        }  
      }      
      cur = cur.parent;
    }    
    return null;
  }
  
  public Var findVariable(Var name) {
    return findVariable(name.getName());
  }
  
  /**
   * Find a cursor variable by name
   */
  public Var findCursor(String name) {
    Var cursor = exec.findVariable(name);
    if (cursor != null && cursor.type == Type.CURSOR) {
      return cursor;
    }    
    return null;
  }
  
  /**
   * Enter a new scope
   */
  public void enterScope(Scope.Type type) {
    exec.currentScope = new Scope(exec.currentScope, type);
    exec.scopes.push(exec.currentScope);
  }

  /**
   * Leave the current scope
   */
  public void leaveScope() {
    if (!exec.signals.empty()) {
      Scope scope = exec.scopes.peek();
      Signal signal = exec.signals.peek();
      if (exec.conf.onError != OnError.SETERROR) {
        runExitHandler();
      }
      if (signal.type == Signal.Type.LEAVE_ROUTINE && scope.type == Scope.Type.ROUTINE) {
        exec.signals.pop();
      }
    }
    exec.currentScope = exec.scopes.pop().getParent();
  }
  
  /**
   * Send a signal
   */
  public void signal(Signal signal) {
    exec.signals.push(signal);
  }
  
  public void signal(Signal.Type type, String value, Exception exception) {
    signal(new Signal(type, value, exception));
  }
  
  public void signal(Signal.Type type, String value) {
    setSqlCode(-1);
    signal(type, value, null);   
  }
  
  public void signal(Signal.Type type) {
    setSqlCode(-1);
    signal(type, null, null);   
  }
  
  public void signal(Query query) {
    setSqlCode(query.getException());
    signal(Signal.Type.SQLEXCEPTION, query.errorText(), query.getException());
  }
  
  public void signal(Exception exception) {
    setSqlCode(exception);
    signal(Signal.Type.SQLEXCEPTION, exception.getMessage(), exception);
  }
  
  /**
   * Resignal the condition
   */
  public void resignal() {
    resignal(exec.currentSignal);
  }
  
  public void resignal(Signal signal) {
    if (signal != null) {
      exec.resignal = true;
      signal(signal);
    }
  }

  /**
   * Run CONTINUE handlers 
   */
  boolean runContinueHandler() {
    Scope cur = exec.currentScope;    
    exec.currentSignal = exec.signals.pop(); 
    while (cur != null) {
      for (Handler h : cur.handlers) {
        if (h.execType != Handler.ExecType.CONTINUE) {
          continue;
        }
        if ((h.type != Signal.Type.USERDEFINED && h.type == exec.currentSignal.type) ||
            (h.type == Signal.Type.USERDEFINED && h.type == exec.currentSignal.type &&
             h.value.equalsIgnoreCase(exec.currentSignal.value))) {
          trace(h.ctx, "CONTINUE HANDLER");
          enterScope(Scope.Type.HANDLER);
          exec.currentHandlerScope = h.scope; 
          visit(h.ctx.single_block_stmt());
          leaveScope(); 
          exec.currentSignal = null;
          return true;
        }
      }      
      cur = cur.parent;
    } 
    exec.signals.push(exec.currentSignal);
    exec.currentSignal = null;
    return false;
  }
  
  /**
   * Run EXIT handler defined for the current scope 
   */
  boolean runExitHandler() {
    exec.currentSignal = exec.signals.pop();
    for (Handler h : currentScope.handlers) {
      if (h.execType != Handler.ExecType.EXIT) {
        continue;
      }
      if ((h.type != Signal.Type.USERDEFINED && h.type == exec.currentSignal.type) ||
          (h.type == Signal.Type.USERDEFINED && h.type == exec.currentSignal.type &&
           h.value.equalsIgnoreCase(currentSignal.value))) {
        trace(h.ctx, "EXIT HANDLER");
        enterScope(Scope.Type.HANDLER);
        exec.currentHandlerScope = h.scope; 
        visit(h.ctx.single_block_stmt());
        leaveScope(); 
        exec.currentSignal = null;
        return true;
      }        
    }    
    exec.signals.push(exec.currentSignal);
    exec.currentSignal = null;
    return false;
  }
    
  /**
   * Pop the last signal
   */
  public Signal signalPop() {
    if (!exec.signals.empty()) {
      return exec.signals.pop();
    }
    return null;
  }
  
  /**
   * Peek the last signal
   */
  public Signal signalPeek() {
    if (!exec.signals.empty()) {
      return exec.signals.peek();
    }
    return null;
  }
  
  /**
   * Pop the current label
   */
  public String labelPop() {
    if(!exec.labels.empty()) {
      return exec.labels.pop();
    }
    return "";
  }
  
  /**
   * Execute a SQL query (SELECT)
   */
  public Query executeQuery(ParserRuleContext ctx, Query query, String connProfile) {
    if (!exec.offline) {
      exec.rowCount = 0;
      exec.conn.executeQuery(query, connProfile);
      return query;
    }
    setSqlNoData();
    trace(ctx, "Not executed - offline mode set");
    return query;
  }

  public Query executeQuery(ParserRuleContext ctx, String sql, String connProfile) {
    return executeQuery(ctx, new Query(sql), connProfile);
  }

  /**
   * Execute a SQL statement 
   */
  public Query executeSql(ParserRuleContext ctx, String sql, String connProfile) {
    if (!exec.offline) {
      exec.rowCount = 0;
      Query query = conn.executeSql(sql, connProfile);
      exec.rowCount = query.getRowCount();
      return query;
    }
    trace(ctx, "Not executed - offline mode set");
    return new Query("");
  }  
  
  /**
   * Close the query object
   */
  public void closeQuery(Query query, String conn) {
    if(!exec.offline) {
      exec.conn.closeQuery(query, conn);
    }
  }
  
  /**
   * Register JARs, FILEs and CREATE TEMPORARY FUNCTION for UDF call
   */
  public void registerUdf() {
    if (udfRegistered) {
      return;
    }
    ArrayList<String> sql = new ArrayList<String>();
    String dir = Utils.getExecDir();
    sql.add("ADD JAR " + dir + "hplsql.jar");
    sql.add("ADD JAR " + dir + "antlr-runtime-4.5.jar");
    sql.add("ADD FILE " + dir + Conf.SITE_XML);
    if (dotHplsqlrcExists) {
      sql.add("ADD FILE " + dir + Conf.DOT_HPLSQLRC);
    }
    if (hplsqlrcExists) {
      sql.add("ADD FILE " + dir + Conf.HPLSQLRC);
    }
    String lu = createLocalUdf();
    if (lu != null) {
      sql.add("ADD FILE " + lu);
    }
    sql.add("CREATE TEMPORARY FUNCTION hplsql AS 'org.apache.hive.hplsql.Udf'");
    exec.conn.addPreSql(exec.conf.defaultConnection, sql);
    udfRegistered = true;
  }

  /**
   * Initialize options
   */
  void initOptions() {
    Iterator<Map.Entry<String,String>> i = exec.conf.iterator();
    while (i.hasNext()) {
      Entry<String,String> item = (Entry<String,String>)i.next();
      String key = (String)item.getKey();
      String value = (String)item.getValue();
      if (key == null || value == null || !key.startsWith("hplsql.")) {
        continue;
      }
      else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) {
        exec.conf.defaultConnection = value;
      }
      else if (key.startsWith("hplsql.conn.init.")) {
        exec.conn.addConnectionInit(key.substring(17), value);        
      }
      else if (key.startsWith(Conf.CONN_CONVERT)) {
        exec.conf.setConnectionConvert(key.substring(20), value);        
      }
      else if (key.startsWith("hplsql.conn.")) {
        exec.conn.addConnection(key.substring(12), value);
      }
      else if (key.startsWith("hplsql.")) {
        exec.conf.setOption(key, value);
      }
    }    
  }
  
  /**
   * Set SQLCODE
   */
  public void setSqlCode(int sqlcode) {
    Var var = findVariable(SQLCODE);
    if (var != null) {
      var.setValue(new Long(sqlcode));
    }
  }
  
  public void setSqlCode(Exception exception) {
    if (exception instanceof SQLException) {
      setSqlCode(((SQLException)exception).getErrorCode());
      setSqlState(((SQLException)exception).getSQLState());
    }
    else {
      setSqlCode(-1);
      setSqlState("02000");
    }    
  }
  
  /**
   * Set SQLSTATE
   */
  public void setSqlState(String sqlstate) {
    Var var = findVariable(SQLSTATE);
    if (var != null) {
      var.setValue(sqlstate);
    }
  }
    
  /**
   * Set HOSTCODE
   */
  public void setHostCode(int code) {
    Var var = findVariable(HOSTCODE);
    if (var != null) {
      var.setValue(new Long(code));
    }
  }
  
  /**
   * Set successful execution for SQL
   */
  public void setSqlSuccess() {
    setSqlCode(0);
    setSqlState("00000");
  }
  
  /**
   * Set SQL_NO_DATA as the result of SQL execution
   */
  public void setSqlNoData() {
    setSqlCode(100);
    setSqlState("01000");
  }
  
  /**
   * Compile and run PL/HQL script 
   */
  public Integer run(String[] args) throws Exception {
    if (init(args) != 0) {
      return 1;
    }
    Var result = run();
    if (result != null) {
      System.out.println(result.toString());
    }
    cleanup();
    printExceptions();
    return getProgramReturnCode();
  }
  
  /**
   * Run already compiled PL/HQL script (also used from Hive UDF)
   */
  public Var run() {
    if (tree == null) {
      return null;
    }
    if (execMain != null) {
      initRoutines = true;
      visit(tree);
      initRoutines = false;
      exec.function.execProc(execMain);
    }
    else {
      visit(tree);
    }
    return stackPop();
  }
  
  /**
   * Initialize PL/HQL
   */
  Integer init(String[] args) throws Exception {
    if (!parseArguments(args)) {
      return 1;
    }
    conf = new Conf();
    conf.init();    
    conn = new Conn(this);   
    initOptions();
    
    expr = new Expression(this);
    select = new Select(this);
    stmt = new Stmt(this);
    converter = new Converter(this);
    
    function = new Function(this);
    new FunctionDatetime(this).register(function);
    new FunctionMisc(this).register(function);
    new FunctionString(this).register(function);
    new FunctionOra(this).register(function);
    
    enterScope(Scope.Type.FILE);
    addVariable(new Var(SQLCODE, Var.Type.BIGINT, 0L));
    addVariable(new Var(SQLSTATE, Var.Type.STRING, "00000"));
    addVariable(new Var(HOSTCODE, Var.Type.BIGINT, 0L)); 
    
    for (Map.Entry<String, String> v : arguments.getVars().entrySet()) {
      addVariable(new Var(v.getKey(), Var.Type.STRING, v.getValue()));
    }    
    InputStream input = null;
    if (execString != null) {
      input = new ByteArrayInputStream(execString.getBytes("UTF-8"));
    }
    else {
      input = new FileInputStream(execFile);
    }
    HplsqlLexer lexer = new HplsqlLexer(new ANTLRInputStream(input));
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    HplsqlParser parser = new HplsqlParser(tokens);
    tree = parser.program();    
    if (trace) {
      System.err.println("Configuration file: " + conf.getLocation());
      System.err.println("Parser tree: " + tree.toStringTree(parser));
    }
    includeRcFile();    
    return 0;
  }
  
  /**
   * Parse command line arguments
   */
  boolean parseArguments(String[] args) {
    boolean parsed = arguments.parse(args);
    if (parsed && arguments.hasVersionOption()) {
      System.err.println(VERSION);
      return false;
    }
    if (!parsed || arguments.hasHelpOption() ||
      (arguments.getExecString() == null && arguments.getFileName() == null)) {
      arguments.printHelp();
      return false;
    }    
    execString = arguments.getExecString();
    execFile = arguments.getFileName();
    execMain = arguments.getMain();
    if (arguments.hasTraceOption()) {
      trace = true;
    }
    if (arguments.hasOfflineOption()) {
      offline = true;
    }
    if (execString != null && execFile != null) {
      System.err.println("The '-e' and '-f' options cannot be specified simultaneously.");
      return false;
    }   
    return true;
  }
  
  /**
   * Include statements from .hplsqlrc and hplsql rc files
   */
  void includeRcFile() {
    if (includeFile(Conf.DOT_HPLSQLRC)) {
      dotHplsqlrcExists = true;
    }
    else {
      if (includeFile(Conf.HPLSQLRC)) {
        hplsqlrcExists = true;
      }
    }
    if (udfRun) {
      includeFile(Conf.HPLSQL_LOCALS_SQL);
    }
  }
  
  /**
   * Include statements from a file
   */
  boolean includeFile(String file) {
    try {
      String content = FileUtils.readFileToString(new java.io.File(file), "UTF-8");
      if (content != null && !content.isEmpty()) {
        if (trace) {
          trace(null, "INLCUDE CONTENT " + file + " (non-empty)");
        }
        new Exec(this).include(content);
        return true;
      }
    } 
    catch (Exception e) {} 
    return false;
  }
  
  /**
   * Execute statements from an include file
   */
  void include(String content) throws Exception {
    InputStream input = new ByteArrayInputStream(content.getBytes("UTF-8"));
    HplsqlLexer lexer = new HplsqlLexer(new ANTLRInputStream(input));
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    HplsqlParser parser = new HplsqlParser(tokens);
    ParseTree tree = parser.program(); 
    visit(tree);    
  }
  
  /**
   * Start executing PL/HQL script
   */
  @Override 
  public Integer visitProgram(HplsqlParser.ProgramContext ctx) {
    enterScope(Scope.Type.FILE);
    Integer rc = visitChildren(ctx);
    leaveScope();
    return rc;
  }
  
  /**
   * Enter BEGIN-END block
   */
  @Override  
  public Integer visitBegin_end_block(HplsqlParser.Begin_end_blockContext ctx) { 
    enterScope(Scope.Type.BEGIN_END);
    Integer rc = visitChildren(ctx); 
    leaveScope();
    return rc;
  }
  
  /**
   * Free resources before exit
   */
  void cleanup() {
    for (Map.Entry<String, String> i : managedTables.entrySet()) {
      String sql = "DROP TABLE IF EXISTS " + i.getValue();
      Query query = executeSql(null, sql, exec.conf.defaultConnection);      
      closeQuery(query, exec.conf.defaultConnection);
      if (trace) {
        trace(null, sql);        
      }      
    }
  }
  
  /**
   * Output information about unhandled exceptions
   */
  void printExceptions() {
    while (!signals.empty()) {
      Signal sig = signals.pop();
      if (sig.type == Signal.Type.SQLEXCEPTION) {
        System.err.println("Unhandled exception in PL/HQL");
      }
      if (sig.exception != null) {
        sig.exception.printStackTrace(); 
      }
      else if (sig.value != null) {
        System.err.println(sig.value);
      }
    }
  } 
  
  /**
   * Get the program return code
   */
  Integer getProgramReturnCode() {
    Integer rc = 0;
    if(!signals.empty()) {
      Signal sig = signals.pop();
      if(sig.type == Signal.Type.LEAVE_ROUTINE && sig.value != null) {
        try {
          rc = Integer.parseInt(sig.value);
        }
        catch(NumberFormatException e) {
          rc = 1;
        }
      }
    }
    return rc;
  }

  /**
   * Executing a statement
   */
  @Override 
  public Integer visitStmt(HplsqlParser.StmtContext ctx) {
    if (ctx.semicolon_stmt() != null) {
      return 0;
    }
    if (initRoutines && ctx.create_procedure_stmt() == null && ctx.create_function_stmt() == null) {
      return 0;
    }
    if (exec.resignal) {
      if (exec.currentScope != exec.currentHandlerScope.parent) {
        return 0;
      }
      exec.resignal = false;
    }
    if (!exec.signals.empty() && exec.conf.onError != OnError.SETERROR) {
      if (!runContinueHandler()) {
        return 0;
      }
    }
    Var prevResult = stackPop();
    if (prevResult != null) {
      System.out.println(prevResult.toString());
    }
    return visitChildren(ctx); 
  }
  
  /**
   * Executing or building SELECT statement
   */
  @Override 
  public Integer visitSelect_stmt(HplsqlParser.Select_stmtContext ctx) { 
    return exec.select.select(ctx);
  }
  
  @Override 
  public Integer visitCte_select_stmt(HplsqlParser.Cte_select_stmtContext ctx) { 
    return exec.select.cte(ctx); 
  }

  @Override 
  public Integer visitFullselect_stmt(HplsqlParser.Fullselect_stmtContext ctx) { 
    return exec.select.fullselect(ctx);
  }
  
  @Override 
  public Integer visitSubselect_stmt(HplsqlParser.Subselect_stmtContext ctx) { 
    return exec.select.subselect(ctx);
  }  
  
  @Override 
  public Integer visitSelect_list(HplsqlParser.Select_listContext ctx) { 
    return exec.select.selectList(ctx); 
  }
  
  @Override 
  public Integer visitFrom_clause(HplsqlParser.From_clauseContext ctx) { 
    return exec.select.from(ctx); 
  }
  
  @Override 
  public Integer visitFrom_table_name_clause(HplsqlParser.From_table_name_clauseContext ctx) { 
    return exec.select.fromTable(ctx); 
  }
  
  @Override 
  public Integer visitFrom_join_clause(HplsqlParser.From_join_clauseContext ctx) { 
    return exec.select.fromJoin(ctx); 
  }
  
  @Override 
  public Integer visitFrom_table_values_clause(HplsqlParser.From_table_values_clauseContext ctx) { 
    return exec.select.fromTableValues(ctx); 
  }
  
  @Override 
  public Integer visitWhere_clause(HplsqlParser.Where_clauseContext ctx) { 
    return exec.select.where(ctx); 
  }  
  
  @Override 
  public Integer visitSelect_options_item(HplsqlParser.Select_options_itemContext ctx) { 
    return exec.select.option(ctx); 
  }
    
  /**
   * Table name
   */
  @Override 
  public Integer visitTable_name(HplsqlParser.Table_nameContext ctx) {
    String name = ctx.getText().toUpperCase(); 
    String actualName = exec.managedTables.get(name);
    String conn = exec.objectConnMap.get(name);
    if (conn == null) {
      conn = conf.defaultConnection;
    }
    stmtConnList.add(conn);    
    if (actualName != null) {
      stackPush(actualName);
      return 0;
    }
    actualName = exec.objectMap.get(name);
    if (actualName != null) {
      stackPush(actualName);
      return 0;
    }
    stackPush(ctx.getText());
    return 0; 
  }

  /**
   * SQL INSERT statement
   */
  @Override 
  public Integer visitInsert_stmt(HplsqlParser.Insert_stmtContext ctx) { 
    return exec.stmt.insert(ctx); 
  }
    
  /**
   * EXCEPTION block
   */
  @Override 
  public Integer visitException_block_item(HplsqlParser.Exception_block_itemContext ctx) { 
    if (exec.signals.empty()) {
      return 0;
    }
    if (exec.conf.onError == OnError.SETERROR || exec.conf.onError == OnError.STOP) {
      exec.signals.pop();
      return 0;
    }
    if (ctx.L_ID().toString().equalsIgnoreCase("OTHERS")) {
      trace(ctx, "EXCEPTION HANDLER");
      exec.signals.pop();
      enterScope(Scope.Type.HANDLER);
      visit(ctx.block());
      leaveScope(); 
    }
    return 0;
  }
    
  /**
   * DECLARE variable statement
   */
  @Override
  public Integer visitDeclare_var_item(HplsqlParser.Declare_var_itemContext ctx) { 
    String type = getFormattedText(ctx.dtype());
    String len = null;
    String scale = null;
    Var default_ = null;
    if (ctx.dtype_len() != null) {
      len = ctx.dtype_len().L_INT(0).getText();
      if (ctx.dtype_len().L_INT(1) != null) {
        scale = ctx.dtype_len().L_INT(1).getText();
      }
    }    
    if (ctx.dtype_default() != null) {
      default_ = evalPop(ctx.dtype_default());
    }
	  int cnt = ctx.ident().size();        // Number of variables declared with the same data type and default
	  for (int i = 0; i < cnt; i++) {  	    
	    String name = ctx.ident(i).getText();
	    Var var = new Var(name, type, len, scale, default_);	     
	    addVariable(var);		
	    if (trace) {
	      if (default_ != null) {
	        trace(ctx, "DECLARE " + name + " " + type + " = " + var.toSqlString());
	      }
	      else {
	        trace(ctx, "DECLARE " + name + " " + type);
	      }
	    }
	  }	
	  return 0;
  }
  
  /**
   * ALLOCATE CURSOR statement
   */
  @Override 
  public Integer visitAllocate_cursor_stmt(HplsqlParser.Allocate_cursor_stmtContext ctx) { 
    return exec.stmt.allocateCursor(ctx); 
  }

  /**
   * ASSOCIATE LOCATOR statement
   */
  @Override 
  public Integer visitAssociate_locator_stmt(HplsqlParser.Associate_locator_stmtContext ctx) { 
    return exec.stmt.associateLocator(ctx); 
  }

  /**
   * DECLARE cursor statement
   */
  @Override 
  public Integer visitDeclare_cursor_item(HplsqlParser.Declare_cursor_itemContext ctx) { 
    return exec.stmt.declareCursor(ctx); 
  }
  
  /**
   * DROP statement
   */
  @Override 
  public Integer visitDrop_stmt(HplsqlParser.Drop_stmtContext ctx) { 
    return exec.stmt.drop(ctx); 
  }
  
  /**
   * OPEN cursor statement
   */
  @Override 
  public Integer visitOpen_stmt(HplsqlParser.Open_stmtContext ctx) { 
    return exec.stmt.open(ctx); 
  }  
  
  /**
   * FETCH cursor statement
   */
  @Override 
  public Integer visitFetch_stmt(HplsqlParser.Fetch_stmtContext ctx) { 
    return exec.stmt.fetch(ctx);
  }

  /**
   * CLOSE cursor statement
   */
  @Override 
  public Integer visitClose_stmt(HplsqlParser.Close_stmtContext ctx) { 
    return exec.stmt.close(ctx); 
  }
  
  /**
   * COPY statement
   */
  @Override 
  public Integer visitCopy_stmt(HplsqlParser.Copy_stmtContext ctx) { 
    return new Copy(exec).run(ctx); 
  }
  
  /**
   * COPY FROM LOCAL statement
   */
  @Override 
  public Integer visitCopy_from_local_stmt(HplsqlParser.Copy_from_local_stmtContext ctx) { 
    return new Copy(exec).runFromLocal(ctx); 
  }
  
  /**
   * DECLARE HANDLER statement
   */
  @Override 
  public Integer visitDeclare_handler_item(HplsqlParser.Declare_handler_itemContext ctx) {
    trace(ctx, "DECLARE HANDLER");
    Handler.ExecType execType = Handler.ExecType.EXIT;
    Signal.Type type = Signal.Type.SQLEXCEPTION;
    String value = null;
    if (ctx.T_CONTINUE() != null) {
      execType = Handler.ExecType.CONTINUE;
    }    
    if (ctx.ident() != null) {
      type = Signal.Type.USERDEFINED;
      value = ctx.ident().getText();
    }
    else if (ctx.T_NOT() != null && ctx.T_FOUND() != null) {
      type = Signal.Type.NOTFOUND;
    }
    addHandler(new Handler(execType, type, value, exec.currentScope, ctx));
    return 0; 
  }
  
  /**
   * DECLARE CONDITION
   */
  @Override 
  public Integer visitDeclare_condition_item(HplsqlParser.Declare_condition_itemContext ctx) { 
    return 0; 
  }
  
  /**
   * DECLARE TEMPORARY TABLE statement 
   */
  @Override 
  public Integer visitDeclare_temporary_table_item(HplsqlParser.Declare_temporary_table_itemContext ctx) { 
    return exec.stmt.declareTemporaryTable(ctx); 
  }
  
  /**
   * CREATE TABLE statement
   */
  @Override 
  public Integer visitCreate_table_stmt(HplsqlParser.Create_table_stmtContext ctx) { 
    return exec.stmt.createTable(ctx); 
  } 
  
  @Override 
  public Integer visitCreate_table_options_hive_item(HplsqlParser.Create_table_options_hive_itemContext ctx) { 
    return exec.stmt.createTableHiveOptions(ctx); 
  }
  
  /**
   * CREATE LOCAL TEMPORARY | VOLATILE TABLE statement 
   */
  @Override 
  public Integer visitCreate_local_temp_table_stmt(HplsqlParser.Create_local_temp_table_stmtContext ctx) { 
    return exec.stmt.createLocalTemporaryTable(ctx); 
  }
  
  /**
   * CREATE FUNCTION statement
   */
  @Override 
  public Integer visitCreate_function_stmt(HplsqlParser.Create_function_stmtContext ctx) {
    exec.function.addUserFunction(ctx);
    addLocalUdf(ctx);
    return 0; 
  }
  
  /**
   * CREATE PROCEDURE statement
   */
  @Override 
  public Integer visitCreate_procedure_stmt(HplsqlParser.Create_procedure_stmtContext ctx) {
    exec.function.addUserProcedure(ctx);
    addLocalUdf(ctx);                      // Add procedures as they can be invoked by functions
    return 0; 
  }
  
  /**
   * CREATE INDEX statement
   */
  @Override 
  public Integer visitCreate_index_stmt(HplsqlParser.Create_index_stmtContext ctx) { 
    return 0; 
  }
  
  /**
   * Add functions and procedures defined in the current script
   */
  void addLocalUdf(ParserRuleContext ctx) {
    if (exec == this) {                              
      localUdf.append(exec.getFormattedText(ctx));
      localUdf.append("\n");
    }
  }
  
  /**
   * Save local functions and procedures to a file (will be added to the distributed cache) 
   */
  String createLocalUdf() {
    if(localUdf.length() == 0) {
      return null;
    }
    try {
      String file = System.getProperty("user.dir") + "/" + Conf.HPLSQL_LOCALS_SQL; 
      PrintWriter writer = new PrintWriter(file, "UTF-8");
      writer.print(localUdf);
      writer.close();
      return file;
    } 
    catch (Exception e) {
      e.printStackTrace();
    }
    return null;
  }
      
  /**
   * Assignment statement for single value
   */
  @Override 
  public Integer visitAssignment_stmt_single_item(HplsqlParser.Assignment_stmt_single_itemContext ctx) { 
    String name = ctx.ident().getText();
    visit(ctx.expr());    
    Var var = setVariable(name);
    if (trace) {
      trace(ctx, "SET " + name + " = " + var.toSqlString());      
    }    
    return 0;
  }  

  /**
   * Assignment statement for multiple values
   */
  @Override 
  public Integer visitAssignment_stmt_multiple_item(HplsqlParser.Assignment_stmt_multiple_itemContext ctx) { 
    int cnt = ctx.ident().size();
    int ecnt = ctx.expr().size();    
    for (int i = 0; i < cnt; i++) {
      String name = ctx.ident(i).getText();      
      if (i < ecnt) {
        visit(ctx.expr(i));
        Var var = setVariable(name);        
        if (trace) {
          trace(ctx, "SET " + name + " = " + var.toString());      
        } 
      }      
    }    
    return 0; 
  }
  
  /**
   * Assignment from SELECT statement 
   */
  @Override 
  public Integer visitAssignment_stmt_select_item(HplsqlParser.Assignment_stmt_select_itemContext ctx) { 
    return stmt.assignFromSelect(ctx); 
  }
  
  /**
   * Evaluate an expression
   */
  @Override 
  public Integer visitExpr(HplsqlParser.ExprContext ctx) { 
    if (exec.buildSql) {
      exec.expr.execSql(ctx);
    }
    else {
      exec.expr.exec(ctx);
    }
    return 0;
  }

  /**
   * Evaluate a boolean expression
   */
  @Override 
  public Integer visitBool_expr(HplsqlParser.Bool_exprContext ctx) {
    if (exec.buildSql) {
      exec.expr.execBoolSql(ctx);
    }
    else {
      exec.expr.execBool(ctx);
    }
    return 0; 
  }
  
  @Override 
  public Integer visitBool_expr_binary(HplsqlParser.Bool_expr_binaryContext ctx) {
    if (exec.buildSql) {
      exec.expr.execBoolBinarySql(ctx);
    }
    else {
      exec.expr.execBoolBinary(ctx);
    }
    return 0; 
  }
  
  @Override 
  public Integer visitBool_expr_unary(HplsqlParser.Bool_expr_unaryContext ctx) {
    if (exec.buildSql) {
      exec.expr.execBoolUnarySql(ctx);
    }
    else {
      exec.expr.execBoolUnary(ctx);
    }
    return 0; 
  }
    
  /**
   * Function call
   */
  @Override 
  public Integer visitExpr_func(HplsqlParser.Expr_funcContext ctx) {
    String name = ctx.ident().getText();  
    if (exec.buildSql) {
      exec.function.execSql(name, ctx.expr_func_params());
    }
    else {
      exec.function.exec(name, ctx.expr_func_params());
    }
    return 0;
  }
  
  /**
   * Aggregate or window function call
   */
  @Override 
  public Integer visitExpr_agg_window_func(HplsqlParser.Expr_agg_window_funcContext ctx) {
    exec.function.execAggWindowSql(ctx);
    return 0; 
  }
  
  /**
   * Function with specific syntax
   */
  @Override 
  public Integer visitExpr_spec_func(HplsqlParser.Expr_spec_funcContext ctx) { 
    if (exec.buildSql) {
      exec.function.specExecSql(ctx);
    }
    else {
      exec.function.specExec(ctx);
    }
    return 0;
  }  
  
  /**
   * INCLUDE statement
   */
  @Override 
  public Integer visitInclude_stmt(@NotNull HplsqlParser.Include_stmtContext ctx) {
    return exec.stmt.include(ctx); 
  }
    
  /**
   * IF statement (PL/SQL syntax)
   */
  @Override 
  public Integer visitIf_plsql_stmt(HplsqlParser.If_plsql_stmtContext ctx) { 
    return exec.stmt.ifPlsql(ctx); 
  }

  /**
   * IF statement (Transact-SQL syntax)
   */
  @Override  
  public Integer visitIf_tsql_stmt(HplsqlParser.If_tsql_stmtContext ctx) { 
    return exec.stmt.ifTsql(ctx); 
  }
  
  /**
   * USE statement
   */
  @Override 
  public Integer visitUse_stmt(HplsqlParser.Use_stmtContext ctx) { 
    return exec.stmt.use(ctx); 
  }
  
  /** 
   * VALUES statement
   */
  @Override 
  public Integer visitValues_into_stmt(HplsqlParser.Values_into_stmtContext ctx) { 
    return exec.stmt.values(ctx); 
  }  
  
  /**
   * WHILE statement
   */
  @Override 
  public Integer visitWhile_stmt(HplsqlParser.While_stmtContext ctx) { 
    return exec.stmt.while_(ctx); 
  }  
 
  /**
   * FOR cursor statement
   */
  @Override 
  public Integer visitFor_cursor_stmt(HplsqlParser.For_cursor_stmtContext ctx) { 
    return exec.stmt.forCursor(ctx); 
  }
  
  /**
   * FOR (integer range) statement
   */
  @Override 
  public Integer visitFor_range_stmt(HplsqlParser.For_range_stmtContext ctx) { 
    return exec.stmt.forRange(ctx); 
  }  

  /**
   * EXEC, EXECUTE and EXECUTE IMMEDIATE statement to execute dynamic SQL
   */
  @Override 
  public Integer visitExec_stmt(HplsqlParser.Exec_stmtContext ctx) { 
    return exec.stmt.exec(ctx); 
  }
  
  /**
   * CALL statement
   */
  @Override 
  public Integer visitCall_stmt(HplsqlParser.Call_stmtContext ctx) { 
    if (exec.function.execProc(ctx.expr_func_params(), ctx.ident().getText())) {
      return 0;
    }
    return -1;
  }
    
  /**
   * EXIT statement (leave the specified loop with a condition)
   */
  @Override 
  public Integer visitExit_stmt(HplsqlParser.Exit_stmtContext ctx) { 
    return exec.stmt.exit(ctx); 
  }

  /**
   * BREAK statement (leave the innermost loop unconditionally)
   */
  @Override 
  public Integer visitBreak_stmt(HplsqlParser.Break_stmtContext ctx) { 
    return exec.stmt.break_(ctx);
  }
  
  /**
   * LEAVE statement (leave the specified loop unconditionally)
   */
  @Override 
  public Integer visitLeave_stmt(HplsqlParser.Leave_stmtContext ctx) { 
    return exec.stmt.leave(ctx); 
  }
      
  /** 
   * PRINT statement 
   */
  @Override 
  public Integer visitPrint_stmt(HplsqlParser.Print_stmtContext ctx) { 
	  return exec.stmt.print(ctx); 
  }
  
  /**
   * SIGNAL statement
   */
  @Override 
  public Integer visitSignal_stmt(HplsqlParser.Signal_stmtContext ctx) { 
    return exec.stmt.signal(ctx); 
  }  
  
  /**
   * RESIGNAL statement
   */
  @Override 
  public Integer visitResignal_stmt(HplsqlParser.Resignal_stmtContext ctx) {  
    return exec.stmt.resignal(ctx); 
  }
    
  /**
   * RETURN statement
   */
  @Override 
  public Integer visitReturn_stmt(HplsqlParser.Return_stmtContext ctx) {
    return exec.stmt.return_(ctx); 
  }  
  
  /**
   * MAP OBJECT statement
   */
  @Override 
  public Integer visitMap_object_stmt(HplsqlParser.Map_object_stmtContext ctx) {
    String source = evalPop(ctx.expr(0)).toString();
    String target = null;
    String conn = null;
    if (ctx.T_TO() != null) {
      target = evalPop(ctx.expr(1)).toString();
      exec.objectMap.put(source.toUpperCase(), target);  
    }
    if (ctx.T_AT() != null) {
      if (ctx.T_TO() == null) {
        conn = evalPop(ctx.expr(1)).toString();
      }
      else {
        conn = evalPop(ctx.expr(2)).toString();
      }
      exec.objectConnMap.put(source.toUpperCase(), conn);      
    }
    if (trace) {
      String log = "MAP OBJECT " + source;
      if (target != null) {
        log += " AS " + target;
      }
      if (conn != null) {
        log += " AT " + conn;
      }
      trace(ctx, log);
    }
    return 0; 
  }
  
  /**
   * UPDATE statement
   */
  @Override 
  public Integer visitUpdate_stmt(HplsqlParser.Update_stmtContext ctx) { 
    return stmt.update(ctx); 
  }
  
  /**
   * DELETE statement
   */
  @Override 
  public Integer visitDelete_stmt(HplsqlParser.Delete_stmtContext ctx) { 
    return stmt.delete(ctx); 
  }
  
  /**
   * MERGE statement
   */
  @Override 
  public Integer visitMerge_stmt(HplsqlParser.Merge_stmtContext ctx) { 
    return stmt.merge(ctx); 
  }
    
  /**
   * Run a Hive command line
   */
  @Override 
  public Integer visitHive(@NotNull HplsqlParser.HiveContext ctx) { 
    trace(ctx, "HIVE");      
    ArrayList<String> cmd = new ArrayList<String>();
    cmd.add("hive");    
    Var params = new Var(Var.Type.STRINGLIST, cmd);
    stackPush(params);
    visitChildren(ctx);
    stackPop();    
    try { 
      String[] cmdarr = new String[cmd.size()];
      cmd.toArray(cmdarr);
      if(trace) {
        trace(ctx, "HIVE Parameters: " + Utils.toString(cmdarr, ' '));      
      }     
      if (!offline) {
        Process p = Runtime.getRuntime().exec(cmdarr);      
        new StreamGobbler(p.getInputStream()).start();
        new StreamGobbler(p.getErrorStream()).start(); 
        int rc = p.waitFor();      
        if (trace) {
          trace(ctx, "HIVE Process exit code: " + rc);      
        } 
      }
    } catch (Exception e) {
      setSqlCode(-1);
      signal(Signal.Type.SQLEXCEPTION, e.getMessage(), e);
      return -1;
    }    
    return 0; 
  }
  
  @Override 
  @SuppressWarnings("unchecked")
  public Integer visitHive_item(HplsqlParser.Hive_itemContext ctx) { 
    Var params = stackPeek();
    ArrayList<String> a = (ArrayList<String>)params.value;
    if(ctx.P_e() != null) {
      a.add("-e");
      a.add(evalPop(ctx.expr()).toString());
    }   
    else if(ctx.P_f() != null) {
      a.add("-f");
      a.add(evalPop(ctx.expr()).toString());
    }
    else if(ctx.P_hiveconf() != null) {
      a.add("-hiveconf");
      a.add(ctx.L_ID().toString() + "=" + evalPop(ctx.expr()).toString());
    }
    return 0;
  }
  
  /**
   * Executing OS command
   */
  @Override 
  public Integer visitHost_cmd(HplsqlParser.Host_cmdContext ctx) { 
    trace(ctx, "HOST");      
    execHost(ctx, ctx.start.getInputStream().getText(
        new org.antlr.v4.runtime.misc.Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex())));                
    return 0; 
  }
  
  @Override 
  public Integer visitHost_stmt(HplsqlParser.Host_stmtContext ctx) { 
    trace(ctx, "HOST");      
    execHost(ctx, evalPop(ctx.expr()).toString());                
    return 0; 
  }
  
  public void execHost(ParserRuleContext ctx, String cmd) { 
    try { 
      if (trace) {
        trace(ctx, "HOST Command: " + cmd);      
      } 
      Process p = Runtime.getRuntime().exec(cmd);      
      new StreamGobbler(p.getInputStream()).start();
      new StreamGobbler(p.getErrorStream()).start(); 
      int rc = p.waitFor();      
      if (trace) {
        trace(ctx, "HOST Process exit code: " + rc);      
      }
      setHostCode(rc);
    } catch (Exception e) {
      setHostCode(1);
      signal(Signal.Type.SQLEXCEPTION);
    }        
  }
  
  /**
   * Standalone expression (as a statement)
   */
  @Override 
  public Integer visitExpr_stmt(HplsqlParser.Expr_stmtContext ctx) { 	
    visitChildren(ctx); 
 	  return 0;
  }
  
  /**
   * String concatenation operator
   */
  @Override 
  public Integer visitExpr_concat(HplsqlParser.Expr_concatContext ctx) { 
    if (exec.buildSql) {
      exec.expr.operatorConcatSql(ctx);
    }
    else {
      exec.expr.operatorConcat(ctx);
    }
    return 0;
  }
    
  /**
   * Simple CASE expression
   */
  @Override 
  public Integer visitExpr_case_simple(HplsqlParser.Expr_case_simpleContext ctx) { 
    if (exec.buildSql) {
      exec.expr.execSimpleCaseSql(ctx);
    }
    else {
      exec.expr.execSimpleCase(ctx);
    }
    return 0;
  }
  
  /**
   * Searched CASE expression
   */
  @Override 
  public Integer visitExpr_case_searched(HplsqlParser.Expr_case_searchedContext ctx) { 
    if (exec.buildSql) {
      exec.expr.execSearchedCaseSql(ctx);
    }
    else {
      exec.expr.execSearchedCase(ctx);
    }
    return 0;
  }

  /**
   * GET DIAGNOSTICS EXCEPTION statement
   */
  @Override 
  public Integer visitGet_diag_stmt_exception_item(HplsqlParser.Get_diag_stmt_exception_itemContext ctx) { 
    return exec.stmt.getDiagnosticsException(ctx); 
  }  

  /**
   * GET DIAGNOSTICS ROW_COUNT statement
   */
  @Override 
  public Integer visitGet_diag_stmt_rowcount_item(HplsqlParser.Get_diag_stmt_rowcount_itemContext ctx) { 
    return exec.stmt.getDiagnosticsRowCount(ctx);  
  }
  
  /**
   * GRANT statement
   */
  @Override 
  public Integer visitGrant_stmt(HplsqlParser.Grant_stmtContext ctx) { 
    trace(ctx, "GRANT");
    return 0; 
  }
  
  /**
   * Label
   */
  @Override 
  public Integer visitLabel(HplsqlParser.LabelContext ctx) { 
    if (ctx.L_ID() != null) {
      exec.labels.push(ctx.L_ID().toString());
    }
    else {
      String label = ctx.L_LABEL().getText();
      if (label.endsWith(":")) {
        label = label.substring(0, label.length() - 1);
      }
      exec.labels.push(label);
    }
    return 0;
  }
  
  /**
   * Identifier
   */
  @Override 
  public Integer visitIdent(HplsqlParser.IdentContext ctx) { 
    String ident = ctx.getText();
    Var var = findVariable(ident);
    if (var != null) {
      if (!exec.buildSql) {
        exec.stackPush(var);
      }
      else {
        exec.stackPush(new Var(ident, Var.Type.STRING, var.toSqlString()));
      }
    }
    else {
      exec.stackPush(new Var(Var.Type.IDENT, ident));
    }
    return 0;
  }  
  
  /** 
   * Single quoted string literal 
   */
  @Override 
  public Integer visitSingle_quotedString(HplsqlParser.Single_quotedStringContext ctx) { 
    if (exec.buildSql) {
      exec.stackPush(ctx.getText());
    }
    else {
      exec.stackPush(Utils.unquoteString(ctx.getText()));
    }
    return 0;
  }
  
  /**
   * Integer literal, signed or unsigned
   */
  @Override 
  public Integer visitInt_number(HplsqlParser.Int_numberContext ctx) {
    exec.stack.push(new Var(new Long(ctx.getText())));  	  
	  return 0; 
  }
 
  /**
   * Interval number (1 DAYS i.e)
   */
  @Override 
  public Integer visitInterval_number(HplsqlParser.Interval_numberContext ctx) {
    int num = evalPop(ctx.int_number()).intValue();
    Interval interval = new Interval().set(num, ctx.interval_item().getText());
    stackPush(new Var(interval));
    return 0; 
  }
  
  /**
   * Decimal literal, signed or unsigned
   */
  @Override 
  public Integer visitDec_number(HplsqlParser.Dec_numberContext ctx) {
    stackPush(new Var(new BigDecimal(ctx.getText())));     
    return 0; 
  }

  /**
   * NULL constant
   */
  @Override 
  public Integer visitNull_const(HplsqlParser.Null_constContext ctx) { 
    stackPush(new Var());     
    return 0;  
  }

  /**
   * DATE 'YYYY-MM-DD' literal
   */
  @Override 
  public Integer visitDate_literal(HplsqlParser.Date_literalContext ctx) { 
    String str = evalPop(ctx.string()).toString();
    stackPush(new Var(Var.Type.DATE, Utils.toDate(str))); 
    return 0; 
  }

  /**
   * TIMESTAMP 'YYYY-MM-DD HH:MI:SS.FFF' literal
   */
  @Override 
  public Integer visitTimestamp_literal(HplsqlParser.Timestamp_literalContext ctx) { 
    String str = evalPop(ctx.string()).toString();
    int len = str.length();
    int precision = 0;
    if (len > 19 && len <= 29) {
      precision = len - 20;
      if (precision > 3) {
        precision = 3;
      }
    }
    stackPush(new Var(Utils.toTimestamp(str), precision)); 
    return 0; 
  }
  
  /**
   * Define the connection profile to execute the current statement
   */
  String getStatementConnection() {
    if (exec.stmtConnList.contains(exec.conf.defaultConnection)) {
      return exec.conf.defaultConnection;
    }
    else if (!exec.stmtConnList.isEmpty()) {
      return exec.stmtConnList.get(0);
    }
    return exec.conf.defaultConnection;
  }
  
  /**
   * Define the connection profile for the specified object
   * @return
   */
  String getObjectConnection(String name) {
    String conn = exec.objectConnMap.get(name.toUpperCase());
    if (conn != null) {
      return conn;
    }
    return exec.conf.defaultConnection;
  }
  
  /**
   * Get the connection (open the new connection if not available)
   * @throws Exception 
   */
  Connection getConnection(String conn) throws Exception {
    return exec.conn.getConnection(conn);
  }
  
  /**
   * Return the connection to the pool
   */
  void returnConnection(String name, Connection conn) {
    exec.conn.returnConnection(name, conn);
  }
  
  /**
   * Define the database type by profile name
   */
  Conn.Type getConnectionType(String conn) {
    return exec.conn.getType(conn);
  }
  
  /**
   * Get the current database type
   */
  public Conn.Type getConnectionType() {
    return getConnectionType(exec.conf.defaultConnection);
  }
  
  /** 
   * Add managed temporary table
   */
  public void addManagedTable(String name, String managedName) {
    exec.managedTables.put(name, managedName);
  }
  
  /**
   * Get node text including spaces
   */
  String getText(ParserRuleContext ctx) {
    return ctx.start.getInputStream().getText(new org.antlr.v4.runtime.misc.Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));
  }
  
  String getText(ParserRuleContext ctx, Token start, Token stop) {
    return ctx.start.getInputStream().getText(new org.antlr.v4.runtime.misc.Interval(start.getStartIndex(), stop.getStopIndex()));
  }
  
  /**
   * Evaluate the expression and pop value from the stack
   */
  Var evalPop(ParserRuleContext ctx) {
    visit(ctx);
    if (!exec.stack.isEmpty()) { 
      return exec.stackPop();
    }
    return Var.Empty;
  }
  
  Var evalPop(ParserRuleContext ctx, long def) {
    visit(ctx);
    if (!exec.stack.isEmpty()) { 
      return stackPop();
    }
    return new Var(def);
  } 
  
  /**
   * Evaluate the data type and length 
   * 
   */
  String evalPop(HplsqlParser.DtypeContext type, HplsqlParser.Dtype_lenContext len) {
    if (isConvert(exec.conf.defaultConnection)) {
      return exec.converter.dataType(type, len);
    }
    return getText(type, type.getStart(), len.getStop());
  }
  
  /**
   * Evaluate the expression to NULL
   */
  void evalNull() {
    stackPush(Var.Null); 
  }
  
  /**
   * Get formatted text between 2 tokens
   */
  public String getFormattedText(ParserRuleContext ctx) {
    return ctx.start.getInputStream().getText(
      new org.antlr.v4.runtime.misc.Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));                
  }
  
  /**
   * Flag whether executed from UDF or not
   */
  void setUdfRun(boolean udfRun) {
    this.udfRun = udfRun;
  }
  
  /**
   * Whether on-the-fly SQL conversion is required for the connection 
   */
  boolean isConvert(String connName) {
    return exec.conf.getConnectionConvert(connName);
  }
  
  /**
   * Increment the row count
   */
  public int incRowCount() {
    return exec.rowCount++;
  }
  
  /**
   * Set the row count
   */
  public void setRowCount(int rowCount) {
    exec.rowCount = rowCount;
  }
  
  /**
   * Trace information
   */
  public void trace(ParserRuleContext ctx, String message) {
		if (!trace) {
		  return;
	  }
		if (ctx != null) {
	    System.out.println("Ln:" + ctx.getStart().getLine() + " " + message);
		}
		else {
		  System.out.println(message);
		}
  }
  
  /**
   * Informational messages
   */
  public void info(ParserRuleContext ctx, String message) {
    if (!info) {
      return;
    }
    if (ctx != null) {
      System.err.println("Ln:" + ctx.getStart().getLine() + " " + message);
    }
    else {
      System.err.println(message);
    }
  }
  
  public Stack<Var> getStack() {
    return exec.stack;
  }
 
  public int getRowCount() {
    return exec.rowCount;
  }

  public Conf getConf() {
    return exec.conf;
  }
  
  public boolean getTrace() {
    return exec.trace;
  }
  
  public boolean getInfo() {
    return exec.info;
  }
  
  public boolean getOffline() {
    return exec.offline;
  }
} 


File: hplsql/src/main/java/org/apache/hive/hplsql/Expression.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hive.hplsql;

import java.sql.Date;
import java.sql.Timestamp;
import java.util.Calendar;

import org.antlr.v4.runtime.ParserRuleContext;
import org.apache.hive.hplsql.Var.Type;

/**
 * Expressions
 */
public class Expression {

  Exec exec;
  boolean trace = false; 
  
  Expression(Exec e) {
    exec = e;  
    trace = exec.getTrace();
  }
  
  /**
   * Evaluate an expression
   */
  public void exec(HplsqlParser.ExprContext ctx) {
    if (ctx.T_ADD() != null) {
      operatorAdd(ctx); 
    }
    else if (ctx.T_SUB() != null) {
      operatorSub(ctx); 
    }
    else if (ctx.interval_item() != null) {
      createInterval(ctx);
    }
    else {
     visitChildren(ctx);
    }
  }
  
  /**
   * Evaluate an expression in executable SQL statement
   */
  public void execSql(HplsqlParser.ExprContext ctx) {
    StringBuilder sql = new StringBuilder();
    if (ctx.T_OPEN_P() != null) {
      sql.append("(");
      sql.append(evalPop(ctx.expr(0)).toString());
      sql.append(")");      
    }
    else if (ctx.T_ADD() != null) {
      sql.append(evalPop(ctx.expr(0)).toString());
      sql.append(" + ");
      sql.append(evalPop(ctx.expr(1)).toString());
    }
    else if (ctx.T_SUB() != null) {
      sql.append(evalPop(ctx.expr(0)).toString());
      sql.append(" - ");
      sql.append(evalPop(ctx.expr(1)).toString());
    }
    else if (ctx.interval_item() != null) {
      sql.append(exec.getFormattedText(ctx));
    }
    else {
      visitChildren(ctx);
      sql.append(exec.stackPop().toString());
    }
    exec.stackPush(sql);
  }
  
  /**
   * Evaluate a boolean expression
   */
  public void execBool(HplsqlParser.Bool_exprContext ctx) {
    if (ctx.T_OPEN_P() != null) {
      eval(ctx.bool_expr(0));
      return;
    }
    else if (ctx.bool_expr_atom() != null) {
      eval(ctx.bool_expr_atom());
      return;
    }
    Var result = evalPop(ctx.bool_expr(0));
    if (ctx.bool_expr_logical_operator() != null) {
      if (ctx.bool_expr_logical_operator().T_AND() != null) {
        if (result.isTrue()) {
          result = evalPop(ctx.bool_expr(1));
        }
      }
      else if (ctx.bool_expr_logical_operator().T_OR() != null) {
        if (!result.isTrue()) {
          result = evalPop(ctx.bool_expr(1));
        }
      }
    }
    exec.stackPush(result);
  }
  
  /**
   * Evaluate a boolean expression in executable SQL statement
   */
  public void execBoolSql(HplsqlParser.Bool_exprContext ctx) {
    StringBuilder sql = new StringBuilder();
    if (ctx.T_OPEN_P() != null) {
      sql.append("(");
      sql.append(evalPop(ctx.bool_expr(0)).toString());
      sql.append(")");
    }
    else if (ctx.bool_expr_atom() != null) {
      sql.append(evalPop(ctx.bool_expr_atom()).toString());
    }
    else if (ctx.bool_expr_logical_operator() != null) {
      sql.append(evalPop(ctx.bool_expr(0)).toString());
      sql.append(" " + ctx.bool_expr_logical_operator().getText() + " ");
      sql.append(evalPop(ctx.bool_expr(1)).toString());
    }
    exec.stackPush(sql);
  }
  
  /**
   * Binary boolean expression
   */
  public Integer execBoolBinary(HplsqlParser.Bool_expr_binaryContext ctx) {
    HplsqlParser.Bool_expr_binary_operatorContext op = ctx.bool_expr_binary_operator(); 
    if (op.T_EQUAL() != null || op.T_EQUAL2() != null) {
      operatorEqual(ctx, true); 
    }
    else if (op.T_NOTEQUAL() != null || op.T_NOTEQUAL2() != null) {
      operatorEqual(ctx, false); 
    }
    else if (op.T_GREATER() != null || op.T_LESS() != null || op.T_GREATEREQUAL() != null || op.T_LESSEQUAL() != null) {
      operatorCompare(ctx, op);
    }
    else {
      exec.stackPush(false);
    }
    return 0; 
  }
  
  /**
   * Binary boolean expression in executable SQL statement
   */
  public Integer execBoolBinarySql(HplsqlParser.Bool_expr_binaryContext ctx) {
    StringBuilder sql = new StringBuilder();
    sql.append(evalPop(ctx.expr(0)).toString());
    sql.append(" " + exec.getFormattedText(ctx.bool_expr_binary_operator()) + " ");
    sql.append(evalPop(ctx.expr(1)).toString());
    exec.stackPush(sql);
    return 0; 
  }
  
  /**
   * Unary boolean expression
   */
  public Integer execBoolUnary(HplsqlParser.Bool_expr_unaryContext ctx) {
    boolean val = false;
    if (ctx.T_IS() != null) {
      val = evalPop(ctx.expr(0)).isNull();
      if (ctx.T_NOT() != null) {
        val = !val;
      }
    }
    else if (ctx.T_BETWEEN() != null) {
      Var v = evalPop(ctx.expr(0));
      Var v1 = evalPop(ctx.expr(1));
      int cmp = v.compareTo(v1);
      if (cmp >= 0) {
        Var v2 = evalPop(ctx.expr(2));
        cmp = v.compareTo(v2);
        if (cmp <= 0) {
          val = true;
        }
      }
    }
    exec.stackPush(val);
    return 0; 
  }
  
  /**
   * Unary boolean expression in executable SQL statement
   */
  public Integer execBoolUnarySql(HplsqlParser.Bool_expr_unaryContext ctx) {
    StringBuilder sql = new StringBuilder();
    if (ctx.T_IS() != null) {
      sql.append(evalPop(ctx.expr(0)).toString());
      sql.append(" " + exec.getText(ctx, ctx.T_IS().getSymbol(), ctx.T_NULL().getSymbol()));
    }    
    else if (ctx.T_BETWEEN() != null) {
      sql.append(evalPop(ctx.expr(0)).toString());
      sql.append(" " + ctx.T_BETWEEN().getText() + " ");
      sql.append(evalPop(ctx.expr(1)).toString());
      sql.append(" " + ctx.T_AND().getText() + " ");
      sql.append(evalPop(ctx.expr(2)).toString());
    }
    else if (ctx.bool_expr_single_in() != null) {
      singleInClauseSql(ctx.bool_expr_single_in(), sql);
    }
    else if (ctx.bool_expr_multi_in() != null) {
      multiInClauseSql(ctx.bool_expr_multi_in(), sql);
    }
    exec.stackPush(sql);
    return 0; 
  }
  
  /**
   * Single value IN clause in executable SQL statement
   */
  public void singleInClauseSql(HplsqlParser.Bool_expr_single_inContext ctx, StringBuilder sql) {
    sql.append(evalPop(ctx.expr(0)).toString());
    if (ctx.T_NOT() != null) {
      sql.append(" " + ctx.T_NOT().getText());
    }
    sql.append(" " + ctx.T_IN().getText() + " (");
    if (ctx.select_stmt() != null) {
      sql.append(evalPop(ctx.select_stmt()));
    }
    else {
      int cnt = ctx.expr().size();
      for (int i = 1; i < cnt; i++) {
        sql.append(evalPop(ctx.expr(i)).toString());
        if (i + 1 < cnt) {
          sql.append(", ");
        }
      }
    }
    sql.append(")");
  }
  
  /**
   * Multi-value IN clause in executable SQL statement
   */
  public void multiInClauseSql(HplsqlParser.Bool_expr_multi_inContext ctx, StringBuilder sql) {
    int cnt = ctx.expr().size();
    sql.append("(");
    for (int i = 0; i < cnt; i++) {
      sql.append(evalPop(ctx.expr(i)).toString());
      if (i + 1 < cnt) {
        sql.append(", ");
      }
    }
    sql.append(")");
    if (ctx.T_NOT() != null) {
      sql.append(" " + ctx.T_NOT().getText());
    }
    sql.append(" " + ctx.T_IN().getText() + " (");
    if (ctx.select_stmt() != null) {
      sql.append(evalPop(ctx.select_stmt()));
    }
    sql.append(")");
  }
  
  /**
   * Addition operator
   */
  public void operatorAdd(HplsqlParser.ExprContext ctx) {
    Var v1 = evalPop(ctx.expr(0));
    Var v2 = evalPop(ctx.expr(1));
    if (v1.value == null || v2.value == null) {
      evalNull();
    }
    else if (v1.type == Type.BIGINT && v2.type == Type.BIGINT) {
      exec.stackPush(new Var((Long)v1.value + (Long)v2.value)); 
    }
    else if (v1.type == Type.BIGINT && v2.type == Type.DATE) {
      exec.stackPush(changeDateByInt((Date)v2.value, (Long)v1.value, true /*add*/));
    }
    else if (v1.type == Type.DATE && v2.type == Type.BIGINT) {
      exec.stackPush(changeDateByInt((Date)v1.value, (Long)v2.value, true /*add*/));
    }
    else if (v1.type == Type.DATE && v2.type == Type.INTERVAL) {
      exec.stackPush(new Var(((Interval)v2.value).dateChange((Date)v1.value, true /*add*/)));
    }
    else if (v1.type == Type.TIMESTAMP && v2.type == Type.INTERVAL) {
      exec.stackPush(new Var(((Interval)v2.value).timestampChange((Timestamp)v1.value, true /*add*/), v1.scale));
    }
  }

  /**
   * Subtraction operator
   */
  public void operatorSub(HplsqlParser.ExprContext ctx) {
    Var v1 = evalPop(ctx.expr(0));
    Var v2 = evalPop(ctx.expr(1));
    if (v1.value == null || v2.value == null) {
      evalNull();
    }
    else if (v1.type == Type.BIGINT && v2.type == Type.BIGINT) {
      exec.stackPush(new Var((Long)v1.value - (Long)v2.value)); 
    }
    else if (v1.type == Type.DATE && v2.type == Type.BIGINT) {
      exec.stackPush(changeDateByInt((Date)v1.value, (Long)v2.value, false /*subtract*/));
    }
    else if (v1.type == Type.DATE && v2.type == Type.INTERVAL) {
      exec.stackPush(new Var(((Interval)v2.value).dateChange((Date)v1.value, false /*subtract*/)));
    }
    else if (v1.type == Type.TIMESTAMP && v2.type == Type.INTERVAL) {
      exec.stackPush(new Var(((Interval)v2.value).timestampChange((Timestamp)v1.value, false /*subtract*/), v1.scale));
    }
  }
  
  /**
   * Add or subtract the specified number of days from DATE
   */
  public Var changeDateByInt(Date d, Long i, boolean add) {
    Calendar c = Calendar.getInstance();
    c.setTimeInMillis(d.getTime());
    int days = i.intValue();
    if(!add) {
      days *= -1;
    }
    c.add(Calendar.DAY_OF_MONTH, days);
    return new Var(new Date(c.getTimeInMillis()));
  }
    
  /**
   * Equality operator
   */
  public void operatorEqual(HplsqlParser.Bool_expr_binaryContext ctx, boolean equal) {
    Var v1 = evalPop(ctx.expr(0));
    Var v2 = evalPop(ctx.expr(1));
    boolean eq = v1.equals(v2);
    if (!equal) {
      eq = !eq;
    }
    exec.stackPush(eq);
  }

  /**
   * Comparison operator
   */
  public void operatorCompare(HplsqlParser.Bool_expr_binaryContext ctx, HplsqlParser.Bool_expr_binary_operatorContext op) {
    Var v1 = evalPop(ctx.expr(0));
    Var v2 = evalPop(ctx.expr(1));
    int cmp = v1.compareTo(v2);
    boolean bool = false;
    if (op.T_GREATER() != null) {
      if (cmp > 0) {
        bool = true;
      }
    }
    else if (op.T_GREATEREQUAL() != null) {
      if (cmp >= 0) {
        bool = true;
      }
    }
    if (op.T_LESS() != null) {
      if (cmp < 0) {
        bool = true;
      }
    }
    else if (op.T_LESSEQUAL() != null) {
      if (cmp <= 0) {
        bool = true;
      }
    }
    exec.stackPush(bool);
  }
  
  /**
   * String concatenation operator
   */
  public void operatorConcat(HplsqlParser.Expr_concatContext ctx) {
    StringBuilder val = new StringBuilder();
    int cnt = ctx.expr_concat_item().size();
    boolean nulls = true;
    for (int i = 0; i < cnt; i++) {
      Var c = evalPop(ctx.expr_concat_item(i));
      if (!c.isNull()) {
        val.append(c.toString());
        nulls = false;
      }
    }
    if (nulls) {
      evalNull();
    }
    else {
      evalString(val);
    }
  }
  
  /**
   * String concatenation operator in executable SQL statement
   */
  public void operatorConcatSql(HplsqlParser.Expr_concatContext ctx) {
    StringBuilder sql = new StringBuilder();
    sql.append("CONCAT(");
    int cnt = ctx.expr_concat_item().size();
    for (int i = 0; i < cnt; i++) {
      sql.append(evalPop(ctx.expr_concat_item(i)).toString());
      if (i + 1 < cnt) {
        sql.append(", ");
      }
    }
    sql.append(")");
    exec.stackPush(sql);
  }
  
  /**
   * Simple CASE expression
   */
  public void execSimpleCase(HplsqlParser.Expr_case_simpleContext ctx) { 
    int i = 1;
    int cnt = ctx.expr().size();
    boolean found = false;
    Var val = evalPop(ctx.expr(0));
    while(i < cnt) {
      Var when = evalPop(ctx.expr(i));
      if(val.compareTo(when) == 0) {
        visit(ctx.expr(i + 1));
        found = true;
        break;
      }
      i += 2;
    }
    if(!found) {
      if(ctx.T_ELSE() != null) {
        visit(ctx.expr(cnt - 1));
      }
      else {
        evalNull();
      }
    }
  }
  
  /**
   * Simple CASE expression in executable SQL statement
   */
  public void execSimpleCaseSql(HplsqlParser.Expr_case_simpleContext ctx) { 
    StringBuilder sql = new StringBuilder();
    sql.append("CASE ");
    sql.append(evalPop(ctx.expr(0)).toString());
    int cnt = ctx.T_WHEN().size();
    for (int i = 0; i < cnt; i++) {
      sql.append(" WHEN ");
      sql.append(evalPop(ctx.expr(i * 2 + 1)).toString());
      sql.append(" THEN ");
      sql.append(evalPop(ctx.expr(i * 2 + 2)).toString());
    }
    if (ctx.T_ELSE() != null) {
      sql.append(" ELSE ");
      sql.append(evalPop(ctx.expr(cnt * 2 + 1)).toString());
    }
    sql.append(" END");
    exec.stackPush(sql);
  }
  
  /**
   * Searched CASE expression
   */
  public void execSearchedCase(HplsqlParser.Expr_case_searchedContext ctx) { 
    int cnt = ctx.bool_expr().size();
    boolean found = false;
    for(int i = 0; i < cnt; i++) {
      if(evalPop(ctx.bool_expr(i)).isTrue()) {
        visit(ctx.expr(i)); 
        found = true;
        break;
      }
    }
    if(!found) {
      if(ctx.T_ELSE() != null) {
        visit(ctx.expr(cnt));
      }
      else {
        evalNull();
      }
    }
  }
  
  /**
   * Searched CASE expression in executable SQL statement
   */
  public void execSearchedCaseSql(HplsqlParser.Expr_case_searchedContext ctx) { 
    StringBuilder sql = new StringBuilder();
    sql.append("CASE");
    int cnt = ctx.T_WHEN().size();
    for (int i = 0; i < cnt; i++) {
      sql.append(" WHEN ");
      sql.append(evalPop(ctx.bool_expr(i)).toString());
      sql.append(" THEN ");
      sql.append(evalPop(ctx.expr(i)).toString());
    }
    if (ctx.T_ELSE() != null) {
      sql.append(" ELSE ");
      sql.append(evalPop(ctx.expr(cnt)).toString());
    }
    sql.append(" END");
    exec.stackPush(sql);
  }
  
  /**
   * Create an interval variable
   */
  public void createInterval(HplsqlParser.ExprContext ctx) {
    int num = evalPop(ctx.expr(0)).intValue();
    Interval interval = new Interval().set(num, ctx.interval_item().getText());
    exec.stackPush(new Var(interval));
  }
  
  /**
   * Evaluate the expression and push the value to the stack
   */
  void eval(ParserRuleContext ctx) {
    visit(ctx);
  }
      
  /**
   * Evaluate the expression and pop value from the stack
   */
  Var evalPop(ParserRuleContext ctx) {
    visit(ctx);
    if (!exec.stack.isEmpty()) { 
      return exec.stackPop();
    }
    return Var.Empty;
  }
  
  /**
   * Evaluate the expression to specified String value
   */
  void evalString(String string) {
    exec.stackPush(new Var(string)); 
  }
  
  void evalString(StringBuilder string) {
    evalString(string.toString()); 
  }
  
  /**
   * Evaluate the expression to NULL
   */
  void evalNull() {
    exec.stackPush(Var.Null); 
  }
  
  /**
   * Execute rules
   */
  Integer visit(ParserRuleContext ctx) {
    return exec.visit(ctx);  
  } 
  
  /**
   * Execute children rules
   */
  Integer visitChildren(ParserRuleContext ctx) {
    return exec.visitChildren(ctx);  
  }  
  
  /**
   * Trace information
   */
  public void trace(ParserRuleContext ctx, String message) {
    exec.trace(ctx, message);
  }
}


File: hplsql/src/main/java/org/apache/hive/hplsql/Query.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hive.hplsql;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import org.antlr.v4.runtime.ParserRuleContext;

public class Query {
  String sql;
  ParserRuleContext sqlExpr;
  ParserRuleContext sqlSelect;  
  
  Connection conn;
  Statement stmt;
  ResultSet rs;
  Exception exception;
  
  boolean withReturn = false;
  
  Query() {
  }
  
  Query(String sql) {
    this.sql = sql;
  }  
 
  /** 
   * Set query objects
   */
  public void set(Connection conn, Statement stmt, ResultSet rs) {
    this.conn = conn;
    this.stmt = stmt;
    this.rs = rs;
  }
  
  /**
   * Get the number of rows
   */
  public int getRowCount() {
    if (!error() && stmt != null) {
      try {
        return stmt.getUpdateCount();
      } catch (SQLException e) {}
    }
    return -1;
  }
  
  /**
   * Close statement results
   */
  public void closeStatement() {
    try {
      if(rs != null) {
        rs.close();
        rs = null;
      }
      if(stmt != null) {
        stmt.close();
        stmt = null;
      }
    } catch (SQLException e) {
      e.printStackTrace();
    }   
  }
  
  /**
   * Set SQL statement
   */
  public void setSql(String sql) {
    this.sql = sql;
  }
  
  /**
   * Set expression context
   */
  public void setExprCtx(ParserRuleContext sqlExpr) {
    this.sqlExpr = sqlExpr;
  }

  /**
   * Set SELECT statement context
   */
  public void setSelectCtx(ParserRuleContext sqlSelect) {
    this.sqlSelect = sqlSelect;
  }
  
  /**
   * Set whether the cursor is returned to the caller
   */
  public void setWithReturn(boolean withReturn) {
    this.withReturn = withReturn;
  }
  
  /**
   * Set an execution error
   */
  public void setError(Exception e) {
    exception = e;
  }
  
  /**
   * Print error stack trace
   */
  public void printStackTrace() {
    if(exception != null) {
      exception.printStackTrace();
    }
  }
  
  /**
   * Get the result set object
   */
  public ResultSet getResultSet() {
    return rs;
  }
  
  /**
   * Get the connection object
   */
  public Connection getConnection() {
    return conn;
  }
  
  /**
   * Check if the cursor defined as a return cursor to client
   */
  public boolean getWithReturn() {
    return withReturn;
  }
  
  /**
   * Return error information
   */
  public boolean error() {
    return exception != null;
  }
  
  public String errorText() {
    if(exception != null) {
      if(exception instanceof ClassNotFoundException) {
        return "ClassNotFoundException: " + exception.getMessage();
      }
      return exception.getMessage();
    }
    return "";
  }
  
  public Exception getException() {
    return exception;
  }
}


File: hplsql/src/main/java/org/apache/hive/hplsql/Stmt.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hive.hplsql;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.Stack;
import java.util.UUID;

import org.antlr.v4.runtime.ParserRuleContext;
import org.apache.hive.hplsql.Var.Type;
import org.apache.hive.hplsql.HplsqlParser.Create_table_columns_itemContext;
import org.apache.hive.hplsql.HplsqlParser.Create_table_columnsContext;

/**
 * HPL/SQL statements execution
 */
public class Stmt {

  Exec exec = null;
  Stack<Var> stack = null;
  Conf conf;
  
  boolean trace = false; 
  
  Stmt(Exec e) {
    exec = e;  
    stack = exec.getStack();
    conf = exec.getConf();
    trace = exec.getTrace();
  }
  
  /**
   * ALLOCATE CURSOR statement
   */
  public Integer allocateCursor(HplsqlParser.Allocate_cursor_stmtContext ctx) { 
    trace(ctx, "ALLOCATE CURSOR");
    String name = ctx.ident(0).getText();
    Var cur = null;
    if (ctx.T_PROCEDURE() != null) {
      cur = exec.consumeReturnCursor(ctx.ident(1).getText());
    }
    else if (ctx.T_RESULT() != null) {
      cur = exec.findVariable(ctx.ident(1).getText());
      if (cur != null && cur.type != Type.RS_LOCATOR) {
        cur = null;
      }
    }
    if (cur == null) {
      trace(ctx, "Cursor for procedure not found: " + name);
      exec.signal(Signal.Type.SQLEXCEPTION);
      return -1;
    }
    exec.addVariable(new Var(name, Type.CURSOR, cur.value)); 
    return 0; 
  }
  
  /**
   * ASSOCIATE LOCATOR statement
   */
  public Integer associateLocator(HplsqlParser.Associate_locator_stmtContext ctx) { 
    trace(ctx, "ASSOCIATE LOCATOR");
    int cnt = ctx.ident().size();
    if (cnt < 2) {
      return -1;
    }
    String procedure = ctx.ident(cnt - 1).getText();
    for (int i = 0; i < cnt - 1; i++) {
      Var cur = exec.consumeReturnCursor(procedure);
      if (cur != null) {
        String name = ctx.ident(i).getText(); 
        Var loc = exec.findVariable(name);
        if (loc == null) {
          loc = new Var(name, Type.RS_LOCATOR, cur.value);
          exec.addVariable(loc);
        }
        else {
          loc.setValue(cur.value);
        }
      }      
    }
    return 0; 
  }
  
  /**
   * DECLARE cursor statement
   */
  public Integer declareCursor(HplsqlParser.Declare_cursor_itemContext ctx) { 
    String name = ctx.ident().getText();
    if (trace) {
      trace(ctx, "DECLARE CURSOR " + name);
    }
    Query query = new Query();
    if (ctx.expr() != null) {
      query.setExprCtx(ctx.expr());
    }
    else if (ctx.select_stmt() != null) {
      query.setSelectCtx(ctx.select_stmt());
    }
    if (ctx.cursor_with_return() != null) {
      query.setWithReturn(true);
    }
    Var var = new Var(name, Type.CURSOR, query);
    exec.addVariable(var);
    return 0; 
  }
  
  /**
   * CREATE TABLE statement
   */
  public Integer createTable(HplsqlParser.Create_table_stmtContext ctx) { 
    trace(ctx, "CREATE TABLE");
    StringBuilder sql = new StringBuilder();
    sql.append(exec.getText(ctx, ctx.T_CREATE().getSymbol(), ctx.T_OPEN_P().getSymbol()));
    int cnt = ctx.create_table_columns().create_table_columns_item().size();
    int cols = 0;
    for (int i = 0; i < cnt; i++) {
      Create_table_columns_itemContext col = ctx.create_table_columns().create_table_columns_item(i);
      if (col.create_table_column_cons() != null) {
        continue;
      }
      if (cols > 0) {
        sql.append(",\n");
      }
      sql.append(col.ident().getText());
      sql.append(" ");
      sql.append(exec.evalPop(col.dtype(), col.dtype_len()));
      cols++;
    }
    sql.append("\n)");
    if (ctx.create_table_options() != null) {
      sql.append(" " + evalPop(ctx.create_table_options()).toString());
    }
    trace(ctx, sql.toString());
    Query query = exec.executeSql(ctx, sql.toString(), exec.conf.defaultConnection);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0; 
  }  

  /**
   * CREATE TABLE options for Hive
   */
  public Integer createTableHiveOptions(HplsqlParser.Create_table_options_hive_itemContext ctx) {
    if (ctx.create_table_hive_row_format() != null) {
      createTableHiveRowFormat(ctx.create_table_hive_row_format());
    }
    return 0; 
  }
  
  public Integer createTableHiveRowFormat(HplsqlParser.Create_table_hive_row_formatContext ctx) {
    StringBuilder sql = new StringBuilder();
    sql.append("ROW FORMAT DELIMITED");
    int cnt = ctx.create_table_hive_row_format_fields().size();
    for (int i = 0; i < cnt; i++) {
      HplsqlParser.Create_table_hive_row_format_fieldsContext c = ctx.create_table_hive_row_format_fields(i);
      if (c.T_FIELDS() != null) {
        sql.append(" FIELDS TERMINATED BY " + evalPop(c.expr(0)).toSqlString());
      }
      else if (c.T_LINES() != null) {
        sql.append(" LINES TERMINATED BY " + evalPop(c.expr(0)).toSqlString());
      } 
    }
    evalString(sql);
    return 0; 
  }
    
  /**
   * DECLARE TEMPORARY TABLE statement 
   */
  public Integer declareTemporaryTable(HplsqlParser.Declare_temporary_table_itemContext ctx) { 
    String name = ctx.ident().getText();
    if (trace) {
      trace(ctx, "DECLARE TEMPORARY TABLE " + name);
    }
    return createTemporaryTable(ctx, ctx.create_table_columns(), name);
  }
  
  /**
   * CREATE LOCAL TEMPORARY | VOLATILE TABLE statement 
   */
  public Integer createLocalTemporaryTable(HplsqlParser.Create_local_temp_table_stmtContext ctx) { 
    String name = ctx.ident().getText();
    if (trace) {
      trace(ctx, "CREATE LOCAL TEMPORARY TABLE " + name);
    }
    return createTemporaryTable(ctx, ctx.create_table_columns(), name);
   }
  
  /**
   * Create a temporary table statement 
   */
  public Integer createTemporaryTable(ParserRuleContext ctx, Create_table_columnsContext colCtx, String name) { 
    String managedName = null;
    String sql = null;
    String columns = exec.getFormattedText(colCtx);
    if (conf.tempTables == Conf.TempTables.NATIVE) {
      sql = "CREATE TEMPORARY TABLE " + name + "\n(" + columns + "\n)";
    } else if (conf.tempTables == Conf.TempTables.MANAGED) {
      managedName = name + "_" + UUID.randomUUID().toString().replace("-","");
      if (!conf.tempTablesSchema.isEmpty()) {
        managedName = conf.tempTablesSchema + "." + managedName;
      }      
      sql = "CREATE TABLE " + managedName + "\n(" + columns + "\n)";
      if (!conf.tempTablesLocation.isEmpty()) {
        sql += "\nLOCATION '" + conf.tempTablesLocation + "/" + managedName + "'";
      }
      if (trace) {
        trace(ctx, "Managed table name: " + managedName);
      }
    }  
    if (sql != null) {
      Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
      if (query.error()) {
        exec.signal(query);
        return 1;
      }
      if (managedName != null) {
        exec.addManagedTable(name, managedName);
      }
      exec.setSqlSuccess();
      exec.closeQuery(query, exec.conf.defaultConnection);
    }    
    return 0; 
  }
  
  /**
   * DROP statement
   */
  public Integer drop(HplsqlParser.Drop_stmtContext ctx) { 
    trace(ctx, "DROP");
    String sql = null;    
    if (ctx.T_TABLE() != null) {
      sql = "DROP TABLE ";
      if (ctx.T_EXISTS() != null) {
        sql += "IF NOT EXISTS ";
      }
      sql += evalPop(ctx.table_name()).toString();
    }
    if (sql != null) {
      trace(ctx, sql);
      Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
      if (query.error()) {
        exec.signal(query);
        return 1;
      }
      exec.setSqlSuccess();
      exec.closeQuery(query, exec.conf.defaultConnection);
    }
    return 0; 
  }
  
  /**
   * OPEN cursor statement
   */
  public Integer open(HplsqlParser.Open_stmtContext ctx) { 
    trace(ctx, "OPEN");
    Query query = null;
    Var var = null;
    String cursor = ctx.L_ID().toString();   
    String sql = null;
    // Dynamic SQL
    if (ctx.T_FOR() != null) {
      sql = evalPop(ctx.expr()).toString();
      if (trace) {
        trace(ctx, cursor + ": " + sql);
      }
      query = new Query(sql);
      var = new Var(cursor, Type.CURSOR, query);
      exec.addVariable(var);
    }
    // Declared cursor
    else {
      var = exec.findVariable(cursor);      
      if (var != null && var.type == Type.CURSOR) {
        query = (Query)var.value;
        if (query.sqlExpr != null) {
          sql = evalPop(query.sqlExpr).toString();
          query.setSql(sql);
        }
        else if (query.sqlSelect != null) {
          sql = evalPop(query.sqlSelect).toString();
          query.setSql(sql);
        }
        if (trace) {
          trace(ctx, cursor + ": " + sql);
        } 
      }
    }
    // Open cursor now
    if (query != null) {
      exec.executeQuery(ctx, query, exec.conf.defaultConnection);
      if (query.error()) {
        exec.signal(query);
        return 1;
      }
      else if (!exec.getOffline()) {
        exec.setSqlCode(0);
      }
      if (query.getWithReturn()) {
        exec.addReturnCursor(var);
      }
    }
    else {
      trace(ctx, "Cursor not found: " + cursor);
      exec.setSqlCode(-1);
      exec.signal(Signal.Type.SQLEXCEPTION);
      return 1;
    }
    return 0; 
  }
  
  /**
   * FETCH cursor statement
   */
  public Integer fetch(HplsqlParser.Fetch_stmtContext ctx) { 
    trace(ctx, "FETCH");
    String name = ctx.L_ID(0).toString();
    Var cursor = exec.findCursor(name);
    if (cursor == null) {
      trace(ctx, "Cursor not found: " + name);
      exec.setSqlCode(-1);
      exec.signal(Signal.Type.SQLEXCEPTION);
      return 1;
    }    
    else if (exec.getOffline()) {
      exec.setSqlCode(100);
      exec.signal(Signal.Type.NOTFOUND);
      return 0;
    }
    // Assign values from the row to local variables
    try {
      Query query = (Query)cursor.value;
      ResultSet rs = query.getResultSet();
      ResultSetMetaData rsm = null;
      if(rs != null) {
        rsm = rs.getMetaData();
      }
      if(rs != null && rsm != null) {
        int cols = ctx.L_ID().size() - 1;
        if(rs.next()) {
          for(int i=1; i <= cols; i++) {
            Var var = exec.findVariable(ctx.L_ID(i).getText());
            if(var != null) {
              var.setValue(rs, rsm, i);
              if(trace) {
                trace(ctx, "COLUMN: " + rsm.getColumnName(i) + ", " + rsm.getColumnTypeName(i));
                trace(ctx, "SET " + var.getName() + " = " + var.toString());
              }            
            } 
            else if(trace) {
              trace(ctx, "Variable not found: " + ctx.L_ID(i).getText());
            }
          }
          exec.incRowCount();
          exec.setSqlSuccess();
        }
        else {
          exec.setSqlCode(100);
        }
      }
      else {
        exec.setSqlCode(-1);
      }
    } 
    catch (SQLException e) {
      exec.setSqlCode(e);
      exec.signal(Signal.Type.SQLEXCEPTION, e.getMessage(), e);
    } 
    return 0; 
  }  
  
  /**
   * CLOSE cursor statement
   */
  public Integer close(HplsqlParser.Close_stmtContext ctx) { 
    trace(ctx, "CLOSE");
    String name = ctx.L_ID().toString();
    Var var = exec.findVariable(name);
    if(var != null && var.type == Type.CURSOR) {
      exec.closeQuery((Query)var.value, exec.conf.defaultConnection);
      exec.setSqlCode(0);
    }
    else if(trace) {
      trace(ctx, "Cursor not found: " + name);
    }
    return 0; 
  }
  
  /**
   * INCLUDE statement
   */
  public Integer include(HplsqlParser.Include_stmtContext ctx) {
    String file = ctx.file_name().getText();
    trace(ctx, "INCLUDE " + file);
    exec.includeFile(file);
    return 0; 
  }
  
  /**
   * IF statement (PL/SQL syntax)
   */
  public Integer ifPlsql(HplsqlParser.If_plsql_stmtContext ctx) {
    boolean trueExecuted = false;
    trace(ctx, "IF");
    if (evalPop(ctx.bool_expr()).isTrue()) {
      trace(ctx, "IF TRUE executed");
      visit(ctx.block());
      trueExecuted = true;
    }
    else if (ctx.elseif_block() != null) {
      int cnt = ctx.elseif_block().size();
      for (int i = 0; i < cnt; i++) {
        if (evalPop(ctx.elseif_block(i).bool_expr()).isTrue()) {
          trace(ctx, "ELSE IF executed");
          visit(ctx.elseif_block(i).block());
          trueExecuted = true;
          break;
        }
      }
    }
    if (!trueExecuted && ctx.else_block() != null) {
      trace(ctx, "ELSE executed");
      visit(ctx.else_block());
    }
    return 0; 
  }
  
  /**
   * IF statement (Transact-SQL syntax)
   */
  public Integer ifTsql(HplsqlParser.If_tsql_stmtContext ctx) {
    trace(ctx, "IF");
    visit(ctx.bool_expr());
    if(exec.stackPop().isTrue()) {
      trace(ctx, "IF TRUE executed");
      visit(ctx.single_block_stmt(0));
    }
    else if(ctx.T_ELSE() != null) {
      trace(ctx, "ELSE executed");
      visit(ctx.single_block_stmt(1));
    }
    return 0; 
  }
  
  /**
   * Assignment from SELECT statement 
   */
  public Integer assignFromSelect(HplsqlParser.Assignment_stmt_select_itemContext ctx) { 
    String sql = evalPop(ctx.select_stmt()).toString();
    if (trace) {
      trace(ctx, sql.toString());
    }
    String conn = exec.getStatementConnection();
    Query query = exec.executeQuery(ctx, sql.toString(), conn);
    if (query.error()) { 
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    try {
      ResultSet rs = query.getResultSet();
      ResultSetMetaData rm = null;
      if (rs != null) {
        rm = rs.getMetaData();
        int cnt = ctx.ident().size();
        if (rs.next()) {
          for (int i = 1; i <= cnt; i++) {
            Var var = exec.findVariable(ctx.ident(i-1).getText());
            if (var != null) {
              var.setValue(rs, rm, i);
              if (trace) {
                trace(ctx, "COLUMN: " + rm.getColumnName(i) + ", " + rm.getColumnTypeName(i));
                trace(ctx, "SET " + var.getName() + " = " + var.toString());
              }             
            } 
            else if(trace) {
              trace(ctx, "Variable not found: " + ctx.ident(i-1).getText());
            }
          }
          exec.incRowCount();
          exec.setSqlSuccess();
        }
        else {
          exec.setSqlCode(100);
          exec.signal(Signal.Type.NOTFOUND);
        }
      }
    }
    catch (SQLException e) {
      exec.signal(query);
      return 1;
    }
    finally {
      exec.closeQuery(query, conn);
    }
    return 0; 
  }
  
  /**
   * SQL INSERT statement
   */
  public Integer insert(HplsqlParser.Insert_stmtContext ctx) {
    exec.stmtConnList.clear();
    if (ctx.select_stmt() != null) {
      return insertSelect(ctx);
    }
    return insertValues(ctx); 
  }
  
  /**
   * SQL INSERT SELECT statement
   */
  public Integer insertSelect(HplsqlParser.Insert_stmtContext ctx) { 
    trace(ctx, "INSERT SELECT");
    String table = evalPop(ctx.table_name()).toString();
    String select = evalPop(ctx.select_stmt()).toString();
    String sql = "INSERT INTO TABLE " + table + " " + select;    
    trace(ctx, sql);
    Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0; 
  }
  
  /**
   * SQL INSERT VALUES statement
   */
  public Integer insertValues(HplsqlParser.Insert_stmtContext ctx) { 
    trace(ctx, "INSERT VALUES");
    String table = evalPop(ctx.table_name()).toString();
    String conn = exec.getObjectConnection(ctx.table_name().getText());
    Conn.Type type = exec.getConnectionType(conn); 
    StringBuilder sql = new StringBuilder();
    if (type == Conn.Type.HIVE) {
      sql.append("INSERT INTO TABLE " + table + " ");
      if (conf.insertValues == Conf.InsertValues.NATIVE) {
        sql.append("VALUES\n("); 
      }
    }
    else {
      sql.append("INSERT INTO " + table);
      if (ctx.insert_stmt_cols() != null) {
        sql.append(" " + exec.getFormattedText(ctx.insert_stmt_cols()));
      }
      sql.append(" VALUES\n("); 
    }
    int rows = ctx.insert_stmt_rows().insert_stmt_row().size();
    for (int i = 0; i < rows; i++) {
      HplsqlParser.Insert_stmt_rowContext row =ctx.insert_stmt_rows().insert_stmt_row(i);
      int cols = row.expr().size();
      for (int j = 0; j < cols; j++) {         
        String value = evalPop(row.expr(j)).toSqlString();
        if (j == 0 && type == Conn.Type.HIVE && conf.insertValues == Conf.InsertValues.SELECT ) {
          sql.append("SELECT ");
        }
        sql.append(value);
        if (j + 1 != cols) {
          sql.append(", ");
        }       
      }
      if (type != Conn.Type.HIVE || conf.insertValues == Conf.InsertValues.NATIVE) {
        if (i + 1 == rows) {
          sql.append(")");
        } else {
          sql.append("),\n(");
        } 
      }
      else if (type == Conn.Type.HIVE && conf.insertValues == Conf.InsertValues.SELECT) {
        sql.append(" FROM " + conf.dualTable); 
        if (i + 1 < rows) {
          sql.append("\nUNION ALL\n");
        }
      }      
    }    
    if (trace) {
      trace(ctx, sql.toString());
    }
    Query query = exec.executeSql(ctx, sql.toString(), conn);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0; 
  }
  
  /**
   * GET DIAGNOSTICS EXCEPTION statement
   */
  public Integer getDiagnosticsException(HplsqlParser.Get_diag_stmt_exception_itemContext ctx) {
    trace(ctx, "GET DIAGNOSTICS EXCEPTION");
    Signal signal = exec.signalPeek();
    if (signal == null || (signal != null && signal.type != Signal.Type.SQLEXCEPTION)) {
      signal = exec.currentSignal;
    }
    if (signal != null) {
      exec.setVariable(ctx.ident().getText(), signal.getValue());
    }
    return 0; 
  }
  
  /**
   * GET DIAGNOSTICS ROW_COUNT statement
   */
  public Integer getDiagnosticsRowCount(HplsqlParser.Get_diag_stmt_rowcount_itemContext ctx) {
    trace(ctx, "GET DIAGNOSTICS ROW_COUNT");
    exec.setVariable(ctx.ident().getText(), exec.getRowCount());
    return 0;  
  }
  
  /**
   * USE statement
   */
  public Integer use(HplsqlParser.Use_stmtContext ctx) {
    if(trace) {
      trace(ctx, "USE");
    }
    String sql = ctx.T_USE().toString() + " " + evalPop(ctx.expr()).toString();
    if(trace) {
      trace(ctx, "Query: " + sql);
    }    
    Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
    if(query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlCode(0);
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0; 
  }
  
  /** 
   * VALUES statement
   */
  public Integer values(HplsqlParser.Values_into_stmtContext ctx) { 
    trace(ctx, "VALUES statement");    
    int cnt = ctx.ident().size();        // Number of variables and assignment expressions
    int ecnt = ctx.expr().size();    
    for (int i = 0; i < cnt; i++) {
      String name = ctx.ident(i).getText();      
      if (i < ecnt) {
        visit(ctx.expr(i));
        Var var = exec.setVariable(name);        
        if (trace) {
          trace(ctx, "SET " + name + " = " + var.toString());      
        } 
      }      
    }    
    return 0; 
  } 
  
  /**
   * WHILE statement
   */
  public Integer while_(HplsqlParser.While_stmtContext ctx) {
    trace(ctx, "WHILE - ENTERED");
    String label = exec.labelPop();
    while (true) {
      if (evalPop(ctx.bool_expr()).isTrue()) {
        exec.enterScope(Scope.Type.LOOP);
        visit(ctx.block());
        exec.leaveScope();        
        if (canContinue(label)) {
          continue;
        }
      }
      break;
    }    
    trace(ctx, "WHILE - LEFT");
    return 0; 
  }
  
  /**
   * FOR cursor statement
   */
  public Integer forCursor(HplsqlParser.For_cursor_stmtContext ctx) { 
    trace(ctx, "FOR CURSOR - ENTERED");
    exec.enterScope(Scope.Type.LOOP);
    String cursor = ctx.L_ID().getText();
    String sql = evalPop(ctx.select_stmt()).toString();   
    trace(ctx, sql);
    Query query = exec.executeQuery(ctx, sql, exec.conf.defaultConnection);
    if (query.error()) { 
      exec.signal(query);
      return 1;
    }
    trace(ctx, "SELECT completed successfully");
    exec.setSqlSuccess();
    try {
      ResultSet rs = query.getResultSet();
      if (rs != null) {
        ResultSetMetaData rm = rs.getMetaData();
        int cols = rm.getColumnCount();
        Var[] vars = new Var[cols];
        for (int i = 0; i < cols; i++) {
          vars[i] = new Var();
          vars[i].setName(cursor + "." + rm.getColumnName(i + 1));
          vars[i].setType(rm.getColumnType(i + 1));          
          exec.addVariable(vars[i]);
          if (trace) {
            trace(ctx, "Column: " + vars[i].getName() + " " + rm.getColumnTypeName(i + 1));
          }
        }                
        while (rs.next()) {
          for (int i = 0; i < cols; i++) {
            vars[i].setValue(rs, rm, i + 1);
          }
          visit(ctx.block());
          exec.incRowCount();
        }
      }
    }
    catch (SQLException e) {
      exec.signal(e);
      exec.closeQuery(query, exec.conf.defaultConnection);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    exec.leaveScope();
    trace(ctx, "FOR CURSOR - LEFT");
    return 0; 
  }
  
  /**
   * FOR (integer range) statement
   */
  public Integer forRange(HplsqlParser.For_range_stmtContext ctx) { 
    trace(ctx, "FOR RANGE - ENTERED");
    int start = evalPop(ctx.expr(0)).intValue();
    int end = evalPop(ctx.expr(1)).intValue();
    int step = evalPop(ctx.expr(2), 1L).intValue();
    exec.enterScope(Scope.Type.LOOP);
    Var index = new Var(ctx.L_ID().getText(), new Long(start));       
    exec.addVariable(index);     
    if (ctx.T_REVERSE() == null) {
      for (int i = start; i <= end; i += step) {
        visit(ctx.block());
        index.increment(new Long(step));
      } 
    } else {
      for (int i = start; i >= end; i -= step) {
        visit(ctx.block());
        index.decrement(new Long(step));
      }    
    }
    exec.leaveScope();
    trace(ctx, "FOR RANGE - LEFT");
    return 0; 
  }  
  
  /**
   * EXEC, EXECUTE and EXECUTE IMMEDIATE statement to execute dynamic SQL
   */
  public Integer exec(HplsqlParser.Exec_stmtContext ctx) { 
    if(trace) {
      trace(ctx, "EXECUTE");
    }
    Var vsql = evalPop(ctx.expr());
    String sql = vsql.toString();
    if(trace) {
      trace(ctx, "Query: " + sql);
    }
    Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
    if(query.error()) {
      exec.signal(query);
      return 1;
    }
    ResultSet rs = query.getResultSet();
    if(rs != null) {
      try {
        ResultSetMetaData rsm = rs.getMetaData();
        // Assign to variables
        if(ctx.T_INTO() != null) {
          int cols = ctx.L_ID().size();
          if(rs.next()) {
            for(int i=0; i < cols; i++) {
              Var var = exec.findVariable(ctx.L_ID(i).getText());
              if(var != null) {
                var.setValue(rs, rsm, i+1);
                if(trace) {
                  trace(ctx, "COLUMN: " + rsm.getColumnName(i+1) + ", " + rsm.getColumnTypeName(i+1));
                  trace(ctx, "SET " + var.getName() + " = " + var.toString());
                }
              } 
              else if(trace) {
                trace(ctx, "Variable not found: " + ctx.L_ID(i).getText());
              }
            }
            exec.setSqlCode(0);
          }
        }
        // Print the results
        else {
          int cols = rsm.getColumnCount();
          while(rs.next()) {
            for(int i = 1; i <= cols; i++) {
              if(i > 1) {
                System.out.print("\t");
              }
              System.out.print(rs.getString(i));
            }
            System.out.println("");
          }
        }
      } 
      catch(SQLException e) {
        exec.setSqlCode(e);
      } 
    }   
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0; 
  }
      
  /**
   * EXIT statement (leave the specified loop with a condition)
   */
  public Integer exit(HplsqlParser.Exit_stmtContext ctx) { 
    trace(ctx, "EXIT");
    String label = "";
    if (ctx.L_ID() != null) {
      label = ctx.L_ID().toString();
    }
    if (ctx.T_WHEN() != null) {
      if (evalPop(ctx.bool_expr()).isTrue()) {
        leaveLoop(label);
      }
    } else {
      leaveLoop(label);
    }
    return 0;
  }
  
  /**
   * BREAK statement (leave the innermost loop unconditionally)
   */
  public Integer break_(HplsqlParser.Break_stmtContext ctx) { 
    trace(ctx, "BREAK");
    leaveLoop("");
    return 0;
  }
  
  /**
   * LEAVE statement (leave the specified loop unconditionally)
   */
  public Integer leave(HplsqlParser.Leave_stmtContext ctx) { 
    trace(ctx, "LEAVE");
    String label = "";
    if (ctx.L_ID() != null) {
      label = ctx.L_ID().toString();
    }
    leaveLoop(label);    
    return 0;
  }
  
  /**
   * Leave the specified or innermost loop unconditionally
   */
  public void leaveLoop(String value) { 
    exec.signal(Signal.Type.LEAVE_LOOP, value);
  }
  
  /**
   * UPDATE statement
   */
  public Integer update(HplsqlParser.Update_stmtContext ctx) {
    trace(ctx, "UPDATE");
    String sql = exec.getFormattedText(ctx);
    trace(ctx, sql);
    Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0;
  }
  
  /**
   * DELETE statement
   */
  public Integer delete(HplsqlParser.Delete_stmtContext ctx) {
    trace(ctx, "DELETE");
    String table = evalPop(ctx.table_name()).toString();
    StringBuilder sql = new StringBuilder();
    sql.append("DELETE FROM ");
    sql.append(table);
    if (ctx.where_clause() != null) {
      boolean oldBuildSql = exec.buildSql; 
      exec.buildSql = true;
      sql.append(" " + evalPop(ctx.where_clause()).toString());
      exec.buildSql = oldBuildSql;
    }
    trace(ctx, sql.toString());
    Query query = exec.executeSql(ctx, sql.toString(), exec.conf.defaultConnection);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0;
  }
  
  /**
   * MERGE statement
   */
  public Integer merge(HplsqlParser.Merge_stmtContext ctx) {
    trace(ctx, "MERGE");
    String sql = exec.getFormattedText(ctx);
    trace(ctx, sql);
    Query query = exec.executeSql(ctx, sql, exec.conf.defaultConnection);
    if (query.error()) {
      exec.signal(query);
      return 1;
    }
    exec.setSqlSuccess();
    exec.closeQuery(query, exec.conf.defaultConnection);
    return 0;
  }
  
  /**
   * PRINT Statement 
   */
  public Integer print(HplsqlParser.Print_stmtContext ctx) { 
    trace(ctx, "PRINT");
    if (ctx.expr() != null) {
      visit(ctx.expr());
      System.out.println(stack.pop().toString());
    }
	  return 0; 
  }
  
  /**
   * SIGNAL statement
   */
  public Integer signal(HplsqlParser.Signal_stmtContext ctx) {
    trace(ctx, "SIGNAL");
    Signal signal = new Signal(Signal.Type.USERDEFINED, ctx.ident().getText());
    exec.signal(signal);
    return 0; 
  }  
  
  /**
   * RESIGNAL statement
   */
  public Integer resignal(HplsqlParser.Resignal_stmtContext ctx) { 
    trace(ctx, "RESIGNAL");
    if (ctx.T_SQLSTATE() != null) {
      String sqlstate = evalPop(ctx.expr(0)).toString();
      String text = "";
      if (ctx.T_MESSAGE_TEXT() != null) {
        text = evalPop(ctx.expr(1)).toString();
      }
      SQLException exception = new SQLException(text, sqlstate, -1);
      Signal signal = new Signal(Signal.Type.SQLEXCEPTION, text, exception);
      exec.setSqlCode(exception);
      exec.resignal(signal);
    }
    else {
      exec.resignal();
    }
    return 0; 
  }
  
  /**
   * RETURN statement
   */
  public Integer return_(HplsqlParser.Return_stmtContext ctx) {
    trace(ctx, "RETURN");
    if (ctx.expr() != null) {
      eval(ctx.expr());
    }
    exec.signal(Signal.Type.LEAVE_ROUTINE);    
    return 0; 
  }  
  
  /**
   * Check if an exception is raised or EXIT executed, and we should leave the block
   */
  boolean canContinue(String label) {
    Signal signal = exec.signalPeek();
    if (signal != null && signal.type == Signal.Type.SQLEXCEPTION) {
      return false;
    }
    signal = exec.signalPeek();
    if (signal != null && signal.type == Signal.Type.LEAVE_LOOP) {
      if (signal.value == null || signal.value.isEmpty() ||
          (label != null && label.equalsIgnoreCase(signal.value))) {
        exec.signalPop();
      }
      return false;
    }
    return true;     
  }
  
  /**
   * Evaluate the expression and push the value to the stack
   */
  void eval(ParserRuleContext ctx) {
    exec.visit(ctx);
  }
  
  /**
   * Evaluate the expression to specified String value
   */
  void evalString(String string) {
    exec.stackPush(new Var(string)); 
  }
  
  void evalString(StringBuilder string) {
    evalString(string.toString()); 
  }
  
  /**
   * Evaluate the expression and pop value from the stack
   */
  Var evalPop(ParserRuleContext ctx) {
    visit(ctx);
    if (!exec.stack.isEmpty()) { 
      return exec.stackPop();
    }
    return Var.Empty;
  }
  
  Var evalPop(ParserRuleContext ctx, long def) {
    if (ctx != null) {
      exec.visit(ctx);
      return exec.stackPop();
    }
    return new Var(def);
  }
  
  /**
   * Execute rules
   */
  Integer visit(ParserRuleContext ctx) {
    return exec.visit(ctx);  
  } 
  
  /**
   * Execute children rules
   */
  Integer visitChildren(ParserRuleContext ctx) {
	  return exec.visitChildren(ctx);  
  }  
  
  /**
   * Trace information
   */
  void trace(ParserRuleContext ctx, String message) {
	  exec.trace(ctx, message);
  }
}


File: hplsql/src/main/java/org/apache/hive/hplsql/Var.java
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hive.hplsql;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Date;
import java.sql.Timestamp;

/**
 * Variable or the result of expression 
 */
public class Var {

	// Data types
	public enum Type {BOOL, CURSOR, DATE, DEC, FILE, IDENT, BIGINT, INTERVAL, RS_LOCATOR, STRING, STRINGLIST, TIMESTAMP, NULL};
	public static Var Empty = new Var();
	public static Var Null = new Var(Type.NULL);
	
	public String name;
	public Type type; 
	public Object value;
	
	int len;
	int scale;
	
	public Var() {
	  type = Type.NULL;  
	}
	
	public Var(Var var) {
	  name = var.name;
    type = var.type;
    value = var.value;
    len = var.len;
    scale = var.scale;
  }
	
	public Var(Long value) {
    this.type = Type.BIGINT;
    this.value = value;
	}
	
	public Var(BigDecimal value) {
    this.type = Type.DEC;
    this.value = value;
  }
  
	public Var(String name, Long value) {
    this.type = Type.BIGINT;
    this.name = name;    
    this.value = value;
  }
  
	public Var(String value) {
    this.type = Type.STRING;
    this.value = value;
  }
  
	public Var(Date value) {
    this.type = Type.DATE;
    this.value = value;
  }

	public Var(Timestamp value, int scale) {
    this.type = Type.TIMESTAMP;
    this.value = value;
    this.scale = scale;
  }
	
	public Var(Interval value) {
    this.type = Type.INTERVAL;
    this.value = value;
  }

	public Var(ArrayList<String> value) {
    this.type = Type.STRINGLIST;
    this.value = value;
  }
  
	public Var(Boolean b) {
    type = Type.BOOL;
    value = b;
  }
	
	public Var(Type type, String name) {
    this.type = type;
    this.name = name;
  }
  
	public Var(Type type, Object value) {
    this.type = type;
    this.value = value;
  }
  
	public Var(String name, Type type, Object value) {
    this.name = name;
    this.type = type;
    this.value = value;
  }
	
	public Var(Type type) {
    this.type = type;
  }

	public Var(String name, String type, String len, String scale, Var def) {
	  this.name = name;
	  setType(type);	  
	  if (len != null) {
	    this.len = Integer.parseInt(len);
	  }
    if (scale != null) {
	    this.scale = Integer.parseInt(scale);
    }
    if (def != null) {
      cast(def);
    }
	}
	
	/**
	 * Cast a new value to the variable 
	 */
	public Var cast(Var val) {
	  if (val == null || val.value == null) {
	    value = null;
	  }
	  else if (type == val.type && type == Type.STRING) {
	    cast((String)val.value);
	  }
	  else if (type == val.type) {
	    value = val.value;
	  }
	  else if (type == Type.STRING) {
	    cast(val.toString());
	  }
	  else if (type == Type.DATE) {
	    value = Utils.toDate(val.toString());
    }
    else if (type == Type.TIMESTAMP) {
      value = Utils.toTimestamp(val.toString());
    }
	  return this;
	}

  /**
   * Cast a new string value to the variable 
   */
  public Var cast(String val) {
    if (type == Type.STRING) {
      if (len != 0 ) {
        int l = val.length();
        if (l > len) {
          value = val.substring(0, len);
          return this;
        }
      }
      value = val;
    }
    return this;
  }
	
	/**
	 * Set the new value 
	 */
	public void setValue(String str) {
	  if(type == Type.STRING) {
	    value = str;
	  }
	}
	
	public Var setValue(Long val) {
    if (type == Type.BIGINT) {
      value = val;
    }
    return this;
  }
	
	public void setValue(Object value) {
    this.value = value;
  }
	
	/**
   * Set the new value from a result set
   */
  public Var setValue(ResultSet rs, ResultSetMetaData rsm, int idx) throws SQLException {
    int type = rsm.getColumnType(idx);
    if (type == java.sql.Types.CHAR || type == java.sql.Types.VARCHAR) {
      cast(new Var(rs.getString(idx)));
    }
    else if (type == java.sql.Types.INTEGER || type == java.sql.Types.BIGINT) {
      cast(new Var(new Long(rs.getLong(idx))));
    }
    return this;
  }
	
	/**
	 * Set the data type from string representation
	 */
	void setType(String type) {
	  this.type = defineType(type);
	}
	
	/**
   * Set the data type from JDBC type code
   */
  void setType(int type) {
    this.type = defineType(type);
  }	
	
	/**
   * Define the data type from string representation
   */
  public static Type defineType(String type) {
    if (type == null) {
      return Type.NULL;
    }    
    else if (type.equalsIgnoreCase("INT") || type.equalsIgnoreCase("INTEGER")) {
      return Type.BIGINT;
    }
    else if (type.equalsIgnoreCase("CHAR") || type.equalsIgnoreCase("VARCHAR") || type.equalsIgnoreCase("STRING")) {
      return Type.STRING;
    }
    else if (type.equalsIgnoreCase("DATE")) {
      return Type.DATE;
    }
    else if (type.equalsIgnoreCase("TIMESTAMP")) {
      return Type.TIMESTAMP;
    }
    else if (type.equalsIgnoreCase("UTL_FILE.FILE_TYPE")) {
      return Type.FILE;
    }
    else if (type.toUpperCase().startsWith("RESULT_SET_LOCATOR")) {
      return Type.RS_LOCATOR;
    }
    return Type.NULL;
  }
  
  /**
   * Define the data type from JDBC type code
   */
  public static Type defineType(int type) {
    if (type == java.sql.Types.CHAR || type == java.sql.Types.VARCHAR) {
      return Type.STRING;
    }
    else if (type == java.sql.Types.INTEGER || type == java.sql.Types.BIGINT) {
      return Type.BIGINT;
    }
    return Type.NULL;
  }
	
	/**
	 * Remove value
	 */
	public void removeValue() {
	  type = Type.NULL;  
    name = null;
    value = null;
    len = 0;
    scale = 0;
	}
	
	/*
	 * Compare values
	 */
	@Override
  public boolean equals(Object obj) {
	  if (this == obj) {
      return true;
	  }
	  else if (obj == null || this.value == null) {
      return false;
    }
	  else if (getClass() != obj.getClass()) {
      return false;
	  }
	  
    Var var = (Var)obj;    
    if (type == Type.BIGINT && var.type == Type.BIGINT &&
       ((Long)value).longValue() == ((Long)var.value).longValue()) {
      return true;
    }
    else if (type == Type.STRING && var.type == Type.STRING &&
            ((String)value).equals((String)var.value)) {
      return true;
    }
    return false;
	}
	
	/*
   * Compare values
   */
  public int compareTo(Var v) {
    if (this == v) {
      return 0;
    }
    else if (v == null) {
      return -1;
    }
    else if (type == Type.BIGINT && v.type == Type.BIGINT) {
      return ((Long)value).compareTo((Long)v.value);
    }
    else if (type == Type.STRING && v.type == Type.STRING) {
      return ((String)value).compareTo((String)v.value);
    }
    return -1;
  }
	
	 /**
   * Increment an integer value
   */
  public Var increment(Long i) {
    if (type == Type.BIGINT) {
      value = new Long(((Long)value).longValue() + i);
    }
    return this;
  }

  /**
  * Decrement an integer value
  */
 public Var decrement(Long i) {
   if (type == Type.BIGINT) {
     value = new Long(((Long)value).longValue() - i);
   }
   return this;
 }
  
	/**
	 * Return an integer value
	 */
	public int intValue() {
	  if (type == Type.BIGINT) {
	    return ((Long)value).intValue();
	  }
	  return -1;
	}
	
	/**
	 * Return true/false for BOOL type
	 */
	public boolean isTrue() {
	  if(type == Type.BOOL && value != null) {
	    return ((Boolean)value).booleanValue();
	  }
	  return false;
	}
	
	/**
	 * Check if the variable contains NULL
	 */
	public boolean isNull() {
    if (type == Type.NULL || value == null) {
      return true;
    }
    return false;
  }
	
	/**
	 * Convert value to String
	 */
	@Override
  public String toString() {
	  if (type == Type.IDENT) {
      return name;
    }   
	  else if (value == null) {
	    return null;
	  }
	  else if (type == Type.BIGINT) {
	    return ((Long)value).toString();
	  }
	  else if (type == Type.STRING) {
      return (String)value;
    }
    else if (type == Type.DATE) {
      return ((Date)value).toString();
    }
    else if (type == Type.TIMESTAMP) {
      int len = 19;
      String t = ((Timestamp)value).toString();   // .0 returned if the fractional part not set
      if (scale > 0) {
        len += scale + 1;
      }
      if (t.length() > len) {
        t = t.substring(0, len);
      }
      return t;
    }
	  return value.toString();
	}

  /**
   * Convert value to SQL string - string literals are quoted and escaped, ab'c -> 'ab''c'
   */
  public String toSqlString() {
    if (value == null) {
      return "NULL";
    }
    else if (type == Type.STRING) {
      return Utils.quoteString((String)value);
    }
    return toString();
  }
	
  /**
   * Set variable name
   */
  public void setName(String name) {
    this.name = name;
  }
  
	/**
	 * Get variable name
	 */
	public String getName() {
	  return name;
	}
}
