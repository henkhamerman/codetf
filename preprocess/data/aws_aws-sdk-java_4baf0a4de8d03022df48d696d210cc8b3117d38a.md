Refactoring Types: ['Inline Method', 'Extract Method']
naws/services/cloudfront/AmazonCloudFront.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.cloudfront.model.*;

/**
 * Interface for accessing AmazonCloudFront.
 * 
 */
public interface AmazonCloudFront {

    /**
     * Overrides the default endpoint for this client ("https://cloudfront.amazonaws.com/").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "cloudfront.amazonaws.com/") or a full
     * URL, including the protocol (ex: "https://cloudfront.amazonaws.com/"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "cloudfront.amazonaws.com/") or a full URL,
     *            including the protocol (ex: "https://cloudfront.amazonaws.com/") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonCloudFront#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution service method on
     *           AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws NoSuchDistributionException
     * @throws DistributionNotDisabledException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteDistribution(DeleteDistributionRequest deleteDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the UpdateDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyCookieNamesInWhiteListException
     * @throws InvalidGeoRestrictionParameterException
     * @throws InvalidResponseCodeException
     * @throws TooManyHeadersInForwardedValuesException
     * @throws MissingBodyException
     * @throws TooManyDistributionCNAMEsException
     * @throws InvalidLocationCodeException
     * @throws NoSuchOriginException
     * @throws PreconditionFailedException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TooManyCacheBehaviorsException
     * @throws TooManyTrustedSignersException
     * @throws NoSuchDistributionException
     * @throws InvalidViewerCertificateException
     * @throws TooManyOriginsException
     * @throws InvalidRequiredProtocolException
     * @throws InvalidDefaultRootObjectException
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws InvalidForwardCookiesException
     * @throws InvalidHeadersForS3OriginException
     * @throws TrustedSignerDoesNotExistException
     * @throws TooManyCertificatesException
     * @throws InvalidRelativePathException
     * @throws InvalidErrorCodeException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateDistributionResult updateDistribution(UpdateDistributionRequest updateDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations service method on AmazonCloudFront.
     * 
     * @return The response from the ListInvalidations service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws InvalidArgumentException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListInvalidationsResult listInvalidations(ListInvalidationsRequest listInvalidationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * @return The response from the UpdateStreamingDistribution service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws MissingBodyException
     * @throws PreconditionFailedException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TrustedSignerDoesNotExistException
     * @throws TooManyTrustedSignersException
     * @throws NoSuchStreamingDistributionException
     * @throws TooManyStreamingDistributionCNAMEsException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateStreamingDistributionResult updateStreamingDistribution(UpdateStreamingDistributionRequest updateStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetStreamingDistribution service method,
     *         as returned by AmazonCloudFront.
     * 
     * @throws NoSuchStreamingDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStreamingDistributionResult getStreamingDistribution(GetStreamingDistributionRequest getStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws NoSuchStreamingDistributionException
     * @throws StreamingDistributionNotDisabledException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteStreamingDistribution(DeleteStreamingDistributionRequest deleteStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           service method on AmazonCloudFront.
     * 
     * @return The response from the GetCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCloudFrontOriginAccessIdentityResult getCloudFrontOriginAccessIdentity(GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws TooManyCloudFrontOriginAccessIdentitiesException
     * @throws MissingBodyException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws CloudFrontOriginAccessIdentityAlreadyExistsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateCloudFrontOriginAccessIdentityResult createCloudFrontOriginAccessIdentity(CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetDistributionConfig service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDistributionConfigResult getDistributionConfig(GetDistributionConfigRequest getDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the UpdateCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws MissingBodyException
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateCloudFrontOriginAccessIdentityResult updateCloudFrontOriginAccessIdentity(UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyCookieNamesInWhiteListException
     * @throws InvalidGeoRestrictionParameterException
     * @throws InvalidResponseCodeException
     * @throws TooManyHeadersInForwardedValuesException
     * @throws MissingBodyException
     * @throws TooManyDistributionCNAMEsException
     * @throws InvalidLocationCodeException
     * @throws TooManyDistributionsException
     * @throws NoSuchOriginException
     * @throws InconsistentQuantitiesException
     * @throws InvalidArgumentException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidOriginAccessIdentityException
     * @throws TooManyCacheBehaviorsException
     * @throws TooManyTrustedSignersException
     * @throws InvalidViewerCertificateException
     * @throws TooManyOriginsException
     * @throws DistributionAlreadyExistsException
     * @throws InvalidRequiredProtocolException
     * @throws InvalidDefaultRootObjectException
     * @throws InvalidProtocolSettingsException
     * @throws InvalidForwardCookiesException
     * @throws InvalidHeadersForS3OriginException
     * @throws TrustedSignerDoesNotExistException
     * @throws InvalidOriginException
     * @throws TooManyCertificatesException
     * @throws InvalidRelativePathException
     * @throws InvalidErrorCodeException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateDistributionResult createDistribution(CreateDistributionRequest createDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the ListCloudFrontOriginAccessIdentities
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListCloudFrontOriginAccessIdentitiesResult listCloudFrontOriginAccessIdentities(ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           service method on AmazonCloudFront.
     * 
     * @return The response from the GetStreamingDistributionConfig service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchStreamingDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStreamingDistributionConfigResult getStreamingDistributionConfig(GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetCloudFrontOriginAccessIdentityConfig
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCloudFrontOriginAccessIdentityConfigResult getCloudFrontOriginAccessIdentityConfig(GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateInvalidation service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyInvalidationsInProgressException
     * @throws MissingBodyException
     * @throws NoSuchDistributionException
     * @throws BatchTooLargeException
     * @throws AccessDeniedException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateInvalidationResult createInvalidation(CreateInvalidationRequest createInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws CloudFrontOriginAccessIdentityInUseException
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteCloudFrontOriginAccessIdentity(DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions service method on AmazonCloudFront.
     * 
     * @return The response from the ListDistributions service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListDistributionsResult listDistributions(ListDistributionsRequest listDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation service method on AmazonCloudFront.
     * 
     * @return The response from the GetInvalidation service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchInvalidationException
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetInvalidationResult getInvalidation(GetInvalidationRequest getInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the ListStreamingDistributions service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListStreamingDistributionsResult listStreamingDistributions(ListStreamingDistributionsRequest listStreamingDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution service method on AmazonCloudFront.
     * 
     * @return The response from the GetDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDistributionResult getDistribution(GetDistributionRequest getDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * @return The response from the CreateStreamingDistribution service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws TooManyTrustedSignersException
     * @throws MissingBodyException
     * @throws TooManyStreamingDistributionCNAMEsException
     * @throws StreamingDistributionAlreadyExistsException
     * @throws CNAMEAlreadyExistsException
     * @throws AccessDeniedException
     * @throws TooManyStreamingDistributionsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TrustedSignerDoesNotExistException
     * @throws InvalidOriginException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateStreamingDistributionResult createStreamingDistribution(CreateStreamingDistributionRequest createStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/AmazonCloudFrontAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.cloudfront.model.*;

/**
 * Interface for accessing AmazonCloudFront asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * 
 */
public interface AmazonCloudFrontAsync extends AmazonCloudFront {
    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDistributionAsync(DeleteDistributionRequest deleteDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDistributionAsync(DeleteDistributionRequest deleteDistributionRequest,
            AsyncHandler<DeleteDistributionRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateDistributionResult> updateDistributionAsync(UpdateDistributionRequest updateDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateDistributionResult> updateDistributionAsync(UpdateDistributionRequest updateDistributionRequest,
            AsyncHandler<UpdateDistributionRequest, UpdateDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListInvalidations service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListInvalidationsResult> listInvalidationsAsync(ListInvalidationsRequest listInvalidationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListInvalidations service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListInvalidationsResult> listInvalidationsAsync(ListInvalidationsRequest listInvalidationsRequest,
            AsyncHandler<ListInvalidationsRequest, ListInvalidationsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateStreamingDistributionResult> updateStreamingDistributionAsync(UpdateStreamingDistributionRequest updateStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateStreamingDistributionResult> updateStreamingDistributionAsync(UpdateStreamingDistributionRequest updateStreamingDistributionRequest,
            AsyncHandler<UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionResult> getStreamingDistributionAsync(GetStreamingDistributionRequest getStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionResult> getStreamingDistributionAsync(GetStreamingDistributionRequest getStreamingDistributionRequest,
            AsyncHandler<GetStreamingDistributionRequest, GetStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteStreamingDistributionAsync(DeleteStreamingDistributionRequest deleteStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteStreamingDistributionAsync(DeleteStreamingDistributionRequest deleteStreamingDistributionRequest,
            AsyncHandler<DeleteStreamingDistributionRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityResult> getCloudFrontOriginAccessIdentityAsync(GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityResult> getCloudFrontOriginAccessIdentityAsync(GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest,
            AsyncHandler<GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateCloudFrontOriginAccessIdentityResult> createCloudFrontOriginAccessIdentityAsync(CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateCloudFrontOriginAccessIdentityResult> createCloudFrontOriginAccessIdentityAsync(CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest,
            AsyncHandler<CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistributionConfig service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionConfigResult> getDistributionConfigAsync(GetDistributionConfigRequest getDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistributionConfig service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionConfigResult> getDistributionConfigAsync(GetDistributionConfigRequest getDistributionConfigRequest,
            AsyncHandler<GetDistributionConfigRequest, GetDistributionConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateCloudFrontOriginAccessIdentityResult> updateCloudFrontOriginAccessIdentityAsync(UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateCloudFrontOriginAccessIdentityResult> updateCloudFrontOriginAccessIdentityAsync(UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest,
            AsyncHandler<UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateDistributionResult> createDistributionAsync(CreateDistributionRequest createDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateDistributionResult> createDistributionAsync(CreateDistributionRequest createDistributionRequest,
            AsyncHandler<CreateDistributionRequest, CreateDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListCloudFrontOriginAccessIdentities service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListCloudFrontOriginAccessIdentitiesResult> listCloudFrontOriginAccessIdentitiesAsync(ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListCloudFrontOriginAccessIdentities service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListCloudFrontOriginAccessIdentitiesResult> listCloudFrontOriginAccessIdentitiesAsync(ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest,
            AsyncHandler<ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistributionConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionConfigResult> getStreamingDistributionConfigAsync(GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistributionConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionConfigResult> getStreamingDistributionConfigAsync(GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest,
            AsyncHandler<GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentityConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityConfigResult> getCloudFrontOriginAccessIdentityConfigAsync(GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentityConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityConfigResult> getCloudFrontOriginAccessIdentityConfigAsync(GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest,
            AsyncHandler<GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateInvalidationResult> createInvalidationAsync(CreateInvalidationRequest createInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateInvalidationResult> createInvalidationAsync(CreateInvalidationRequest createInvalidationRequest,
            AsyncHandler<CreateInvalidationRequest, CreateInvalidationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteCloudFrontOriginAccessIdentityAsync(DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteCloudFrontOriginAccessIdentityAsync(DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest,
            AsyncHandler<DeleteCloudFrontOriginAccessIdentityRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListDistributions service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDistributionsResult> listDistributionsAsync(ListDistributionsRequest listDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListDistributions service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDistributionsResult> listDistributionsAsync(ListDistributionsRequest listDistributionsRequest,
            AsyncHandler<ListDistributionsRequest, ListDistributionsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetInvalidationResult> getInvalidationAsync(GetInvalidationRequest getInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetInvalidationResult> getInvalidationAsync(GetInvalidationRequest getInvalidationRequest,
            AsyncHandler<GetInvalidationRequest, GetInvalidationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListStreamingDistributions service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListStreamingDistributionsResult> listStreamingDistributionsAsync(ListStreamingDistributionsRequest listStreamingDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListStreamingDistributions service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListStreamingDistributionsResult> listStreamingDistributionsAsync(ListStreamingDistributionsRequest listStreamingDistributionsRequest,
            AsyncHandler<ListStreamingDistributionsRequest, ListStreamingDistributionsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionResult> getDistributionAsync(GetDistributionRequest getDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionResult> getDistributionAsync(GetDistributionRequest getDistributionRequest,
            AsyncHandler<GetDistributionRequest, GetDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateStreamingDistributionResult> createStreamingDistributionAsync(CreateStreamingDistributionRequest createStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateStreamingDistributionResult> createStreamingDistributionAsync(CreateStreamingDistributionRequest createStreamingDistributionRequest,
            AsyncHandler<CreateStreamingDistributionRequest, CreateStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/AmazonCloudFrontAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.cloudfront.model.*;

/**
 * Asynchronous client for accessing AmazonCloudFront.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * 
 */
public class AmazonCloudFrontAsyncClient extends AmazonCloudFrontClient
        implements AmazonCloudFrontAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCloudFrontAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCloudFront
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCloudFrontAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonCloudFrontAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCloudFrontAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDistributionAsync(final DeleteDistributionRequest deleteDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteDistribution(deleteDistributionRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDistributionAsync(
            final DeleteDistributionRequest deleteDistributionRequest,
            final AsyncHandler<DeleteDistributionRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteDistribution(deleteDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteDistributionRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateDistributionResult> updateDistributionAsync(final UpdateDistributionRequest updateDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateDistributionResult>() {
            public UpdateDistributionResult call() throws Exception {
                return updateDistribution(updateDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateDistributionResult> updateDistributionAsync(
            final UpdateDistributionRequest updateDistributionRequest,
            final AsyncHandler<UpdateDistributionRequest, UpdateDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateDistributionResult>() {
            public UpdateDistributionResult call() throws Exception {
              UpdateDistributionResult result;
                try {
                result = updateDistribution(updateDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(updateDistributionRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListInvalidations service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListInvalidationsResult> listInvalidationsAsync(final ListInvalidationsRequest listInvalidationsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListInvalidationsResult>() {
            public ListInvalidationsResult call() throws Exception {
                return listInvalidations(listInvalidationsRequest);
        }
    });
    }

    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListInvalidations service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListInvalidationsResult> listInvalidationsAsync(
            final ListInvalidationsRequest listInvalidationsRequest,
            final AsyncHandler<ListInvalidationsRequest, ListInvalidationsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListInvalidationsResult>() {
            public ListInvalidationsResult call() throws Exception {
              ListInvalidationsResult result;
                try {
                result = listInvalidations(listInvalidationsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listInvalidationsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateStreamingDistributionResult> updateStreamingDistributionAsync(final UpdateStreamingDistributionRequest updateStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateStreamingDistributionResult>() {
            public UpdateStreamingDistributionResult call() throws Exception {
                return updateStreamingDistribution(updateStreamingDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateStreamingDistributionResult> updateStreamingDistributionAsync(
            final UpdateStreamingDistributionRequest updateStreamingDistributionRequest,
            final AsyncHandler<UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateStreamingDistributionResult>() {
            public UpdateStreamingDistributionResult call() throws Exception {
              UpdateStreamingDistributionResult result;
                try {
                result = updateStreamingDistribution(updateStreamingDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(updateStreamingDistributionRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionResult> getStreamingDistributionAsync(final GetStreamingDistributionRequest getStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStreamingDistributionResult>() {
            public GetStreamingDistributionResult call() throws Exception {
                return getStreamingDistribution(getStreamingDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionResult> getStreamingDistributionAsync(
            final GetStreamingDistributionRequest getStreamingDistributionRequest,
            final AsyncHandler<GetStreamingDistributionRequest, GetStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStreamingDistributionResult>() {
            public GetStreamingDistributionResult call() throws Exception {
              GetStreamingDistributionResult result;
                try {
                result = getStreamingDistribution(getStreamingDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getStreamingDistributionRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteStreamingDistributionAsync(final DeleteStreamingDistributionRequest deleteStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteStreamingDistribution(deleteStreamingDistributionRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteStreamingDistributionAsync(
            final DeleteStreamingDistributionRequest deleteStreamingDistributionRequest,
            final AsyncHandler<DeleteStreamingDistributionRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteStreamingDistribution(deleteStreamingDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteStreamingDistributionRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityResult> getCloudFrontOriginAccessIdentityAsync(final GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCloudFrontOriginAccessIdentityResult>() {
            public GetCloudFrontOriginAccessIdentityResult call() throws Exception {
                return getCloudFrontOriginAccessIdentity(getCloudFrontOriginAccessIdentityRequest);
        }
    });
    }

    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityResult> getCloudFrontOriginAccessIdentityAsync(
            final GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest,
            final AsyncHandler<GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCloudFrontOriginAccessIdentityResult>() {
            public GetCloudFrontOriginAccessIdentityResult call() throws Exception {
              GetCloudFrontOriginAccessIdentityResult result;
                try {
                result = getCloudFrontOriginAccessIdentity(getCloudFrontOriginAccessIdentityRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getCloudFrontOriginAccessIdentityRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateCloudFrontOriginAccessIdentityResult> createCloudFrontOriginAccessIdentityAsync(final CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateCloudFrontOriginAccessIdentityResult>() {
            public CreateCloudFrontOriginAccessIdentityResult call() throws Exception {
                return createCloudFrontOriginAccessIdentity(createCloudFrontOriginAccessIdentityRequest);
        }
    });
    }

    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateCloudFrontOriginAccessIdentityResult> createCloudFrontOriginAccessIdentityAsync(
            final CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest,
            final AsyncHandler<CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateCloudFrontOriginAccessIdentityResult>() {
            public CreateCloudFrontOriginAccessIdentityResult call() throws Exception {
              CreateCloudFrontOriginAccessIdentityResult result;
                try {
                result = createCloudFrontOriginAccessIdentity(createCloudFrontOriginAccessIdentityRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createCloudFrontOriginAccessIdentityRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistributionConfig service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionConfigResult> getDistributionConfigAsync(final GetDistributionConfigRequest getDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDistributionConfigResult>() {
            public GetDistributionConfigResult call() throws Exception {
                return getDistributionConfig(getDistributionConfigRequest);
        }
    });
    }

    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistributionConfig service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionConfigResult> getDistributionConfigAsync(
            final GetDistributionConfigRequest getDistributionConfigRequest,
            final AsyncHandler<GetDistributionConfigRequest, GetDistributionConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDistributionConfigResult>() {
            public GetDistributionConfigResult call() throws Exception {
              GetDistributionConfigResult result;
                try {
                result = getDistributionConfig(getDistributionConfigRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getDistributionConfigRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateCloudFrontOriginAccessIdentityResult> updateCloudFrontOriginAccessIdentityAsync(final UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateCloudFrontOriginAccessIdentityResult>() {
            public UpdateCloudFrontOriginAccessIdentityResult call() throws Exception {
                return updateCloudFrontOriginAccessIdentity(updateCloudFrontOriginAccessIdentityRequest);
        }
    });
    }

    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateCloudFrontOriginAccessIdentityResult> updateCloudFrontOriginAccessIdentityAsync(
            final UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest,
            final AsyncHandler<UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateCloudFrontOriginAccessIdentityResult>() {
            public UpdateCloudFrontOriginAccessIdentityResult call() throws Exception {
              UpdateCloudFrontOriginAccessIdentityResult result;
                try {
                result = updateCloudFrontOriginAccessIdentity(updateCloudFrontOriginAccessIdentityRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(updateCloudFrontOriginAccessIdentityRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateDistributionResult> createDistributionAsync(final CreateDistributionRequest createDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateDistributionResult>() {
            public CreateDistributionResult call() throws Exception {
                return createDistribution(createDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateDistributionResult> createDistributionAsync(
            final CreateDistributionRequest createDistributionRequest,
            final AsyncHandler<CreateDistributionRequest, CreateDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateDistributionResult>() {
            public CreateDistributionResult call() throws Exception {
              CreateDistributionResult result;
                try {
                result = createDistribution(createDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createDistributionRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListCloudFrontOriginAccessIdentities service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListCloudFrontOriginAccessIdentitiesResult> listCloudFrontOriginAccessIdentitiesAsync(final ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListCloudFrontOriginAccessIdentitiesResult>() {
            public ListCloudFrontOriginAccessIdentitiesResult call() throws Exception {
                return listCloudFrontOriginAccessIdentities(listCloudFrontOriginAccessIdentitiesRequest);
        }
    });
    }

    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListCloudFrontOriginAccessIdentities service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListCloudFrontOriginAccessIdentitiesResult> listCloudFrontOriginAccessIdentitiesAsync(
            final ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest,
            final AsyncHandler<ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListCloudFrontOriginAccessIdentitiesResult>() {
            public ListCloudFrontOriginAccessIdentitiesResult call() throws Exception {
              ListCloudFrontOriginAccessIdentitiesResult result;
                try {
                result = listCloudFrontOriginAccessIdentities(listCloudFrontOriginAccessIdentitiesRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listCloudFrontOriginAccessIdentitiesRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistributionConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionConfigResult> getStreamingDistributionConfigAsync(final GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStreamingDistributionConfigResult>() {
            public GetStreamingDistributionConfigResult call() throws Exception {
                return getStreamingDistributionConfig(getStreamingDistributionConfigRequest);
        }
    });
    }

    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStreamingDistributionConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStreamingDistributionConfigResult> getStreamingDistributionConfigAsync(
            final GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest,
            final AsyncHandler<GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStreamingDistributionConfigResult>() {
            public GetStreamingDistributionConfigResult call() throws Exception {
              GetStreamingDistributionConfigResult result;
                try {
                result = getStreamingDistributionConfig(getStreamingDistributionConfigRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getStreamingDistributionConfigRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentityConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityConfigResult> getCloudFrontOriginAccessIdentityConfigAsync(final GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCloudFrontOriginAccessIdentityConfigResult>() {
            public GetCloudFrontOriginAccessIdentityConfigResult call() throws Exception {
                return getCloudFrontOriginAccessIdentityConfig(getCloudFrontOriginAccessIdentityConfigRequest);
        }
    });
    }

    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCloudFrontOriginAccessIdentityConfig service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCloudFrontOriginAccessIdentityConfigResult> getCloudFrontOriginAccessIdentityConfigAsync(
            final GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest,
            final AsyncHandler<GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCloudFrontOriginAccessIdentityConfigResult>() {
            public GetCloudFrontOriginAccessIdentityConfigResult call() throws Exception {
              GetCloudFrontOriginAccessIdentityConfigResult result;
                try {
                result = getCloudFrontOriginAccessIdentityConfig(getCloudFrontOriginAccessIdentityConfigRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getCloudFrontOriginAccessIdentityConfigRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateInvalidationResult> createInvalidationAsync(final CreateInvalidationRequest createInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateInvalidationResult>() {
            public CreateInvalidationResult call() throws Exception {
                return createInvalidation(createInvalidationRequest);
        }
    });
    }

    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateInvalidationResult> createInvalidationAsync(
            final CreateInvalidationRequest createInvalidationRequest,
            final AsyncHandler<CreateInvalidationRequest, CreateInvalidationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateInvalidationResult>() {
            public CreateInvalidationResult call() throws Exception {
              CreateInvalidationResult result;
                try {
                result = createInvalidation(createInvalidationRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createInvalidationRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteCloudFrontOriginAccessIdentityAsync(final DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteCloudFrontOriginAccessIdentity(deleteCloudFrontOriginAccessIdentityRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteCloudFrontOriginAccessIdentity service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteCloudFrontOriginAccessIdentityAsync(
            final DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest,
            final AsyncHandler<DeleteCloudFrontOriginAccessIdentityRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteCloudFrontOriginAccessIdentity(deleteCloudFrontOriginAccessIdentityRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteCloudFrontOriginAccessIdentityRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListDistributions service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDistributionsResult> listDistributionsAsync(final ListDistributionsRequest listDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListDistributionsResult>() {
            public ListDistributionsResult call() throws Exception {
                return listDistributions(listDistributionsRequest);
        }
    });
    }

    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListDistributions service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDistributionsResult> listDistributionsAsync(
            final ListDistributionsRequest listDistributionsRequest,
            final AsyncHandler<ListDistributionsRequest, ListDistributionsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListDistributionsResult>() {
            public ListDistributionsResult call() throws Exception {
              ListDistributionsResult result;
                try {
                result = listDistributions(listDistributionsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listDistributionsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetInvalidationResult> getInvalidationAsync(final GetInvalidationRequest getInvalidationRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetInvalidationResult>() {
            public GetInvalidationResult call() throws Exception {
                return getInvalidation(getInvalidationRequest);
        }
    });
    }

    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetInvalidation service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetInvalidationResult> getInvalidationAsync(
            final GetInvalidationRequest getInvalidationRequest,
            final AsyncHandler<GetInvalidationRequest, GetInvalidationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetInvalidationResult>() {
            public GetInvalidationResult call() throws Exception {
              GetInvalidationResult result;
                try {
                result = getInvalidation(getInvalidationRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getInvalidationRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         ListStreamingDistributions service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListStreamingDistributionsResult> listStreamingDistributionsAsync(final ListStreamingDistributionsRequest listStreamingDistributionsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListStreamingDistributionsResult>() {
            public ListStreamingDistributionsResult call() throws Exception {
                return listStreamingDistributions(listStreamingDistributionsRequest);
        }
    });
    }

    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListStreamingDistributions service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListStreamingDistributionsResult> listStreamingDistributionsAsync(
            final ListStreamingDistributionsRequest listStreamingDistributionsRequest,
            final AsyncHandler<ListStreamingDistributionsRequest, ListStreamingDistributionsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListStreamingDistributionsResult>() {
            public ListStreamingDistributionsResult call() throws Exception {
              ListStreamingDistributionsResult result;
                try {
                result = listStreamingDistributions(listStreamingDistributionsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listStreamingDistributionsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution operation on AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionResult> getDistributionAsync(final GetDistributionRequest getDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDistributionResult>() {
            public GetDistributionResult call() throws Exception {
                return getDistribution(getDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution operation on AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDistribution service method, as returned by AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDistributionResult> getDistributionAsync(
            final GetDistributionRequest getDistributionRequest,
            final AsyncHandler<GetDistributionRequest, GetDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDistributionResult>() {
            public GetDistributionResult call() throws Exception {
              GetDistributionResult result;
                try {
                result = getDistribution(getDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getDistributionRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution operation on
     *           AmazonCloudFront.
     * 
     * @return A Java Future object containing the response from the
     *         CreateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateStreamingDistributionResult> createStreamingDistributionAsync(final CreateStreamingDistributionRequest createStreamingDistributionRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateStreamingDistributionResult>() {
            public CreateStreamingDistributionResult call() throws Exception {
                return createStreamingDistribution(createStreamingDistributionRequest);
        }
    });
    }

    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution operation on
     *           AmazonCloudFront.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateStreamingDistribution service method, as returned by
     *         AmazonCloudFront.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateStreamingDistributionResult> createStreamingDistributionAsync(
            final CreateStreamingDistributionRequest createStreamingDistributionRequest,
            final AsyncHandler<CreateStreamingDistributionRequest, CreateStreamingDistributionResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateStreamingDistributionResult>() {
            public CreateStreamingDistributionResult call() throws Exception {
              CreateStreamingDistributionResult result;
                try {
                result = createStreamingDistribution(createStreamingDistributionRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createStreamingDistributionRequest, result);
                 return result;
        }
    });
    }
    
}
        

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/AmazonCloudFrontClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront;

import org.w3c.dom.*;

import java.net.*;
import java.util.*;
import java.util.Map.Entry;

import com.amazonaws.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.regions.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;

import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.services.cloudfront.model.transform.*;

/**
 * Client for accessing AmazonCloudFront.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * 
 */
public class AmazonCloudFrontClient extends AmazonWebServiceClient implements AmazonCloudFront {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    /**
     * List of exception unmarshallers for all AmazonCloudFront exceptions.
     */
    protected final List<Unmarshaller<AmazonServiceException, Node>> exceptionUnmarshallers
            = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCloudFrontClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCloudFront
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCloudFrontClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonCloudFrontClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * and client configuration options.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCloudFront
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCloudFrontClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(clientConfiguration);
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials provider.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonCloudFrontClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCloudFront
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCloudFrontClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCloudFront using the specified AWS account credentials
     * provider, client configuration options, and request metric collector.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCloudFront
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonCloudFrontClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(clientConfiguration, requestMetricCollector);
        this.awsCredentialsProvider = awsCredentialsProvider;
        init();
    }

    private void init() {
        exceptionUnmarshallers.add(new TooManyCookieNamesInWhiteListExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyHeadersInForwardedValuesExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidLocationCodeExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyDistributionsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new PreconditionFailedExceptionUnmarshaller());
        exceptionUnmarshallers.add(new CNAMEAlreadyExistsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new CloudFrontOriginAccessIdentityInUseExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidViewerCertificateExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidHeadersForS3OriginExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TrustedSignerDoesNotExistExceptionUnmarshaller());
        exceptionUnmarshallers.add(new DistributionNotDisabledExceptionUnmarshaller());
        exceptionUnmarshallers.add(new BatchTooLargeExceptionUnmarshaller());
        exceptionUnmarshallers.add(new StreamingDistributionNotDisabledExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyStreamingDistributionsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidArgumentExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyTrustedSignersExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyOriginsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidRequiredProtocolExceptionUnmarshaller());
        exceptionUnmarshallers.add(new IllegalUpdateExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidErrorCodeExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyCloudFrontOriginAccessIdentitiesExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchOriginExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyCacheBehaviorsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchDistributionExceptionUnmarshaller());
        exceptionUnmarshallers.add(new DistributionAlreadyExistsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new CloudFrontOriginAccessIdentityAlreadyExistsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyInvalidationsInProgressExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidDefaultRootObjectExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidIfMatchVersionExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidOriginExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyCertificatesExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidRelativePathExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchInvalidationExceptionUnmarshaller());
        exceptionUnmarshallers.add(new StreamingDistributionAlreadyExistsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new AccessDeniedExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidGeoRestrictionParameterExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidResponseCodeExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MissingBodyExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyDistributionCNAMEsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchCloudFrontOriginAccessIdentityExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InconsistentQuantitiesExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidOriginAccessIdentityExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchStreamingDistributionExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidProtocolSettingsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidForwardCookiesExceptionUnmarshaller());
        exceptionUnmarshallers.add(new TooManyStreamingDistributionCNAMEsExceptionUnmarshaller());
        
        exceptionUnmarshallers.add(new StandardErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("cloudfront.amazonaws.com/");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/cloudfront/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/cloudfront/request.handler2s"));
    }

    /**
     * <p>
     * Delete a distribution.
     * </p>
     *
     * @param deleteDistributionRequest Container for the necessary
     *           parameters to execute the DeleteDistribution service method on
     *           AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws NoSuchDistributionException
     * @throws DistributionNotDisabledException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteDistribution(DeleteDistributionRequest deleteDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        Request<DeleteDistributionRequest> request = null;
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteDistributionRequestMarshaller().marshall(super.beforeMarshalling(deleteDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            invoke(request, null, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null);
        }
    }
    
    /**
     * <p>
     * Update a distribution.
     * </p>
     *
     * @param updateDistributionRequest Container for the necessary
     *           parameters to execute the UpdateDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the UpdateDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyCookieNamesInWhiteListException
     * @throws InvalidGeoRestrictionParameterException
     * @throws InvalidResponseCodeException
     * @throws TooManyHeadersInForwardedValuesException
     * @throws MissingBodyException
     * @throws TooManyDistributionCNAMEsException
     * @throws InvalidLocationCodeException
     * @throws NoSuchOriginException
     * @throws PreconditionFailedException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TooManyCacheBehaviorsException
     * @throws TooManyTrustedSignersException
     * @throws NoSuchDistributionException
     * @throws InvalidViewerCertificateException
     * @throws TooManyOriginsException
     * @throws InvalidRequiredProtocolException
     * @throws InvalidDefaultRootObjectException
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws InvalidForwardCookiesException
     * @throws InvalidHeadersForS3OriginException
     * @throws TrustedSignerDoesNotExistException
     * @throws TooManyCertificatesException
     * @throws InvalidRelativePathException
     * @throws InvalidErrorCodeException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateDistributionResult updateDistribution(UpdateDistributionRequest updateDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(updateDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateDistributionRequest> request = null;
        Response<UpdateDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateDistributionRequestMarshaller().marshall(super.beforeMarshalling(updateDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new UpdateDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * List invalidation batches.
     * </p>
     *
     * @param listInvalidationsRequest Container for the necessary parameters
     *           to execute the ListInvalidations service method on AmazonCloudFront.
     * 
     * @return The response from the ListInvalidations service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws InvalidArgumentException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListInvalidationsResult listInvalidations(ListInvalidationsRequest listInvalidationsRequest) {
        ExecutionContext executionContext = createExecutionContext(listInvalidationsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListInvalidationsRequest> request = null;
        Response<ListInvalidationsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListInvalidationsRequestMarshaller().marshall(super.beforeMarshalling(listInvalidationsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new ListInvalidationsResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Update a streaming distribution.
     * </p>
     *
     * @param updateStreamingDistributionRequest Container for the necessary
     *           parameters to execute the UpdateStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * @return The response from the UpdateStreamingDistribution service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws MissingBodyException
     * @throws PreconditionFailedException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TrustedSignerDoesNotExistException
     * @throws TooManyTrustedSignersException
     * @throws NoSuchStreamingDistributionException
     * @throws TooManyStreamingDistributionCNAMEsException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateStreamingDistributionResult updateStreamingDistribution(UpdateStreamingDistributionRequest updateStreamingDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(updateStreamingDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateStreamingDistributionRequest> request = null;
        Response<UpdateStreamingDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateStreamingDistributionRequestMarshaller().marshall(super.beforeMarshalling(updateStreamingDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new UpdateStreamingDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionRequest Container for the necessary
     *           parameters to execute the GetStreamingDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetStreamingDistribution service method,
     *         as returned by AmazonCloudFront.
     * 
     * @throws NoSuchStreamingDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStreamingDistributionResult getStreamingDistribution(GetStreamingDistributionRequest getStreamingDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(getStreamingDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetStreamingDistributionRequest> request = null;
        Response<GetStreamingDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetStreamingDistributionRequestMarshaller().marshall(super.beforeMarshalling(getStreamingDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetStreamingDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Delete a streaming distribution.
     * </p>
     *
     * @param deleteStreamingDistributionRequest Container for the necessary
     *           parameters to execute the DeleteStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws NoSuchStreamingDistributionException
     * @throws StreamingDistributionNotDisabledException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteStreamingDistribution(DeleteStreamingDistributionRequest deleteStreamingDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteStreamingDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        Request<DeleteStreamingDistributionRequest> request = null;
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteStreamingDistributionRequestMarshaller().marshall(super.beforeMarshalling(deleteStreamingDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            invoke(request, null, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null);
        }
    }
    
    /**
     * <p>
     * Get the information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the GetCloudFrontOriginAccessIdentity
     *           service method on AmazonCloudFront.
     * 
     * @return The response from the GetCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCloudFrontOriginAccessIdentityResult getCloudFrontOriginAccessIdentity(GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(getCloudFrontOriginAccessIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetCloudFrontOriginAccessIdentityRequest> request = null;
        Response<GetCloudFrontOriginAccessIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetCloudFrontOriginAccessIdentityRequestMarshaller().marshall(super.beforeMarshalling(getCloudFrontOriginAccessIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetCloudFrontOriginAccessIdentityResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Create a new origin access identity.
     * </p>
     *
     * @param createCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           CreateCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws TooManyCloudFrontOriginAccessIdentitiesException
     * @throws MissingBodyException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws CloudFrontOriginAccessIdentityAlreadyExistsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateCloudFrontOriginAccessIdentityResult createCloudFrontOriginAccessIdentity(CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(createCloudFrontOriginAccessIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateCloudFrontOriginAccessIdentityRequest> request = null;
        Response<CreateCloudFrontOriginAccessIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateCloudFrontOriginAccessIdentityRequestMarshaller().marshall(super.beforeMarshalling(createCloudFrontOriginAccessIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CreateCloudFrontOriginAccessIdentityResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the configuration information about a distribution.
     * </p>
     *
     * @param getDistributionConfigRequest Container for the necessary
     *           parameters to execute the GetDistributionConfig service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetDistributionConfig service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDistributionConfigResult getDistributionConfig(GetDistributionConfigRequest getDistributionConfigRequest) {
        ExecutionContext executionContext = createExecutionContext(getDistributionConfigRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetDistributionConfigRequest> request = null;
        Response<GetDistributionConfigResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetDistributionConfigRequestMarshaller().marshall(super.beforeMarshalling(getDistributionConfigRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetDistributionConfigResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Update an origin access identity.
     * </p>
     *
     * @param updateCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           UpdateCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the UpdateCloudFrontOriginAccessIdentity
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidIfMatchVersionException
     * @throws IllegalUpdateException
     * @throws MissingBodyException
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateCloudFrontOriginAccessIdentityResult updateCloudFrontOriginAccessIdentity(UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(updateCloudFrontOriginAccessIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateCloudFrontOriginAccessIdentityRequest> request = null;
        Response<UpdateCloudFrontOriginAccessIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateCloudFrontOriginAccessIdentityRequestMarshaller().marshall(super.beforeMarshalling(updateCloudFrontOriginAccessIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new UpdateCloudFrontOriginAccessIdentityResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Create a new distribution.
     * </p>
     *
     * @param createDistributionRequest Container for the necessary
     *           parameters to execute the CreateDistribution service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyCookieNamesInWhiteListException
     * @throws InvalidGeoRestrictionParameterException
     * @throws InvalidResponseCodeException
     * @throws TooManyHeadersInForwardedValuesException
     * @throws MissingBodyException
     * @throws TooManyDistributionCNAMEsException
     * @throws InvalidLocationCodeException
     * @throws TooManyDistributionsException
     * @throws NoSuchOriginException
     * @throws InconsistentQuantitiesException
     * @throws InvalidArgumentException
     * @throws CNAMEAlreadyExistsException
     * @throws InvalidOriginAccessIdentityException
     * @throws TooManyCacheBehaviorsException
     * @throws TooManyTrustedSignersException
     * @throws InvalidViewerCertificateException
     * @throws TooManyOriginsException
     * @throws DistributionAlreadyExistsException
     * @throws InvalidRequiredProtocolException
     * @throws InvalidDefaultRootObjectException
     * @throws InvalidProtocolSettingsException
     * @throws InvalidForwardCookiesException
     * @throws InvalidHeadersForS3OriginException
     * @throws TrustedSignerDoesNotExistException
     * @throws InvalidOriginException
     * @throws TooManyCertificatesException
     * @throws InvalidRelativePathException
     * @throws InvalidErrorCodeException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateDistributionResult createDistribution(CreateDistributionRequest createDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(createDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateDistributionRequest> request = null;
        Response<CreateDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateDistributionRequestMarshaller().marshall(super.beforeMarshalling(createDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CreateDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * List origin access identities.
     * </p>
     *
     * @param listCloudFrontOriginAccessIdentitiesRequest Container for the
     *           necessary parameters to execute the
     *           ListCloudFrontOriginAccessIdentities service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the ListCloudFrontOriginAccessIdentities
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListCloudFrontOriginAccessIdentitiesResult listCloudFrontOriginAccessIdentities(ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest) {
        ExecutionContext executionContext = createExecutionContext(listCloudFrontOriginAccessIdentitiesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListCloudFrontOriginAccessIdentitiesRequest> request = null;
        Response<ListCloudFrontOriginAccessIdentitiesResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListCloudFrontOriginAccessIdentitiesRequestMarshaller().marshall(super.beforeMarshalling(listCloudFrontOriginAccessIdentitiesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new ListCloudFrontOriginAccessIdentitiesResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the configuration information about a streaming distribution.
     * </p>
     *
     * @param getStreamingDistributionConfigRequest Container for the
     *           necessary parameters to execute the GetStreamingDistributionConfig
     *           service method on AmazonCloudFront.
     * 
     * @return The response from the GetStreamingDistributionConfig service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchStreamingDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStreamingDistributionConfigResult getStreamingDistributionConfig(GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest) {
        ExecutionContext executionContext = createExecutionContext(getStreamingDistributionConfigRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetStreamingDistributionConfigRequest> request = null;
        Response<GetStreamingDistributionConfigResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetStreamingDistributionConfigRequestMarshaller().marshall(super.beforeMarshalling(getStreamingDistributionConfigRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetStreamingDistributionConfigResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the configuration information about an origin access identity.
     * </p>
     *
     * @param getCloudFrontOriginAccessIdentityConfigRequest Container for
     *           the necessary parameters to execute the
     *           GetCloudFrontOriginAccessIdentityConfig service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the GetCloudFrontOriginAccessIdentityConfig
     *         service method, as returned by AmazonCloudFront.
     * 
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCloudFrontOriginAccessIdentityConfigResult getCloudFrontOriginAccessIdentityConfig(GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest) {
        ExecutionContext executionContext = createExecutionContext(getCloudFrontOriginAccessIdentityConfigRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetCloudFrontOriginAccessIdentityConfigRequest> request = null;
        Response<GetCloudFrontOriginAccessIdentityConfigResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetCloudFrontOriginAccessIdentityConfigRequestMarshaller().marshall(super.beforeMarshalling(getCloudFrontOriginAccessIdentityConfigRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetCloudFrontOriginAccessIdentityConfigResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Create a new invalidation.
     * </p>
     *
     * @param createInvalidationRequest Container for the necessary
     *           parameters to execute the CreateInvalidation service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the CreateInvalidation service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws TooManyInvalidationsInProgressException
     * @throws MissingBodyException
     * @throws NoSuchDistributionException
     * @throws BatchTooLargeException
     * @throws AccessDeniedException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateInvalidationResult createInvalidation(CreateInvalidationRequest createInvalidationRequest) {
        ExecutionContext executionContext = createExecutionContext(createInvalidationRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateInvalidationRequest> request = null;
        Response<CreateInvalidationResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateInvalidationRequestMarshaller().marshall(super.beforeMarshalling(createInvalidationRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CreateInvalidationResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Delete an origin access identity.
     * </p>
     *
     * @param deleteCloudFrontOriginAccessIdentityRequest Container for the
     *           necessary parameters to execute the
     *           DeleteCloudFrontOriginAccessIdentity service method on
     *           AmazonCloudFront.
     * 
     * 
     * @throws InvalidIfMatchVersionException
     * @throws CloudFrontOriginAccessIdentityInUseException
     * @throws NoSuchCloudFrontOriginAccessIdentityException
     * @throws PreconditionFailedException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteCloudFrontOriginAccessIdentity(DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteCloudFrontOriginAccessIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        Request<DeleteCloudFrontOriginAccessIdentityRequest> request = null;
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteCloudFrontOriginAccessIdentityRequestMarshaller().marshall(super.beforeMarshalling(deleteCloudFrontOriginAccessIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            invoke(request, null, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null);
        }
    }
    
    /**
     * <p>
     * List distributions.
     * </p>
     *
     * @param listDistributionsRequest Container for the necessary parameters
     *           to execute the ListDistributions service method on AmazonCloudFront.
     * 
     * @return The response from the ListDistributions service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListDistributionsResult listDistributions(ListDistributionsRequest listDistributionsRequest) {
        ExecutionContext executionContext = createExecutionContext(listDistributionsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListDistributionsRequest> request = null;
        Response<ListDistributionsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListDistributionsRequestMarshaller().marshall(super.beforeMarshalling(listDistributionsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new ListDistributionsResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the information about an invalidation.
     * </p>
     *
     * @param getInvalidationRequest Container for the necessary parameters
     *           to execute the GetInvalidation service method on AmazonCloudFront.
     * 
     * @return The response from the GetInvalidation service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchInvalidationException
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetInvalidationResult getInvalidation(GetInvalidationRequest getInvalidationRequest) {
        ExecutionContext executionContext = createExecutionContext(getInvalidationRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetInvalidationRequest> request = null;
        Response<GetInvalidationResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetInvalidationRequestMarshaller().marshall(super.beforeMarshalling(getInvalidationRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetInvalidationResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * List streaming distributions.
     * </p>
     *
     * @param listStreamingDistributionsRequest Container for the necessary
     *           parameters to execute the ListStreamingDistributions service method on
     *           AmazonCloudFront.
     * 
     * @return The response from the ListStreamingDistributions service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws InvalidArgumentException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListStreamingDistributionsResult listStreamingDistributions(ListStreamingDistributionsRequest listStreamingDistributionsRequest) {
        ExecutionContext executionContext = createExecutionContext(listStreamingDistributionsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListStreamingDistributionsRequest> request = null;
        Response<ListStreamingDistributionsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListStreamingDistributionsRequestMarshaller().marshall(super.beforeMarshalling(listStreamingDistributionsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new ListStreamingDistributionsResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Get the information about a distribution.
     * </p>
     *
     * @param getDistributionRequest Container for the necessary parameters
     *           to execute the GetDistribution service method on AmazonCloudFront.
     * 
     * @return The response from the GetDistribution service method, as
     *         returned by AmazonCloudFront.
     * 
     * @throws NoSuchDistributionException
     * @throws AccessDeniedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDistributionResult getDistribution(GetDistributionRequest getDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(getDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetDistributionRequest> request = null;
        Response<GetDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetDistributionRequestMarshaller().marshall(super.beforeMarshalling(getDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * Create a new streaming distribution.
     * </p>
     *
     * @param createStreamingDistributionRequest Container for the necessary
     *           parameters to execute the CreateStreamingDistribution service method
     *           on AmazonCloudFront.
     * 
     * @return The response from the CreateStreamingDistribution service
     *         method, as returned by AmazonCloudFront.
     * 
     * @throws TooManyTrustedSignersException
     * @throws MissingBodyException
     * @throws TooManyStreamingDistributionCNAMEsException
     * @throws StreamingDistributionAlreadyExistsException
     * @throws CNAMEAlreadyExistsException
     * @throws AccessDeniedException
     * @throws TooManyStreamingDistributionsException
     * @throws InvalidArgumentException
     * @throws InconsistentQuantitiesException
     * @throws InvalidOriginAccessIdentityException
     * @throws TrustedSignerDoesNotExistException
     * @throws InvalidOriginException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCloudFront indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateStreamingDistributionResult createStreamingDistribution(CreateStreamingDistributionRequest createStreamingDistributionRequest) {
        ExecutionContext executionContext = createExecutionContext(createStreamingDistributionRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateStreamingDistributionRequest> request = null;
        Response<CreateStreamingDistributionResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateStreamingDistributionRequestMarshaller().marshall(super.beforeMarshalling(createStreamingDistributionRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CreateStreamingDistributionResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            Unmarshaller<X, StaxUnmarshallerContext> unmarshaller,
            ExecutionContext executionContext)
    {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);
        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();

        AWSCredentials credentials = awsCredentialsProvider.getCredentials();
        if (originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        
        StaxResponseHandler<X> responseHandler = new StaxResponseHandler<X>(unmarshaller);
        DefaultErrorResponseHandler errorResponseHandler = new DefaultErrorResponseHandler(exceptionUnmarshallers);
        return client.execute(request, responseHandler, errorResponseHandler, executionContext);
    }
}
        

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/CacheBehavior.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model;

import java.io.Serializable;

/**
 * <p>
 * A complex type that describes how CloudFront processes requests. You
 * can create up to 10 cache behaviors.You must create at least as many
 * cache behaviors (including the default cache behavior) as you have
 * origins if you want CloudFront to distribute objects from all of the
 * origins. Each cache behavior specifies the one origin from which you
 * want CloudFront to get objects. If you have two origins and only the
 * default cache behavior, the default cache behavior will cause
 * CloudFront to get objects from one of the origins, but the other
 * origin will never be used. If you don't want to specify any cache
 * behaviors, include only an empty CacheBehaviors element. Don't include
 * an empty CacheBehavior element, or CloudFront returns a MalformedXML
 * error. To delete all cache behaviors in an existing distribution,
 * update the distribution configuration and include only an empty
 * CacheBehaviors element. To add, change, or remove one or more cache
 * behaviors, update the distribution configuration and specify all of
 * the cache behaviors that you want to include in the updated
 * distribution.
 * </p>
 */
public class CacheBehavior implements Serializable, Cloneable {

    /**
     * The pattern (for example, images/*.jpg) that specifies which requests
     * you want this cache behavior to apply to. When CloudFront receives an
     * end-user request, the requested path is compared with path patterns in
     * the order in which cache behaviors are listed in the distribution. The
     * path pattern for the default cache behavior is * and cannot be
     * changed. If the request for an object does not match the path pattern
     * for any cache behaviors, CloudFront applies the behavior in the
     * default cache behavior.
     */
    private String pathPattern;

    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     */
    private String targetOriginId;

    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     */
    private ForwardedValues forwardedValues;

    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     */
    private TrustedSigners trustedSigners;

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     */
    private String viewerProtocolPolicy;

    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     */
    private Long minTTL;

    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     */
    private AllowedMethods allowedMethods;

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     */
    private Boolean smoothStreaming;

    /**
     * The pattern (for example, images/*.jpg) that specifies which requests
     * you want this cache behavior to apply to. When CloudFront receives an
     * end-user request, the requested path is compared with path patterns in
     * the order in which cache behaviors are listed in the distribution. The
     * path pattern for the default cache behavior is * and cannot be
     * changed. If the request for an object does not match the path pattern
     * for any cache behaviors, CloudFront applies the behavior in the
     * default cache behavior.
     *
     * @return The pattern (for example, images/*.jpg) that specifies which requests
     *         you want this cache behavior to apply to. When CloudFront receives an
     *         end-user request, the requested path is compared with path patterns in
     *         the order in which cache behaviors are listed in the distribution. The
     *         path pattern for the default cache behavior is * and cannot be
     *         changed. If the request for an object does not match the path pattern
     *         for any cache behaviors, CloudFront applies the behavior in the
     *         default cache behavior.
     */
    public String getPathPattern() {
        return pathPattern;
    }
    
    /**
     * The pattern (for example, images/*.jpg) that specifies which requests
     * you want this cache behavior to apply to. When CloudFront receives an
     * end-user request, the requested path is compared with path patterns in
     * the order in which cache behaviors are listed in the distribution. The
     * path pattern for the default cache behavior is * and cannot be
     * changed. If the request for an object does not match the path pattern
     * for any cache behaviors, CloudFront applies the behavior in the
     * default cache behavior.
     *
     * @param pathPattern The pattern (for example, images/*.jpg) that specifies which requests
     *         you want this cache behavior to apply to. When CloudFront receives an
     *         end-user request, the requested path is compared with path patterns in
     *         the order in which cache behaviors are listed in the distribution. The
     *         path pattern for the default cache behavior is * and cannot be
     *         changed. If the request for an object does not match the path pattern
     *         for any cache behaviors, CloudFront applies the behavior in the
     *         default cache behavior.
     */
    public void setPathPattern(String pathPattern) {
        this.pathPattern = pathPattern;
    }
    
    /**
     * The pattern (for example, images/*.jpg) that specifies which requests
     * you want this cache behavior to apply to. When CloudFront receives an
     * end-user request, the requested path is compared with path patterns in
     * the order in which cache behaviors are listed in the distribution. The
     * path pattern for the default cache behavior is * and cannot be
     * changed. If the request for an object does not match the path pattern
     * for any cache behaviors, CloudFront applies the behavior in the
     * default cache behavior.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param pathPattern The pattern (for example, images/*.jpg) that specifies which requests
     *         you want this cache behavior to apply to. When CloudFront receives an
     *         end-user request, the requested path is compared with path patterns in
     *         the order in which cache behaviors are listed in the distribution. The
     *         path pattern for the default cache behavior is * and cannot be
     *         changed. If the request for an object does not match the path pattern
     *         for any cache behaviors, CloudFront applies the behavior in the
     *         default cache behavior.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withPathPattern(String pathPattern) {
        this.pathPattern = pathPattern;
        return this;
    }

    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     *
     * @return The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     */
    public String getTargetOriginId() {
        return targetOriginId;
    }
    
    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     *
     * @param targetOriginId The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     */
    public void setTargetOriginId(String targetOriginId) {
        this.targetOriginId = targetOriginId;
    }
    
    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param targetOriginId The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withTargetOriginId(String targetOriginId) {
        this.targetOriginId = targetOriginId;
        return this;
    }

    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     *
     * @return A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     */
    public ForwardedValues getForwardedValues() {
        return forwardedValues;
    }
    
    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     *
     * @param forwardedValues A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     */
    public void setForwardedValues(ForwardedValues forwardedValues) {
        this.forwardedValues = forwardedValues;
    }
    
    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param forwardedValues A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withForwardedValues(ForwardedValues forwardedValues) {
        this.forwardedValues = forwardedValues;
        return this;
    }

    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     *
     * @return A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     */
    public TrustedSigners getTrustedSigners() {
        return trustedSigners;
    }
    
    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     *
     * @param trustedSigners A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     */
    public void setTrustedSigners(TrustedSigners trustedSigners) {
        this.trustedSigners = trustedSigners;
    }
    
    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param trustedSigners A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withTrustedSigners(TrustedSigners trustedSigners) {
        this.trustedSigners = trustedSigners;
        return this;
    }

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @return Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public String getViewerProtocolPolicy() {
        return viewerProtocolPolicy;
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public void setViewerProtocolPolicy(String viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy;
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ViewerProtocolPolicy
     */
    public CacheBehavior withViewerProtocolPolicy(String viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy;
        return this;
    }

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public void setViewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy.toString();
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ViewerProtocolPolicy
     */
    public CacheBehavior withViewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy.toString();
        return this;
    }

    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     *
     * @return The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     */
    public Long getMinTTL() {
        return minTTL;
    }
    
    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     *
     * @param minTTL The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     */
    public void setMinTTL(Long minTTL) {
        this.minTTL = minTTL;
    }
    
    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param minTTL The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withMinTTL(Long minTTL) {
        this.minTTL = minTTL;
        return this;
    }

    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     *
     * @return A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     */
    public AllowedMethods getAllowedMethods() {
        return allowedMethods;
    }
    
    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     *
     * @param allowedMethods A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     */
    public void setAllowedMethods(AllowedMethods allowedMethods) {
        this.allowedMethods = allowedMethods;
    }
    
    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param allowedMethods A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withAllowedMethods(AllowedMethods allowedMethods) {
        this.allowedMethods = allowedMethods;
        return this;
    }

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @return Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public Boolean isSmoothStreaming() {
        return smoothStreaming;
    }
    
    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @param smoothStreaming Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public void setSmoothStreaming(Boolean smoothStreaming) {
        this.smoothStreaming = smoothStreaming;
    }
    
    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param smoothStreaming Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CacheBehavior withSmoothStreaming(Boolean smoothStreaming) {
        this.smoothStreaming = smoothStreaming;
        return this;
    }

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @return Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public Boolean getSmoothStreaming() {
        return smoothStreaming;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getPathPattern() != null) sb.append("PathPattern: " + getPathPattern() + ",");
        if (getTargetOriginId() != null) sb.append("TargetOriginId: " + getTargetOriginId() + ",");
        if (getForwardedValues() != null) sb.append("ForwardedValues: " + getForwardedValues() + ",");
        if (getTrustedSigners() != null) sb.append("TrustedSigners: " + getTrustedSigners() + ",");
        if (getViewerProtocolPolicy() != null) sb.append("ViewerProtocolPolicy: " + getViewerProtocolPolicy() + ",");
        if (getMinTTL() != null) sb.append("MinTTL: " + getMinTTL() + ",");
        if (getAllowedMethods() != null) sb.append("AllowedMethods: " + getAllowedMethods() + ",");
        if (isSmoothStreaming() != null) sb.append("SmoothStreaming: " + isSmoothStreaming() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getPathPattern() == null) ? 0 : getPathPattern().hashCode()); 
        hashCode = prime * hashCode + ((getTargetOriginId() == null) ? 0 : getTargetOriginId().hashCode()); 
        hashCode = prime * hashCode + ((getForwardedValues() == null) ? 0 : getForwardedValues().hashCode()); 
        hashCode = prime * hashCode + ((getTrustedSigners() == null) ? 0 : getTrustedSigners().hashCode()); 
        hashCode = prime * hashCode + ((getViewerProtocolPolicy() == null) ? 0 : getViewerProtocolPolicy().hashCode()); 
        hashCode = prime * hashCode + ((getMinTTL() == null) ? 0 : getMinTTL().hashCode()); 
        hashCode = prime * hashCode + ((getAllowedMethods() == null) ? 0 : getAllowedMethods().hashCode()); 
        hashCode = prime * hashCode + ((isSmoothStreaming() == null) ? 0 : isSmoothStreaming().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CacheBehavior == false) return false;
        CacheBehavior other = (CacheBehavior)obj;
        
        if (other.getPathPattern() == null ^ this.getPathPattern() == null) return false;
        if (other.getPathPattern() != null && other.getPathPattern().equals(this.getPathPattern()) == false) return false; 
        if (other.getTargetOriginId() == null ^ this.getTargetOriginId() == null) return false;
        if (other.getTargetOriginId() != null && other.getTargetOriginId().equals(this.getTargetOriginId()) == false) return false; 
        if (other.getForwardedValues() == null ^ this.getForwardedValues() == null) return false;
        if (other.getForwardedValues() != null && other.getForwardedValues().equals(this.getForwardedValues()) == false) return false; 
        if (other.getTrustedSigners() == null ^ this.getTrustedSigners() == null) return false;
        if (other.getTrustedSigners() != null && other.getTrustedSigners().equals(this.getTrustedSigners()) == false) return false; 
        if (other.getViewerProtocolPolicy() == null ^ this.getViewerProtocolPolicy() == null) return false;
        if (other.getViewerProtocolPolicy() != null && other.getViewerProtocolPolicy().equals(this.getViewerProtocolPolicy()) == false) return false; 
        if (other.getMinTTL() == null ^ this.getMinTTL() == null) return false;
        if (other.getMinTTL() != null && other.getMinTTL().equals(this.getMinTTL()) == false) return false; 
        if (other.getAllowedMethods() == null ^ this.getAllowedMethods() == null) return false;
        if (other.getAllowedMethods() != null && other.getAllowedMethods().equals(this.getAllowedMethods()) == false) return false; 
        if (other.isSmoothStreaming() == null ^ this.isSmoothStreaming() == null) return false;
        if (other.isSmoothStreaming() != null && other.isSmoothStreaming().equals(this.isSmoothStreaming()) == false) return false; 
        return true;
    }
    
    @Override
    public CacheBehavior clone() {
        try {
            return (CacheBehavior) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/DefaultCacheBehavior.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model;

import java.io.Serializable;

/**
 * <p>
 * A complex type that describes the default cache behavior if you do
 * not specify a CacheBehavior element or if files don't match any of the
 * values of PathPattern in CacheBehavior elements.You must create
 * exactly one default cache behavior.
 * </p>
 */
public class DefaultCacheBehavior implements Serializable, Cloneable {

    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     */
    private String targetOriginId;

    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     */
    private ForwardedValues forwardedValues;

    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     */
    private TrustedSigners trustedSigners;

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     */
    private String viewerProtocolPolicy;

    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     */
    private Long minTTL;

    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     */
    private AllowedMethods allowedMethods;

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     */
    private Boolean smoothStreaming;

    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     *
     * @return The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     */
    public String getTargetOriginId() {
        return targetOriginId;
    }
    
    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     *
     * @param targetOriginId The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     */
    public void setTargetOriginId(String targetOriginId) {
        this.targetOriginId = targetOriginId;
    }
    
    /**
     * The value of ID for the origin that you want CloudFront to route
     * requests to when a request matches the path pattern either for a cache
     * behavior or for the default cache behavior.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param targetOriginId The value of ID for the origin that you want CloudFront to route
     *         requests to when a request matches the path pattern either for a cache
     *         behavior or for the default cache behavior.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withTargetOriginId(String targetOriginId) {
        this.targetOriginId = targetOriginId;
        return this;
    }

    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     *
     * @return A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     */
    public ForwardedValues getForwardedValues() {
        return forwardedValues;
    }
    
    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     *
     * @param forwardedValues A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     */
    public void setForwardedValues(ForwardedValues forwardedValues) {
        this.forwardedValues = forwardedValues;
    }
    
    /**
     * A complex type that specifies how CloudFront handles query strings,
     * cookies and headers.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param forwardedValues A complex type that specifies how CloudFront handles query strings,
     *         cookies and headers.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withForwardedValues(ForwardedValues forwardedValues) {
        this.forwardedValues = forwardedValues;
        return this;
    }

    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     *
     * @return A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     */
    public TrustedSigners getTrustedSigners() {
        return trustedSigners;
    }
    
    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     *
     * @param trustedSigners A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     */
    public void setTrustedSigners(TrustedSigners trustedSigners) {
        this.trustedSigners = trustedSigners;
    }
    
    /**
     * A complex type that specifies the AWS accounts, if any, that you want
     * to allow to create signed URLs for private content. If you want to
     * require signed URLs in requests for objects in the target origin that
     * match the PathPattern for this cache behavior, specify true for
     * Enabled, and specify the applicable values for Quantity and Items. For
     * more information, go to Using a Signed URL to Serve Private Content in
     * the Amazon CloudFront Developer Guide. If you don't want to require
     * signed URLs in requests for objects that match PathPattern, specify
     * false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     * remove one or more trusted signers, change Enabled to true (if it's
     * currently false), change Quantity as applicable, and specify all of
     * the trusted signers that you want to include in the updated
     * distribution.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param trustedSigners A complex type that specifies the AWS accounts, if any, that you want
     *         to allow to create signed URLs for private content. If you want to
     *         require signed URLs in requests for objects in the target origin that
     *         match the PathPattern for this cache behavior, specify true for
     *         Enabled, and specify the applicable values for Quantity and Items. For
     *         more information, go to Using a Signed URL to Serve Private Content in
     *         the Amazon CloudFront Developer Guide. If you don't want to require
     *         signed URLs in requests for objects that match PathPattern, specify
     *         false for Enabled and 0 for Quantity. Omit Items. To add, change, or
     *         remove one or more trusted signers, change Enabled to true (if it's
     *         currently false), change Quantity as applicable, and specify all of
     *         the trusted signers that you want to include in the updated
     *         distribution.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withTrustedSigners(TrustedSigners trustedSigners) {
        this.trustedSigners = trustedSigners;
        return this;
    }

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @return Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public String getViewerProtocolPolicy() {
        return viewerProtocolPolicy;
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public void setViewerProtocolPolicy(String viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy;
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ViewerProtocolPolicy
     */
    public DefaultCacheBehavior withViewerProtocolPolicy(String viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy;
        return this;
    }

    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @see ViewerProtocolPolicy
     */
    public void setViewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy.toString();
    }
    
    /**
     * Use this element to specify the protocol that users can use to access
     * the files in the origin specified by TargetOriginId when a request
     * matches the path pattern in PathPattern. If you want CloudFront to
     * allow end users to use any available protocol, specify allow-all. If
     * you want CloudFront to require HTTPS, specify https. If you want
     * CloudFront to respond to an HTTP request with an HTTP status code of
     * 301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     * The viewer then resubmits the request using the HTTPS URL.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>allow-all, https-only, redirect-to-https
     *
     * @param viewerProtocolPolicy Use this element to specify the protocol that users can use to access
     *         the files in the origin specified by TargetOriginId when a request
     *         matches the path pattern in PathPattern. If you want CloudFront to
     *         allow end users to use any available protocol, specify allow-all. If
     *         you want CloudFront to require HTTPS, specify https. If you want
     *         CloudFront to respond to an HTTP request with an HTTP status code of
     *         301 (Moved Permanently) and the HTTPS URL, specify redirect-to-https.
     *         The viewer then resubmits the request using the HTTPS URL.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ViewerProtocolPolicy
     */
    public DefaultCacheBehavior withViewerProtocolPolicy(ViewerProtocolPolicy viewerProtocolPolicy) {
        this.viewerProtocolPolicy = viewerProtocolPolicy.toString();
        return this;
    }

    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     *
     * @return The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     */
    public Long getMinTTL() {
        return minTTL;
    }
    
    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     *
     * @param minTTL The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     */
    public void setMinTTL(Long minTTL) {
        this.minTTL = minTTL;
    }
    
    /**
     * The minimum amount of time that you want objects to stay in CloudFront
     * caches before CloudFront queries your origin to see whether the object
     * has been updated.You can specify a value from 0 to 3,153,600,000
     * seconds (100 years).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param minTTL The minimum amount of time that you want objects to stay in CloudFront
     *         caches before CloudFront queries your origin to see whether the object
     *         has been updated.You can specify a value from 0 to 3,153,600,000
     *         seconds (100 years).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withMinTTL(Long minTTL) {
        this.minTTL = minTTL;
        return this;
    }

    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     *
     * @return A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     */
    public AllowedMethods getAllowedMethods() {
        return allowedMethods;
    }
    
    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     *
     * @param allowedMethods A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     */
    public void setAllowedMethods(AllowedMethods allowedMethods) {
        this.allowedMethods = allowedMethods;
    }
    
    /**
     * A complex type that controls which HTTP methods CloudFront processes
     * and forwards to your Amazon S3 bucket or your custom origin. There are
     * three choices: - CloudFront forwards only GET and HEAD requests. -
     * CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     * forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     * you pick the third choice, you may need to restrict access to your
     * Amazon S3 bucket or to your custom origin so users can't perform
     * operations that you don't want them to. For example, you may not want
     * users to have permission to delete objects from your origin.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param allowedMethods A complex type that controls which HTTP methods CloudFront processes
     *         and forwards to your Amazon S3 bucket or your custom origin. There are
     *         three choices: - CloudFront forwards only GET and HEAD requests. -
     *         CloudFront forwards only GET, HEAD and OPTIONS requests. - CloudFront
     *         forwards GET, HEAD, OPTIONS, PUT, PATCH, POST, and DELETE requests. If
     *         you pick the third choice, you may need to restrict access to your
     *         Amazon S3 bucket or to your custom origin so users can't perform
     *         operations that you don't want them to. For example, you may not want
     *         users to have permission to delete objects from your origin.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withAllowedMethods(AllowedMethods allowedMethods) {
        this.allowedMethods = allowedMethods;
        return this;
    }

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @return Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public Boolean isSmoothStreaming() {
        return smoothStreaming;
    }
    
    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @param smoothStreaming Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public void setSmoothStreaming(Boolean smoothStreaming) {
        this.smoothStreaming = smoothStreaming;
    }
    
    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param smoothStreaming Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DefaultCacheBehavior withSmoothStreaming(Boolean smoothStreaming) {
        this.smoothStreaming = smoothStreaming;
        return this;
    }

    /**
     * Indicates whether you want to distribute media files in Microsoft
     * Smooth Streaming format using the origin that is associated with this
     * cache behavior. If so, specify true; if not, specify false.
     *
     * @return Indicates whether you want to distribute media files in Microsoft
     *         Smooth Streaming format using the origin that is associated with this
     *         cache behavior. If so, specify true; if not, specify false.
     */
    public Boolean getSmoothStreaming() {
        return smoothStreaming;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getTargetOriginId() != null) sb.append("TargetOriginId: " + getTargetOriginId() + ",");
        if (getForwardedValues() != null) sb.append("ForwardedValues: " + getForwardedValues() + ",");
        if (getTrustedSigners() != null) sb.append("TrustedSigners: " + getTrustedSigners() + ",");
        if (getViewerProtocolPolicy() != null) sb.append("ViewerProtocolPolicy: " + getViewerProtocolPolicy() + ",");
        if (getMinTTL() != null) sb.append("MinTTL: " + getMinTTL() + ",");
        if (getAllowedMethods() != null) sb.append("AllowedMethods: " + getAllowedMethods() + ",");
        if (isSmoothStreaming() != null) sb.append("SmoothStreaming: " + isSmoothStreaming() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getTargetOriginId() == null) ? 0 : getTargetOriginId().hashCode()); 
        hashCode = prime * hashCode + ((getForwardedValues() == null) ? 0 : getForwardedValues().hashCode()); 
        hashCode = prime * hashCode + ((getTrustedSigners() == null) ? 0 : getTrustedSigners().hashCode()); 
        hashCode = prime * hashCode + ((getViewerProtocolPolicy() == null) ? 0 : getViewerProtocolPolicy().hashCode()); 
        hashCode = prime * hashCode + ((getMinTTL() == null) ? 0 : getMinTTL().hashCode()); 
        hashCode = prime * hashCode + ((getAllowedMethods() == null) ? 0 : getAllowedMethods().hashCode()); 
        hashCode = prime * hashCode + ((isSmoothStreaming() == null) ? 0 : isSmoothStreaming().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DefaultCacheBehavior == false) return false;
        DefaultCacheBehavior other = (DefaultCacheBehavior)obj;
        
        if (other.getTargetOriginId() == null ^ this.getTargetOriginId() == null) return false;
        if (other.getTargetOriginId() != null && other.getTargetOriginId().equals(this.getTargetOriginId()) == false) return false; 
        if (other.getForwardedValues() == null ^ this.getForwardedValues() == null) return false;
        if (other.getForwardedValues() != null && other.getForwardedValues().equals(this.getForwardedValues()) == false) return false; 
        if (other.getTrustedSigners() == null ^ this.getTrustedSigners() == null) return false;
        if (other.getTrustedSigners() != null && other.getTrustedSigners().equals(this.getTrustedSigners()) == false) return false; 
        if (other.getViewerProtocolPolicy() == null ^ this.getViewerProtocolPolicy() == null) return false;
        if (other.getViewerProtocolPolicy() != null && other.getViewerProtocolPolicy().equals(this.getViewerProtocolPolicy()) == false) return false; 
        if (other.getMinTTL() == null ^ this.getMinTTL() == null) return false;
        if (other.getMinTTL() != null && other.getMinTTL().equals(this.getMinTTL()) == false) return false; 
        if (other.getAllowedMethods() == null ^ this.getAllowedMethods() == null) return false;
        if (other.getAllowedMethods() != null && other.getAllowedMethods().equals(this.getAllowedMethods()) == false) return false; 
        if (other.isSmoothStreaming() == null ^ this.isSmoothStreaming() == null) return false;
        if (other.isSmoothStreaming() != null && other.isSmoothStreaming().equals(this.isSmoothStreaming()) == false) return false; 
        return true;
    }
    
    @Override
    public DefaultCacheBehavior clone() {
        try {
            return (DefaultCacheBehavior) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/CacheBehaviorStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.cloudfront.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Cache Behavior StAX Unmarshaller
 */
public class CacheBehaviorStaxUnmarshaller implements Unmarshaller<CacheBehavior, StaxUnmarshallerContext> {

    public CacheBehavior unmarshall(StaxUnmarshallerContext context) throws Exception {
        CacheBehavior cacheBehavior = new CacheBehavior();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;
        if (context.isStartOfDocument()) targetDepth += 1;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return cacheBehavior;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("PathPattern", targetDepth)) {
                    cacheBehavior.setPathPattern(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("TargetOriginId", targetDepth)) {
                    cacheBehavior.setTargetOriginId(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ForwardedValues", targetDepth)) {
                    cacheBehavior.setForwardedValues(ForwardedValuesStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("TrustedSigners", targetDepth)) {
                    cacheBehavior.setTrustedSigners(TrustedSignersStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ViewerProtocolPolicy", targetDepth)) {
                    cacheBehavior.setViewerProtocolPolicy(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("MinTTL", targetDepth)) {
                    cacheBehavior.setMinTTL(LongStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("AllowedMethods", targetDepth)) {
                    cacheBehavior.setAllowedMethods(AllowedMethodsStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("SmoothStreaming", targetDepth)) {
                    cacheBehavior.setSmoothStreaming(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return cacheBehavior;
                }
            }
        }
    }

    private static CacheBehaviorStaxUnmarshaller instance;
    public static CacheBehaviorStaxUnmarshaller getInstance() {
        if (instance == null) instance = new CacheBehaviorStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/CreateCloudFrontOriginAccessIdentityRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Create Cloud Front Origin Access Identity Request Marshaller
 */
public class CreateCloudFrontOriginAccessIdentityRequestMarshaller implements Marshaller<Request<CreateCloudFrontOriginAccessIdentityRequest>, CreateCloudFrontOriginAccessIdentityRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateCloudFrontOriginAccessIdentityRequest> marshall(CreateCloudFrontOriginAccessIdentityRequest createCloudFrontOriginAccessIdentityRequest) {

        if (createCloudFrontOriginAccessIdentityRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateCloudFrontOriginAccessIdentityRequest> request = new DefaultRequest<CreateCloudFrontOriginAccessIdentityRequest>(createCloudFrontOriginAccessIdentityRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.POST);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (createCloudFrontOriginAccessIdentityRequest != null) {
            CloudFrontOriginAccessIdentityConfig cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig = createCloudFrontOriginAccessIdentityRequest.getCloudFrontOriginAccessIdentityConfig();
            if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig != null) {
                xmlWriter.startElement("CloudFrontOriginAccessIdentityConfig");
                if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getCallerReference()).endElement();
                }
                if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getComment()).endElement();
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/CreateDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Create Distribution Request Marshaller
 */
public class CreateDistributionRequestMarshaller implements Marshaller<Request<CreateDistributionRequest>, CreateDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateDistributionRequest> marshall(CreateDistributionRequest createDistributionRequest) {

        if (createDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateDistributionRequest> request = new DefaultRequest<CreateDistributionRequest>(createDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.POST);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (createDistributionRequest != null) {
            DistributionConfig distributionConfigDistributionConfig = createDistributionRequest.getDistributionConfig();
            if (distributionConfigDistributionConfig != null) {
                xmlWriter.startElement("DistributionConfig");
                if (distributionConfigDistributionConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(distributionConfigDistributionConfig.getCallerReference()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    Aliases aliasesAliases = distributionConfigDistributionConfig.getAliases();
                    if (aliasesAliases != null) {
                        xmlWriter.startElement("Aliases");
                        if (aliasesAliases.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(aliasesAliases.getQuantity()).endElement();
                        }

                        if (aliasesAliases != null) {
                            java.util.List<String> aliasesAliasesitemsList = aliasesAliases.getItems();
                            if (aliasesAliasesitemsList != null && aliasesAliasesitemsList.size() > 0) {
                                int aliasesAliasesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String aliasesAliasesitemsListValue : aliasesAliasesitemsList) {

                                xmlWriter.startElement("CNAME");
                                    xmlWriter.value(aliasesAliasesitemsListValue);
                                xmlWriter.endElement();

                                    aliasesAliasesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getDefaultRootObject() != null) {
                    xmlWriter.startElement("DefaultRootObject").value(distributionConfigDistributionConfig.getDefaultRootObject()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    Origins originsOrigins = distributionConfigDistributionConfig.getOrigins();
                    if (originsOrigins != null) {
                        xmlWriter.startElement("Origins");
                        if (originsOrigins.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(originsOrigins.getQuantity()).endElement();
                        }

                        if (originsOrigins != null) {
                            java.util.List<Origin> originsOriginsitemsList = originsOrigins.getItems();
                            if (originsOriginsitemsList != null && originsOriginsitemsList.size() > 0) {
                                int originsOriginsitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (Origin originsOriginsitemsListValue : originsOriginsitemsList) {

                                xmlWriter.startElement("Origin");
                                    if (originsOriginsitemsListValue.getId() != null) {
                                        xmlWriter.startElement("Id").value(originsOriginsitemsListValue.getId()).endElement();
                                    }
                                    if (originsOriginsitemsListValue.getDomainName() != null) {
                                        xmlWriter.startElement("DomainName").value(originsOriginsitemsListValue.getDomainName()).endElement();
                                    }
                                    if (originsOriginsitemsListValue.getOriginPath() != null) {
                                        xmlWriter.startElement("OriginPath").value(originsOriginsitemsListValue.getOriginPath()).endElement();
                                    }
                                    if (originsOriginsitemsListValue != null) {
                                        S3OriginConfig s3OriginConfigS3OriginConfig = originsOriginsitemsListValue.getS3OriginConfig();
                                        if (s3OriginConfigS3OriginConfig != null) {
                                            xmlWriter.startElement("S3OriginConfig");
                                            if (s3OriginConfigS3OriginConfig.getOriginAccessIdentity() != null) {
                                                xmlWriter.startElement("OriginAccessIdentity").value(s3OriginConfigS3OriginConfig.getOriginAccessIdentity()).endElement();
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (originsOriginsitemsListValue != null) {
                                        CustomOriginConfig customOriginConfigCustomOriginConfig = originsOriginsitemsListValue.getCustomOriginConfig();
                                        if (customOriginConfigCustomOriginConfig != null) {
                                            xmlWriter.startElement("CustomOriginConfig");
                                            if (customOriginConfigCustomOriginConfig.getHTTPPort() != null) {
                                                xmlWriter.startElement("HTTPPort").value(customOriginConfigCustomOriginConfig.getHTTPPort()).endElement();
                                            }
                                            if (customOriginConfigCustomOriginConfig.getHTTPSPort() != null) {
                                                xmlWriter.startElement("HTTPSPort").value(customOriginConfigCustomOriginConfig.getHTTPSPort()).endElement();
                                            }
                                            if (customOriginConfigCustomOriginConfig.getOriginProtocolPolicy() != null) {
                                                xmlWriter.startElement("OriginProtocolPolicy").value(customOriginConfigCustomOriginConfig.getOriginProtocolPolicy()).endElement();
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                xmlWriter.endElement();

                                    originsOriginsitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    DefaultCacheBehavior defaultCacheBehaviorDefaultCacheBehavior = distributionConfigDistributionConfig.getDefaultCacheBehavior();
                    if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                        xmlWriter.startElement("DefaultCacheBehavior");
                        if (defaultCacheBehaviorDefaultCacheBehavior.getTargetOriginId() != null) {
                            xmlWriter.startElement("TargetOriginId").value(defaultCacheBehaviorDefaultCacheBehavior.getTargetOriginId()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            ForwardedValues forwardedValuesForwardedValues = defaultCacheBehaviorDefaultCacheBehavior.getForwardedValues();
                            if (forwardedValuesForwardedValues != null) {
                                xmlWriter.startElement("ForwardedValues");
                                if (forwardedValuesForwardedValues.isQueryString() != null) {
                                    xmlWriter.startElement("QueryString").value(forwardedValuesForwardedValues.isQueryString()).endElement();
                                }
                                if (forwardedValuesForwardedValues != null) {
                                    CookiePreference cookiePreferenceCookies = forwardedValuesForwardedValues.getCookies();
                                    if (cookiePreferenceCookies != null) {
                                        xmlWriter.startElement("Cookies");
                                        if (cookiePreferenceCookies.getForward() != null) {
                                            xmlWriter.startElement("Forward").value(cookiePreferenceCookies.getForward()).endElement();
                                        }
                                        if (cookiePreferenceCookies != null) {
                                            CookieNames cookieNamesWhitelistedNames = cookiePreferenceCookies.getWhitelistedNames();
                                            if (cookieNamesWhitelistedNames != null) {
                                                xmlWriter.startElement("WhitelistedNames");
                                                if (cookieNamesWhitelistedNames.getQuantity() != null) {
                                                    xmlWriter.startElement("Quantity").value(cookieNamesWhitelistedNames.getQuantity()).endElement();
                                                }

                                                if (cookieNamesWhitelistedNames != null) {
                                                    java.util.List<String> cookieNamesWhitelistedNamesitemsList = cookieNamesWhitelistedNames.getItems();
                                                    if (cookieNamesWhitelistedNamesitemsList != null && cookieNamesWhitelistedNamesitemsList.size() > 0) {
                                                        int cookieNamesWhitelistedNamesitemsListIndex = 1;
                                                        xmlWriter.startElement("Items");
                                                        for (String cookieNamesWhitelistedNamesitemsListValue : cookieNamesWhitelistedNamesitemsList) {

                                                        xmlWriter.startElement("Name");
                                                            xmlWriter.value(cookieNamesWhitelistedNamesitemsListValue);
                                                        xmlWriter.endElement();

                                                            cookieNamesWhitelistedNamesitemsListIndex++;
                                                        }
                                                        xmlWriter.endElement();
                                                    }
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                if (forwardedValuesForwardedValues != null) {
                                    Headers headersHeaders = forwardedValuesForwardedValues.getHeaders();
                                    if (headersHeaders != null) {
                                        xmlWriter.startElement("Headers");
                                        if (headersHeaders.getQuantity() != null) {
                                            xmlWriter.startElement("Quantity").value(headersHeaders.getQuantity()).endElement();
                                        }

                                        if (headersHeaders != null) {
                                            java.util.List<String> headersHeadersitemsList = headersHeaders.getItems();
                                            if (headersHeadersitemsList != null && headersHeadersitemsList.size() > 0) {
                                                int headersHeadersitemsListIndex = 1;
                                                xmlWriter.startElement("Items");
                                                for (String headersHeadersitemsListValue : headersHeadersitemsList) {

                                                xmlWriter.startElement("Name");
                                                    xmlWriter.value(headersHeadersitemsListValue);
                                                xmlWriter.endElement();

                                                    headersHeadersitemsListIndex++;
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            TrustedSigners trustedSignersTrustedSigners = defaultCacheBehaviorDefaultCacheBehavior.getTrustedSigners();
                            if (trustedSignersTrustedSigners != null) {
                                xmlWriter.startElement("TrustedSigners");
                                if (trustedSignersTrustedSigners.isEnabled() != null) {
                                    xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                                }
                                if (trustedSignersTrustedSigners.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                                }

                                if (trustedSignersTrustedSigners != null) {
                                    java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                                    if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                        int trustedSignersTrustedSignersitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                        xmlWriter.startElement("AwsAccountNumber");
                                            xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                        xmlWriter.endElement();

                                            trustedSignersTrustedSignersitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.getViewerProtocolPolicy() != null) {
                            xmlWriter.startElement("ViewerProtocolPolicy").value(defaultCacheBehaviorDefaultCacheBehavior.getViewerProtocolPolicy()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.getMinTTL() != null) {
                            xmlWriter.startElement("MinTTL").value(defaultCacheBehaviorDefaultCacheBehavior.getMinTTL()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            AllowedMethods allowedMethodsAllowedMethods = defaultCacheBehaviorDefaultCacheBehavior.getAllowedMethods();
                            if (allowedMethodsAllowedMethods != null) {
                                xmlWriter.startElement("AllowedMethods");
                                if (allowedMethodsAllowedMethods.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(allowedMethodsAllowedMethods.getQuantity()).endElement();
                                }

                                if (allowedMethodsAllowedMethods != null) {
                                    java.util.List<String> allowedMethodsAllowedMethodsitemsList = allowedMethodsAllowedMethods.getItems();
                                    if (allowedMethodsAllowedMethodsitemsList != null && allowedMethodsAllowedMethodsitemsList.size() > 0) {
                                        int allowedMethodsAllowedMethodsitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String allowedMethodsAllowedMethodsitemsListValue : allowedMethodsAllowedMethodsitemsList) {

                                        xmlWriter.startElement("Method");
                                            xmlWriter.value(allowedMethodsAllowedMethodsitemsListValue);
                                        xmlWriter.endElement();

                                            allowedMethodsAllowedMethodsitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                if (allowedMethodsAllowedMethods != null) {
                                    CachedMethods cachedMethodsCachedMethods = allowedMethodsAllowedMethods.getCachedMethods();
                                    if (cachedMethodsCachedMethods != null) {
                                        xmlWriter.startElement("CachedMethods");
                                        if (cachedMethodsCachedMethods.getQuantity() != null) {
                                            xmlWriter.startElement("Quantity").value(cachedMethodsCachedMethods.getQuantity()).endElement();
                                        }

                                        if (cachedMethodsCachedMethods != null) {
                                            java.util.List<String> cachedMethodsCachedMethodsitemsList = cachedMethodsCachedMethods.getItems();
                                            if (cachedMethodsCachedMethodsitemsList != null && cachedMethodsCachedMethodsitemsList.size() > 0) {
                                                int cachedMethodsCachedMethodsitemsListIndex = 1;
                                                xmlWriter.startElement("Items");
                                                for (String cachedMethodsCachedMethodsitemsListValue : cachedMethodsCachedMethodsitemsList) {

                                                xmlWriter.startElement("Method");
                                                    xmlWriter.value(cachedMethodsCachedMethodsitemsListValue);
                                                xmlWriter.endElement();

                                                    cachedMethodsCachedMethodsitemsListIndex++;
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.isSmoothStreaming() != null) {
                            xmlWriter.startElement("SmoothStreaming").value(defaultCacheBehaviorDefaultCacheBehavior.isSmoothStreaming()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    CacheBehaviors cacheBehaviorsCacheBehaviors = distributionConfigDistributionConfig.getCacheBehaviors();
                    if (cacheBehaviorsCacheBehaviors != null) {
                        xmlWriter.startElement("CacheBehaviors");
                        if (cacheBehaviorsCacheBehaviors.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(cacheBehaviorsCacheBehaviors.getQuantity()).endElement();
                        }

                        if (cacheBehaviorsCacheBehaviors != null) {
                            java.util.List<CacheBehavior> cacheBehaviorsCacheBehaviorsitemsList = cacheBehaviorsCacheBehaviors.getItems();
                            if (cacheBehaviorsCacheBehaviorsitemsList != null && cacheBehaviorsCacheBehaviorsitemsList.size() > 0) {
                                int cacheBehaviorsCacheBehaviorsitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (CacheBehavior cacheBehaviorsCacheBehaviorsitemsListValue : cacheBehaviorsCacheBehaviorsitemsList) {

                                xmlWriter.startElement("CacheBehavior");
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getPathPattern() != null) {
                                        xmlWriter.startElement("PathPattern").value(cacheBehaviorsCacheBehaviorsitemsListValue.getPathPattern()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getTargetOriginId() != null) {
                                        xmlWriter.startElement("TargetOriginId").value(cacheBehaviorsCacheBehaviorsitemsListValue.getTargetOriginId()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        ForwardedValues forwardedValuesForwardedValues = cacheBehaviorsCacheBehaviorsitemsListValue.getForwardedValues();
                                        if (forwardedValuesForwardedValues != null) {
                                            xmlWriter.startElement("ForwardedValues");
                                            if (forwardedValuesForwardedValues.isQueryString() != null) {
                                                xmlWriter.startElement("QueryString").value(forwardedValuesForwardedValues.isQueryString()).endElement();
                                            }
                                            if (forwardedValuesForwardedValues != null) {
                                                CookiePreference cookiePreferenceCookies = forwardedValuesForwardedValues.getCookies();
                                                if (cookiePreferenceCookies != null) {
                                                    xmlWriter.startElement("Cookies");
                                                    if (cookiePreferenceCookies.getForward() != null) {
                                                        xmlWriter.startElement("Forward").value(cookiePreferenceCookies.getForward()).endElement();
                                                    }
                                                    if (cookiePreferenceCookies != null) {
                                                        CookieNames cookieNamesWhitelistedNames = cookiePreferenceCookies.getWhitelistedNames();
                                                        if (cookieNamesWhitelistedNames != null) {
                                                            xmlWriter.startElement("WhitelistedNames");
                                                            if (cookieNamesWhitelistedNames.getQuantity() != null) {
                                                                xmlWriter.startElement("Quantity").value(cookieNamesWhitelistedNames.getQuantity()).endElement();
                                                            }

                                                            if (cookieNamesWhitelistedNames != null) {
                                                                java.util.List<String> cookieNamesWhitelistedNamesitemsList = cookieNamesWhitelistedNames.getItems();
                                                                if (cookieNamesWhitelistedNamesitemsList != null && cookieNamesWhitelistedNamesitemsList.size() > 0) {
                                                                    int cookieNamesWhitelistedNamesitemsListIndex = 1;
                                                                    xmlWriter.startElement("Items");
                                                                    for (String cookieNamesWhitelistedNamesitemsListValue : cookieNamesWhitelistedNamesitemsList) {

                                                                    xmlWriter.startElement("Name");
                                                                        xmlWriter.value(cookieNamesWhitelistedNamesitemsListValue);
                                                                    xmlWriter.endElement();

                                                                        cookieNamesWhitelistedNamesitemsListIndex++;
                                                                    }
                                                                    xmlWriter.endElement();
                                                                }
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            if (forwardedValuesForwardedValues != null) {
                                                Headers headersHeaders = forwardedValuesForwardedValues.getHeaders();
                                                if (headersHeaders != null) {
                                                    xmlWriter.startElement("Headers");
                                                    if (headersHeaders.getQuantity() != null) {
                                                        xmlWriter.startElement("Quantity").value(headersHeaders.getQuantity()).endElement();
                                                    }

                                                    if (headersHeaders != null) {
                                                        java.util.List<String> headersHeadersitemsList = headersHeaders.getItems();
                                                        if (headersHeadersitemsList != null && headersHeadersitemsList.size() > 0) {
                                                            int headersHeadersitemsListIndex = 1;
                                                            xmlWriter.startElement("Items");
                                                            for (String headersHeadersitemsListValue : headersHeadersitemsList) {

                                                            xmlWriter.startElement("Name");
                                                                xmlWriter.value(headersHeadersitemsListValue);
                                                            xmlWriter.endElement();

                                                                headersHeadersitemsListIndex++;
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        TrustedSigners trustedSignersTrustedSigners = cacheBehaviorsCacheBehaviorsitemsListValue.getTrustedSigners();
                                        if (trustedSignersTrustedSigners != null) {
                                            xmlWriter.startElement("TrustedSigners");
                                            if (trustedSignersTrustedSigners.isEnabled() != null) {
                                                xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                                            }
                                            if (trustedSignersTrustedSigners.getQuantity() != null) {
                                                xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                                            }

                                            if (trustedSignersTrustedSigners != null) {
                                                java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                                                if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                                    int trustedSignersTrustedSignersitemsListIndex = 1;
                                                    xmlWriter.startElement("Items");
                                                    for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                                    xmlWriter.startElement("AwsAccountNumber");
                                                        xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                                    xmlWriter.endElement();

                                                        trustedSignersTrustedSignersitemsListIndex++;
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getViewerProtocolPolicy() != null) {
                                        xmlWriter.startElement("ViewerProtocolPolicy").value(cacheBehaviorsCacheBehaviorsitemsListValue.getViewerProtocolPolicy()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getMinTTL() != null) {
                                        xmlWriter.startElement("MinTTL").value(cacheBehaviorsCacheBehaviorsitemsListValue.getMinTTL()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        AllowedMethods allowedMethodsAllowedMethods = cacheBehaviorsCacheBehaviorsitemsListValue.getAllowedMethods();
                                        if (allowedMethodsAllowedMethods != null) {
                                            xmlWriter.startElement("AllowedMethods");
                                            if (allowedMethodsAllowedMethods.getQuantity() != null) {
                                                xmlWriter.startElement("Quantity").value(allowedMethodsAllowedMethods.getQuantity()).endElement();
                                            }

                                            if (allowedMethodsAllowedMethods != null) {
                                                java.util.List<String> allowedMethodsAllowedMethodsitemsList = allowedMethodsAllowedMethods.getItems();
                                                if (allowedMethodsAllowedMethodsitemsList != null && allowedMethodsAllowedMethodsitemsList.size() > 0) {
                                                    int allowedMethodsAllowedMethodsitemsListIndex = 1;
                                                    xmlWriter.startElement("Items");
                                                    for (String allowedMethodsAllowedMethodsitemsListValue : allowedMethodsAllowedMethodsitemsList) {

                                                    xmlWriter.startElement("Method");
                                                        xmlWriter.value(allowedMethodsAllowedMethodsitemsListValue);
                                                    xmlWriter.endElement();

                                                        allowedMethodsAllowedMethodsitemsListIndex++;
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            if (allowedMethodsAllowedMethods != null) {
                                                CachedMethods cachedMethodsCachedMethods = allowedMethodsAllowedMethods.getCachedMethods();
                                                if (cachedMethodsCachedMethods != null) {
                                                    xmlWriter.startElement("CachedMethods");
                                                    if (cachedMethodsCachedMethods.getQuantity() != null) {
                                                        xmlWriter.startElement("Quantity").value(cachedMethodsCachedMethods.getQuantity()).endElement();
                                                    }

                                                    if (cachedMethodsCachedMethods != null) {
                                                        java.util.List<String> cachedMethodsCachedMethodsitemsList = cachedMethodsCachedMethods.getItems();
                                                        if (cachedMethodsCachedMethodsitemsList != null && cachedMethodsCachedMethodsitemsList.size() > 0) {
                                                            int cachedMethodsCachedMethodsitemsListIndex = 1;
                                                            xmlWriter.startElement("Items");
                                                            for (String cachedMethodsCachedMethodsitemsListValue : cachedMethodsCachedMethodsitemsList) {

                                                            xmlWriter.startElement("Method");
                                                                xmlWriter.value(cachedMethodsCachedMethodsitemsListValue);
                                                            xmlWriter.endElement();

                                                                cachedMethodsCachedMethodsitemsListIndex++;
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.isSmoothStreaming() != null) {
                                        xmlWriter.startElement("SmoothStreaming").value(cacheBehaviorsCacheBehaviorsitemsListValue.isSmoothStreaming()).endElement();
                                    }
                                xmlWriter.endElement();

                                    cacheBehaviorsCacheBehaviorsitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    CustomErrorResponses customErrorResponsesCustomErrorResponses = distributionConfigDistributionConfig.getCustomErrorResponses();
                    if (customErrorResponsesCustomErrorResponses != null) {
                        xmlWriter.startElement("CustomErrorResponses");
                        if (customErrorResponsesCustomErrorResponses.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(customErrorResponsesCustomErrorResponses.getQuantity()).endElement();
                        }

                        if (customErrorResponsesCustomErrorResponses != null) {
                            java.util.List<CustomErrorResponse> customErrorResponsesCustomErrorResponsesitemsList = customErrorResponsesCustomErrorResponses.getItems();
                            if (customErrorResponsesCustomErrorResponsesitemsList != null && customErrorResponsesCustomErrorResponsesitemsList.size() > 0) {
                                int customErrorResponsesCustomErrorResponsesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (CustomErrorResponse customErrorResponsesCustomErrorResponsesitemsListValue : customErrorResponsesCustomErrorResponsesitemsList) {

                                xmlWriter.startElement("CustomErrorResponse");
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCode() != null) {
                                        xmlWriter.startElement("ErrorCode").value(customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCode()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getResponsePagePath() != null) {
                                        xmlWriter.startElement("ResponsePagePath").value(customErrorResponsesCustomErrorResponsesitemsListValue.getResponsePagePath()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getResponseCode() != null) {
                                        xmlWriter.startElement("ResponseCode").value(customErrorResponsesCustomErrorResponsesitemsListValue.getResponseCode()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCachingMinTTL() != null) {
                                        xmlWriter.startElement("ErrorCachingMinTTL").value(customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCachingMinTTL()).endElement();
                                    }
                                xmlWriter.endElement();

                                    customErrorResponsesCustomErrorResponsesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(distributionConfigDistributionConfig.getComment()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    LoggingConfig loggingConfigLogging = distributionConfigDistributionConfig.getLogging();
                    if (loggingConfigLogging != null) {
                        xmlWriter.startElement("Logging");
                        if (loggingConfigLogging.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(loggingConfigLogging.isEnabled()).endElement();
                        }
                        if (loggingConfigLogging.isIncludeCookies() != null) {
                            xmlWriter.startElement("IncludeCookies").value(loggingConfigLogging.isIncludeCookies()).endElement();
                        }
                        if (loggingConfigLogging.getBucket() != null) {
                            xmlWriter.startElement("Bucket").value(loggingConfigLogging.getBucket()).endElement();
                        }
                        if (loggingConfigLogging.getPrefix() != null) {
                            xmlWriter.startElement("Prefix").value(loggingConfigLogging.getPrefix()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getPriceClass() != null) {
                    xmlWriter.startElement("PriceClass").value(distributionConfigDistributionConfig.getPriceClass()).endElement();
                }
                if (distributionConfigDistributionConfig.isEnabled() != null) {
                    xmlWriter.startElement("Enabled").value(distributionConfigDistributionConfig.isEnabled()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    ViewerCertificate viewerCertificateViewerCertificate = distributionConfigDistributionConfig.getViewerCertificate();
                    if (viewerCertificateViewerCertificate != null) {
                        xmlWriter.startElement("ViewerCertificate");
                        if (viewerCertificateViewerCertificate.getIAMCertificateId() != null) {
                            xmlWriter.startElement("IAMCertificateId").value(viewerCertificateViewerCertificate.getIAMCertificateId()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.isCloudFrontDefaultCertificate() != null) {
                            xmlWriter.startElement("CloudFrontDefaultCertificate").value(viewerCertificateViewerCertificate.isCloudFrontDefaultCertificate()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.getSSLSupportMethod() != null) {
                            xmlWriter.startElement("SSLSupportMethod").value(viewerCertificateViewerCertificate.getSSLSupportMethod()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.getMinimumProtocolVersion() != null) {
                            xmlWriter.startElement("MinimumProtocolVersion").value(viewerCertificateViewerCertificate.getMinimumProtocolVersion()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    Restrictions restrictionsRestrictions = distributionConfigDistributionConfig.getRestrictions();
                    if (restrictionsRestrictions != null) {
                        xmlWriter.startElement("Restrictions");
                        if (restrictionsRestrictions != null) {
                            GeoRestriction geoRestrictionGeoRestriction = restrictionsRestrictions.getGeoRestriction();
                            if (geoRestrictionGeoRestriction != null) {
                                xmlWriter.startElement("GeoRestriction");
                                if (geoRestrictionGeoRestriction.getRestrictionType() != null) {
                                    xmlWriter.startElement("RestrictionType").value(geoRestrictionGeoRestriction.getRestrictionType()).endElement();
                                }
                                if (geoRestrictionGeoRestriction.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(geoRestrictionGeoRestriction.getQuantity()).endElement();
                                }

                                if (geoRestrictionGeoRestriction != null) {
                                    java.util.List<String> geoRestrictionGeoRestrictionitemsList = geoRestrictionGeoRestriction.getItems();
                                    if (geoRestrictionGeoRestrictionitemsList != null && geoRestrictionGeoRestrictionitemsList.size() > 0) {
                                        int geoRestrictionGeoRestrictionitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String geoRestrictionGeoRestrictionitemsListValue : geoRestrictionGeoRestrictionitemsList) {

                                        xmlWriter.startElement("Location");
                                            xmlWriter.value(geoRestrictionGeoRestrictionitemsListValue);
                                        xmlWriter.endElement();

                                            geoRestrictionGeoRestrictionitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/CreateInvalidationRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Create Invalidation Request Marshaller
 */
public class CreateInvalidationRequestMarshaller implements Marshaller<Request<CreateInvalidationRequest>, CreateInvalidationRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{DistributionId}/invalidation";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateInvalidationRequest> marshall(CreateInvalidationRequest createInvalidationRequest) {

        if (createInvalidationRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateInvalidationRequest> request = new DefaultRequest<CreateInvalidationRequest>(createInvalidationRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.POST);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("DistributionId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("DistributionId");
            String value = (createInvalidationRequest.getDistributionId() == null) ? null : StringUtils.fromString(createInvalidationRequest.getDistributionId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{DistributionId}", (createInvalidationRequest.getDistributionId() == null) ? "" : StringUtils.fromString(createInvalidationRequest.getDistributionId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (createInvalidationRequest != null) {
            InvalidationBatch invalidationBatchInvalidationBatch = createInvalidationRequest.getInvalidationBatch();
            if (invalidationBatchInvalidationBatch != null) {
                xmlWriter.startElement("InvalidationBatch");
                if (invalidationBatchInvalidationBatch != null) {
                    Paths pathsPaths = invalidationBatchInvalidationBatch.getPaths();
                    if (pathsPaths != null) {
                        xmlWriter.startElement("Paths");
                        if (pathsPaths.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(pathsPaths.getQuantity()).endElement();
                        }

                        if (pathsPaths != null) {
                            java.util.List<String> pathsPathsitemsList = pathsPaths.getItems();
                            if (pathsPathsitemsList != null && pathsPathsitemsList.size() > 0) {
                                int pathsPathsitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String pathsPathsitemsListValue : pathsPathsitemsList) {

                                xmlWriter.startElement("Path");
                                    xmlWriter.value(pathsPathsitemsListValue);
                                xmlWriter.endElement();

                                    pathsPathsitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (invalidationBatchInvalidationBatch.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(invalidationBatchInvalidationBatch.getCallerReference()).endElement();
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/CreateStreamingDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Create Streaming Distribution Request Marshaller
 */
public class CreateStreamingDistributionRequestMarshaller implements Marshaller<Request<CreateStreamingDistributionRequest>, CreateStreamingDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateStreamingDistributionRequest> marshall(CreateStreamingDistributionRequest createStreamingDistributionRequest) {

        if (createStreamingDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateStreamingDistributionRequest> request = new DefaultRequest<CreateStreamingDistributionRequest>(createStreamingDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.POST);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (createStreamingDistributionRequest != null) {
            StreamingDistributionConfig streamingDistributionConfigStreamingDistributionConfig = createStreamingDistributionRequest.getStreamingDistributionConfig();
            if (streamingDistributionConfigStreamingDistributionConfig != null) {
                xmlWriter.startElement("StreamingDistributionConfig");
                if (streamingDistributionConfigStreamingDistributionConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(streamingDistributionConfigStreamingDistributionConfig.getCallerReference()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    S3Origin s3OriginS3Origin = streamingDistributionConfigStreamingDistributionConfig.getS3Origin();
                    if (s3OriginS3Origin != null) {
                        xmlWriter.startElement("S3Origin");
                        if (s3OriginS3Origin.getDomainName() != null) {
                            xmlWriter.startElement("DomainName").value(s3OriginS3Origin.getDomainName()).endElement();
                        }
                        if (s3OriginS3Origin.getOriginAccessIdentity() != null) {
                            xmlWriter.startElement("OriginAccessIdentity").value(s3OriginS3Origin.getOriginAccessIdentity()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    Aliases aliasesAliases = streamingDistributionConfigStreamingDistributionConfig.getAliases();
                    if (aliasesAliases != null) {
                        xmlWriter.startElement("Aliases");
                        if (aliasesAliases.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(aliasesAliases.getQuantity()).endElement();
                        }

                        if (aliasesAliases != null) {
                            java.util.List<String> aliasesAliasesitemsList = aliasesAliases.getItems();
                            if (aliasesAliasesitemsList != null && aliasesAliasesitemsList.size() > 0) {
                                int aliasesAliasesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String aliasesAliasesitemsListValue : aliasesAliasesitemsList) {

                                xmlWriter.startElement("CNAME");
                                    xmlWriter.value(aliasesAliasesitemsListValue);
                                xmlWriter.endElement();

                                    aliasesAliasesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(streamingDistributionConfigStreamingDistributionConfig.getComment()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    StreamingLoggingConfig streamingLoggingConfigLogging = streamingDistributionConfigStreamingDistributionConfig.getLogging();
                    if (streamingLoggingConfigLogging != null) {
                        xmlWriter.startElement("Logging");
                        if (streamingLoggingConfigLogging.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(streamingLoggingConfigLogging.isEnabled()).endElement();
                        }
                        if (streamingLoggingConfigLogging.getBucket() != null) {
                            xmlWriter.startElement("Bucket").value(streamingLoggingConfigLogging.getBucket()).endElement();
                        }
                        if (streamingLoggingConfigLogging.getPrefix() != null) {
                            xmlWriter.startElement("Prefix").value(streamingLoggingConfigLogging.getPrefix()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    TrustedSigners trustedSignersTrustedSigners = streamingDistributionConfigStreamingDistributionConfig.getTrustedSigners();
                    if (trustedSignersTrustedSigners != null) {
                        xmlWriter.startElement("TrustedSigners");
                        if (trustedSignersTrustedSigners.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                        }
                        if (trustedSignersTrustedSigners.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                        }

                        if (trustedSignersTrustedSigners != null) {
                            java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                            if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                int trustedSignersTrustedSignersitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                xmlWriter.startElement("AwsAccountNumber");
                                    xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                xmlWriter.endElement();

                                    trustedSignersTrustedSignersitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig.getPriceClass() != null) {
                    xmlWriter.startElement("PriceClass").value(streamingDistributionConfigStreamingDistributionConfig.getPriceClass()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig.isEnabled() != null) {
                    xmlWriter.startElement("Enabled").value(streamingDistributionConfigStreamingDistributionConfig.isEnabled()).endElement();
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/DefaultCacheBehaviorStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.cloudfront.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Default Cache Behavior StAX Unmarshaller
 */
public class DefaultCacheBehaviorStaxUnmarshaller implements Unmarshaller<DefaultCacheBehavior, StaxUnmarshallerContext> {

    public DefaultCacheBehavior unmarshall(StaxUnmarshallerContext context) throws Exception {
        DefaultCacheBehavior defaultCacheBehavior = new DefaultCacheBehavior();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;
        if (context.isStartOfDocument()) targetDepth += 1;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return defaultCacheBehavior;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("TargetOriginId", targetDepth)) {
                    defaultCacheBehavior.setTargetOriginId(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ForwardedValues", targetDepth)) {
                    defaultCacheBehavior.setForwardedValues(ForwardedValuesStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("TrustedSigners", targetDepth)) {
                    defaultCacheBehavior.setTrustedSigners(TrustedSignersStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ViewerProtocolPolicy", targetDepth)) {
                    defaultCacheBehavior.setViewerProtocolPolicy(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("MinTTL", targetDepth)) {
                    defaultCacheBehavior.setMinTTL(LongStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("AllowedMethods", targetDepth)) {
                    defaultCacheBehavior.setAllowedMethods(AllowedMethodsStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("SmoothStreaming", targetDepth)) {
                    defaultCacheBehavior.setSmoothStreaming(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return defaultCacheBehavior;
                }
            }
        }
    }

    private static DefaultCacheBehaviorStaxUnmarshaller instance;
    public static DefaultCacheBehaviorStaxUnmarshaller getInstance() {
        if (instance == null) instance = new DefaultCacheBehaviorStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/DeleteCloudFrontOriginAccessIdentityRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Delete Cloud Front Origin Access Identity Request Marshaller
 */
public class DeleteCloudFrontOriginAccessIdentityRequestMarshaller implements Marshaller<Request<DeleteCloudFrontOriginAccessIdentityRequest>, DeleteCloudFrontOriginAccessIdentityRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteCloudFrontOriginAccessIdentityRequest> marshall(DeleteCloudFrontOriginAccessIdentityRequest deleteCloudFrontOriginAccessIdentityRequest) {

        if (deleteCloudFrontOriginAccessIdentityRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteCloudFrontOriginAccessIdentityRequest> request = new DefaultRequest<DeleteCloudFrontOriginAccessIdentityRequest>(deleteCloudFrontOriginAccessIdentityRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.DELETE);
        if (deleteCloudFrontOriginAccessIdentityRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(deleteCloudFrontOriginAccessIdentityRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (deleteCloudFrontOriginAccessIdentityRequest.getId() == null) ? null : StringUtils.fromString(deleteCloudFrontOriginAccessIdentityRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (deleteCloudFrontOriginAccessIdentityRequest.getId() == null) ? "" : StringUtils.fromString(deleteCloudFrontOriginAccessIdentityRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/DeleteDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Delete Distribution Request Marshaller
 */
public class DeleteDistributionRequestMarshaller implements Marshaller<Request<DeleteDistributionRequest>, DeleteDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteDistributionRequest> marshall(DeleteDistributionRequest deleteDistributionRequest) {

        if (deleteDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteDistributionRequest> request = new DefaultRequest<DeleteDistributionRequest>(deleteDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.DELETE);
        if (deleteDistributionRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(deleteDistributionRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (deleteDistributionRequest.getId() == null) ? null : StringUtils.fromString(deleteDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (deleteDistributionRequest.getId() == null) ? "" : StringUtils.fromString(deleteDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/DeleteStreamingDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Delete Streaming Distribution Request Marshaller
 */
public class DeleteStreamingDistributionRequestMarshaller implements Marshaller<Request<DeleteStreamingDistributionRequest>, DeleteStreamingDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteStreamingDistributionRequest> marshall(DeleteStreamingDistributionRequest deleteStreamingDistributionRequest) {

        if (deleteStreamingDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteStreamingDistributionRequest> request = new DefaultRequest<DeleteStreamingDistributionRequest>(deleteStreamingDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.DELETE);
        if (deleteStreamingDistributionRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(deleteStreamingDistributionRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (deleteStreamingDistributionRequest.getId() == null) ? null : StringUtils.fromString(deleteStreamingDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (deleteStreamingDistributionRequest.getId() == null) ? "" : StringUtils.fromString(deleteStreamingDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetCloudFrontOriginAccessIdentityConfigRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Cloud Front Origin Access Identity Config Request Marshaller
 */
public class GetCloudFrontOriginAccessIdentityConfigRequestMarshaller implements Marshaller<Request<GetCloudFrontOriginAccessIdentityConfigRequest>, GetCloudFrontOriginAccessIdentityConfigRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetCloudFrontOriginAccessIdentityConfigRequest> marshall(GetCloudFrontOriginAccessIdentityConfigRequest getCloudFrontOriginAccessIdentityConfigRequest) {

        if (getCloudFrontOriginAccessIdentityConfigRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetCloudFrontOriginAccessIdentityConfigRequest> request = new DefaultRequest<GetCloudFrontOriginAccessIdentityConfigRequest>(getCloudFrontOriginAccessIdentityConfigRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getCloudFrontOriginAccessIdentityConfigRequest.getId() == null) ? null : StringUtils.fromString(getCloudFrontOriginAccessIdentityConfigRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getCloudFrontOriginAccessIdentityConfigRequest.getId() == null) ? "" : StringUtils.fromString(getCloudFrontOriginAccessIdentityConfigRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetCloudFrontOriginAccessIdentityRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Cloud Front Origin Access Identity Request Marshaller
 */
public class GetCloudFrontOriginAccessIdentityRequestMarshaller implements Marshaller<Request<GetCloudFrontOriginAccessIdentityRequest>, GetCloudFrontOriginAccessIdentityRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetCloudFrontOriginAccessIdentityRequest> marshall(GetCloudFrontOriginAccessIdentityRequest getCloudFrontOriginAccessIdentityRequest) {

        if (getCloudFrontOriginAccessIdentityRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetCloudFrontOriginAccessIdentityRequest> request = new DefaultRequest<GetCloudFrontOriginAccessIdentityRequest>(getCloudFrontOriginAccessIdentityRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getCloudFrontOriginAccessIdentityRequest.getId() == null) ? null : StringUtils.fromString(getCloudFrontOriginAccessIdentityRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getCloudFrontOriginAccessIdentityRequest.getId() == null) ? "" : StringUtils.fromString(getCloudFrontOriginAccessIdentityRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetDistributionConfigRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Distribution Config Request Marshaller
 */
public class GetDistributionConfigRequestMarshaller implements Marshaller<Request<GetDistributionConfigRequest>, GetDistributionConfigRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetDistributionConfigRequest> marshall(GetDistributionConfigRequest getDistributionConfigRequest) {

        if (getDistributionConfigRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetDistributionConfigRequest> request = new DefaultRequest<GetDistributionConfigRequest>(getDistributionConfigRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getDistributionConfigRequest.getId() == null) ? null : StringUtils.fromString(getDistributionConfigRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getDistributionConfigRequest.getId() == null) ? "" : StringUtils.fromString(getDistributionConfigRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Distribution Request Marshaller
 */
public class GetDistributionRequestMarshaller implements Marshaller<Request<GetDistributionRequest>, GetDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetDistributionRequest> marshall(GetDistributionRequest getDistributionRequest) {

        if (getDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetDistributionRequest> request = new DefaultRequest<GetDistributionRequest>(getDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getDistributionRequest.getId() == null) ? null : StringUtils.fromString(getDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getDistributionRequest.getId() == null) ? "" : StringUtils.fromString(getDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetInvalidationRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Invalidation Request Marshaller
 */
public class GetInvalidationRequestMarshaller implements Marshaller<Request<GetInvalidationRequest>, GetInvalidationRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{DistributionId}/invalidation/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetInvalidationRequest> marshall(GetInvalidationRequest getInvalidationRequest) {

        if (getInvalidationRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetInvalidationRequest> request = new DefaultRequest<GetInvalidationRequest>(getInvalidationRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("DistributionId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("DistributionId");
            String value = (getInvalidationRequest.getDistributionId() == null) ? null : StringUtils.fromString(getInvalidationRequest.getDistributionId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{DistributionId}", (getInvalidationRequest.getDistributionId() == null) ? "" : StringUtils.fromString(getInvalidationRequest.getDistributionId())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getInvalidationRequest.getId() == null) ? null : StringUtils.fromString(getInvalidationRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getInvalidationRequest.getId() == null) ? "" : StringUtils.fromString(getInvalidationRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetStreamingDistributionConfigRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Streaming Distribution Config Request Marshaller
 */
public class GetStreamingDistributionConfigRequestMarshaller implements Marshaller<Request<GetStreamingDistributionConfigRequest>, GetStreamingDistributionConfigRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetStreamingDistributionConfigRequest> marshall(GetStreamingDistributionConfigRequest getStreamingDistributionConfigRequest) {

        if (getStreamingDistributionConfigRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetStreamingDistributionConfigRequest> request = new DefaultRequest<GetStreamingDistributionConfigRequest>(getStreamingDistributionConfigRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getStreamingDistributionConfigRequest.getId() == null) ? null : StringUtils.fromString(getStreamingDistributionConfigRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getStreamingDistributionConfigRequest.getId() == null) ? "" : StringUtils.fromString(getStreamingDistributionConfigRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/GetStreamingDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Get Streaming Distribution Request Marshaller
 */
public class GetStreamingDistributionRequestMarshaller implements Marshaller<Request<GetStreamingDistributionRequest>, GetStreamingDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution/{Id}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<GetStreamingDistributionRequest> marshall(GetStreamingDistributionRequest getStreamingDistributionRequest) {

        if (getStreamingDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetStreamingDistributionRequest> request = new DefaultRequest<GetStreamingDistributionRequest>(getStreamingDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (getStreamingDistributionRequest.getId() == null) ? null : StringUtils.fromString(getStreamingDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (getStreamingDistributionRequest.getId() == null) ? "" : StringUtils.fromString(getStreamingDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/ListCloudFrontOriginAccessIdentitiesRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * List Cloud Front Origin Access Identities Request Marshaller
 */
public class ListCloudFrontOriginAccessIdentitiesRequestMarshaller implements Marshaller<Request<ListCloudFrontOriginAccessIdentitiesRequest>, ListCloudFrontOriginAccessIdentitiesRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront?Marker={Marker}&MaxItems={MaxItems}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<ListCloudFrontOriginAccessIdentitiesRequest> marshall(ListCloudFrontOriginAccessIdentitiesRequest listCloudFrontOriginAccessIdentitiesRequest) {

        if (listCloudFrontOriginAccessIdentitiesRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ListCloudFrontOriginAccessIdentitiesRequest> request = new DefaultRequest<ListCloudFrontOriginAccessIdentitiesRequest>(listCloudFrontOriginAccessIdentitiesRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");
            String value = (listCloudFrontOriginAccessIdentitiesRequest.getMarker() == null) ? null : StringUtils.fromString(listCloudFrontOriginAccessIdentitiesRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (listCloudFrontOriginAccessIdentitiesRequest.getMarker() == null) ? "" : StringUtils.fromString(listCloudFrontOriginAccessIdentitiesRequest.getMarker())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");
            String value = (listCloudFrontOriginAccessIdentitiesRequest.getMaxItems() == null) ? null : StringUtils.fromString(listCloudFrontOriginAccessIdentitiesRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (listCloudFrontOriginAccessIdentitiesRequest.getMaxItems() == null) ? "" : StringUtils.fromString(listCloudFrontOriginAccessIdentitiesRequest.getMaxItems())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/ListDistributionsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * List Distributions Request Marshaller
 */
public class ListDistributionsRequestMarshaller implements Marshaller<Request<ListDistributionsRequest>, ListDistributionsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution?Marker={Marker}&MaxItems={MaxItems}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<ListDistributionsRequest> marshall(ListDistributionsRequest listDistributionsRequest) {

        if (listDistributionsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ListDistributionsRequest> request = new DefaultRequest<ListDistributionsRequest>(listDistributionsRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");
            String value = (listDistributionsRequest.getMarker() == null) ? null : StringUtils.fromString(listDistributionsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (listDistributionsRequest.getMarker() == null) ? "" : StringUtils.fromString(listDistributionsRequest.getMarker())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");
            String value = (listDistributionsRequest.getMaxItems() == null) ? null : StringUtils.fromString(listDistributionsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (listDistributionsRequest.getMaxItems() == null) ? "" : StringUtils.fromString(listDistributionsRequest.getMaxItems())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/ListInvalidationsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * List Invalidations Request Marshaller
 */
public class ListInvalidationsRequestMarshaller implements Marshaller<Request<ListInvalidationsRequest>, ListInvalidationsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{DistributionId}/invalidation?Marker={Marker}&MaxItems={MaxItems}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<ListInvalidationsRequest> marshall(ListInvalidationsRequest listInvalidationsRequest) {

        if (listInvalidationsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ListInvalidationsRequest> request = new DefaultRequest<ListInvalidationsRequest>(listInvalidationsRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("DistributionId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("DistributionId");
            String value = (listInvalidationsRequest.getDistributionId() == null) ? null : StringUtils.fromString(listInvalidationsRequest.getDistributionId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{DistributionId}", (listInvalidationsRequest.getDistributionId() == null) ? "" : StringUtils.fromString(listInvalidationsRequest.getDistributionId())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");
            String value = (listInvalidationsRequest.getMarker() == null) ? null : StringUtils.fromString(listInvalidationsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (listInvalidationsRequest.getMarker() == null) ? "" : StringUtils.fromString(listInvalidationsRequest.getMarker())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");
            String value = (listInvalidationsRequest.getMaxItems() == null) ? null : StringUtils.fromString(listInvalidationsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (listInvalidationsRequest.getMaxItems() == null) ? "" : StringUtils.fromString(listInvalidationsRequest.getMaxItems())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/ListStreamingDistributionsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * List Streaming Distributions Request Marshaller
 */
public class ListStreamingDistributionsRequestMarshaller implements Marshaller<Request<ListStreamingDistributionsRequest>, ListStreamingDistributionsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution?Marker={Marker}&MaxItems={MaxItems}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<ListStreamingDistributionsRequest> marshall(ListStreamingDistributionsRequest listStreamingDistributionsRequest) {

        if (listStreamingDistributionsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ListStreamingDistributionsRequest> request = new DefaultRequest<ListStreamingDistributionsRequest>(listStreamingDistributionsRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.GET);

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");
            String value = (listStreamingDistributionsRequest.getMarker() == null) ? null : StringUtils.fromString(listStreamingDistributionsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (listStreamingDistributionsRequest.getMarker() == null) ? "" : StringUtils.fromString(listStreamingDistributionsRequest.getMarker())); 
        }
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");
            String value = (listStreamingDistributionsRequest.getMaxItems() == null) ? null : StringUtils.fromString(listStreamingDistributionsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (listStreamingDistributionsRequest.getMaxItems() == null) ? "" : StringUtils.fromString(listStreamingDistributionsRequest.getMaxItems())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/UpdateCloudFrontOriginAccessIdentityRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Update Cloud Front Origin Access Identity Request Marshaller
 */
public class UpdateCloudFrontOriginAccessIdentityRequestMarshaller implements Marshaller<Request<UpdateCloudFrontOriginAccessIdentityRequest>, UpdateCloudFrontOriginAccessIdentityRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/origin-access-identity/cloudfront/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<UpdateCloudFrontOriginAccessIdentityRequest> marshall(UpdateCloudFrontOriginAccessIdentityRequest updateCloudFrontOriginAccessIdentityRequest) {

        if (updateCloudFrontOriginAccessIdentityRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<UpdateCloudFrontOriginAccessIdentityRequest> request = new DefaultRequest<UpdateCloudFrontOriginAccessIdentityRequest>(updateCloudFrontOriginAccessIdentityRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.PUT);
        if (updateCloudFrontOriginAccessIdentityRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(updateCloudFrontOriginAccessIdentityRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (updateCloudFrontOriginAccessIdentityRequest.getId() == null) ? null : StringUtils.fromString(updateCloudFrontOriginAccessIdentityRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (updateCloudFrontOriginAccessIdentityRequest.getId() == null) ? "" : StringUtils.fromString(updateCloudFrontOriginAccessIdentityRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (updateCloudFrontOriginAccessIdentityRequest != null) {
            CloudFrontOriginAccessIdentityConfig cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig = updateCloudFrontOriginAccessIdentityRequest.getCloudFrontOriginAccessIdentityConfig();
            if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig != null) {
                xmlWriter.startElement("CloudFrontOriginAccessIdentityConfig");
                if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getCallerReference()).endElement();
                }
                if (cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(cloudFrontOriginAccessIdentityConfigCloudFrontOriginAccessIdentityConfig.getComment()).endElement();
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/UpdateDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Update Distribution Request Marshaller
 */
public class UpdateDistributionRequestMarshaller implements Marshaller<Request<UpdateDistributionRequest>, UpdateDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/distribution/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<UpdateDistributionRequest> marshall(UpdateDistributionRequest updateDistributionRequest) {

        if (updateDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<UpdateDistributionRequest> request = new DefaultRequest<UpdateDistributionRequest>(updateDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.PUT);
        if (updateDistributionRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(updateDistributionRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (updateDistributionRequest.getId() == null) ? null : StringUtils.fromString(updateDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (updateDistributionRequest.getId() == null) ? "" : StringUtils.fromString(updateDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (updateDistributionRequest != null) {
            DistributionConfig distributionConfigDistributionConfig = updateDistributionRequest.getDistributionConfig();
            if (distributionConfigDistributionConfig != null) {
                xmlWriter.startElement("DistributionConfig");
                if (distributionConfigDistributionConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(distributionConfigDistributionConfig.getCallerReference()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    Aliases aliasesAliases = distributionConfigDistributionConfig.getAliases();
                    if (aliasesAliases != null) {
                        xmlWriter.startElement("Aliases");
                        if (aliasesAliases.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(aliasesAliases.getQuantity()).endElement();
                        }

                        if (aliasesAliases != null) {
                            java.util.List<String> aliasesAliasesitemsList = aliasesAliases.getItems();
                            if (aliasesAliasesitemsList != null && aliasesAliasesitemsList.size() > 0) {
                                int aliasesAliasesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String aliasesAliasesitemsListValue : aliasesAliasesitemsList) {

                                xmlWriter.startElement("CNAME");
                                    xmlWriter.value(aliasesAliasesitemsListValue);
                                xmlWriter.endElement();

                                    aliasesAliasesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getDefaultRootObject() != null) {
                    xmlWriter.startElement("DefaultRootObject").value(distributionConfigDistributionConfig.getDefaultRootObject()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    Origins originsOrigins = distributionConfigDistributionConfig.getOrigins();
                    if (originsOrigins != null) {
                        xmlWriter.startElement("Origins");
                        if (originsOrigins.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(originsOrigins.getQuantity()).endElement();
                        }

                        if (originsOrigins != null) {
                            java.util.List<Origin> originsOriginsitemsList = originsOrigins.getItems();
                            if (originsOriginsitemsList != null && originsOriginsitemsList.size() > 0) {
                                int originsOriginsitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (Origin originsOriginsitemsListValue : originsOriginsitemsList) {

                                xmlWriter.startElement("Origin");
                                    if (originsOriginsitemsListValue.getId() != null) {
                                        xmlWriter.startElement("Id").value(originsOriginsitemsListValue.getId()).endElement();
                                    }
                                    if (originsOriginsitemsListValue.getDomainName() != null) {
                                        xmlWriter.startElement("DomainName").value(originsOriginsitemsListValue.getDomainName()).endElement();
                                    }
                                    if (originsOriginsitemsListValue.getOriginPath() != null) {
                                        xmlWriter.startElement("OriginPath").value(originsOriginsitemsListValue.getOriginPath()).endElement();
                                    }
                                    if (originsOriginsitemsListValue != null) {
                                        S3OriginConfig s3OriginConfigS3OriginConfig = originsOriginsitemsListValue.getS3OriginConfig();
                                        if (s3OriginConfigS3OriginConfig != null) {
                                            xmlWriter.startElement("S3OriginConfig");
                                            if (s3OriginConfigS3OriginConfig.getOriginAccessIdentity() != null) {
                                                xmlWriter.startElement("OriginAccessIdentity").value(s3OriginConfigS3OriginConfig.getOriginAccessIdentity()).endElement();
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (originsOriginsitemsListValue != null) {
                                        CustomOriginConfig customOriginConfigCustomOriginConfig = originsOriginsitemsListValue.getCustomOriginConfig();
                                        if (customOriginConfigCustomOriginConfig != null) {
                                            xmlWriter.startElement("CustomOriginConfig");
                                            if (customOriginConfigCustomOriginConfig.getHTTPPort() != null) {
                                                xmlWriter.startElement("HTTPPort").value(customOriginConfigCustomOriginConfig.getHTTPPort()).endElement();
                                            }
                                            if (customOriginConfigCustomOriginConfig.getHTTPSPort() != null) {
                                                xmlWriter.startElement("HTTPSPort").value(customOriginConfigCustomOriginConfig.getHTTPSPort()).endElement();
                                            }
                                            if (customOriginConfigCustomOriginConfig.getOriginProtocolPolicy() != null) {
                                                xmlWriter.startElement("OriginProtocolPolicy").value(customOriginConfigCustomOriginConfig.getOriginProtocolPolicy()).endElement();
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                xmlWriter.endElement();

                                    originsOriginsitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    DefaultCacheBehavior defaultCacheBehaviorDefaultCacheBehavior = distributionConfigDistributionConfig.getDefaultCacheBehavior();
                    if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                        xmlWriter.startElement("DefaultCacheBehavior");
                        if (defaultCacheBehaviorDefaultCacheBehavior.getTargetOriginId() != null) {
                            xmlWriter.startElement("TargetOriginId").value(defaultCacheBehaviorDefaultCacheBehavior.getTargetOriginId()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            ForwardedValues forwardedValuesForwardedValues = defaultCacheBehaviorDefaultCacheBehavior.getForwardedValues();
                            if (forwardedValuesForwardedValues != null) {
                                xmlWriter.startElement("ForwardedValues");
                                if (forwardedValuesForwardedValues.isQueryString() != null) {
                                    xmlWriter.startElement("QueryString").value(forwardedValuesForwardedValues.isQueryString()).endElement();
                                }
                                if (forwardedValuesForwardedValues != null) {
                                    CookiePreference cookiePreferenceCookies = forwardedValuesForwardedValues.getCookies();
                                    if (cookiePreferenceCookies != null) {
                                        xmlWriter.startElement("Cookies");
                                        if (cookiePreferenceCookies.getForward() != null) {
                                            xmlWriter.startElement("Forward").value(cookiePreferenceCookies.getForward()).endElement();
                                        }
                                        if (cookiePreferenceCookies != null) {
                                            CookieNames cookieNamesWhitelistedNames = cookiePreferenceCookies.getWhitelistedNames();
                                            if (cookieNamesWhitelistedNames != null) {
                                                xmlWriter.startElement("WhitelistedNames");
                                                if (cookieNamesWhitelistedNames.getQuantity() != null) {
                                                    xmlWriter.startElement("Quantity").value(cookieNamesWhitelistedNames.getQuantity()).endElement();
                                                }

                                                if (cookieNamesWhitelistedNames != null) {
                                                    java.util.List<String> cookieNamesWhitelistedNamesitemsList = cookieNamesWhitelistedNames.getItems();
                                                    if (cookieNamesWhitelistedNamesitemsList != null && cookieNamesWhitelistedNamesitemsList.size() > 0) {
                                                        int cookieNamesWhitelistedNamesitemsListIndex = 1;
                                                        xmlWriter.startElement("Items");
                                                        for (String cookieNamesWhitelistedNamesitemsListValue : cookieNamesWhitelistedNamesitemsList) {

                                                        xmlWriter.startElement("Name");
                                                            xmlWriter.value(cookieNamesWhitelistedNamesitemsListValue);
                                                        xmlWriter.endElement();

                                                            cookieNamesWhitelistedNamesitemsListIndex++;
                                                        }
                                                        xmlWriter.endElement();
                                                    }
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                if (forwardedValuesForwardedValues != null) {
                                    Headers headersHeaders = forwardedValuesForwardedValues.getHeaders();
                                    if (headersHeaders != null) {
                                        xmlWriter.startElement("Headers");
                                        if (headersHeaders.getQuantity() != null) {
                                            xmlWriter.startElement("Quantity").value(headersHeaders.getQuantity()).endElement();
                                        }

                                        if (headersHeaders != null) {
                                            java.util.List<String> headersHeadersitemsList = headersHeaders.getItems();
                                            if (headersHeadersitemsList != null && headersHeadersitemsList.size() > 0) {
                                                int headersHeadersitemsListIndex = 1;
                                                xmlWriter.startElement("Items");
                                                for (String headersHeadersitemsListValue : headersHeadersitemsList) {

                                                xmlWriter.startElement("Name");
                                                    xmlWriter.value(headersHeadersitemsListValue);
                                                xmlWriter.endElement();

                                                    headersHeadersitemsListIndex++;
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            TrustedSigners trustedSignersTrustedSigners = defaultCacheBehaviorDefaultCacheBehavior.getTrustedSigners();
                            if (trustedSignersTrustedSigners != null) {
                                xmlWriter.startElement("TrustedSigners");
                                if (trustedSignersTrustedSigners.isEnabled() != null) {
                                    xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                                }
                                if (trustedSignersTrustedSigners.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                                }

                                if (trustedSignersTrustedSigners != null) {
                                    java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                                    if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                        int trustedSignersTrustedSignersitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                        xmlWriter.startElement("AwsAccountNumber");
                                            xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                        xmlWriter.endElement();

                                            trustedSignersTrustedSignersitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.getViewerProtocolPolicy() != null) {
                            xmlWriter.startElement("ViewerProtocolPolicy").value(defaultCacheBehaviorDefaultCacheBehavior.getViewerProtocolPolicy()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.getMinTTL() != null) {
                            xmlWriter.startElement("MinTTL").value(defaultCacheBehaviorDefaultCacheBehavior.getMinTTL()).endElement();
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior != null) {
                            AllowedMethods allowedMethodsAllowedMethods = defaultCacheBehaviorDefaultCacheBehavior.getAllowedMethods();
                            if (allowedMethodsAllowedMethods != null) {
                                xmlWriter.startElement("AllowedMethods");
                                if (allowedMethodsAllowedMethods.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(allowedMethodsAllowedMethods.getQuantity()).endElement();
                                }

                                if (allowedMethodsAllowedMethods != null) {
                                    java.util.List<String> allowedMethodsAllowedMethodsitemsList = allowedMethodsAllowedMethods.getItems();
                                    if (allowedMethodsAllowedMethodsitemsList != null && allowedMethodsAllowedMethodsitemsList.size() > 0) {
                                        int allowedMethodsAllowedMethodsitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String allowedMethodsAllowedMethodsitemsListValue : allowedMethodsAllowedMethodsitemsList) {

                                        xmlWriter.startElement("Method");
                                            xmlWriter.value(allowedMethodsAllowedMethodsitemsListValue);
                                        xmlWriter.endElement();

                                            allowedMethodsAllowedMethodsitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                if (allowedMethodsAllowedMethods != null) {
                                    CachedMethods cachedMethodsCachedMethods = allowedMethodsAllowedMethods.getCachedMethods();
                                    if (cachedMethodsCachedMethods != null) {
                                        xmlWriter.startElement("CachedMethods");
                                        if (cachedMethodsCachedMethods.getQuantity() != null) {
                                            xmlWriter.startElement("Quantity").value(cachedMethodsCachedMethods.getQuantity()).endElement();
                                        }

                                        if (cachedMethodsCachedMethods != null) {
                                            java.util.List<String> cachedMethodsCachedMethodsitemsList = cachedMethodsCachedMethods.getItems();
                                            if (cachedMethodsCachedMethodsitemsList != null && cachedMethodsCachedMethodsitemsList.size() > 0) {
                                                int cachedMethodsCachedMethodsitemsListIndex = 1;
                                                xmlWriter.startElement("Items");
                                                for (String cachedMethodsCachedMethodsitemsListValue : cachedMethodsCachedMethodsitemsList) {

                                                xmlWriter.startElement("Method");
                                                    xmlWriter.value(cachedMethodsCachedMethodsitemsListValue);
                                                xmlWriter.endElement();

                                                    cachedMethodsCachedMethodsitemsListIndex++;
                                                }
                                                xmlWriter.endElement();
                                            }
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        if (defaultCacheBehaviorDefaultCacheBehavior.isSmoothStreaming() != null) {
                            xmlWriter.startElement("SmoothStreaming").value(defaultCacheBehaviorDefaultCacheBehavior.isSmoothStreaming()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    CacheBehaviors cacheBehaviorsCacheBehaviors = distributionConfigDistributionConfig.getCacheBehaviors();
                    if (cacheBehaviorsCacheBehaviors != null) {
                        xmlWriter.startElement("CacheBehaviors");
                        if (cacheBehaviorsCacheBehaviors.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(cacheBehaviorsCacheBehaviors.getQuantity()).endElement();
                        }

                        if (cacheBehaviorsCacheBehaviors != null) {
                            java.util.List<CacheBehavior> cacheBehaviorsCacheBehaviorsitemsList = cacheBehaviorsCacheBehaviors.getItems();
                            if (cacheBehaviorsCacheBehaviorsitemsList != null && cacheBehaviorsCacheBehaviorsitemsList.size() > 0) {
                                int cacheBehaviorsCacheBehaviorsitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (CacheBehavior cacheBehaviorsCacheBehaviorsitemsListValue : cacheBehaviorsCacheBehaviorsitemsList) {

                                xmlWriter.startElement("CacheBehavior");
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getPathPattern() != null) {
                                        xmlWriter.startElement("PathPattern").value(cacheBehaviorsCacheBehaviorsitemsListValue.getPathPattern()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getTargetOriginId() != null) {
                                        xmlWriter.startElement("TargetOriginId").value(cacheBehaviorsCacheBehaviorsitemsListValue.getTargetOriginId()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        ForwardedValues forwardedValuesForwardedValues = cacheBehaviorsCacheBehaviorsitemsListValue.getForwardedValues();
                                        if (forwardedValuesForwardedValues != null) {
                                            xmlWriter.startElement("ForwardedValues");
                                            if (forwardedValuesForwardedValues.isQueryString() != null) {
                                                xmlWriter.startElement("QueryString").value(forwardedValuesForwardedValues.isQueryString()).endElement();
                                            }
                                            if (forwardedValuesForwardedValues != null) {
                                                CookiePreference cookiePreferenceCookies = forwardedValuesForwardedValues.getCookies();
                                                if (cookiePreferenceCookies != null) {
                                                    xmlWriter.startElement("Cookies");
                                                    if (cookiePreferenceCookies.getForward() != null) {
                                                        xmlWriter.startElement("Forward").value(cookiePreferenceCookies.getForward()).endElement();
                                                    }
                                                    if (cookiePreferenceCookies != null) {
                                                        CookieNames cookieNamesWhitelistedNames = cookiePreferenceCookies.getWhitelistedNames();
                                                        if (cookieNamesWhitelistedNames != null) {
                                                            xmlWriter.startElement("WhitelistedNames");
                                                            if (cookieNamesWhitelistedNames.getQuantity() != null) {
                                                                xmlWriter.startElement("Quantity").value(cookieNamesWhitelistedNames.getQuantity()).endElement();
                                                            }

                                                            if (cookieNamesWhitelistedNames != null) {
                                                                java.util.List<String> cookieNamesWhitelistedNamesitemsList = cookieNamesWhitelistedNames.getItems();
                                                                if (cookieNamesWhitelistedNamesitemsList != null && cookieNamesWhitelistedNamesitemsList.size() > 0) {
                                                                    int cookieNamesWhitelistedNamesitemsListIndex = 1;
                                                                    xmlWriter.startElement("Items");
                                                                    for (String cookieNamesWhitelistedNamesitemsListValue : cookieNamesWhitelistedNamesitemsList) {

                                                                    xmlWriter.startElement("Name");
                                                                        xmlWriter.value(cookieNamesWhitelistedNamesitemsListValue);
                                                                    xmlWriter.endElement();

                                                                        cookieNamesWhitelistedNamesitemsListIndex++;
                                                                    }
                                                                    xmlWriter.endElement();
                                                                }
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            if (forwardedValuesForwardedValues != null) {
                                                Headers headersHeaders = forwardedValuesForwardedValues.getHeaders();
                                                if (headersHeaders != null) {
                                                    xmlWriter.startElement("Headers");
                                                    if (headersHeaders.getQuantity() != null) {
                                                        xmlWriter.startElement("Quantity").value(headersHeaders.getQuantity()).endElement();
                                                    }

                                                    if (headersHeaders != null) {
                                                        java.util.List<String> headersHeadersitemsList = headersHeaders.getItems();
                                                        if (headersHeadersitemsList != null && headersHeadersitemsList.size() > 0) {
                                                            int headersHeadersitemsListIndex = 1;
                                                            xmlWriter.startElement("Items");
                                                            for (String headersHeadersitemsListValue : headersHeadersitemsList) {

                                                            xmlWriter.startElement("Name");
                                                                xmlWriter.value(headersHeadersitemsListValue);
                                                            xmlWriter.endElement();

                                                                headersHeadersitemsListIndex++;
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        TrustedSigners trustedSignersTrustedSigners = cacheBehaviorsCacheBehaviorsitemsListValue.getTrustedSigners();
                                        if (trustedSignersTrustedSigners != null) {
                                            xmlWriter.startElement("TrustedSigners");
                                            if (trustedSignersTrustedSigners.isEnabled() != null) {
                                                xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                                            }
                                            if (trustedSignersTrustedSigners.getQuantity() != null) {
                                                xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                                            }

                                            if (trustedSignersTrustedSigners != null) {
                                                java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                                                if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                                    int trustedSignersTrustedSignersitemsListIndex = 1;
                                                    xmlWriter.startElement("Items");
                                                    for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                                    xmlWriter.startElement("AwsAccountNumber");
                                                        xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                                    xmlWriter.endElement();

                                                        trustedSignersTrustedSignersitemsListIndex++;
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getViewerProtocolPolicy() != null) {
                                        xmlWriter.startElement("ViewerProtocolPolicy").value(cacheBehaviorsCacheBehaviorsitemsListValue.getViewerProtocolPolicy()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.getMinTTL() != null) {
                                        xmlWriter.startElement("MinTTL").value(cacheBehaviorsCacheBehaviorsitemsListValue.getMinTTL()).endElement();
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue != null) {
                                        AllowedMethods allowedMethodsAllowedMethods = cacheBehaviorsCacheBehaviorsitemsListValue.getAllowedMethods();
                                        if (allowedMethodsAllowedMethods != null) {
                                            xmlWriter.startElement("AllowedMethods");
                                            if (allowedMethodsAllowedMethods.getQuantity() != null) {
                                                xmlWriter.startElement("Quantity").value(allowedMethodsAllowedMethods.getQuantity()).endElement();
                                            }

                                            if (allowedMethodsAllowedMethods != null) {
                                                java.util.List<String> allowedMethodsAllowedMethodsitemsList = allowedMethodsAllowedMethods.getItems();
                                                if (allowedMethodsAllowedMethodsitemsList != null && allowedMethodsAllowedMethodsitemsList.size() > 0) {
                                                    int allowedMethodsAllowedMethodsitemsListIndex = 1;
                                                    xmlWriter.startElement("Items");
                                                    for (String allowedMethodsAllowedMethodsitemsListValue : allowedMethodsAllowedMethodsitemsList) {

                                                    xmlWriter.startElement("Method");
                                                        xmlWriter.value(allowedMethodsAllowedMethodsitemsListValue);
                                                    xmlWriter.endElement();

                                                        allowedMethodsAllowedMethodsitemsListIndex++;
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            if (allowedMethodsAllowedMethods != null) {
                                                CachedMethods cachedMethodsCachedMethods = allowedMethodsAllowedMethods.getCachedMethods();
                                                if (cachedMethodsCachedMethods != null) {
                                                    xmlWriter.startElement("CachedMethods");
                                                    if (cachedMethodsCachedMethods.getQuantity() != null) {
                                                        xmlWriter.startElement("Quantity").value(cachedMethodsCachedMethods.getQuantity()).endElement();
                                                    }

                                                    if (cachedMethodsCachedMethods != null) {
                                                        java.util.List<String> cachedMethodsCachedMethodsitemsList = cachedMethodsCachedMethods.getItems();
                                                        if (cachedMethodsCachedMethodsitemsList != null && cachedMethodsCachedMethodsitemsList.size() > 0) {
                                                            int cachedMethodsCachedMethodsitemsListIndex = 1;
                                                            xmlWriter.startElement("Items");
                                                            for (String cachedMethodsCachedMethodsitemsListValue : cachedMethodsCachedMethodsitemsList) {

                                                            xmlWriter.startElement("Method");
                                                                xmlWriter.value(cachedMethodsCachedMethodsitemsListValue);
                                                            xmlWriter.endElement();

                                                                cachedMethodsCachedMethodsitemsListIndex++;
                                                            }
                                                            xmlWriter.endElement();
                                                        }
                                                    }
                                                    xmlWriter.endElement();
                                                }
                                            }
                                            xmlWriter.endElement();
                                        }
                                    }
                                    if (cacheBehaviorsCacheBehaviorsitemsListValue.isSmoothStreaming() != null) {
                                        xmlWriter.startElement("SmoothStreaming").value(cacheBehaviorsCacheBehaviorsitemsListValue.isSmoothStreaming()).endElement();
                                    }
                                xmlWriter.endElement();

                                    cacheBehaviorsCacheBehaviorsitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    CustomErrorResponses customErrorResponsesCustomErrorResponses = distributionConfigDistributionConfig.getCustomErrorResponses();
                    if (customErrorResponsesCustomErrorResponses != null) {
                        xmlWriter.startElement("CustomErrorResponses");
                        if (customErrorResponsesCustomErrorResponses.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(customErrorResponsesCustomErrorResponses.getQuantity()).endElement();
                        }

                        if (customErrorResponsesCustomErrorResponses != null) {
                            java.util.List<CustomErrorResponse> customErrorResponsesCustomErrorResponsesitemsList = customErrorResponsesCustomErrorResponses.getItems();
                            if (customErrorResponsesCustomErrorResponsesitemsList != null && customErrorResponsesCustomErrorResponsesitemsList.size() > 0) {
                                int customErrorResponsesCustomErrorResponsesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (CustomErrorResponse customErrorResponsesCustomErrorResponsesitemsListValue : customErrorResponsesCustomErrorResponsesitemsList) {

                                xmlWriter.startElement("CustomErrorResponse");
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCode() != null) {
                                        xmlWriter.startElement("ErrorCode").value(customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCode()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getResponsePagePath() != null) {
                                        xmlWriter.startElement("ResponsePagePath").value(customErrorResponsesCustomErrorResponsesitemsListValue.getResponsePagePath()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getResponseCode() != null) {
                                        xmlWriter.startElement("ResponseCode").value(customErrorResponsesCustomErrorResponsesitemsListValue.getResponseCode()).endElement();
                                    }
                                    if (customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCachingMinTTL() != null) {
                                        xmlWriter.startElement("ErrorCachingMinTTL").value(customErrorResponsesCustomErrorResponsesitemsListValue.getErrorCachingMinTTL()).endElement();
                                    }
                                xmlWriter.endElement();

                                    customErrorResponsesCustomErrorResponsesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(distributionConfigDistributionConfig.getComment()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    LoggingConfig loggingConfigLogging = distributionConfigDistributionConfig.getLogging();
                    if (loggingConfigLogging != null) {
                        xmlWriter.startElement("Logging");
                        if (loggingConfigLogging.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(loggingConfigLogging.isEnabled()).endElement();
                        }
                        if (loggingConfigLogging.isIncludeCookies() != null) {
                            xmlWriter.startElement("IncludeCookies").value(loggingConfigLogging.isIncludeCookies()).endElement();
                        }
                        if (loggingConfigLogging.getBucket() != null) {
                            xmlWriter.startElement("Bucket").value(loggingConfigLogging.getBucket()).endElement();
                        }
                        if (loggingConfigLogging.getPrefix() != null) {
                            xmlWriter.startElement("Prefix").value(loggingConfigLogging.getPrefix()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig.getPriceClass() != null) {
                    xmlWriter.startElement("PriceClass").value(distributionConfigDistributionConfig.getPriceClass()).endElement();
                }
                if (distributionConfigDistributionConfig.isEnabled() != null) {
                    xmlWriter.startElement("Enabled").value(distributionConfigDistributionConfig.isEnabled()).endElement();
                }
                if (distributionConfigDistributionConfig != null) {
                    ViewerCertificate viewerCertificateViewerCertificate = distributionConfigDistributionConfig.getViewerCertificate();
                    if (viewerCertificateViewerCertificate != null) {
                        xmlWriter.startElement("ViewerCertificate");
                        if (viewerCertificateViewerCertificate.getIAMCertificateId() != null) {
                            xmlWriter.startElement("IAMCertificateId").value(viewerCertificateViewerCertificate.getIAMCertificateId()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.isCloudFrontDefaultCertificate() != null) {
                            xmlWriter.startElement("CloudFrontDefaultCertificate").value(viewerCertificateViewerCertificate.isCloudFrontDefaultCertificate()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.getSSLSupportMethod() != null) {
                            xmlWriter.startElement("SSLSupportMethod").value(viewerCertificateViewerCertificate.getSSLSupportMethod()).endElement();
                        }
                        if (viewerCertificateViewerCertificate.getMinimumProtocolVersion() != null) {
                            xmlWriter.startElement("MinimumProtocolVersion").value(viewerCertificateViewerCertificate.getMinimumProtocolVersion()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (distributionConfigDistributionConfig != null) {
                    Restrictions restrictionsRestrictions = distributionConfigDistributionConfig.getRestrictions();
                    if (restrictionsRestrictions != null) {
                        xmlWriter.startElement("Restrictions");
                        if (restrictionsRestrictions != null) {
                            GeoRestriction geoRestrictionGeoRestriction = restrictionsRestrictions.getGeoRestriction();
                            if (geoRestrictionGeoRestriction != null) {
                                xmlWriter.startElement("GeoRestriction");
                                if (geoRestrictionGeoRestriction.getRestrictionType() != null) {
                                    xmlWriter.startElement("RestrictionType").value(geoRestrictionGeoRestriction.getRestrictionType()).endElement();
                                }
                                if (geoRestrictionGeoRestriction.getQuantity() != null) {
                                    xmlWriter.startElement("Quantity").value(geoRestrictionGeoRestriction.getQuantity()).endElement();
                                }

                                if (geoRestrictionGeoRestriction != null) {
                                    java.util.List<String> geoRestrictionGeoRestrictionitemsList = geoRestrictionGeoRestriction.getItems();
                                    if (geoRestrictionGeoRestrictionitemsList != null && geoRestrictionGeoRestrictionitemsList.size() > 0) {
                                        int geoRestrictionGeoRestrictionitemsListIndex = 1;
                                        xmlWriter.startElement("Items");
                                        for (String geoRestrictionGeoRestrictionitemsListValue : geoRestrictionGeoRestrictionitemsList) {

                                        xmlWriter.startElement("Location");
                                            xmlWriter.value(geoRestrictionGeoRestrictionitemsListValue);
                                        xmlWriter.endElement();

                                            geoRestrictionGeoRestrictionitemsListIndex++;
                                        }
                                        xmlWriter.endElement();
                                    }
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cloudfront/src/main/java/com/amazonaws/services/cloudfront/model/transform/UpdateStreamingDistributionRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cloudfront.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;

import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.cloudfront.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.XMLWriter;

/**
 * Update Streaming Distribution Request Marshaller
 */
public class UpdateStreamingDistributionRequestMarshaller implements Marshaller<Request<UpdateStreamingDistributionRequest>, UpdateStreamingDistributionRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "2014-11-06/streaming-distribution/{Id}/config";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<UpdateStreamingDistributionRequest> marshall(UpdateStreamingDistributionRequest updateStreamingDistributionRequest) {

        if (updateStreamingDistributionRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<UpdateStreamingDistributionRequest> request = new DefaultRequest<UpdateStreamingDistributionRequest>(updateStreamingDistributionRequest, "AmazonCloudFront");
        request.setHttpMethod(HttpMethodName.PUT);
        if (updateStreamingDistributionRequest.getIfMatch() != null)
          request.addHeader("If-Match", StringUtils.fromString(updateStreamingDistributionRequest.getIfMatch()));

        String uriResourcePath = RESOURCE_PATH_TEMPLATE;
        
        if (DYNAMIC_QUERY_PARAMS.containsKey("Id")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Id");
            String value = (updateStreamingDistributionRequest.getId() == null) ? null : StringUtils.fromString(updateStreamingDistributionRequest.getId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
        } else {
            uriResourcePath = uriResourcePath.replace("{Id}", (updateStreamingDistributionRequest.getId() == null) ? "" : StringUtils.fromString(updateStreamingDistributionRequest.getId())); 
        }

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

            StringWriter stringWriter = new StringWriter();
            XMLWriter xmlWriter = new XMLWriter(stringWriter, "http://cloudfront.amazonaws.com/doc/2014-11-06/");

                    if (updateStreamingDistributionRequest != null) {
            StreamingDistributionConfig streamingDistributionConfigStreamingDistributionConfig = updateStreamingDistributionRequest.getStreamingDistributionConfig();
            if (streamingDistributionConfigStreamingDistributionConfig != null) {
                xmlWriter.startElement("StreamingDistributionConfig");
                if (streamingDistributionConfigStreamingDistributionConfig.getCallerReference() != null) {
                    xmlWriter.startElement("CallerReference").value(streamingDistributionConfigStreamingDistributionConfig.getCallerReference()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    S3Origin s3OriginS3Origin = streamingDistributionConfigStreamingDistributionConfig.getS3Origin();
                    if (s3OriginS3Origin != null) {
                        xmlWriter.startElement("S3Origin");
                        if (s3OriginS3Origin.getDomainName() != null) {
                            xmlWriter.startElement("DomainName").value(s3OriginS3Origin.getDomainName()).endElement();
                        }
                        if (s3OriginS3Origin.getOriginAccessIdentity() != null) {
                            xmlWriter.startElement("OriginAccessIdentity").value(s3OriginS3Origin.getOriginAccessIdentity()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    Aliases aliasesAliases = streamingDistributionConfigStreamingDistributionConfig.getAliases();
                    if (aliasesAliases != null) {
                        xmlWriter.startElement("Aliases");
                        if (aliasesAliases.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(aliasesAliases.getQuantity()).endElement();
                        }

                        if (aliasesAliases != null) {
                            java.util.List<String> aliasesAliasesitemsList = aliasesAliases.getItems();
                            if (aliasesAliasesitemsList != null && aliasesAliasesitemsList.size() > 0) {
                                int aliasesAliasesitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String aliasesAliasesitemsListValue : aliasesAliasesitemsList) {

                                xmlWriter.startElement("CNAME");
                                    xmlWriter.value(aliasesAliasesitemsListValue);
                                xmlWriter.endElement();

                                    aliasesAliasesitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig.getComment() != null) {
                    xmlWriter.startElement("Comment").value(streamingDistributionConfigStreamingDistributionConfig.getComment()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    StreamingLoggingConfig streamingLoggingConfigLogging = streamingDistributionConfigStreamingDistributionConfig.getLogging();
                    if (streamingLoggingConfigLogging != null) {
                        xmlWriter.startElement("Logging");
                        if (streamingLoggingConfigLogging.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(streamingLoggingConfigLogging.isEnabled()).endElement();
                        }
                        if (streamingLoggingConfigLogging.getBucket() != null) {
                            xmlWriter.startElement("Bucket").value(streamingLoggingConfigLogging.getBucket()).endElement();
                        }
                        if (streamingLoggingConfigLogging.getPrefix() != null) {
                            xmlWriter.startElement("Prefix").value(streamingLoggingConfigLogging.getPrefix()).endElement();
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig != null) {
                    TrustedSigners trustedSignersTrustedSigners = streamingDistributionConfigStreamingDistributionConfig.getTrustedSigners();
                    if (trustedSignersTrustedSigners != null) {
                        xmlWriter.startElement("TrustedSigners");
                        if (trustedSignersTrustedSigners.isEnabled() != null) {
                            xmlWriter.startElement("Enabled").value(trustedSignersTrustedSigners.isEnabled()).endElement();
                        }
                        if (trustedSignersTrustedSigners.getQuantity() != null) {
                            xmlWriter.startElement("Quantity").value(trustedSignersTrustedSigners.getQuantity()).endElement();
                        }

                        if (trustedSignersTrustedSigners != null) {
                            java.util.List<String> trustedSignersTrustedSignersitemsList = trustedSignersTrustedSigners.getItems();
                            if (trustedSignersTrustedSignersitemsList != null && trustedSignersTrustedSignersitemsList.size() > 0) {
                                int trustedSignersTrustedSignersitemsListIndex = 1;
                                xmlWriter.startElement("Items");
                                for (String trustedSignersTrustedSignersitemsListValue : trustedSignersTrustedSignersitemsList) {

                                xmlWriter.startElement("AwsAccountNumber");
                                    xmlWriter.value(trustedSignersTrustedSignersitemsListValue);
                                xmlWriter.endElement();

                                    trustedSignersTrustedSignersitemsListIndex++;
                                }
                                xmlWriter.endElement();
                            }
                        }
                        xmlWriter.endElement();
                    }
                }
                if (streamingDistributionConfigStreamingDistributionConfig.getPriceClass() != null) {
                    xmlWriter.startElement("PriceClass").value(streamingDistributionConfigStreamingDistributionConfig.getPriceClass()).endElement();
                }
                if (streamingDistributionConfigStreamingDistributionConfig.isEnabled() != null) {
                    xmlWriter.startElement("Enabled").value(streamingDistributionConfigStreamingDistributionConfig.isEnabled()).endElement();
                }
                xmlWriter.endElement();
            }
        }

            try {
                request.setContent(new StringInputStream(stringWriter.getBuffer().toString()));
                request.addHeader("Content-Length", Integer.toString(stringWriter.getBuffer().toString().getBytes(UTF8).length));
                request.addHeader("Content-Type", "application/xml");
            } catch (UnsupportedEncodingException e) {
                throw new AmazonClientException("Unable to marshall request to XML", e);
            }

        return request;
    }
}


File: aws-java-sdk-cognitoidentity/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentity.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitoidentity;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.cognitoidentity.model.*;

/**
 * Interface for accessing AmazonCognitoIdentity.
 * Amazon Cognito <p>
 * Amazon Cognito is a web service that delivers scoped temporary
 * credentials to mobile devices and other untrusted environments. Amazon
 * Cognito uniquely identifies a device and supplies the user with a
 * consistent identity over the lifetime of an application.
 * </p>
 * <p>
 * Using Amazon Cognito, you can enable authentication with one or more
 * third-party identity providers (Facebook, Google, or Login with
 * Amazon), and you can also choose to support unauthenticated access
 * from your app. Cognito delivers a unique identifier for each user and
 * acts as an OpenID token provider trusted by AWS Security Token Service
 * (STS) to access temporary, limited-privilege AWS credentials.
 * </p>
 * <p>
 * To provide end-user credentials, first make an unsigned call to GetId.
 * If the end user is authenticated with one of the supported identity
 * providers, set the <code>Logins</code> map with the identity provider
 * token. <code>GetId</code> returns a unique identifier for the user.
 * </p>
 * <p>
 * Next, make an unsigned call to GetCredentialsForIdentity. This call
 * expects the same <code>Logins</code> map as the <code>GetId</code>
 * call, as well as the <code>IdentityID</code> originally returned by
 * <code>GetId</code> . Assuming your identity pool has been configured
 * via the SetIdentityPoolRoles operation,
 * <code>GetCredentialsForIdentity</code> will return AWS credentials for
 * your use. If your pool has not been configured with
 * <code>SetIdentityPoolRoles</code> , or if you want to follow legacy
 * flow, make an unsigned call to GetOpenIdToken, which returns the
 * OpenID token necessary to call STS and retrieve AWS credentials. This
 * call expects the same <code>Logins</code> map as the
 * <code>GetId</code> call, as well as the <code>IdentityID</code>
 * originally returned by <code>GetId</code> . The token returned by
 * <code>GetOpenIdToken</code> can be passed to the STS operation
 * <a href="http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html"> AssumeRoleWithWebIdentity </a>
 * to retrieve AWS credentials.
 * </p>
 * <p>
 * If you want to use Amazon Cognito in an Android, iOS, or Unity
 * application, you will probably want to make API calls via the AWS
 * Mobile SDK. To learn more, see the
 * <a href="http://docs.aws.amazon.com/mobile/index.html"> AWS Mobile SDK Developer Guide </a>
 * .
 * </p>
 */
public interface AmazonCognitoIdentity {

    /**
     * Overrides the default endpoint for this client ("https://cognito-identity.us-east-1.amazonaws.com/").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "cognito-identity.us-east-1.amazonaws.com/") or a full
     * URL, including the protocol (ex: "https://cognito-identity.us-east-1.amazonaws.com/"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "cognito-identity.us-east-1.amazonaws.com/") or a full URL,
     *            including the protocol (ex: "https://cognito-identity.us-east-1.amazonaws.com/") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonCognitoIdentity#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * Unlinks a <code>DeveloperUserIdentifier</code> from an existing
     * identity. Unlinked developer users will be considered new identities
     * next time they are seen. If, for a given Cognito identity, you remove
     * all federated identities as well as the developer user identifier, the
     * Cognito identity becomes inaccessible.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param unlinkDeveloperIdentityRequest Container for the necessary
     *           parameters to execute the UnlinkDeveloperIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void unlinkDeveloperIdentity(UnlinkDeveloperIdentityRequest unlinkDeveloperIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes identities from an identity pool. You can specify a list of
     * 1-60 identities that you want to delete.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param deleteIdentitiesRequest Container for the necessary parameters
     *           to execute the DeleteIdentities service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DeleteIdentities service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeleteIdentitiesResult deleteIdentities(DeleteIdentitiesRequest deleteIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets details about a particular identity pool, including the pool
     * name, ID description, creation date, and current number of users.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param describeIdentityPoolRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DescribeIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityPoolResult describeIdentityPool(DescribeIdentityPoolRequest describeIdentityPoolRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Generates (or retrieves) a Cognito ID. Supplying multiple logins will
     * create an implicit linked account.
     * </p>
     * <p>
     * token+";"+tokenSecret.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getIdRequest Container for the necessary parameters to execute
     *           the GetId service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetId service method, as returned by
     *         AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws LimitExceededException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdResult getId(GetIdRequest getIdRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes a user pool. Once a pool is deleted, users will not be able
     * to authenticate with the pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param deleteIdentityPoolRequest Container for the necessary
     *           parameters to execute the DeleteIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteIdentityPool(DeleteIdentityPoolRequest deleteIdentityPoolRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Updates a user pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param updateIdentityPoolRequest Container for the necessary
     *           parameters to execute the UpdateIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the UpdateIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateIdentityPoolResult updateIdentityPool(UpdateIdentityPoolRequest updateIdentityPoolRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns credentials for the the provided identity ID. Any provided
     * logins will be validated against supported login providers. If the
     * token is for cognito-identity.amazonaws.com, it will be passed through
     * to AWS Security Token Service with the appropriate role for the token.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getCredentialsForIdentityRequest Container for the necessary
     *           parameters to execute the GetCredentialsForIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the GetCredentialsForIdentity service
     *         method, as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws InvalidIdentityPoolConfigurationException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCredentialsForIdentityResult getCredentialsForIdentity(GetCredentialsForIdentityRequest getCredentialsForIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Merges two users having different <code>IdentityId</code> s, existing
     * in the same identity pool, and identified by the same developer
     * provider. You can use this action to request that discrete users be
     * merged and identified as a single user in the Cognito environment.
     * Cognito associates the given source user (
     * <code>SourceUserIdentifier</code> ) with the <code>IdentityId</code>
     * of the <code>DestinationUserIdentifier</code> . Only
     * developer-authenticated users can be merged. If the users to be merged
     * are associated with the same public provider, but as two different
     * users, an exception will be thrown.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param mergeDeveloperIdentitiesRequest Container for the necessary
     *           parameters to execute the MergeDeveloperIdentities service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the MergeDeveloperIdentities service method,
     *         as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public MergeDeveloperIdentitiesResult mergeDeveloperIdentities(MergeDeveloperIdentitiesRequest mergeDeveloperIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Lists all of the Cognito identity pools registered for your account.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param listIdentityPoolsRequest Container for the necessary parameters
     *           to execute the ListIdentityPools service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the ListIdentityPools service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentityPoolsResult listIdentityPools(ListIdentityPoolsRequest listIdentityPoolsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets an OpenID token, using a known Cognito ID. This known Cognito ID
     * is returned by GetId. You can optionally add additional logins for the
     * identity. Supplying multiple logins creates an implicit link.
     * </p>
     * <p>
     * The OpenId token is valid for 15 minutes.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getOpenIdTokenRequest Container for the necessary parameters to
     *           execute the GetOpenIdToken service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetOpenIdToken service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetOpenIdTokenResult getOpenIdToken(GetOpenIdTokenRequest getOpenIdTokenRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Retrieves the <code>IdentityID</code> associated with a
     * <code>DeveloperUserIdentifier</code> or the list of
     * <code>DeveloperUserIdentifier</code> s associated with an
     * <code>IdentityId</code> for an existing identity. Either
     * <code>IdentityID</code> or <code>DeveloperUserIdentifier</code> must
     * not be null. If you supply only one of these values, the other value
     * will be searched in the database and returned as a part of the
     * response. If you supply both, <code>DeveloperUserIdentifier</code>
     * will be matched against <code>IdentityID</code> . If the values are
     * verified against the database, the response returns both values and is
     * the same as the request. Otherwise a
     * <code>ResourceConflictException</code> is thrown.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param lookupDeveloperIdentityRequest Container for the necessary
     *           parameters to execute the LookupDeveloperIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the LookupDeveloperIdentity service method,
     *         as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public LookupDeveloperIdentityResult lookupDeveloperIdentity(LookupDeveloperIdentityRequest lookupDeveloperIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns metadata related to the given identity, including when the
     * identity was created and any associated linked logins.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param describeIdentityRequest Container for the necessary parameters
     *           to execute the DescribeIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DescribeIdentity service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityResult describeIdentity(DescribeIdentityRequest describeIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the roles for an identity pool. These roles are used when making
     * calls to <code>GetCredentialsForIdentity</code> action.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param setIdentityPoolRolesRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolRoles service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setIdentityPoolRoles(SetIdentityPoolRolesRequest setIdentityPoolRolesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Unlinks a federated identity from an existing account. Unlinked
     * logins will be considered new identities next time they are seen.
     * Removing the last linked login will make this identity inaccessible.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param unlinkIdentityRequest Container for the necessary parameters to
     *           execute the UnlinkIdentity service method on AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void unlinkIdentity(UnlinkIdentityRequest unlinkIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Lists the identities in a pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param listIdentitiesRequest Container for the necessary parameters to
     *           execute the ListIdentities service method on AmazonCognitoIdentity.
     * 
     * @return The response from the ListIdentities service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentitiesResult listIdentities(ListIdentitiesRequest listIdentitiesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the roles for an identity pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param getIdentityPoolRolesRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolRoles service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the GetIdentityPoolRoles service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdentityPoolRolesResult getIdentityPoolRoles(GetIdentityPoolRolesRequest getIdentityPoolRolesRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Registers (or retrieves) a Cognito <code>IdentityId</code> and an
     * OpenID Connect token for a user authenticated by your backend
     * authentication process. Supplying multiple logins will create an
     * implicit linked account. You can only specify one developer provider
     * as part of the <code>Logins</code> map, which is linked to the
     * identity pool. The developer provider is the "domain" by which Cognito
     * will refer to your users.
     * </p>
     * <p>
     * You can use <code>GetOpenIdTokenForDeveloperIdentity</code> to create
     * a new identity and to link new logins (that is, user credentials
     * issued by a public provider or developer provider) to an existing
     * identity. When you want to create a new identity, the
     * <code>IdentityId</code> should be null. When you want to associate a
     * new login with an existing authenticated/unauthenticated identity, you
     * can do so by providing the existing <code>IdentityId</code> . This API
     * will create the identity in the specified <code>IdentityPoolId</code>
     * .
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param getOpenIdTokenForDeveloperIdentityRequest Container for the
     *           necessary parameters to execute the GetOpenIdTokenForDeveloperIdentity
     *           service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetOpenIdTokenForDeveloperIdentity
     *         service method, as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws DeveloperUserAlreadyRegisteredException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetOpenIdTokenForDeveloperIdentityResult getOpenIdTokenForDeveloperIdentity(GetOpenIdTokenForDeveloperIdentityRequest getOpenIdTokenForDeveloperIdentityRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new identity pool. The identity pool is a store of user
     * identity information that is specific to your AWS account. The limit
     * on identity pools is 60 per account. You must use AWS Developer
     * credentials to call this API.
     * </p>
     *
     * @param createIdentityPoolRequest Container for the necessary
     *           parameters to execute the CreateIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the CreateIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws LimitExceededException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateIdentityPoolResult createIdentityPool(CreateIdentityPoolRequest createIdentityPoolRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-cognitoidentity/src/main/java/com/amazonaws/services/cognitoidentity/AmazonCognitoIdentityClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitoidentity;

import java.net.*;
import java.util.*;

import org.apache.commons.logging.*;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.regions.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;
import com.amazonaws.util.json.*;

import com.amazonaws.services.cognitoidentity.model.*;
import com.amazonaws.services.cognitoidentity.model.transform.*;

/**
 * Client for accessing AmazonCognitoIdentity.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * Amazon Cognito <p>
 * Amazon Cognito is a web service that delivers scoped temporary
 * credentials to mobile devices and other untrusted environments. Amazon
 * Cognito uniquely identifies a device and supplies the user with a
 * consistent identity over the lifetime of an application.
 * </p>
 * <p>
 * Using Amazon Cognito, you can enable authentication with one or more
 * third-party identity providers (Facebook, Google, or Login with
 * Amazon), and you can also choose to support unauthenticated access
 * from your app. Cognito delivers a unique identifier for each user and
 * acts as an OpenID token provider trusted by AWS Security Token Service
 * (STS) to access temporary, limited-privilege AWS credentials.
 * </p>
 * <p>
 * To provide end-user credentials, first make an unsigned call to GetId.
 * If the end user is authenticated with one of the supported identity
 * providers, set the <code>Logins</code> map with the identity provider
 * token. <code>GetId</code> returns a unique identifier for the user.
 * </p>
 * <p>
 * Next, make an unsigned call to GetCredentialsForIdentity. This call
 * expects the same <code>Logins</code> map as the <code>GetId</code>
 * call, as well as the <code>IdentityID</code> originally returned by
 * <code>GetId</code> . Assuming your identity pool has been configured
 * via the SetIdentityPoolRoles operation,
 * <code>GetCredentialsForIdentity</code> will return AWS credentials for
 * your use. If your pool has not been configured with
 * <code>SetIdentityPoolRoles</code> , or if you want to follow legacy
 * flow, make an unsigned call to GetOpenIdToken, which returns the
 * OpenID token necessary to call STS and retrieve AWS credentials. This
 * call expects the same <code>Logins</code> map as the
 * <code>GetId</code> call, as well as the <code>IdentityID</code>
 * originally returned by <code>GetId</code> . The token returned by
 * <code>GetOpenIdToken</code> can be passed to the STS operation
 * <a href="http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html"> AssumeRoleWithWebIdentity </a>
 * to retrieve AWS credentials.
 * </p>
 * <p>
 * If you want to use Amazon Cognito in an Android, iOS, or Unity
 * application, you will probably want to make API calls via the AWS
 * Mobile SDK. To learn more, see the
 * <a href="http://docs.aws.amazon.com/mobile/index.html"> AWS Mobile SDK Developer Guide </a>
 * .
 * </p>
 */
public class AmazonCognitoIdentityClient extends AmazonWebServiceClient implements AmazonCognitoIdentity {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    private static final Log log = LogFactory.getLog(AmazonCognitoIdentity.class);

    /**
     * List of exception unmarshallers for all AmazonCognitoIdentity exceptions.
     */
    protected List<JsonErrorUnmarshaller> jsonErrorUnmarshallers;

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoIdentityClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoIdentity
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoIdentityClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity using the specified AWS account credentials.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonCognitoIdentityClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity using the specified AWS account credentials
     * and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoIdentity
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCognitoIdentityClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(adjustClientConfiguration(clientConfiguration));
        
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity using the specified AWS account credentials provider.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity using the specified AWS account credentials
     * provider and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoIdentity
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoIdentity using the specified AWS account credentials
     * provider, client configuration options and request metric collector.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoIdentity
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonCognitoIdentityClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
        
        this.awsCredentialsProvider = awsCredentialsProvider;
        
        init();
    }

    private void init() {
        jsonErrorUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
        jsonErrorUnmarshallers.add(new DeveloperUserAlreadyRegisteredExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InternalErrorExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidParameterExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ResourceConflictExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ExternalServiceExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidIdentityPoolConfigurationExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new LimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NotAuthorizedExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ResourceNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new TooManyRequestsExceptionUnmarshaller());
        
        jsonErrorUnmarshallers.add(new JsonErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("cognito-identity.us-east-1.amazonaws.com/");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/cognitoidentity/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/cognitoidentity/request.handler2s"));
    }

    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
        ClientConfiguration config = orig;
        
        return config;
    }

    /**
     * <p>
     * Unlinks a <code>DeveloperUserIdentifier</code> from an existing
     * identity. Unlinked developer users will be considered new identities
     * next time they are seen. If, for a given Cognito identity, you remove
     * all federated identities as well as the developer user identifier, the
     * Cognito identity becomes inaccessible.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param unlinkDeveloperIdentityRequest Container for the necessary
     *           parameters to execute the UnlinkDeveloperIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void unlinkDeveloperIdentity(UnlinkDeveloperIdentityRequest unlinkDeveloperIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(unlinkDeveloperIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UnlinkDeveloperIdentityRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UnlinkDeveloperIdentityRequestMarshaller().marshall(super.beforeMarshalling(unlinkDeveloperIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Deletes identities from an identity pool. You can specify a list of
     * 1-60 identities that you want to delete.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param deleteIdentitiesRequest Container for the necessary parameters
     *           to execute the DeleteIdentities service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DeleteIdentities service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeleteIdentitiesResult deleteIdentities(DeleteIdentitiesRequest deleteIdentitiesRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteIdentitiesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteIdentitiesRequest> request = null;
        Response<DeleteIdentitiesResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteIdentitiesRequestMarshaller().marshall(super.beforeMarshalling(deleteIdentitiesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DeleteIdentitiesResult, JsonUnmarshallerContext> unmarshaller =
                new DeleteIdentitiesResultJsonUnmarshaller();
            JsonResponseHandler<DeleteIdentitiesResult> responseHandler =
                new JsonResponseHandler<DeleteIdentitiesResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets details about a particular identity pool, including the pool
     * name, ID description, creation date, and current number of users.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param describeIdentityPoolRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DescribeIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityPoolResult describeIdentityPool(DescribeIdentityPoolRequest describeIdentityPoolRequest) {
        ExecutionContext executionContext = createExecutionContext(describeIdentityPoolRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeIdentityPoolRequest> request = null;
        Response<DescribeIdentityPoolResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeIdentityPoolRequestMarshaller().marshall(super.beforeMarshalling(describeIdentityPoolRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeIdentityPoolResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeIdentityPoolResultJsonUnmarshaller();
            JsonResponseHandler<DescribeIdentityPoolResult> responseHandler =
                new JsonResponseHandler<DescribeIdentityPoolResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Generates (or retrieves) a Cognito ID. Supplying multiple logins will
     * create an implicit linked account.
     * </p>
     * <p>
     * token+";"+tokenSecret.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getIdRequest Container for the necessary parameters to execute
     *           the GetId service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetId service method, as returned by
     *         AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws LimitExceededException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdResult getId(GetIdRequest getIdRequest) {
        ExecutionContext executionContext = createExecutionContext(getIdRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetIdRequest> request = null;
        Response<GetIdResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetIdRequestMarshaller().marshall(super.beforeMarshalling(getIdRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetIdResult, JsonUnmarshallerContext> unmarshaller =
                new GetIdResultJsonUnmarshaller();
            JsonResponseHandler<GetIdResult> responseHandler =
                new JsonResponseHandler<GetIdResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Deletes a user pool. Once a pool is deleted, users will not be able
     * to authenticate with the pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param deleteIdentityPoolRequest Container for the necessary
     *           parameters to execute the DeleteIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteIdentityPool(DeleteIdentityPoolRequest deleteIdentityPoolRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteIdentityPoolRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteIdentityPoolRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteIdentityPoolRequestMarshaller().marshall(super.beforeMarshalling(deleteIdentityPoolRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Updates a user pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param updateIdentityPoolRequest Container for the necessary
     *           parameters to execute the UpdateIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the UpdateIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateIdentityPoolResult updateIdentityPool(UpdateIdentityPoolRequest updateIdentityPoolRequest) {
        ExecutionContext executionContext = createExecutionContext(updateIdentityPoolRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateIdentityPoolRequest> request = null;
        Response<UpdateIdentityPoolResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateIdentityPoolRequestMarshaller().marshall(super.beforeMarshalling(updateIdentityPoolRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<UpdateIdentityPoolResult, JsonUnmarshallerContext> unmarshaller =
                new UpdateIdentityPoolResultJsonUnmarshaller();
            JsonResponseHandler<UpdateIdentityPoolResult> responseHandler =
                new JsonResponseHandler<UpdateIdentityPoolResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns credentials for the the provided identity ID. Any provided
     * logins will be validated against supported login providers. If the
     * token is for cognito-identity.amazonaws.com, it will be passed through
     * to AWS Security Token Service with the appropriate role for the token.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getCredentialsForIdentityRequest Container for the necessary
     *           parameters to execute the GetCredentialsForIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the GetCredentialsForIdentity service
     *         method, as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws InvalidIdentityPoolConfigurationException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCredentialsForIdentityResult getCredentialsForIdentity(GetCredentialsForIdentityRequest getCredentialsForIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(getCredentialsForIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetCredentialsForIdentityRequest> request = null;
        Response<GetCredentialsForIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetCredentialsForIdentityRequestMarshaller().marshall(super.beforeMarshalling(getCredentialsForIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetCredentialsForIdentityResult, JsonUnmarshallerContext> unmarshaller =
                new GetCredentialsForIdentityResultJsonUnmarshaller();
            JsonResponseHandler<GetCredentialsForIdentityResult> responseHandler =
                new JsonResponseHandler<GetCredentialsForIdentityResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Merges two users having different <code>IdentityId</code> s, existing
     * in the same identity pool, and identified by the same developer
     * provider. You can use this action to request that discrete users be
     * merged and identified as a single user in the Cognito environment.
     * Cognito associates the given source user (
     * <code>SourceUserIdentifier</code> ) with the <code>IdentityId</code>
     * of the <code>DestinationUserIdentifier</code> . Only
     * developer-authenticated users can be merged. If the users to be merged
     * are associated with the same public provider, but as two different
     * users, an exception will be thrown.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param mergeDeveloperIdentitiesRequest Container for the necessary
     *           parameters to execute the MergeDeveloperIdentities service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the MergeDeveloperIdentities service method,
     *         as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public MergeDeveloperIdentitiesResult mergeDeveloperIdentities(MergeDeveloperIdentitiesRequest mergeDeveloperIdentitiesRequest) {
        ExecutionContext executionContext = createExecutionContext(mergeDeveloperIdentitiesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<MergeDeveloperIdentitiesRequest> request = null;
        Response<MergeDeveloperIdentitiesResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new MergeDeveloperIdentitiesRequestMarshaller().marshall(super.beforeMarshalling(mergeDeveloperIdentitiesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<MergeDeveloperIdentitiesResult, JsonUnmarshallerContext> unmarshaller =
                new MergeDeveloperIdentitiesResultJsonUnmarshaller();
            JsonResponseHandler<MergeDeveloperIdentitiesResult> responseHandler =
                new JsonResponseHandler<MergeDeveloperIdentitiesResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Lists all of the Cognito identity pools registered for your account.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param listIdentityPoolsRequest Container for the necessary parameters
     *           to execute the ListIdentityPools service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the ListIdentityPools service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentityPoolsResult listIdentityPools(ListIdentityPoolsRequest listIdentityPoolsRequest) {
        ExecutionContext executionContext = createExecutionContext(listIdentityPoolsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListIdentityPoolsRequest> request = null;
        Response<ListIdentityPoolsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListIdentityPoolsRequestMarshaller().marshall(super.beforeMarshalling(listIdentityPoolsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListIdentityPoolsResult, JsonUnmarshallerContext> unmarshaller =
                new ListIdentityPoolsResultJsonUnmarshaller();
            JsonResponseHandler<ListIdentityPoolsResult> responseHandler =
                new JsonResponseHandler<ListIdentityPoolsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets an OpenID token, using a known Cognito ID. This known Cognito ID
     * is returned by GetId. You can optionally add additional logins for the
     * identity. Supplying multiple logins creates an implicit link.
     * </p>
     * <p>
     * The OpenId token is valid for 15 minutes.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param getOpenIdTokenRequest Container for the necessary parameters to
     *           execute the GetOpenIdToken service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetOpenIdToken service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetOpenIdTokenResult getOpenIdToken(GetOpenIdTokenRequest getOpenIdTokenRequest) {
        ExecutionContext executionContext = createExecutionContext(getOpenIdTokenRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetOpenIdTokenRequest> request = null;
        Response<GetOpenIdTokenResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetOpenIdTokenRequestMarshaller().marshall(super.beforeMarshalling(getOpenIdTokenRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetOpenIdTokenResult, JsonUnmarshallerContext> unmarshaller =
                new GetOpenIdTokenResultJsonUnmarshaller();
            JsonResponseHandler<GetOpenIdTokenResult> responseHandler =
                new JsonResponseHandler<GetOpenIdTokenResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Retrieves the <code>IdentityID</code> associated with a
     * <code>DeveloperUserIdentifier</code> or the list of
     * <code>DeveloperUserIdentifier</code> s associated with an
     * <code>IdentityId</code> for an existing identity. Either
     * <code>IdentityID</code> or <code>DeveloperUserIdentifier</code> must
     * not be null. If you supply only one of these values, the other value
     * will be searched in the database and returned as a part of the
     * response. If you supply both, <code>DeveloperUserIdentifier</code>
     * will be matched against <code>IdentityID</code> . If the values are
     * verified against the database, the response returns both values and is
     * the same as the request. Otherwise a
     * <code>ResourceConflictException</code> is thrown.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param lookupDeveloperIdentityRequest Container for the necessary
     *           parameters to execute the LookupDeveloperIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the LookupDeveloperIdentity service method,
     *         as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public LookupDeveloperIdentityResult lookupDeveloperIdentity(LookupDeveloperIdentityRequest lookupDeveloperIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(lookupDeveloperIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<LookupDeveloperIdentityRequest> request = null;
        Response<LookupDeveloperIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new LookupDeveloperIdentityRequestMarshaller().marshall(super.beforeMarshalling(lookupDeveloperIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<LookupDeveloperIdentityResult, JsonUnmarshallerContext> unmarshaller =
                new LookupDeveloperIdentityResultJsonUnmarshaller();
            JsonResponseHandler<LookupDeveloperIdentityResult> responseHandler =
                new JsonResponseHandler<LookupDeveloperIdentityResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns metadata related to the given identity, including when the
     * identity was created and any associated linked logins.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param describeIdentityRequest Container for the necessary parameters
     *           to execute the DescribeIdentity service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the DescribeIdentity service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityResult describeIdentity(DescribeIdentityRequest describeIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(describeIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeIdentityRequest> request = null;
        Response<DescribeIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeIdentityRequestMarshaller().marshall(super.beforeMarshalling(describeIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeIdentityResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeIdentityResultJsonUnmarshaller();
            JsonResponseHandler<DescribeIdentityResult> responseHandler =
                new JsonResponseHandler<DescribeIdentityResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Sets the roles for an identity pool. These roles are used when making
     * calls to <code>GetCredentialsForIdentity</code> action.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param setIdentityPoolRolesRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolRoles service method on
     *           AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setIdentityPoolRoles(SetIdentityPoolRolesRequest setIdentityPoolRolesRequest) {
        ExecutionContext executionContext = createExecutionContext(setIdentityPoolRolesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetIdentityPoolRolesRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetIdentityPoolRolesRequestMarshaller().marshall(super.beforeMarshalling(setIdentityPoolRolesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Unlinks a federated identity from an existing account. Unlinked
     * logins will be considered new identities next time they are seen.
     * Removing the last linked login will make this identity inaccessible.
     * </p>
     * <p>
     * This is a public API. You do not need any credentials to call this
     * API.
     * </p>
     *
     * @param unlinkIdentityRequest Container for the necessary parameters to
     *           execute the UnlinkIdentity service method on AmazonCognitoIdentity.
     * 
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     * @throws ExternalServiceException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void unlinkIdentity(UnlinkIdentityRequest unlinkIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(unlinkIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UnlinkIdentityRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UnlinkIdentityRequestMarshaller().marshall(super.beforeMarshalling(unlinkIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Lists the identities in a pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param listIdentitiesRequest Container for the necessary parameters to
     *           execute the ListIdentities service method on AmazonCognitoIdentity.
     * 
     * @return The response from the ListIdentities service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentitiesResult listIdentities(ListIdentitiesRequest listIdentitiesRequest) {
        ExecutionContext executionContext = createExecutionContext(listIdentitiesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListIdentitiesRequest> request = null;
        Response<ListIdentitiesResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListIdentitiesRequestMarshaller().marshall(super.beforeMarshalling(listIdentitiesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListIdentitiesResult, JsonUnmarshallerContext> unmarshaller =
                new ListIdentitiesResultJsonUnmarshaller();
            JsonResponseHandler<ListIdentitiesResult> responseHandler =
                new JsonResponseHandler<ListIdentitiesResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets the roles for an identity pool.
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param getIdentityPoolRolesRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolRoles service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the GetIdentityPoolRoles service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdentityPoolRolesResult getIdentityPoolRoles(GetIdentityPoolRolesRequest getIdentityPoolRolesRequest) {
        ExecutionContext executionContext = createExecutionContext(getIdentityPoolRolesRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetIdentityPoolRolesRequest> request = null;
        Response<GetIdentityPoolRolesResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetIdentityPoolRolesRequestMarshaller().marshall(super.beforeMarshalling(getIdentityPoolRolesRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetIdentityPoolRolesResult, JsonUnmarshallerContext> unmarshaller =
                new GetIdentityPoolRolesResultJsonUnmarshaller();
            JsonResponseHandler<GetIdentityPoolRolesResult> responseHandler =
                new JsonResponseHandler<GetIdentityPoolRolesResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Registers (or retrieves) a Cognito <code>IdentityId</code> and an
     * OpenID Connect token for a user authenticated by your backend
     * authentication process. Supplying multiple logins will create an
     * implicit linked account. You can only specify one developer provider
     * as part of the <code>Logins</code> map, which is linked to the
     * identity pool. The developer provider is the "domain" by which Cognito
     * will refer to your users.
     * </p>
     * <p>
     * You can use <code>GetOpenIdTokenForDeveloperIdentity</code> to create
     * a new identity and to link new logins (that is, user credentials
     * issued by a public provider or developer provider) to an existing
     * identity. When you want to create a new identity, the
     * <code>IdentityId</code> should be null. When you want to associate a
     * new login with an existing authenticated/unauthenticated identity, you
     * can do so by providing the existing <code>IdentityId</code> . This API
     * will create the identity in the specified <code>IdentityPoolId</code>
     * .
     * </p>
     * <p>
     * You must use AWS Developer credentials to call this API.
     * </p>
     *
     * @param getOpenIdTokenForDeveloperIdentityRequest Container for the
     *           necessary parameters to execute the GetOpenIdTokenForDeveloperIdentity
     *           service method on AmazonCognitoIdentity.
     * 
     * @return The response from the GetOpenIdTokenForDeveloperIdentity
     *         service method, as returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     * @throws DeveloperUserAlreadyRegisteredException
     * @throws ResourceNotFoundException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetOpenIdTokenForDeveloperIdentityResult getOpenIdTokenForDeveloperIdentity(GetOpenIdTokenForDeveloperIdentityRequest getOpenIdTokenForDeveloperIdentityRequest) {
        ExecutionContext executionContext = createExecutionContext(getOpenIdTokenForDeveloperIdentityRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetOpenIdTokenForDeveloperIdentityRequest> request = null;
        Response<GetOpenIdTokenForDeveloperIdentityResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetOpenIdTokenForDeveloperIdentityRequestMarshaller().marshall(super.beforeMarshalling(getOpenIdTokenForDeveloperIdentityRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetOpenIdTokenForDeveloperIdentityResult, JsonUnmarshallerContext> unmarshaller =
                new GetOpenIdTokenForDeveloperIdentityResultJsonUnmarshaller();
            JsonResponseHandler<GetOpenIdTokenForDeveloperIdentityResult> responseHandler =
                new JsonResponseHandler<GetOpenIdTokenForDeveloperIdentityResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Creates a new identity pool. The identity pool is a store of user
     * identity information that is specific to your AWS account. The limit
     * on identity pools is 60 per account. You must use AWS Developer
     * credentials to call this API.
     * </p>
     *
     * @param createIdentityPoolRequest Container for the necessary
     *           parameters to execute the CreateIdentityPool service method on
     *           AmazonCognitoIdentity.
     * 
     * @return The response from the CreateIdentityPool service method, as
     *         returned by AmazonCognitoIdentity.
     * 
     * @throws ResourceConflictException
     * @throws InternalErrorException
     * @throws LimitExceededException
     * @throws NotAuthorizedException
     * @throws InvalidParameterException
     * @throws TooManyRequestsException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoIdentity indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateIdentityPoolResult createIdentityPool(CreateIdentityPoolRequest createIdentityPoolRequest) {
        ExecutionContext executionContext = createExecutionContext(createIdentityPoolRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateIdentityPoolRequest> request = null;
        Response<CreateIdentityPoolResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateIdentityPoolRequestMarshaller().marshall(super.beforeMarshalling(createIdentityPoolRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<CreateIdentityPoolResult, JsonUnmarshallerContext> unmarshaller =
                new CreateIdentityPoolResultJsonUnmarshaller();
            JsonResponseHandler<CreateIdentityPoolResult> responseHandler =
                new JsonResponseHandler<CreateIdentityPoolResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    @Override
    public void setEndpoint(String endpoint) {
        super.setEndpoint(endpoint);
    }

    @Override
    public void setEndpoint(String endpoint, String serviceName, String regionId) throws IllegalArgumentException {
        super.setEndpoint(endpoint, serviceName, regionId);
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext) {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);

        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        AWSCredentials credentials;
        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
        try {
            credentials = awsCredentialsProvider.getCredentials();
        } finally {
            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
        }

        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(jsonErrorUnmarshallers);
        Response<X> result = client.execute(request, responseHandler,
                errorResponseHandler, executionContext);
        return result;
    }
}
        

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/AmazonCognitoSync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.cognitosync.model.*;

/**
 * Interface for accessing AmazonCognitoSync.
 * Amazon Cognito Sync <p>
 * Amazon Cognito Sync provides an AWS service and client library that
 * enable cross-device syncing of application-related user data.
 * High-level client libraries are available for both iOS and Android.
 * You can use these libraries to persist data locally so that it's
 * available even if the device is offline. Developer credentials don't
 * need to be stored on the mobile device to access the service. You can
 * use Amazon Cognito to obtain a normalized user ID and credentials.
 * User data is persisted in a dataset that can store up to 1 MB of
 * key-value pairs, and you can have up to 20 datasets per user identity.
 * </p>
 * <p>
 * With Amazon Cognito Sync, the data stored for each identity is
 * accessible only to credentials assigned to that identity. In order to
 * use the Cognito Sync service, you need to make API calls using
 * credentials retrieved with
 * <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/Welcome.html"> Amazon Cognito Identity service </a>
 * .
 * </p>
 * <p>
 * If you want to use Cognito Sync in an Android or iOS application, you
 * will probably want to make API calls via the AWS Mobile SDK. To learn
 * more, see the
 * <a href="http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-sync.html"> Developer Guide for Android </a> and the <a href="http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-sync.html"> Developer Guide for iOS </a>
 * .
 * </p>
 */
public interface AmazonCognitoSync {

    /**
     * Overrides the default endpoint for this client ("https://cognito-sync.us-east-1.amazonaws.com/").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "cognito-sync.us-east-1.amazonaws.com/") or a full
     * URL, including the protocol (ex: "https://cognito-sync.us-east-1.amazonaws.com/"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "cognito-sync.us-east-1.amazonaws.com/") or a full URL,
     *            including the protocol (ex: "https://cognito-sync.us-east-1.amazonaws.com/") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonCognitoSync#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords service method on AmazonCognitoSync.
     * 
     * @return The response from the UpdateRecords service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws LimitExceededException
     * @throws TooManyRequestsException
     * @throws ResourceConflictException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws InvalidLambdaFunctionOutputException
     * @throws NotAuthorizedException
     * @throws LambdaThrottledException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateRecordsResult updateRecords(UpdateRecordsRequest updateRecordsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents service method on AmazonCognitoSync.
     * 
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setCognitoEvents(SetCognitoEventsRequest setCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents service method on AmazonCognitoSync.
     * 
     * @return The response from the GetCognitoEvents service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCognitoEventsResult getCognitoEvents(GetCognitoEventsRequest getCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the DescribeIdentityUsage service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityUsageResult describeIdentityUsage(DescribeIdentityUsageRequest describeIdentityUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the UnsubscribeFromDataset service method,
     *         as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UnsubscribeFromDatasetResult unsubscribeFromDataset(UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration service method
     *           on AmazonCognitoSync.
     * 
     * @return The response from the SetIdentityPoolConfiguration service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public SetIdentityPoolConfigurationResult setIdentityPoolConfiguration(SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration service method
     *           on AmazonCognitoSync.
     * 
     * @return The response from the GetIdentityPoolConfiguration service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdentityPoolConfigurationResult getIdentityPoolConfiguration(GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the SubscribeToDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public SubscribeToDatasetResult subscribeToDataset(SubscribeToDatasetRequest subscribeToDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the DescribeIdentityPoolUsage service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityPoolUsageResult describeIdentityPoolUsage(DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets service method on AmazonCognitoSync.
     * 
     * @return The response from the ListDatasets service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListDatasetsResult listDatasets(ListDatasetsRequest listDatasetsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the ListIdentityPoolUsage service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentityPoolUsageResult listIdentityPoolUsage(ListIdentityPoolUsageRequest listIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords service method on AmazonCognitoSync.
     * 
     * @return The response from the ListRecords service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListRecordsResult listRecords(ListRecordsRequest listRecordsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the GetBulkPublishDetails service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetBulkPublishDetailsResult getBulkPublishDetails(GetBulkPublishDetailsRequest getBulkPublishDetailsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish service method on AmazonCognitoSync.
     * 
     * @return The response from the BulkPublish service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     * @throws DuplicateRequestException
     * @throws AlreadyStreamedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public BulkPublishResult bulkPublish(BulkPublishRequest bulkPublishRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset service method on AmazonCognitoSync.
     * 
     * @return The response from the DescribeDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDatasetResult describeDataset(DescribeDatasetRequest describeDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset service method on AmazonCognitoSync.
     * 
     * @return The response from the DeleteDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws ResourceConflictException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeleteDatasetResult deleteDataset(DeleteDatasetRequest deleteDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice service method on AmazonCognitoSync.
     * 
     * @return The response from the RegisterDevice service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public RegisterDeviceResult registerDevice(RegisterDeviceRequest registerDeviceRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/AmazonCognitoSyncAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.cognitosync.model.*;

/**
 * Interface for accessing AmazonCognitoSync asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * Amazon Cognito Sync <p>
 * Amazon Cognito Sync provides an AWS service and client library that
 * enable cross-device syncing of application-related user data.
 * High-level client libraries are available for both iOS and Android.
 * You can use these libraries to persist data locally so that it's
 * available even if the device is offline. Developer credentials don't
 * need to be stored on the mobile device to access the service. You can
 * use Amazon Cognito to obtain a normalized user ID and credentials.
 * User data is persisted in a dataset that can store up to 1 MB of
 * key-value pairs, and you can have up to 20 datasets per user identity.
 * </p>
 * <p>
 * With Amazon Cognito Sync, the data stored for each identity is
 * accessible only to credentials assigned to that identity. In order to
 * use the Cognito Sync service, you need to make API calls using
 * credentials retrieved with
 * <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/Welcome.html"> Amazon Cognito Identity service </a>
 * .
 * </p>
 * <p>
 * If you want to use Cognito Sync in an Android or iOS application, you
 * will probably want to make API calls via the AWS Mobile SDK. To learn
 * more, see the
 * <a href="http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-sync.html"> Developer Guide for Android </a> and the <a href="http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-sync.html"> Developer Guide for iOS </a>
 * .
 * </p>
 */
public interface AmazonCognitoSyncAsync extends AmazonCognitoSync {
    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateRecordsResult> updateRecordsAsync(UpdateRecordsRequest updateRecordsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateRecordsResult> updateRecordsAsync(UpdateRecordsRequest updateRecordsRequest,
            AsyncHandler<UpdateRecordsRequest, UpdateRecordsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setCognitoEventsAsync(SetCognitoEventsRequest setCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setCognitoEventsAsync(SetCognitoEventsRequest setCognitoEventsRequest,
            AsyncHandler<SetCognitoEventsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCognitoEventsResult> getCognitoEventsAsync(GetCognitoEventsRequest getCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCognitoEventsResult> getCognitoEventsAsync(GetCognitoEventsRequest getCognitoEventsRequest,
            AsyncHandler<GetCognitoEventsRequest, GetCognitoEventsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityUsageResult> describeIdentityUsageAsync(DescribeIdentityUsageRequest describeIdentityUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityUsageResult> describeIdentityUsageAsync(DescribeIdentityUsageRequest describeIdentityUsageRequest,
            AsyncHandler<DescribeIdentityUsageRequest, DescribeIdentityUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         UnsubscribeFromDataset service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UnsubscribeFromDatasetResult> unsubscribeFromDatasetAsync(UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UnsubscribeFromDataset service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UnsubscribeFromDatasetResult> unsubscribeFromDatasetAsync(UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest,
            AsyncHandler<UnsubscribeFromDatasetRequest, UnsubscribeFromDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SetIdentityPoolConfigurationResult> setIdentityPoolConfigurationAsync(SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SetIdentityPoolConfigurationResult> setIdentityPoolConfigurationAsync(SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest,
            AsyncHandler<SetIdentityPoolConfigurationRequest, SetIdentityPoolConfigurationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetIdentityPoolConfigurationResult> getIdentityPoolConfigurationAsync(GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetIdentityPoolConfigurationResult> getIdentityPoolConfigurationAsync(GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest,
            AsyncHandler<GetIdentityPoolConfigurationRequest, GetIdentityPoolConfigurationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SubscribeToDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SubscribeToDatasetResult> subscribeToDatasetAsync(SubscribeToDatasetRequest subscribeToDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SubscribeToDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SubscribeToDatasetResult> subscribeToDatasetAsync(SubscribeToDatasetRequest subscribeToDatasetRequest,
            AsyncHandler<SubscribeToDatasetRequest, SubscribeToDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityPoolUsageResult> describeIdentityPoolUsageAsync(DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityPoolUsageResult> describeIdentityPoolUsageAsync(DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest,
            AsyncHandler<DescribeIdentityPoolUsageRequest, DescribeIdentityPoolUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListDatasets service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDatasetsResult> listDatasetsAsync(ListDatasetsRequest listDatasetsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListDatasets service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDatasetsResult> listDatasetsAsync(ListDatasetsRequest listDatasetsRequest,
            AsyncHandler<ListDatasetsRequest, ListDatasetsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListIdentityPoolUsageResult> listIdentityPoolUsageAsync(ListIdentityPoolUsageRequest listIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListIdentityPoolUsageResult> listIdentityPoolUsageAsync(ListIdentityPoolUsageRequest listIdentityPoolUsageRequest,
            AsyncHandler<ListIdentityPoolUsageRequest, ListIdentityPoolUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListRecordsResult> listRecordsAsync(ListRecordsRequest listRecordsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListRecordsResult> listRecordsAsync(ListRecordsRequest listRecordsRequest,
            AsyncHandler<ListRecordsRequest, ListRecordsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetBulkPublishDetails service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetBulkPublishDetailsResult> getBulkPublishDetailsAsync(GetBulkPublishDetailsRequest getBulkPublishDetailsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetBulkPublishDetails service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetBulkPublishDetailsResult> getBulkPublishDetailsAsync(GetBulkPublishDetailsRequest getBulkPublishDetailsRequest,
            AsyncHandler<GetBulkPublishDetailsRequest, GetBulkPublishDetailsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         BulkPublish service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<BulkPublishResult> bulkPublishAsync(BulkPublishRequest bulkPublishRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         BulkPublish service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<BulkPublishResult> bulkPublishAsync(BulkPublishRequest bulkPublishRequest,
            AsyncHandler<BulkPublishRequest, BulkPublishResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDatasetResult> describeDatasetAsync(DescribeDatasetRequest describeDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDatasetResult> describeDatasetAsync(DescribeDatasetRequest describeDatasetRequest,
            AsyncHandler<DescribeDatasetRequest, DescribeDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeleteDatasetResult> deleteDatasetAsync(DeleteDatasetRequest deleteDatasetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeleteDatasetResult> deleteDatasetAsync(DeleteDatasetRequest deleteDatasetRequest,
            AsyncHandler<DeleteDatasetRequest, DeleteDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         RegisterDevice service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<RegisterDeviceResult> registerDeviceAsync(RegisterDeviceRequest registerDeviceRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         RegisterDevice service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<RegisterDeviceResult> registerDeviceAsync(RegisterDeviceRequest registerDeviceRequest,
            AsyncHandler<RegisterDeviceRequest, RegisterDeviceResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/AmazonCognitoSyncAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.cognitosync.model.*;

/**
 * Asynchronous client for accessing AmazonCognitoSync.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * Amazon Cognito Sync <p>
 * Amazon Cognito Sync provides an AWS service and client library that
 * enable cross-device syncing of application-related user data.
 * High-level client libraries are available for both iOS and Android.
 * You can use these libraries to persist data locally so that it's
 * available even if the device is offline. Developer credentials don't
 * need to be stored on the mobile device to access the service. You can
 * use Amazon Cognito to obtain a normalized user ID and credentials.
 * User data is persisted in a dataset that can store up to 1 MB of
 * key-value pairs, and you can have up to 20 datasets per user identity.
 * </p>
 * <p>
 * With Amazon Cognito Sync, the data stored for each identity is
 * accessible only to credentials assigned to that identity. In order to
 * use the Cognito Sync service, you need to make API calls using
 * credentials retrieved with
 * <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/Welcome.html"> Amazon Cognito Identity service </a>
 * .
 * </p>
 * <p>
 * If you want to use Cognito Sync in an Android or iOS application, you
 * will probably want to make API calls via the AWS Mobile SDK. To learn
 * more, see the
 * <a href="http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-sync.html"> Developer Guide for Android </a> and the <a href="http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-sync.html"> Developer Guide for iOS </a>
 * .
 * </p>
 */
public class AmazonCognitoSyncAsyncClient extends AmazonCognitoSyncClient
        implements AmazonCognitoSyncAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoSyncAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoSync
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoSyncAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonCognitoSyncAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateRecordsResult> updateRecordsAsync(final UpdateRecordsRequest updateRecordsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateRecordsResult>() {
            public UpdateRecordsResult call() throws Exception {
                return updateRecords(updateRecordsRequest);
        }
    });
    }

    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateRecordsResult> updateRecordsAsync(
            final UpdateRecordsRequest updateRecordsRequest,
            final AsyncHandler<UpdateRecordsRequest, UpdateRecordsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateRecordsResult>() {
            public UpdateRecordsResult call() throws Exception {
              UpdateRecordsResult result;
                try {
                result = updateRecords(updateRecordsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(updateRecordsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setCognitoEventsAsync(final SetCognitoEventsRequest setCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                setCognitoEvents(setCognitoEventsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setCognitoEventsAsync(
            final SetCognitoEventsRequest setCognitoEventsRequest,
            final AsyncHandler<SetCognitoEventsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                setCognitoEvents(setCognitoEventsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(setCognitoEventsRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCognitoEventsResult> getCognitoEventsAsync(final GetCognitoEventsRequest getCognitoEventsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCognitoEventsResult>() {
            public GetCognitoEventsResult call() throws Exception {
                return getCognitoEvents(getCognitoEventsRequest);
        }
    });
    }

    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetCognitoEvents service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetCognitoEventsResult> getCognitoEventsAsync(
            final GetCognitoEventsRequest getCognitoEventsRequest,
            final AsyncHandler<GetCognitoEventsRequest, GetCognitoEventsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetCognitoEventsResult>() {
            public GetCognitoEventsResult call() throws Exception {
              GetCognitoEventsResult result;
                try {
                result = getCognitoEvents(getCognitoEventsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getCognitoEventsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityUsageResult> describeIdentityUsageAsync(final DescribeIdentityUsageRequest describeIdentityUsageRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeIdentityUsageResult>() {
            public DescribeIdentityUsageResult call() throws Exception {
                return describeIdentityUsage(describeIdentityUsageRequest);
        }
    });
    }

    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityUsageResult> describeIdentityUsageAsync(
            final DescribeIdentityUsageRequest describeIdentityUsageRequest,
            final AsyncHandler<DescribeIdentityUsageRequest, DescribeIdentityUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeIdentityUsageResult>() {
            public DescribeIdentityUsageResult call() throws Exception {
              DescribeIdentityUsageResult result;
                try {
                result = describeIdentityUsage(describeIdentityUsageRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeIdentityUsageRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         UnsubscribeFromDataset service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UnsubscribeFromDatasetResult> unsubscribeFromDatasetAsync(final UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UnsubscribeFromDatasetResult>() {
            public UnsubscribeFromDatasetResult call() throws Exception {
                return unsubscribeFromDataset(unsubscribeFromDatasetRequest);
        }
    });
    }

    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UnsubscribeFromDataset service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UnsubscribeFromDatasetResult> unsubscribeFromDatasetAsync(
            final UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest,
            final AsyncHandler<UnsubscribeFromDatasetRequest, UnsubscribeFromDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UnsubscribeFromDatasetResult>() {
            public UnsubscribeFromDatasetResult call() throws Exception {
              UnsubscribeFromDatasetResult result;
                try {
                result = unsubscribeFromDataset(unsubscribeFromDatasetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(unsubscribeFromDatasetRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SetIdentityPoolConfigurationResult> setIdentityPoolConfigurationAsync(final SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<SetIdentityPoolConfigurationResult>() {
            public SetIdentityPoolConfigurationResult call() throws Exception {
                return setIdentityPoolConfiguration(setIdentityPoolConfigurationRequest);
        }
    });
    }

    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SetIdentityPoolConfigurationResult> setIdentityPoolConfigurationAsync(
            final SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest,
            final AsyncHandler<SetIdentityPoolConfigurationRequest, SetIdentityPoolConfigurationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<SetIdentityPoolConfigurationResult>() {
            public SetIdentityPoolConfigurationResult call() throws Exception {
              SetIdentityPoolConfigurationResult result;
                try {
                result = setIdentityPoolConfiguration(setIdentityPoolConfigurationRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(setIdentityPoolConfigurationRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetIdentityPoolConfigurationResult> getIdentityPoolConfigurationAsync(final GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetIdentityPoolConfigurationResult>() {
            public GetIdentityPoolConfigurationResult call() throws Exception {
                return getIdentityPoolConfiguration(getIdentityPoolConfigurationRequest);
        }
    });
    }

    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetIdentityPoolConfiguration service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetIdentityPoolConfigurationResult> getIdentityPoolConfigurationAsync(
            final GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest,
            final AsyncHandler<GetIdentityPoolConfigurationRequest, GetIdentityPoolConfigurationResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetIdentityPoolConfigurationResult>() {
            public GetIdentityPoolConfigurationResult call() throws Exception {
              GetIdentityPoolConfigurationResult result;
                try {
                result = getIdentityPoolConfiguration(getIdentityPoolConfigurationRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getIdentityPoolConfigurationRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         SubscribeToDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SubscribeToDatasetResult> subscribeToDatasetAsync(final SubscribeToDatasetRequest subscribeToDatasetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<SubscribeToDatasetResult>() {
            public SubscribeToDatasetResult call() throws Exception {
                return subscribeToDataset(subscribeToDatasetRequest);
        }
    });
    }

    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SubscribeToDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<SubscribeToDatasetResult> subscribeToDatasetAsync(
            final SubscribeToDatasetRequest subscribeToDatasetRequest,
            final AsyncHandler<SubscribeToDatasetRequest, SubscribeToDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<SubscribeToDatasetResult>() {
            public SubscribeToDatasetResult call() throws Exception {
              SubscribeToDatasetResult result;
                try {
                result = subscribeToDataset(subscribeToDatasetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(subscribeToDatasetRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityPoolUsageResult> describeIdentityPoolUsageAsync(final DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeIdentityPoolUsageResult>() {
            public DescribeIdentityPoolUsageResult call() throws Exception {
                return describeIdentityPoolUsage(describeIdentityPoolUsageRequest);
        }
    });
    }

    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeIdentityPoolUsageResult> describeIdentityPoolUsageAsync(
            final DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest,
            final AsyncHandler<DescribeIdentityPoolUsageRequest, DescribeIdentityPoolUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeIdentityPoolUsageResult>() {
            public DescribeIdentityPoolUsageResult call() throws Exception {
              DescribeIdentityPoolUsageResult result;
                try {
                result = describeIdentityPoolUsage(describeIdentityPoolUsageRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeIdentityPoolUsageRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListDatasets service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDatasetsResult> listDatasetsAsync(final ListDatasetsRequest listDatasetsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListDatasetsResult>() {
            public ListDatasetsResult call() throws Exception {
                return listDatasets(listDatasetsRequest);
        }
    });
    }

    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListDatasets service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListDatasetsResult> listDatasetsAsync(
            final ListDatasetsRequest listDatasetsRequest,
            final AsyncHandler<ListDatasetsRequest, ListDatasetsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListDatasetsResult>() {
            public ListDatasetsResult call() throws Exception {
              ListDatasetsResult result;
                try {
                result = listDatasets(listDatasetsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listDatasetsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListIdentityPoolUsageResult> listIdentityPoolUsageAsync(final ListIdentityPoolUsageRequest listIdentityPoolUsageRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListIdentityPoolUsageResult>() {
            public ListIdentityPoolUsageResult call() throws Exception {
                return listIdentityPoolUsage(listIdentityPoolUsageRequest);
        }
    });
    }

    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListIdentityPoolUsage service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListIdentityPoolUsageResult> listIdentityPoolUsageAsync(
            final ListIdentityPoolUsageRequest listIdentityPoolUsageRequest,
            final AsyncHandler<ListIdentityPoolUsageRequest, ListIdentityPoolUsageResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListIdentityPoolUsageResult>() {
            public ListIdentityPoolUsageResult call() throws Exception {
              ListIdentityPoolUsageResult result;
                try {
                result = listIdentityPoolUsage(listIdentityPoolUsageRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listIdentityPoolUsageRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         ListRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListRecordsResult> listRecordsAsync(final ListRecordsRequest listRecordsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListRecordsResult>() {
            public ListRecordsResult call() throws Exception {
                return listRecords(listRecordsRequest);
        }
    });
    }

    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListRecords service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListRecordsResult> listRecordsAsync(
            final ListRecordsRequest listRecordsRequest,
            final AsyncHandler<ListRecordsRequest, ListRecordsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListRecordsResult>() {
            public ListRecordsResult call() throws Exception {
              ListRecordsResult result;
                try {
                result = listRecords(listRecordsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listRecordsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails operation on
     *           AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         GetBulkPublishDetails service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetBulkPublishDetailsResult> getBulkPublishDetailsAsync(final GetBulkPublishDetailsRequest getBulkPublishDetailsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetBulkPublishDetailsResult>() {
            public GetBulkPublishDetailsResult call() throws Exception {
                return getBulkPublishDetails(getBulkPublishDetailsRequest);
        }
    });
    }

    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails operation on
     *           AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetBulkPublishDetails service method, as returned by
     *         AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetBulkPublishDetailsResult> getBulkPublishDetailsAsync(
            final GetBulkPublishDetailsRequest getBulkPublishDetailsRequest,
            final AsyncHandler<GetBulkPublishDetailsRequest, GetBulkPublishDetailsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetBulkPublishDetailsResult>() {
            public GetBulkPublishDetailsResult call() throws Exception {
              GetBulkPublishDetailsResult result;
                try {
                result = getBulkPublishDetails(getBulkPublishDetailsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getBulkPublishDetailsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         BulkPublish service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<BulkPublishResult> bulkPublishAsync(final BulkPublishRequest bulkPublishRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<BulkPublishResult>() {
            public BulkPublishResult call() throws Exception {
                return bulkPublish(bulkPublishRequest);
        }
    });
    }

    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         BulkPublish service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<BulkPublishResult> bulkPublishAsync(
            final BulkPublishRequest bulkPublishRequest,
            final AsyncHandler<BulkPublishRequest, BulkPublishResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<BulkPublishResult>() {
            public BulkPublishResult call() throws Exception {
              BulkPublishResult result;
                try {
                result = bulkPublish(bulkPublishRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(bulkPublishRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDatasetResult> describeDatasetAsync(final DescribeDatasetRequest describeDatasetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDatasetResult>() {
            public DescribeDatasetResult call() throws Exception {
                return describeDataset(describeDatasetRequest);
        }
    });
    }

    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDatasetResult> describeDatasetAsync(
            final DescribeDatasetRequest describeDatasetRequest,
            final AsyncHandler<DescribeDatasetRequest, DescribeDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDatasetResult>() {
            public DescribeDatasetResult call() throws Exception {
              DescribeDatasetResult result;
                try {
                result = describeDataset(describeDatasetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeDatasetRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeleteDatasetResult> deleteDatasetAsync(final DeleteDatasetRequest deleteDatasetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DeleteDatasetResult>() {
            public DeleteDatasetResult call() throws Exception {
                return deleteDataset(deleteDatasetRequest);
        }
    });
    }

    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDataset service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeleteDatasetResult> deleteDatasetAsync(
            final DeleteDatasetRequest deleteDatasetRequest,
            final AsyncHandler<DeleteDatasetRequest, DeleteDatasetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DeleteDatasetResult>() {
            public DeleteDatasetResult call() throws Exception {
              DeleteDatasetResult result;
                try {
                result = deleteDataset(deleteDatasetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteDatasetRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice operation on AmazonCognitoSync.
     * 
     * @return A Java Future object containing the response from the
     *         RegisterDevice service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<RegisterDeviceResult> registerDeviceAsync(final RegisterDeviceRequest registerDeviceRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<RegisterDeviceResult>() {
            public RegisterDeviceResult call() throws Exception {
                return registerDevice(registerDeviceRequest);
        }
    });
    }

    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice operation on AmazonCognitoSync.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         RegisterDevice service method, as returned by AmazonCognitoSync.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<RegisterDeviceResult> registerDeviceAsync(
            final RegisterDeviceRequest registerDeviceRequest,
            final AsyncHandler<RegisterDeviceRequest, RegisterDeviceResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<RegisterDeviceResult>() {
            public RegisterDeviceResult call() throws Exception {
              RegisterDeviceResult result;
                try {
                result = registerDevice(registerDeviceRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(registerDeviceRequest, result);
                 return result;
        }
    });
    }
    
}
        

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/AmazonCognitoSyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync;

import java.net.*;
import java.util.*;

import org.apache.commons.logging.*;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.regions.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;
import com.amazonaws.util.json.*;

import com.amazonaws.services.cognitosync.model.*;
import com.amazonaws.services.cognitosync.model.transform.*;

/**
 * Client for accessing AmazonCognitoSync.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * Amazon Cognito Sync <p>
 * Amazon Cognito Sync provides an AWS service and client library that
 * enable cross-device syncing of application-related user data.
 * High-level client libraries are available for both iOS and Android.
 * You can use these libraries to persist data locally so that it's
 * available even if the device is offline. Developer credentials don't
 * need to be stored on the mobile device to access the service. You can
 * use Amazon Cognito to obtain a normalized user ID and credentials.
 * User data is persisted in a dataset that can store up to 1 MB of
 * key-value pairs, and you can have up to 20 datasets per user identity.
 * </p>
 * <p>
 * With Amazon Cognito Sync, the data stored for each identity is
 * accessible only to credentials assigned to that identity. In order to
 * use the Cognito Sync service, you need to make API calls using
 * credentials retrieved with
 * <a href="http://docs.aws.amazon.com/cognitoidentity/latest/APIReference/Welcome.html"> Amazon Cognito Identity service </a>
 * .
 * </p>
 * <p>
 * If you want to use Cognito Sync in an Android or iOS application, you
 * will probably want to make API calls via the AWS Mobile SDK. To learn
 * more, see the
 * <a href="http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-sync.html"> Developer Guide for Android </a> and the <a href="http://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-sync.html"> Developer Guide for iOS </a>
 * .
 * </p>
 */
public class AmazonCognitoSyncClient extends AmazonWebServiceClient implements AmazonCognitoSync {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    private static final Log log = LogFactory.getLog(AmazonCognitoSync.class);

    /**
     * List of exception unmarshallers for all AmazonCognitoSync exceptions.
     */
    protected List<JsonErrorUnmarshaller> jsonErrorUnmarshallers;

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoSyncClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoSync
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonCognitoSyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonCognitoSyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoSync
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCognitoSyncClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(adjustClientConfiguration(clientConfiguration));
        
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials provider.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonCognitoSyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * provider and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoSync
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonCognitoSyncClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonCognitoSync using the specified AWS account credentials
     * provider, client configuration options and request metric collector.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonCognitoSync
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonCognitoSyncClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
        
        this.awsCredentialsProvider = awsCredentialsProvider;
        
        init();
    }

    private void init() {
        jsonErrorUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
        jsonErrorUnmarshallers.add(new ResourceConflictExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new TooManyRequestsExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new LimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new LambdaThrottledExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidLambdaFunctionOutputExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InternalErrorExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NotAuthorizedExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidConfigurationExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new DuplicateRequestExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidParameterExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ResourceNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new AlreadyStreamedExceptionUnmarshaller());
        
        jsonErrorUnmarshallers.add(new JsonErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("cognito-sync.us-east-1.amazonaws.com/");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/cognitosync/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/cognitosync/request.handler2s"));
    }

    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
        ClientConfiguration config = orig;
        
        return config;
    }

    /**
     * <p>
     * Posts updates to records and adds and deletes records for a dataset
     * and user.
     * </p>
     * <p>
     * UpdateRecords can only be called with temporary user credentials
     * provided by Cognito Identity. You cannot make this API call with
     * developer credentials.
     * </p>
     *
     * @param updateRecordsRequest Container for the necessary parameters to
     *           execute the UpdateRecords service method on AmazonCognitoSync.
     * 
     * @return The response from the UpdateRecords service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws LimitExceededException
     * @throws TooManyRequestsException
     * @throws ResourceConflictException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws InvalidLambdaFunctionOutputException
     * @throws NotAuthorizedException
     * @throws LambdaThrottledException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateRecordsResult updateRecords(UpdateRecordsRequest updateRecordsRequest) {
        ExecutionContext executionContext = createExecutionContext(updateRecordsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateRecordsRequest> request = null;
        Response<UpdateRecordsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateRecordsRequestMarshaller().marshall(super.beforeMarshalling(updateRecordsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<UpdateRecordsResult, JsonUnmarshallerContext> unmarshaller =
                new UpdateRecordsResultJsonUnmarshaller();
            JsonResponseHandler<UpdateRecordsResult> responseHandler =
                new JsonResponseHandler<UpdateRecordsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Sets the AWS Lambda function for a given event type for an identity
     * pool. This request only updates the key/value pair specified. Other
     * key/values pairs are not updated. To remove a key value pair, pass a
     * empty value for the particular key.
     * </p>
     *
     * @param setCognitoEventsRequest Container for the necessary parameters
     *           to execute the SetCognitoEvents service method on AmazonCognitoSync.
     * 
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setCognitoEvents(SetCognitoEventsRequest setCognitoEventsRequest) {
        ExecutionContext executionContext = createExecutionContext(setCognitoEventsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetCognitoEventsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetCognitoEventsRequestMarshaller().marshall(super.beforeMarshalling(setCognitoEventsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Gets the events and the corresponding Lambda functions associated
     * with an identity pool
     * </p>
     *
     * @param getCognitoEventsRequest Container for the necessary parameters
     *           to execute the GetCognitoEvents service method on AmazonCognitoSync.
     * 
     * @return The response from the GetCognitoEvents service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetCognitoEventsResult getCognitoEvents(GetCognitoEventsRequest getCognitoEventsRequest) {
        ExecutionContext executionContext = createExecutionContext(getCognitoEventsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetCognitoEventsRequest> request = null;
        Response<GetCognitoEventsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetCognitoEventsRequestMarshaller().marshall(super.beforeMarshalling(getCognitoEventsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetCognitoEventsResult, JsonUnmarshallerContext> unmarshaller =
                new GetCognitoEventsResultJsonUnmarshaller();
            JsonResponseHandler<GetCognitoEventsResult> responseHandler =
                new JsonResponseHandler<GetCognitoEventsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets usage information for an identity, including number of datasets
     * and data usage.
     * </p>
     * <p>
     * DescribeIdentityUsage can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param describeIdentityUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the DescribeIdentityUsage service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityUsageResult describeIdentityUsage(DescribeIdentityUsageRequest describeIdentityUsageRequest) {
        ExecutionContext executionContext = createExecutionContext(describeIdentityUsageRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeIdentityUsageRequest> request = null;
        Response<DescribeIdentityUsageResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeIdentityUsageRequestMarshaller().marshall(super.beforeMarshalling(describeIdentityUsageRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeIdentityUsageResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeIdentityUsageResultJsonUnmarshaller();
            JsonResponseHandler<DescribeIdentityUsageResult> responseHandler =
                new JsonResponseHandler<DescribeIdentityUsageResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Unsubscribes from receiving notifications when a dataset is modified
     * by another device.
     * </p>
     *
     * @param unsubscribeFromDatasetRequest Container for the necessary
     *           parameters to execute the UnsubscribeFromDataset service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the UnsubscribeFromDataset service method,
     *         as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UnsubscribeFromDatasetResult unsubscribeFromDataset(UnsubscribeFromDatasetRequest unsubscribeFromDatasetRequest) {
        ExecutionContext executionContext = createExecutionContext(unsubscribeFromDatasetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UnsubscribeFromDatasetRequest> request = null;
        Response<UnsubscribeFromDatasetResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UnsubscribeFromDatasetRequestMarshaller().marshall(super.beforeMarshalling(unsubscribeFromDatasetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<UnsubscribeFromDatasetResult, JsonUnmarshallerContext> unmarshaller =
                new UnsubscribeFromDatasetResultJsonUnmarshaller();
            JsonResponseHandler<UnsubscribeFromDatasetResult> responseHandler =
                new JsonResponseHandler<UnsubscribeFromDatasetResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Sets the necessary configuration for push sync.
     * </p>
     *
     * @param setIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the SetIdentityPoolConfiguration service method
     *           on AmazonCognitoSync.
     * 
     * @return The response from the SetIdentityPoolConfiguration service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public SetIdentityPoolConfigurationResult setIdentityPoolConfiguration(SetIdentityPoolConfigurationRequest setIdentityPoolConfigurationRequest) {
        ExecutionContext executionContext = createExecutionContext(setIdentityPoolConfigurationRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetIdentityPoolConfigurationRequest> request = null;
        Response<SetIdentityPoolConfigurationResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetIdentityPoolConfigurationRequestMarshaller().marshall(super.beforeMarshalling(setIdentityPoolConfigurationRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<SetIdentityPoolConfigurationResult, JsonUnmarshallerContext> unmarshaller =
                new SetIdentityPoolConfigurationResultJsonUnmarshaller();
            JsonResponseHandler<SetIdentityPoolConfigurationResult> responseHandler =
                new JsonResponseHandler<SetIdentityPoolConfigurationResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets the configuration settings of an identity pool.
     * </p>
     *
     * @param getIdentityPoolConfigurationRequest Container for the necessary
     *           parameters to execute the GetIdentityPoolConfiguration service method
     *           on AmazonCognitoSync.
     * 
     * @return The response from the GetIdentityPoolConfiguration service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetIdentityPoolConfigurationResult getIdentityPoolConfiguration(GetIdentityPoolConfigurationRequest getIdentityPoolConfigurationRequest) {
        ExecutionContext executionContext = createExecutionContext(getIdentityPoolConfigurationRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetIdentityPoolConfigurationRequest> request = null;
        Response<GetIdentityPoolConfigurationResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetIdentityPoolConfigurationRequestMarshaller().marshall(super.beforeMarshalling(getIdentityPoolConfigurationRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetIdentityPoolConfigurationResult, JsonUnmarshallerContext> unmarshaller =
                new GetIdentityPoolConfigurationResultJsonUnmarshaller();
            JsonResponseHandler<GetIdentityPoolConfigurationResult> responseHandler =
                new JsonResponseHandler<GetIdentityPoolConfigurationResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Subscribes to receive notifications when a dataset is modified by
     * another device.
     * </p>
     *
     * @param subscribeToDatasetRequest Container for the necessary
     *           parameters to execute the SubscribeToDataset service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the SubscribeToDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public SubscribeToDatasetResult subscribeToDataset(SubscribeToDatasetRequest subscribeToDatasetRequest) {
        ExecutionContext executionContext = createExecutionContext(subscribeToDatasetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SubscribeToDatasetRequest> request = null;
        Response<SubscribeToDatasetResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SubscribeToDatasetRequestMarshaller().marshall(super.beforeMarshalling(subscribeToDatasetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<SubscribeToDatasetResult, JsonUnmarshallerContext> unmarshaller =
                new SubscribeToDatasetResultJsonUnmarshaller();
            JsonResponseHandler<SubscribeToDatasetResult> responseHandler =
                new JsonResponseHandler<SubscribeToDatasetResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets usage details (for example, data storage) about a particular
     * identity pool.
     * </p>
     * <p>
     * DescribeIdentityPoolUsage can only be called with developer
     * credentials. You cannot make this API call with the temporary user
     * credentials provided by Cognito Identity.
     * </p>
     *
     * @param describeIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the DescribeIdentityPoolUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the DescribeIdentityPoolUsage service
     *         method, as returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeIdentityPoolUsageResult describeIdentityPoolUsage(DescribeIdentityPoolUsageRequest describeIdentityPoolUsageRequest) {
        ExecutionContext executionContext = createExecutionContext(describeIdentityPoolUsageRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeIdentityPoolUsageRequest> request = null;
        Response<DescribeIdentityPoolUsageResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeIdentityPoolUsageRequestMarshaller().marshall(super.beforeMarshalling(describeIdentityPoolUsageRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeIdentityPoolUsageResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeIdentityPoolUsageResultJsonUnmarshaller();
            JsonResponseHandler<DescribeIdentityPoolUsageResult> responseHandler =
                new JsonResponseHandler<DescribeIdentityPoolUsageResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Lists datasets for an identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListDatasets can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials. You should use the
     * Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param listDatasetsRequest Container for the necessary parameters to
     *           execute the ListDatasets service method on AmazonCognitoSync.
     * 
     * @return The response from the ListDatasets service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListDatasetsResult listDatasets(ListDatasetsRequest listDatasetsRequest) {
        ExecutionContext executionContext = createExecutionContext(listDatasetsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListDatasetsRequest> request = null;
        Response<ListDatasetsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListDatasetsRequestMarshaller().marshall(super.beforeMarshalling(listDatasetsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListDatasetsResult, JsonUnmarshallerContext> unmarshaller =
                new ListDatasetsResultJsonUnmarshaller();
            JsonResponseHandler<ListDatasetsResult> responseHandler =
                new JsonResponseHandler<ListDatasetsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets a list of identity pools registered with Cognito.
     * </p>
     * <p>
     * ListIdentityPoolUsage can only be called with developer credentials.
     * You cannot make this API call with the temporary user credentials
     * provided by Cognito Identity.
     * </p>
     *
     * @param listIdentityPoolUsageRequest Container for the necessary
     *           parameters to execute the ListIdentityPoolUsage service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the ListIdentityPoolUsage service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListIdentityPoolUsageResult listIdentityPoolUsage(ListIdentityPoolUsageRequest listIdentityPoolUsageRequest) {
        ExecutionContext executionContext = createExecutionContext(listIdentityPoolUsageRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListIdentityPoolUsageRequest> request = null;
        Response<ListIdentityPoolUsageResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListIdentityPoolUsageRequestMarshaller().marshall(super.beforeMarshalling(listIdentityPoolUsageRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListIdentityPoolUsageResult, JsonUnmarshallerContext> unmarshaller =
                new ListIdentityPoolUsageResultJsonUnmarshaller();
            JsonResponseHandler<ListIdentityPoolUsageResult> responseHandler =
                new JsonResponseHandler<ListIdentityPoolUsageResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets paginated records, optionally changed after a particular sync
     * count for a dataset and identity. With Amazon Cognito Sync, each
     * identity has access only to its own data. Thus, the credentials used
     * to make this API call need to have access to the identity data.
     * </p>
     * <p>
     * ListRecords can be called with temporary user credentials provided by
     * Cognito Identity or with developer credentials. You should use Cognito
     * Identity credentials to make this API call.
     * </p>
     *
     * @param listRecordsRequest Container for the necessary parameters to
     *           execute the ListRecords service method on AmazonCognitoSync.
     * 
     * @return The response from the ListRecords service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListRecordsResult listRecords(ListRecordsRequest listRecordsRequest) {
        ExecutionContext executionContext = createExecutionContext(listRecordsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListRecordsRequest> request = null;
        Response<ListRecordsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListRecordsRequestMarshaller().marshall(super.beforeMarshalling(listRecordsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListRecordsResult, JsonUnmarshallerContext> unmarshaller =
                new ListRecordsResultJsonUnmarshaller();
            JsonResponseHandler<ListRecordsResult> responseHandler =
                new JsonResponseHandler<ListRecordsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Get the status of the last BulkPublish operation for an identity
     * pool.
     * </p>
     *
     * @param getBulkPublishDetailsRequest Container for the necessary
     *           parameters to execute the GetBulkPublishDetails service method on
     *           AmazonCognitoSync.
     * 
     * @return The response from the GetBulkPublishDetails service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetBulkPublishDetailsResult getBulkPublishDetails(GetBulkPublishDetailsRequest getBulkPublishDetailsRequest) {
        ExecutionContext executionContext = createExecutionContext(getBulkPublishDetailsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetBulkPublishDetailsRequest> request = null;
        Response<GetBulkPublishDetailsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetBulkPublishDetailsRequestMarshaller().marshall(super.beforeMarshalling(getBulkPublishDetailsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetBulkPublishDetailsResult, JsonUnmarshallerContext> unmarshaller =
                new GetBulkPublishDetailsResultJsonUnmarshaller();
            JsonResponseHandler<GetBulkPublishDetailsResult> responseHandler =
                new JsonResponseHandler<GetBulkPublishDetailsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Initiates a bulk publish of all existing datasets for an Identity
     * Pool to the configured stream. Customers are limited to one successful
     * bulk publish per 24 hours. Bulk publish is an asynchronous request,
     * customers can see the status of the request via the
     * GetBulkPublishDetails operation.
     * </p>
     *
     * @param bulkPublishRequest Container for the necessary parameters to
     *           execute the BulkPublish service method on AmazonCognitoSync.
     * 
     * @return The response from the BulkPublish service method, as returned
     *         by AmazonCognitoSync.
     * 
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     * @throws DuplicateRequestException
     * @throws AlreadyStreamedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public BulkPublishResult bulkPublish(BulkPublishRequest bulkPublishRequest) {
        ExecutionContext executionContext = createExecutionContext(bulkPublishRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<BulkPublishRequest> request = null;
        Response<BulkPublishResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new BulkPublishRequestMarshaller().marshall(super.beforeMarshalling(bulkPublishRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<BulkPublishResult, JsonUnmarshallerContext> unmarshaller =
                new BulkPublishResultJsonUnmarshaller();
            JsonResponseHandler<BulkPublishResult> responseHandler =
                new JsonResponseHandler<BulkPublishResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Gets meta data about a dataset by identity and dataset name. With
     * Amazon Cognito Sync, each identity has access only to its own data.
     * Thus, the credentials used to make this API call need to have access
     * to the identity data.
     * </p>
     * <p>
     * DescribeDataset can be called with temporary user credentials
     * provided by Cognito Identity or with developer credentials. You should
     * use Cognito Identity credentials to make this API call.
     * </p>
     *
     * @param describeDatasetRequest Container for the necessary parameters
     *           to execute the DescribeDataset service method on AmazonCognitoSync.
     * 
     * @return The response from the DescribeDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDatasetResult describeDataset(DescribeDatasetRequest describeDatasetRequest) {
        ExecutionContext executionContext = createExecutionContext(describeDatasetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeDatasetRequest> request = null;
        Response<DescribeDatasetResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeDatasetRequestMarshaller().marshall(super.beforeMarshalling(describeDatasetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeDatasetResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeDatasetResultJsonUnmarshaller();
            JsonResponseHandler<DescribeDatasetResult> responseHandler =
                new JsonResponseHandler<DescribeDatasetResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Deletes the specific dataset. The dataset will be deleted
     * permanently, and the action can't be undone. Datasets that this
     * dataset was merged with will no longer report the merge. Any
     * subsequent operation on this dataset will result in a
     * ResourceNotFoundException.
     * </p>
     * <p>
     * DeleteDataset can be called with temporary user credentials provided
     * by Cognito Identity or with developer credentials.
     * </p>
     *
     * @param deleteDatasetRequest Container for the necessary parameters to
     *           execute the DeleteDataset service method on AmazonCognitoSync.
     * 
     * @return The response from the DeleteDataset service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws ResourceConflictException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeleteDatasetResult deleteDataset(DeleteDatasetRequest deleteDatasetRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteDatasetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteDatasetRequest> request = null;
        Response<DeleteDatasetResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteDatasetRequestMarshaller().marshall(super.beforeMarshalling(deleteDatasetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DeleteDatasetResult, JsonUnmarshallerContext> unmarshaller =
                new DeleteDatasetResultJsonUnmarshaller();
            JsonResponseHandler<DeleteDatasetResult> responseHandler =
                new JsonResponseHandler<DeleteDatasetResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Registers a device to receive push sync notifications.
     * </p>
     *
     * @param registerDeviceRequest Container for the necessary parameters to
     *           execute the RegisterDevice service method on AmazonCognitoSync.
     * 
     * @return The response from the RegisterDevice service method, as
     *         returned by AmazonCognitoSync.
     * 
     * @throws TooManyRequestsException
     * @throws InvalidConfigurationException
     * @throws InvalidParameterException
     * @throws ResourceNotFoundException
     * @throws NotAuthorizedException
     * @throws InternalErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonCognitoSync indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public RegisterDeviceResult registerDevice(RegisterDeviceRequest registerDeviceRequest) {
        ExecutionContext executionContext = createExecutionContext(registerDeviceRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<RegisterDeviceRequest> request = null;
        Response<RegisterDeviceResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new RegisterDeviceRequestMarshaller().marshall(super.beforeMarshalling(registerDeviceRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<RegisterDeviceResult, JsonUnmarshallerContext> unmarshaller =
                new RegisterDeviceResultJsonUnmarshaller();
            JsonResponseHandler<RegisterDeviceResult> responseHandler =
                new JsonResponseHandler<RegisterDeviceResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    @Override
    public void setEndpoint(String endpoint) {
        super.setEndpoint(endpoint);
    }

    @Override
    public void setEndpoint(String endpoint, String serviceName, String regionId) throws IllegalArgumentException {
        super.setEndpoint(endpoint, serviceName, regionId);
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext) {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);

        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        AWSCredentials credentials;
        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
        try {
            credentials = awsCredentialsProvider.getCredentials();
        } finally {
            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
        }

        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(jsonErrorUnmarshallers);
        Response<X> result = client.execute(request, responseHandler,
                errorResponseHandler, executionContext);
        return result;
    }
}
        

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/BulkPublishRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#bulkPublish(BulkPublishRequest) BulkPublish operation}.
 * <p>
 * Initiates a bulk publish of all existing datasets for an Identity Pool
 * to the configured stream. Customers are limited to one successful bulk
 * publish per 24 hours. Bulk publish is an asynchronous request,
 * customers can see the status of the request via the
 * GetBulkPublishDetails operation.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#bulkPublish(BulkPublishRequest)
 */
public class BulkPublishRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public BulkPublishRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof BulkPublishRequest == false) return false;
        BulkPublishRequest other = (BulkPublishRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        return true;
    }
    
    @Override
    public BulkPublishRequest clone() {
        
            return (BulkPublishRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/DeleteDatasetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#deleteDataset(DeleteDatasetRequest) DeleteDataset operation}.
 * <p>
 * Deletes the specific dataset. The dataset will be deleted permanently,
 * and the action can't be undone. Datasets that this dataset was merged
 * with will no longer report the merge. Any subsequent operation on this
 * dataset will result in a ResourceNotFoundException.
 * </p>
 * <p>
 * DeleteDataset can be called with temporary user credentials provided
 * by Cognito Identity or with developer credentials.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#deleteDataset(DeleteDatasetRequest)
 */
public class DeleteDatasetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     */
    private String datasetName;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteDatasetRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteDatasetRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @return A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public String getDatasetName() {
        return datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public void setDatasetName(String datasetName) {
        this.datasetName = datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteDatasetRequest withDatasetName(String datasetName) {
        this.datasetName = datasetName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getDatasetName() != null) sb.append("DatasetName: " + getDatasetName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getDatasetName() == null) ? 0 : getDatasetName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteDatasetRequest == false) return false;
        DeleteDatasetRequest other = (DeleteDatasetRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getDatasetName() == null ^ this.getDatasetName() == null) return false;
        if (other.getDatasetName() != null && other.getDatasetName().equals(this.getDatasetName()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteDatasetRequest clone() {
        
            return (DeleteDatasetRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/DescribeDatasetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#describeDataset(DescribeDatasetRequest) DescribeDataset operation}.
 * <p>
 * Gets meta data about a dataset by identity and dataset name. With
 * Amazon Cognito Sync, each identity has access only to its own data.
 * Thus, the credentials used to make this API call need to have access
 * to the identity data.
 * </p>
 * <p>
 * DescribeDataset can be called with temporary user credentials provided
 * by Cognito Identity or with developer credentials. You should use
 * Cognito Identity credentials to make this API call.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#describeDataset(DescribeDatasetRequest)
 */
public class DescribeDatasetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     */
    private String datasetName;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeDatasetRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeDatasetRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @return A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public String getDatasetName() {
        return datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public void setDatasetName(String datasetName) {
        this.datasetName = datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeDatasetRequest withDatasetName(String datasetName) {
        this.datasetName = datasetName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getDatasetName() != null) sb.append("DatasetName: " + getDatasetName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getDatasetName() == null) ? 0 : getDatasetName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeDatasetRequest == false) return false;
        DescribeDatasetRequest other = (DescribeDatasetRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getDatasetName() == null ^ this.getDatasetName() == null) return false;
        if (other.getDatasetName() != null && other.getDatasetName().equals(this.getDatasetName()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeDatasetRequest clone() {
        
            return (DescribeDatasetRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/DescribeIdentityPoolUsageRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#describeIdentityPoolUsage(DescribeIdentityPoolUsageRequest) DescribeIdentityPoolUsage operation}.
 * <p>
 * Gets usage details (for example, data storage) about a particular
 * identity pool.
 * </p>
 * <p>
 * DescribeIdentityPoolUsage can only be called with developer
 * credentials. You cannot make this API call with the temporary user
 * credentials provided by Cognito Identity.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#describeIdentityPoolUsage(DescribeIdentityPoolUsageRequest)
 */
public class DescribeIdentityPoolUsageRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeIdentityPoolUsageRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeIdentityPoolUsageRequest == false) return false;
        DescribeIdentityPoolUsageRequest other = (DescribeIdentityPoolUsageRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeIdentityPoolUsageRequest clone() {
        
            return (DescribeIdentityPoolUsageRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/DescribeIdentityUsageRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#describeIdentityUsage(DescribeIdentityUsageRequest) DescribeIdentityUsage operation}.
 * <p>
 * Gets usage information for an identity, including number of datasets
 * and data usage.
 * </p>
 * <p>
 * DescribeIdentityUsage can be called with temporary user credentials
 * provided by Cognito Identity or with developer credentials.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#describeIdentityUsage(DescribeIdentityUsageRequest)
 */
public class DescribeIdentityUsageRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeIdentityUsageRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeIdentityUsageRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeIdentityUsageRequest == false) return false;
        DescribeIdentityUsageRequest other = (DescribeIdentityUsageRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeIdentityUsageRequest clone() {
        
            return (DescribeIdentityUsageRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/GetBulkPublishDetailsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#getBulkPublishDetails(GetBulkPublishDetailsRequest) GetBulkPublishDetails operation}.
 * <p>
 * Get the status of the last BulkPublish operation for an identity pool.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#getBulkPublishDetails(GetBulkPublishDetailsRequest)
 */
public class GetBulkPublishDetailsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetBulkPublishDetailsRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetBulkPublishDetailsRequest == false) return false;
        GetBulkPublishDetailsRequest other = (GetBulkPublishDetailsRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        return true;
    }
    
    @Override
    public GetBulkPublishDetailsRequest clone() {
        
            return (GetBulkPublishDetailsRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/GetCognitoEventsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#getCognitoEvents(GetCognitoEventsRequest) GetCognitoEvents operation}.
 * <p>
 * Gets the events and the corresponding Lambda functions associated with
 * an identity pool
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#getCognitoEvents(GetCognitoEventsRequest)
 */
public class GetCognitoEventsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The Cognito Identity Pool ID for the request
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * The Cognito Identity Pool ID for the request
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return The Cognito Identity Pool ID for the request
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * The Cognito Identity Pool ID for the request
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId The Cognito Identity Pool ID for the request
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * The Cognito Identity Pool ID for the request
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId The Cognito Identity Pool ID for the request
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetCognitoEventsRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetCognitoEventsRequest == false) return false;
        GetCognitoEventsRequest other = (GetCognitoEventsRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        return true;
    }
    
    @Override
    public GetCognitoEventsRequest clone() {
        
            return (GetCognitoEventsRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/GetIdentityPoolConfigurationRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#getIdentityPoolConfiguration(GetIdentityPoolConfigurationRequest) GetIdentityPoolConfiguration operation}.
 * <p>
 * Gets the configuration settings of an identity pool.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#getIdentityPoolConfiguration(GetIdentityPoolConfigurationRequest)
 */
public class GetIdentityPoolConfigurationRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool for which to return a
     * configuration.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool for which to return a
     * configuration.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool for which to return a
     *         configuration.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool for which to return a
     * configuration.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool for which to return a
     *         configuration.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool for which to return a
     * configuration.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool for which to return a
     *         configuration.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetIdentityPoolConfigurationRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetIdentityPoolConfigurationRequest == false) return false;
        GetIdentityPoolConfigurationRequest other = (GetIdentityPoolConfigurationRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        return true;
    }
    
    @Override
    public GetIdentityPoolConfigurationRequest clone() {
        
            return (GetIdentityPoolConfigurationRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/RegisterDeviceRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#registerDevice(RegisterDeviceRequest) RegisterDevice operation}.
 * <p>
 * Registers a device to receive push sync notifications.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#registerDevice(RegisterDeviceRequest)
 */
public class RegisterDeviceRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. Here, the ID of the pool that the identity belongs to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * The unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     */
    private String platform;

    /**
     * The push token.
     */
    private String token;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. Here, the ID of the pool that the identity belongs to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. Here, the ID of the pool that the identity belongs to.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. Here, the ID of the pool that the identity belongs to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. Here, the ID of the pool that the identity belongs to.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. Here, the ID of the pool that the identity belongs to.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. Here, the ID of the pool that the identity belongs to.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public RegisterDeviceRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * The unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return The unique ID for this identity.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * The unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId The unique ID for this identity.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * The unique ID for this identity.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId The unique ID for this identity.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public RegisterDeviceRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     *
     * @return The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     *
     * @see Platform
     */
    public String getPlatform() {
        return platform;
    }
    
    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     *
     * @param platform The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     *
     * @see Platform
     */
    public void setPlatform(String platform) {
        this.platform = platform;
    }
    
    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     *
     * @param platform The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see Platform
     */
    public RegisterDeviceRequest withPlatform(String platform) {
        this.platform = platform;
        return this;
    }

    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     *
     * @param platform The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     *
     * @see Platform
     */
    public void setPlatform(Platform platform) {
        this.platform = platform.toString();
    }
    
    /**
     * The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>APNS, APNS_SANDBOX, GCM, ADM
     *
     * @param platform The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see Platform
     */
    public RegisterDeviceRequest withPlatform(Platform platform) {
        this.platform = platform.toString();
        return this;
    }

    /**
     * The push token.
     *
     * @return The push token.
     */
    public String getToken() {
        return token;
    }
    
    /**
     * The push token.
     *
     * @param token The push token.
     */
    public void setToken(String token) {
        this.token = token;
    }
    
    /**
     * The push token.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param token The push token.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public RegisterDeviceRequest withToken(String token) {
        this.token = token;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getPlatform() != null) sb.append("Platform: " + getPlatform() + ",");
        if (getToken() != null) sb.append("Token: " + getToken() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getPlatform() == null) ? 0 : getPlatform().hashCode()); 
        hashCode = prime * hashCode + ((getToken() == null) ? 0 : getToken().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof RegisterDeviceRequest == false) return false;
        RegisterDeviceRequest other = (RegisterDeviceRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getPlatform() == null ^ this.getPlatform() == null) return false;
        if (other.getPlatform() != null && other.getPlatform().equals(this.getPlatform()) == false) return false; 
        if (other.getToken() == null ^ this.getToken() == null) return false;
        if (other.getToken() != null && other.getToken().equals(this.getToken()) == false) return false; 
        return true;
    }
    
    @Override
    public RegisterDeviceRequest clone() {
        
            return (RegisterDeviceRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/SetCognitoEventsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#setCognitoEvents(SetCognitoEventsRequest) SetCognitoEvents operation}.
 * <p>
 * Sets the AWS Lambda function for a given event type for an identity
 * pool. This request only updates the key/value pair specified. Other
 * key/values pairs are not updated. To remove a key value pair, pass a
 * empty value for the particular key.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#setCognitoEvents(SetCognitoEventsRequest)
 */
public class SetCognitoEventsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The Cognito Identity Pool to use when configuring Cognito Events
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * The events to configure
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 1<br/>
     */
    private java.util.Map<String,String> events;

    /**
     * The Cognito Identity Pool to use when configuring Cognito Events
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return The Cognito Identity Pool to use when configuring Cognito Events
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * The Cognito Identity Pool to use when configuring Cognito Events
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId The Cognito Identity Pool to use when configuring Cognito Events
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * The Cognito Identity Pool to use when configuring Cognito Events
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId The Cognito Identity Pool to use when configuring Cognito Events
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SetCognitoEventsRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * The events to configure
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 1<br/>
     *
     * @return The events to configure
     */
    public java.util.Map<String,String> getEvents() {
        
        if (events == null) {
            events = new java.util.HashMap<String,String>();
        }
        return events;
    }
    
    /**
     * The events to configure
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 1<br/>
     *
     * @param events The events to configure
     */
    public void setEvents(java.util.Map<String,String> events) {
        this.events = events;
    }
    
    /**
     * The events to configure
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 1<br/>
     *
     * @param events The events to configure
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SetCognitoEventsRequest withEvents(java.util.Map<String,String> events) {
        setEvents(events);
        return this;
    }

    /**
     * The events to configure
     * <p>
     * The method adds a new key-value pair into Events parameter, and
     * returns a reference to this object so that method calls can be chained
     * together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 1<br/>
     *
     * @param key The key of the entry to be added into Events.
     * @param value The corresponding value of the entry to be added into Events.
     */
  public SetCognitoEventsRequest addEventsEntry(String key, String value) {
    if (null == this.events) {
      this.events = new java.util.HashMap<String,String>();
    }
    if (this.events.containsKey(key))
      throw new IllegalArgumentException("Duplicated keys (" + key.toString() + ") are provided.");
    this.events.put(key, value);
    return this;
  }

  /**
   * Removes all the entries added into Events.
   * <p>
   * Returns a reference to this object so that method calls can be chained together.
   */
  public SetCognitoEventsRequest clearEventsEntries() {
    this.events = null;
    return this;
  }
  
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getEvents() != null) sb.append("Events: " + getEvents() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getEvents() == null) ? 0 : getEvents().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof SetCognitoEventsRequest == false) return false;
        SetCognitoEventsRequest other = (SetCognitoEventsRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getEvents() == null ^ this.getEvents() == null) return false;
        if (other.getEvents() != null && other.getEvents().equals(this.getEvents()) == false) return false; 
        return true;
    }
    
    @Override
    public SetCognitoEventsRequest clone() {
        
            return (SetCognitoEventsRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/SetIdentityPoolConfigurationRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#setIdentityPoolConfiguration(SetIdentityPoolConfigurationRequest) SetIdentityPoolConfiguration operation}.
 * <p>
 * Sets the necessary configuration for push sync.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#setIdentityPoolConfiguration(SetIdentityPoolConfigurationRequest)
 */
public class SetIdentityPoolConfigurationRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * Options to apply to this identity pool for push synchronization.
     */
    private PushSync pushSync;

    /**
     * Options to apply to this identity pool for Amazon Cognito streams.
     */
    private CognitoStreams cognitoStreams;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool to modify.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool to modify.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. This is the ID of the pool to modify.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. This is the ID of the pool to modify.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SetIdentityPoolConfigurationRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Options to apply to this identity pool for push synchronization.
     *
     * @return Options to apply to this identity pool for push synchronization.
     */
    public PushSync getPushSync() {
        return pushSync;
    }
    
    /**
     * Options to apply to this identity pool for push synchronization.
     *
     * @param pushSync Options to apply to this identity pool for push synchronization.
     */
    public void setPushSync(PushSync pushSync) {
        this.pushSync = pushSync;
    }
    
    /**
     * Options to apply to this identity pool for push synchronization.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param pushSync Options to apply to this identity pool for push synchronization.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SetIdentityPoolConfigurationRequest withPushSync(PushSync pushSync) {
        this.pushSync = pushSync;
        return this;
    }

    /**
     * Options to apply to this identity pool for Amazon Cognito streams.
     *
     * @return Options to apply to this identity pool for Amazon Cognito streams.
     */
    public CognitoStreams getCognitoStreams() {
        return cognitoStreams;
    }
    
    /**
     * Options to apply to this identity pool for Amazon Cognito streams.
     *
     * @param cognitoStreams Options to apply to this identity pool for Amazon Cognito streams.
     */
    public void setCognitoStreams(CognitoStreams cognitoStreams) {
        this.cognitoStreams = cognitoStreams;
    }
    
    /**
     * Options to apply to this identity pool for Amazon Cognito streams.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cognitoStreams Options to apply to this identity pool for Amazon Cognito streams.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SetIdentityPoolConfigurationRequest withCognitoStreams(CognitoStreams cognitoStreams) {
        this.cognitoStreams = cognitoStreams;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getPushSync() != null) sb.append("PushSync: " + getPushSync() + ",");
        if (getCognitoStreams() != null) sb.append("CognitoStreams: " + getCognitoStreams() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getPushSync() == null) ? 0 : getPushSync().hashCode()); 
        hashCode = prime * hashCode + ((getCognitoStreams() == null) ? 0 : getCognitoStreams().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof SetIdentityPoolConfigurationRequest == false) return false;
        SetIdentityPoolConfigurationRequest other = (SetIdentityPoolConfigurationRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getPushSync() == null ^ this.getPushSync() == null) return false;
        if (other.getPushSync() != null && other.getPushSync().equals(this.getPushSync()) == false) return false; 
        if (other.getCognitoStreams() == null ^ this.getCognitoStreams() == null) return false;
        if (other.getCognitoStreams() != null && other.getCognitoStreams().equals(this.getCognitoStreams()) == false) return false; 
        return true;
    }
    
    @Override
    public SetIdentityPoolConfigurationRequest clone() {
        
            return (SetIdentityPoolConfigurationRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/SubscribeToDatasetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#subscribeToDataset(SubscribeToDatasetRequest) SubscribeToDataset operation}.
 * <p>
 * Subscribes to receive notifications when a dataset is modified by
 * another device.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#subscribeToDataset(SubscribeToDatasetRequest)
 */
public class SubscribeToDatasetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which the identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * The name of the dataset to subcribe to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     */
    private String datasetName;

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String deviceId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which the identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which the identity belongs.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which the identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which the identity belongs.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which the identity belongs.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which the identity belongs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SubscribeToDatasetRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return Unique ID for this identity.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId Unique ID for this identity.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * Unique ID for this identity.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId Unique ID for this identity.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SubscribeToDatasetRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * The name of the dataset to subcribe to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @return The name of the dataset to subcribe to.
     */
    public String getDatasetName() {
        return datasetName;
    }
    
    /**
     * The name of the dataset to subcribe to.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName The name of the dataset to subcribe to.
     */
    public void setDatasetName(String datasetName) {
        this.datasetName = datasetName;
    }
    
    /**
     * The name of the dataset to subcribe to.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName The name of the dataset to subcribe to.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SubscribeToDatasetRequest withDatasetName(String datasetName) {
        this.datasetName = datasetName;
        return this;
    }

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The unique ID generated for this device by Cognito.
     */
    public String getDeviceId() {
        return deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     */
    public void setDeviceId(String deviceId) {
        this.deviceId = deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public SubscribeToDatasetRequest withDeviceId(String deviceId) {
        this.deviceId = deviceId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getDatasetName() != null) sb.append("DatasetName: " + getDatasetName() + ",");
        if (getDeviceId() != null) sb.append("DeviceId: " + getDeviceId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getDatasetName() == null) ? 0 : getDatasetName().hashCode()); 
        hashCode = prime * hashCode + ((getDeviceId() == null) ? 0 : getDeviceId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof SubscribeToDatasetRequest == false) return false;
        SubscribeToDatasetRequest other = (SubscribeToDatasetRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getDatasetName() == null ^ this.getDatasetName() == null) return false;
        if (other.getDatasetName() != null && other.getDatasetName().equals(this.getDatasetName()) == false) return false; 
        if (other.getDeviceId() == null ^ this.getDeviceId() == null) return false;
        if (other.getDeviceId() != null && other.getDeviceId().equals(this.getDeviceId()) == false) return false; 
        return true;
    }
    
    @Override
    public SubscribeToDatasetRequest clone() {
        
            return (SubscribeToDatasetRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/UnsubscribeFromDatasetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#unsubscribeFromDataset(UnsubscribeFromDatasetRequest) UnsubscribeFromDataset operation}.
 * <p>
 * Unsubscribes from receiving notifications when a dataset is modified
 * by another device.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#unsubscribeFromDataset(UnsubscribeFromDatasetRequest)
 */
public class UnsubscribeFromDatasetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which this identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * The name of the dataset from which to unsubcribe.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     */
    private String datasetName;

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String deviceId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which this identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which this identity belongs.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which this identity belongs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which this identity belongs.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. The ID of the pool to which this identity belongs.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. The ID of the pool to which this identity belongs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UnsubscribeFromDatasetRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return Unique ID for this identity.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * Unique ID for this identity.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId Unique ID for this identity.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * Unique ID for this identity.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId Unique ID for this identity.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UnsubscribeFromDatasetRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * The name of the dataset from which to unsubcribe.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @return The name of the dataset from which to unsubcribe.
     */
    public String getDatasetName() {
        return datasetName;
    }
    
    /**
     * The name of the dataset from which to unsubcribe.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName The name of the dataset from which to unsubcribe.
     */
    public void setDatasetName(String datasetName) {
        this.datasetName = datasetName;
    }
    
    /**
     * The name of the dataset from which to unsubcribe.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName The name of the dataset from which to unsubcribe.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UnsubscribeFromDatasetRequest withDatasetName(String datasetName) {
        this.datasetName = datasetName;
        return this;
    }

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The unique ID generated for this device by Cognito.
     */
    public String getDeviceId() {
        return deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     */
    public void setDeviceId(String deviceId) {
        this.deviceId = deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UnsubscribeFromDatasetRequest withDeviceId(String deviceId) {
        this.deviceId = deviceId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getDatasetName() != null) sb.append("DatasetName: " + getDatasetName() + ",");
        if (getDeviceId() != null) sb.append("DeviceId: " + getDeviceId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getDatasetName() == null) ? 0 : getDatasetName().hashCode()); 
        hashCode = prime * hashCode + ((getDeviceId() == null) ? 0 : getDeviceId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof UnsubscribeFromDatasetRequest == false) return false;
        UnsubscribeFromDatasetRequest other = (UnsubscribeFromDatasetRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getDatasetName() == null ^ this.getDatasetName() == null) return false;
        if (other.getDatasetName() != null && other.getDatasetName().equals(this.getDatasetName()) == false) return false; 
        if (other.getDeviceId() == null ^ this.getDeviceId() == null) return false;
        if (other.getDeviceId() != null && other.getDeviceId().equals(this.getDeviceId()) == false) return false; 
        return true;
    }
    
    @Override
    public UnsubscribeFromDatasetRequest clone() {
        
            return (UnsubscribeFromDatasetRequest) super.clone();
    }

}
    

File: aws-java-sdk-cognitosync/src/main/java/com/amazonaws/services/cognitosync/model/UpdateRecordsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.cognitosync.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.cognitosync.AmazonCognitoSync#updateRecords(UpdateRecordsRequest) UpdateRecords operation}.
 * <p>
 * Posts updates to records and adds and deletes records for a dataset
 * and user.
 * </p>
 * <p>
 * UpdateRecords can only be called with temporary user credentials
 * provided by Cognito Identity. You cannot make this API call with
 * developer credentials.
 * </p>
 *
 * @see com.amazonaws.services.cognitosync.AmazonCognitoSync#updateRecords(UpdateRecordsRequest)
 */
public class UpdateRecordsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityPoolId;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     */
    private String identityId;

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     */
    private String datasetName;

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String deviceId;

    /**
     * A list of patch operations.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch> recordPatches;

    /**
     * The SyncSessionToken returned by a previous call to ListRecords for
     * this dataset and identity.
     */
    private String syncSessionToken;

    /**
     * Intended to supply a device ID that will populate the lastModifiedBy
     * field referenced in other methods. The ClientContext field is not yet
     * implemented.
     */
    private String clientContext;

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityPoolId() {
        return identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityPoolId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withIdentityPoolId(String identityPoolId) {
        this.identityPoolId = identityPoolId;
        return this;
    }

    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @return A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public String getIdentityId() {
        return identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     */
    public void setIdentityId(String identityId) {
        this.identityId = identityId;
    }
    
    /**
     * A name-spaced GUID (for example,
     * us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     * Cognito. GUID generation is unique within a region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 50<br/>
     * <b>Pattern: </b>[\w-]+:[0-9a-f-]+<br/>
     *
     * @param identityId A name-spaced GUID (for example,
     *         us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon
     *         Cognito. GUID generation is unique within a region.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withIdentityId(String identityId) {
        this.identityId = identityId;
        return this;
    }

    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @return A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public String getDatasetName() {
        return datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     */
    public void setDatasetName(String datasetName) {
        this.datasetName = datasetName;
    }
    
    /**
     * A string of up to 128 characters. Allowed characters are a-z, A-Z,
     * 0-9, '_' (underscore), '-' (dash), and '.' (dot).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>[a-zA-Z0-9_.:-]+<br/>
     *
     * @param datasetName A string of up to 128 characters. Allowed characters are a-z, A-Z,
     *         0-9, '_' (underscore), '-' (dash), and '.' (dot).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withDatasetName(String datasetName) {
        this.datasetName = datasetName;
        return this;
    }

    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The unique ID generated for this device by Cognito.
     */
    public String getDeviceId() {
        return deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     */
    public void setDeviceId(String deviceId) {
        this.deviceId = deviceId;
    }
    
    /**
     * The unique ID generated for this device by Cognito.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param deviceId The unique ID generated for this device by Cognito.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withDeviceId(String deviceId) {
        this.deviceId = deviceId;
        return this;
    }

    /**
     * A list of patch operations.
     *
     * @return A list of patch operations.
     */
    public java.util.List<RecordPatch> getRecordPatches() {
        if (recordPatches == null) {
              recordPatches = new com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch>();
              recordPatches.setAutoConstruct(true);
        }
        return recordPatches;
    }
    
    /**
     * A list of patch operations.
     *
     * @param recordPatches A list of patch operations.
     */
    public void setRecordPatches(java.util.Collection<RecordPatch> recordPatches) {
        if (recordPatches == null) {
            this.recordPatches = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch> recordPatchesCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch>(recordPatches.size());
        recordPatchesCopy.addAll(recordPatches);
        this.recordPatches = recordPatchesCopy;
    }
    
    /**
     * A list of patch operations.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setRecordPatches(java.util.Collection)} or {@link
     * #withRecordPatches(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param recordPatches A list of patch operations.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withRecordPatches(RecordPatch... recordPatches) {
        if (getRecordPatches() == null) setRecordPatches(new java.util.ArrayList<RecordPatch>(recordPatches.length));
        for (RecordPatch value : recordPatches) {
            getRecordPatches().add(value);
        }
        return this;
    }
    
    /**
     * A list of patch operations.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param recordPatches A list of patch operations.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withRecordPatches(java.util.Collection<RecordPatch> recordPatches) {
        if (recordPatches == null) {
            this.recordPatches = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch> recordPatchesCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<RecordPatch>(recordPatches.size());
            recordPatchesCopy.addAll(recordPatches);
            this.recordPatches = recordPatchesCopy;
        }

        return this;
    }

    /**
     * The SyncSessionToken returned by a previous call to ListRecords for
     * this dataset and identity.
     *
     * @return The SyncSessionToken returned by a previous call to ListRecords for
     *         this dataset and identity.
     */
    public String getSyncSessionToken() {
        return syncSessionToken;
    }
    
    /**
     * The SyncSessionToken returned by a previous call to ListRecords for
     * this dataset and identity.
     *
     * @param syncSessionToken The SyncSessionToken returned by a previous call to ListRecords for
     *         this dataset and identity.
     */
    public void setSyncSessionToken(String syncSessionToken) {
        this.syncSessionToken = syncSessionToken;
    }
    
    /**
     * The SyncSessionToken returned by a previous call to ListRecords for
     * this dataset and identity.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param syncSessionToken The SyncSessionToken returned by a previous call to ListRecords for
     *         this dataset and identity.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withSyncSessionToken(String syncSessionToken) {
        this.syncSessionToken = syncSessionToken;
        return this;
    }

    /**
     * Intended to supply a device ID that will populate the lastModifiedBy
     * field referenced in other methods. The ClientContext field is not yet
     * implemented.
     *
     * @return Intended to supply a device ID that will populate the lastModifiedBy
     *         field referenced in other methods. The ClientContext field is not yet
     *         implemented.
     */
    public String getClientContext() {
        return clientContext;
    }
    
    /**
     * Intended to supply a device ID that will populate the lastModifiedBy
     * field referenced in other methods. The ClientContext field is not yet
     * implemented.
     *
     * @param clientContext Intended to supply a device ID that will populate the lastModifiedBy
     *         field referenced in other methods. The ClientContext field is not yet
     *         implemented.
     */
    public void setClientContext(String clientContext) {
        this.clientContext = clientContext;
    }
    
    /**
     * Intended to supply a device ID that will populate the lastModifiedBy
     * field referenced in other methods. The ClientContext field is not yet
     * implemented.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param clientContext Intended to supply a device ID that will populate the lastModifiedBy
     *         field referenced in other methods. The ClientContext field is not yet
     *         implemented.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateRecordsRequest withClientContext(String clientContext) {
        this.clientContext = clientContext;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getIdentityPoolId() != null) sb.append("IdentityPoolId: " + getIdentityPoolId() + ",");
        if (getIdentityId() != null) sb.append("IdentityId: " + getIdentityId() + ",");
        if (getDatasetName() != null) sb.append("DatasetName: " + getDatasetName() + ",");
        if (getDeviceId() != null) sb.append("DeviceId: " + getDeviceId() + ",");
        if (getRecordPatches() != null) sb.append("RecordPatches: " + getRecordPatches() + ",");
        if (getSyncSessionToken() != null) sb.append("SyncSessionToken: " + getSyncSessionToken() + ",");
        if (getClientContext() != null) sb.append("ClientContext: " + getClientContext() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getIdentityPoolId() == null) ? 0 : getIdentityPoolId().hashCode()); 
        hashCode = prime * hashCode + ((getIdentityId() == null) ? 0 : getIdentityId().hashCode()); 
        hashCode = prime * hashCode + ((getDatasetName() == null) ? 0 : getDatasetName().hashCode()); 
        hashCode = prime * hashCode + ((getDeviceId() == null) ? 0 : getDeviceId().hashCode()); 
        hashCode = prime * hashCode + ((getRecordPatches() == null) ? 0 : getRecordPatches().hashCode()); 
        hashCode = prime * hashCode + ((getSyncSessionToken() == null) ? 0 : getSyncSessionToken().hashCode()); 
        hashCode = prime * hashCode + ((getClientContext() == null) ? 0 : getClientContext().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof UpdateRecordsRequest == false) return false;
        UpdateRecordsRequest other = (UpdateRecordsRequest)obj;
        
        if (other.getIdentityPoolId() == null ^ this.getIdentityPoolId() == null) return false;
        if (other.getIdentityPoolId() != null && other.getIdentityPoolId().equals(this.getIdentityPoolId()) == false) return false; 
        if (other.getIdentityId() == null ^ this.getIdentityId() == null) return false;
        if (other.getIdentityId() != null && other.getIdentityId().equals(this.getIdentityId()) == false) return false; 
        if (other.getDatasetName() == null ^ this.getDatasetName() == null) return false;
        if (other.getDatasetName() != null && other.getDatasetName().equals(this.getDatasetName()) == false) return false; 
        if (other.getDeviceId() == null ^ this.getDeviceId() == null) return false;
        if (other.getDeviceId() != null && other.getDeviceId().equals(this.getDeviceId()) == false) return false; 
        if (other.getRecordPatches() == null ^ this.getRecordPatches() == null) return false;
        if (other.getRecordPatches() != null && other.getRecordPatches().equals(this.getRecordPatches()) == false) return false; 
        if (other.getSyncSessionToken() == null ^ this.getSyncSessionToken() == null) return false;
        if (other.getSyncSessionToken() != null && other.getSyncSessionToken().equals(this.getSyncSessionToken()) == false) return false; 
        if (other.getClientContext() == null ^ this.getClientContext() == null) return false;
        if (other.getClientContext() != null && other.getClientContext().equals(this.getClientContext()) == false) return false; 
        return true;
    }
    
    @Override
    public UpdateRecordsRequest clone() {
        
            return (UpdateRecordsRequest) super.clone();
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/AmazonConfig.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.config.model.*;

/**
 * Interface for accessing AmazonConfig.
 * AWS Config <p>
 * AWS Config provides a way to keep track of the configurations of all
 * the AWS resources associated with your AWS account. You can use AWS
 * Config to get the current and historical configurations of each AWS
 * resource and also to get information about the relationship between
 * the resources. An AWS resource can be an Amazon Compute Cloud (Amazon
 * EC2) instance, an Elastic Block Store (EBS) volume, an Elastic network
 * Interface (ENI), or a security group. For a complete list of resources
 * currently supported by AWS Config, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/config-concepts.html"> Supported AWS Resources </a>
 * .
 * </p>
 * <p>
 * You can access and manage AWS Config through the AWS Management
 * Console, the AWS Command Line Interface (AWS CLI), the AWS Config API,
 * or the AWS SDKs for AWS Config
 * </p>
 * <p>
 * This reference guide contains documentation for the AWS Config API and
 * the AWS CLI commands that you can use to manage AWS Config.
 * </p>
 * <p>
 * The AWS Config API uses the Signature Version 4 protocol for signing
 * requests. For more information about how to sign a request with this
 * protocol, see
 * <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html"> Signature Version 4 Signing Process </a>
 * .
 * </p>
 * <p>
 * For detailed information about AWS Config features and their
 * associated actions or commands, as well as how to work with AWS
 * Management Console, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/WhatIsConfig.html"> What Is AWS Config? </a>
 * in the <i>AWS Config Developer Guide</i> .
 * </p>
 */
public interface AmazonConfig {

    /**
     * Overrides the default endpoint for this client ("https://config.us-east-1.amazonaws.com/").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "config.us-east-1.amazonaws.com/") or a full
     * URL, including the protocol (ex: "https://config.us-east-1.amazonaws.com/"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "config.us-east-1.amazonaws.com/") or a full URL,
     *            including the protocol (ex: "https://config.us-east-1.amazonaws.com/") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonConfig#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           service method on AmazonConfig.
     * 
     * @return The response from the DescribeDeliveryChannelStatus service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelStatusResult describeDeliveryChannelStatus(DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           service method on AmazonConfig.
     * 
     * @return The response from the DescribeConfigurationRecorders service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecordersResult describeConfigurationRecorders(DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchConfigurationRecorderException
     * @throws NoAvailableDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void startConfigurationRecorder(StartConfigurationRecorderRequest startConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel service method on
     *           AmazonConfig.
     * 
     * 
     * @throws InvalidDeliveryChannelNameException
     * @throws InvalidS3KeyPrefixException
     * @throws NoAvailableConfigurationRecorderException
     * @throws NoSuchBucketException
     * @throws InvalidSNSTopicARNException
     * @throws InsufficientDeliveryPolicyException
     * @throws MaxNumberOfDeliveryChannelsExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void putDeliveryChannel(PutDeliveryChannelRequest putDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchDeliveryChannelException
     * @throws LastDeliveryChannelDeleteFailedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteDeliveryChannel(DeleteDeliveryChannelRequest deleteDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void stopConfigurationRecorder(StopConfigurationRecorderRequest stopConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot service method on
     *           AmazonConfig.
     * 
     * @return The response from the DeliverConfigSnapshot service method, as
     *         returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     * @throws NoAvailableConfigurationRecorderException
     * @throws NoRunningConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeliverConfigSnapshotResult deliverConfigSnapshot(DeliverConfigSnapshotRequest deliverConfigSnapshotRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws InvalidRoleException
     * @throws InvalidConfigurationRecorderNameException
     * @throws MaxNumberOfConfigurationRecordersExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void putConfigurationRecorder(PutConfigurationRecorderRequest putConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory service method on
     *           AmazonConfig.
     * 
     * @return The response from the GetResourceConfigHistory service method,
     *         as returned by AmazonConfig.
     * 
     * @throws InvalidNextTokenException
     * @throws NoAvailableConfigurationRecorderException
     * @throws ValidationException
     * @throws ResourceNotDiscoveredException
     * @throws InvalidTimeRangeException
     * @throws InvalidLimitException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetResourceConfigHistoryResult getResourceConfigHistory(GetResourceConfigHistoryRequest getResourceConfigHistoryRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels service method on
     *           AmazonConfig.
     * 
     * @return The response from the DescribeDeliveryChannels service method,
     *         as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelsResult describeDeliveryChannels(DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus service method on AmazonConfig.
     * 
     * @return The response from the DescribeConfigurationRecorderStatus
     *         service method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecorderStatusResult describeConfigurationRecorderStatus(DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     * 
     * @return The response from the DescribeDeliveryChannelStatus service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelStatusResult describeDeliveryChannelStatus() throws AmazonServiceException, AmazonClientException;
    
    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     * 
     * @return The response from the DescribeConfigurationRecorders service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecordersResult describeConfigurationRecorders() throws AmazonServiceException, AmazonClientException;
    
    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     * 
     * @return The response from the DescribeDeliveryChannels service method,
     *         as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelsResult describeDeliveryChannels() throws AmazonServiceException, AmazonClientException;
    
    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     * 
     * @return The response from the DescribeConfigurationRecorderStatus
     *         service method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecorderStatusResult describeConfigurationRecorderStatus() throws AmazonServiceException, AmazonClientException;
    
    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/AmazonConfigAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.config.model.*;

/**
 * Interface for accessing AmazonConfig asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * AWS Config <p>
 * AWS Config provides a way to keep track of the configurations of all
 * the AWS resources associated with your AWS account. You can use AWS
 * Config to get the current and historical configurations of each AWS
 * resource and also to get information about the relationship between
 * the resources. An AWS resource can be an Amazon Compute Cloud (Amazon
 * EC2) instance, an Elastic Block Store (EBS) volume, an Elastic network
 * Interface (ENI), or a security group. For a complete list of resources
 * currently supported by AWS Config, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/config-concepts.html"> Supported AWS Resources </a>
 * .
 * </p>
 * <p>
 * You can access and manage AWS Config through the AWS Management
 * Console, the AWS Command Line Interface (AWS CLI), the AWS Config API,
 * or the AWS SDKs for AWS Config
 * </p>
 * <p>
 * This reference guide contains documentation for the AWS Config API and
 * the AWS CLI commands that you can use to manage AWS Config.
 * </p>
 * <p>
 * The AWS Config API uses the Signature Version 4 protocol for signing
 * requests. For more information about how to sign a request with this
 * protocol, see
 * <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html"> Signature Version 4 Signing Process </a>
 * .
 * </p>
 * <p>
 * For detailed information about AWS Config features and their
 * associated actions or commands, as well as how to work with AWS
 * Management Console, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/WhatIsConfig.html"> What Is AWS Config? </a>
 * in the <i>AWS Config Developer Guide</i> .
 * </p>
 */
public interface AmazonConfigAsync extends AmazonConfig {
    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannelStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelStatusResult> describeDeliveryChannelStatusAsync(DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannelStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelStatusResult> describeDeliveryChannelStatusAsync(DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest,
            AsyncHandler<DescribeDeliveryChannelStatusRequest, DescribeDeliveryChannelStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorders service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecordersResult> describeConfigurationRecordersAsync(DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorders service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecordersResult> describeConfigurationRecordersAsync(DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest,
            AsyncHandler<DescribeConfigurationRecordersRequest, DescribeConfigurationRecordersResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         StartConfigurationRecorder service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> startConfigurationRecorderAsync(StartConfigurationRecorderRequest startConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         StartConfigurationRecorder service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> startConfigurationRecorderAsync(StartConfigurationRecorderRequest startConfigurationRecorderRequest,
            AsyncHandler<StartConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         PutDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putDeliveryChannelAsync(PutDeliveryChannelRequest putDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         PutDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putDeliveryChannelAsync(PutDeliveryChannelRequest putDeliveryChannelRequest,
            AsyncHandler<PutDeliveryChannelRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDeliveryChannelAsync(DeleteDeliveryChannelRequest deleteDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDeliveryChannelAsync(DeleteDeliveryChannelRequest deleteDeliveryChannelRequest,
            AsyncHandler<DeleteDeliveryChannelRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         StopConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> stopConfigurationRecorderAsync(StopConfigurationRecorderRequest stopConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         StopConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> stopConfigurationRecorderAsync(StopConfigurationRecorderRequest stopConfigurationRecorderRequest,
            AsyncHandler<StopConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DeliverConfigSnapshot service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeliverConfigSnapshotResult> deliverConfigSnapshotAsync(DeliverConfigSnapshotRequest deliverConfigSnapshotRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeliverConfigSnapshot service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeliverConfigSnapshotResult> deliverConfigSnapshotAsync(DeliverConfigSnapshotRequest deliverConfigSnapshotRequest,
            AsyncHandler<DeliverConfigSnapshotRequest, DeliverConfigSnapshotResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         PutConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putConfigurationRecorderAsync(PutConfigurationRecorderRequest putConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         PutConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putConfigurationRecorderAsync(PutConfigurationRecorderRequest putConfigurationRecorderRequest,
            AsyncHandler<PutConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         GetResourceConfigHistory service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetResourceConfigHistoryResult> getResourceConfigHistoryAsync(GetResourceConfigHistoryRequest getResourceConfigHistoryRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetResourceConfigHistory service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetResourceConfigHistoryResult> getResourceConfigHistoryAsync(GetResourceConfigHistoryRequest getResourceConfigHistoryRequest,
            AsyncHandler<GetResourceConfigHistoryRequest, GetResourceConfigHistoryResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannels service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelsResult> describeDeliveryChannelsAsync(DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannels service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelsResult> describeDeliveryChannelsAsync(DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest,
            AsyncHandler<DescribeDeliveryChannelsRequest, DescribeDeliveryChannelsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorderStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecorderStatusResult> describeConfigurationRecorderStatusAsync(DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorderStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecorderStatusResult> describeConfigurationRecorderStatusAsync(DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest,
            AsyncHandler<DescribeConfigurationRecorderStatusRequest, DescribeConfigurationRecorderStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/AmazonConfigAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.config.model.*;

/**
 * Asynchronous client for accessing AmazonConfig.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * AWS Config <p>
 * AWS Config provides a way to keep track of the configurations of all
 * the AWS resources associated with your AWS account. You can use AWS
 * Config to get the current and historical configurations of each AWS
 * resource and also to get information about the relationship between
 * the resources. An AWS resource can be an Amazon Compute Cloud (Amazon
 * EC2) instance, an Elastic Block Store (EBS) volume, an Elastic network
 * Interface (ENI), or a security group. For a complete list of resources
 * currently supported by AWS Config, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/config-concepts.html"> Supported AWS Resources </a>
 * .
 * </p>
 * <p>
 * You can access and manage AWS Config through the AWS Management
 * Console, the AWS Command Line Interface (AWS CLI), the AWS Config API,
 * or the AWS SDKs for AWS Config
 * </p>
 * <p>
 * This reference guide contains documentation for the AWS Config API and
 * the AWS CLI commands that you can use to manage AWS Config.
 * </p>
 * <p>
 * The AWS Config API uses the Signature Version 4 protocol for signing
 * requests. For more information about how to sign a request with this
 * protocol, see
 * <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html"> Signature Version 4 Signing Process </a>
 * .
 * </p>
 * <p>
 * For detailed information about AWS Config features and their
 * associated actions or commands, as well as how to work with AWS
 * Management Console, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/WhatIsConfig.html"> What Is AWS Config? </a>
 * in the <i>AWS Config Developer Guide</i> .
 * </p>
 */
public class AmazonConfigAsyncClient extends AmazonConfigClient
        implements AmazonConfigAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonConfigAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonConfig
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonConfigAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonConfigAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonConfigAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonConfigAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonConfigAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonConfigAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonConfigAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonConfigAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannelStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelStatusResult> describeDeliveryChannelStatusAsync(final DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDeliveryChannelStatusResult>() {
            public DescribeDeliveryChannelStatusResult call() throws Exception {
                return describeDeliveryChannelStatus(describeDeliveryChannelStatusRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannelStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelStatusResult> describeDeliveryChannelStatusAsync(
            final DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest,
            final AsyncHandler<DescribeDeliveryChannelStatusRequest, DescribeDeliveryChannelStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDeliveryChannelStatusResult>() {
            public DescribeDeliveryChannelStatusResult call() throws Exception {
              DescribeDeliveryChannelStatusResult result;
                try {
                result = describeDeliveryChannelStatus(describeDeliveryChannelStatusRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeDeliveryChannelStatusRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorders service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecordersResult> describeConfigurationRecordersAsync(final DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeConfigurationRecordersResult>() {
            public DescribeConfigurationRecordersResult call() throws Exception {
                return describeConfigurationRecorders(describeConfigurationRecordersRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorders service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecordersResult> describeConfigurationRecordersAsync(
            final DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest,
            final AsyncHandler<DescribeConfigurationRecordersRequest, DescribeConfigurationRecordersResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeConfigurationRecordersResult>() {
            public DescribeConfigurationRecordersResult call() throws Exception {
              DescribeConfigurationRecordersResult result;
                try {
                result = describeConfigurationRecorders(describeConfigurationRecordersRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeConfigurationRecordersRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         StartConfigurationRecorder service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> startConfigurationRecorderAsync(final StartConfigurationRecorderRequest startConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                startConfigurationRecorder(startConfigurationRecorderRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         StartConfigurationRecorder service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> startConfigurationRecorderAsync(
            final StartConfigurationRecorderRequest startConfigurationRecorderRequest,
            final AsyncHandler<StartConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                startConfigurationRecorder(startConfigurationRecorderRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(startConfigurationRecorderRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         PutDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putDeliveryChannelAsync(final PutDeliveryChannelRequest putDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                putDeliveryChannel(putDeliveryChannelRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         PutDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putDeliveryChannelAsync(
            final PutDeliveryChannelRequest putDeliveryChannelRequest,
            final AsyncHandler<PutDeliveryChannelRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                putDeliveryChannel(putDeliveryChannelRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(putDeliveryChannelRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDeliveryChannelAsync(final DeleteDeliveryChannelRequest deleteDeliveryChannelRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteDeliveryChannel(deleteDeliveryChannelRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteDeliveryChannel service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteDeliveryChannelAsync(
            final DeleteDeliveryChannelRequest deleteDeliveryChannelRequest,
            final AsyncHandler<DeleteDeliveryChannelRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteDeliveryChannel(deleteDeliveryChannelRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteDeliveryChannelRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         StopConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> stopConfigurationRecorderAsync(final StopConfigurationRecorderRequest stopConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                stopConfigurationRecorder(stopConfigurationRecorderRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         StopConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> stopConfigurationRecorderAsync(
            final StopConfigurationRecorderRequest stopConfigurationRecorderRequest,
            final AsyncHandler<StopConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                stopConfigurationRecorder(stopConfigurationRecorderRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(stopConfigurationRecorderRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DeliverConfigSnapshot service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeliverConfigSnapshotResult> deliverConfigSnapshotAsync(final DeliverConfigSnapshotRequest deliverConfigSnapshotRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DeliverConfigSnapshotResult>() {
            public DeliverConfigSnapshotResult call() throws Exception {
                return deliverConfigSnapshot(deliverConfigSnapshotRequest);
        }
    });
    }

    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeliverConfigSnapshot service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DeliverConfigSnapshotResult> deliverConfigSnapshotAsync(
            final DeliverConfigSnapshotRequest deliverConfigSnapshotRequest,
            final AsyncHandler<DeliverConfigSnapshotRequest, DeliverConfigSnapshotResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DeliverConfigSnapshotResult>() {
            public DeliverConfigSnapshotResult call() throws Exception {
              DeliverConfigSnapshotResult result;
                try {
                result = deliverConfigSnapshot(deliverConfigSnapshotRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deliverConfigSnapshotRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         PutConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putConfigurationRecorderAsync(final PutConfigurationRecorderRequest putConfigurationRecorderRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                putConfigurationRecorder(putConfigurationRecorderRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         PutConfigurationRecorder service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> putConfigurationRecorderAsync(
            final PutConfigurationRecorderRequest putConfigurationRecorderRequest,
            final AsyncHandler<PutConfigurationRecorderRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                putConfigurationRecorder(putConfigurationRecorderRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(putConfigurationRecorderRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         GetResourceConfigHistory service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetResourceConfigHistoryResult> getResourceConfigHistoryAsync(final GetResourceConfigHistoryRequest getResourceConfigHistoryRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetResourceConfigHistoryResult>() {
            public GetResourceConfigHistoryResult call() throws Exception {
                return getResourceConfigHistory(getResourceConfigHistoryRequest);
        }
    });
    }

    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetResourceConfigHistory service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetResourceConfigHistoryResult> getResourceConfigHistoryAsync(
            final GetResourceConfigHistoryRequest getResourceConfigHistoryRequest,
            final AsyncHandler<GetResourceConfigHistoryRequest, GetResourceConfigHistoryResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetResourceConfigHistoryResult>() {
            public GetResourceConfigHistoryResult call() throws Exception {
              GetResourceConfigHistoryResult result;
                try {
                result = getResourceConfigHistory(getResourceConfigHistoryRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getResourceConfigHistoryRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels operation on
     *           AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannels service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelsResult> describeDeliveryChannelsAsync(final DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDeliveryChannelsResult>() {
            public DescribeDeliveryChannelsResult call() throws Exception {
                return describeDeliveryChannels(describeDeliveryChannelsRequest);
        }
    });
    }

    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels operation on
     *           AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDeliveryChannels service method, as returned by AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDeliveryChannelsResult> describeDeliveryChannelsAsync(
            final DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest,
            final AsyncHandler<DescribeDeliveryChannelsRequest, DescribeDeliveryChannelsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeDeliveryChannelsResult>() {
            public DescribeDeliveryChannelsResult call() throws Exception {
              DescribeDeliveryChannelsResult result;
                try {
                result = describeDeliveryChannels(describeDeliveryChannelsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeDeliveryChannelsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus operation on AmazonConfig.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorderStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecorderStatusResult> describeConfigurationRecorderStatusAsync(final DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeConfigurationRecorderStatusResult>() {
            public DescribeConfigurationRecorderStatusResult call() throws Exception {
                return describeConfigurationRecorderStatus(describeConfigurationRecorderStatusRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus operation on AmazonConfig.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeConfigurationRecorderStatus service method, as returned by
     *         AmazonConfig.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeConfigurationRecorderStatusResult> describeConfigurationRecorderStatusAsync(
            final DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest,
            final AsyncHandler<DescribeConfigurationRecorderStatusRequest, DescribeConfigurationRecorderStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeConfigurationRecorderStatusResult>() {
            public DescribeConfigurationRecorderStatusResult call() throws Exception {
              DescribeConfigurationRecorderStatusResult result;
                try {
                result = describeConfigurationRecorderStatus(describeConfigurationRecorderStatusRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeConfigurationRecorderStatusRequest, result);
                 return result;
        }
    });
    }
    
}
        

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/AmazonConfigClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config;

import java.net.*;
import java.util.*;

import org.apache.commons.logging.*;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.regions.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;
import com.amazonaws.util.json.*;

import com.amazonaws.services.config.model.*;
import com.amazonaws.services.config.model.transform.*;

/**
 * Client for accessing AmazonConfig.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * AWS Config <p>
 * AWS Config provides a way to keep track of the configurations of all
 * the AWS resources associated with your AWS account. You can use AWS
 * Config to get the current and historical configurations of each AWS
 * resource and also to get information about the relationship between
 * the resources. An AWS resource can be an Amazon Compute Cloud (Amazon
 * EC2) instance, an Elastic Block Store (EBS) volume, an Elastic network
 * Interface (ENI), or a security group. For a complete list of resources
 * currently supported by AWS Config, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/config-concepts.html"> Supported AWS Resources </a>
 * .
 * </p>
 * <p>
 * You can access and manage AWS Config through the AWS Management
 * Console, the AWS Command Line Interface (AWS CLI), the AWS Config API,
 * or the AWS SDKs for AWS Config
 * </p>
 * <p>
 * This reference guide contains documentation for the AWS Config API and
 * the AWS CLI commands that you can use to manage AWS Config.
 * </p>
 * <p>
 * The AWS Config API uses the Signature Version 4 protocol for signing
 * requests. For more information about how to sign a request with this
 * protocol, see
 * <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html"> Signature Version 4 Signing Process </a>
 * .
 * </p>
 * <p>
 * For detailed information about AWS Config features and their
 * associated actions or commands, as well as how to work with AWS
 * Management Console, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/WhatIsConfig.html"> What Is AWS Config? </a>
 * in the <i>AWS Config Developer Guide</i> .
 * </p>
 */
public class AmazonConfigClient extends AmazonWebServiceClient implements AmazonConfig {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    private static final Log log = LogFactory.getLog(AmazonConfig.class);

    /**
     * List of exception unmarshallers for all AmazonConfig exceptions.
     */
    protected List<JsonErrorUnmarshaller> jsonErrorUnmarshallers;

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonConfigClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonConfig
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonConfigClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonConfigClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonConfig
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonConfigClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(adjustClientConfiguration(clientConfiguration));
        
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials provider.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonConfigClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * provider and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonConfig
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonConfigClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonConfig using the specified AWS account credentials
     * provider, client configuration options and request metric collector.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonConfig
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonConfigClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
        
        this.awsCredentialsProvider = awsCredentialsProvider;
        
        init();
    }

    private void init() {
        jsonErrorUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
        jsonErrorUnmarshallers.add(new MaxNumberOfDeliveryChannelsExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidTimeRangeExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ResourceNotDiscoveredExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoSuchConfigurationRecorderExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new MaxNumberOfConfigurationRecordersExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidLimitExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new LastDeliveryChannelDeleteFailedExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidSNSTopicARNExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidDeliveryChannelNameExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidConfigurationRecorderNameExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InsufficientDeliveryPolicyExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoAvailableConfigurationRecorderExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoRunningConfigurationRecorderExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoSuchBucketExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidNextTokenExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoSuchDeliveryChannelExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ValidationExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidS3KeyPrefixExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InvalidRoleExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoAvailableDeliveryChannelExceptionUnmarshaller());
        
        jsonErrorUnmarshallers.add(new JsonErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("config.us-east-1.amazonaws.com/");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/config/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/config/request.handler2s"));
    }

    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
        ClientConfiguration config = orig;
        
        return config;
    }

    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelStatusRequest Container for the
     *           necessary parameters to execute the DescribeDeliveryChannelStatus
     *           service method on AmazonConfig.
     * 
     * @return The response from the DescribeDeliveryChannelStatus service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelStatusResult describeDeliveryChannelStatus(DescribeDeliveryChannelStatusRequest describeDeliveryChannelStatusRequest) {
        ExecutionContext executionContext = createExecutionContext(describeDeliveryChannelStatusRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeDeliveryChannelStatusRequest> request = null;
        Response<DescribeDeliveryChannelStatusResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeDeliveryChannelStatusRequestMarshaller().marshall(super.beforeMarshalling(describeDeliveryChannelStatusRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeDeliveryChannelStatusResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeDeliveryChannelStatusResultJsonUnmarshaller();
            JsonResponseHandler<DescribeDeliveryChannelStatusResult> responseHandler =
                new JsonResponseHandler<DescribeDeliveryChannelStatusResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecordersRequest Container for the
     *           necessary parameters to execute the DescribeConfigurationRecorders
     *           service method on AmazonConfig.
     * 
     * @return The response from the DescribeConfigurationRecorders service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecordersResult describeConfigurationRecorders(DescribeConfigurationRecordersRequest describeConfigurationRecordersRequest) {
        ExecutionContext executionContext = createExecutionContext(describeConfigurationRecordersRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeConfigurationRecordersRequest> request = null;
        Response<DescribeConfigurationRecordersResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeConfigurationRecordersRequestMarshaller().marshall(super.beforeMarshalling(describeConfigurationRecordersRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeConfigurationRecordersResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeConfigurationRecordersResultJsonUnmarshaller();
            JsonResponseHandler<DescribeConfigurationRecordersResult> responseHandler =
                new JsonResponseHandler<DescribeConfigurationRecordersResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Starts recording configurations of all the resources associated with
     * the account.
     * </p>
     * <p>
     * You must have created at least one delivery channel to successfully
     * start the configuration recorder.
     * </p>
     *
     * @param startConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StartConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchConfigurationRecorderException
     * @throws NoAvailableDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void startConfigurationRecorder(StartConfigurationRecorderRequest startConfigurationRecorderRequest) {
        ExecutionContext executionContext = createExecutionContext(startConfigurationRecorderRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<StartConfigurationRecorderRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new StartConfigurationRecorderRequestMarshaller().marshall(super.beforeMarshalling(startConfigurationRecorderRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Creates a new delivery channel object to deliver the configuration
     * information to an Amazon S3 bucket, and to an Amazon SNS topic.
     * </p>
     * <p>
     * You can use this action to change the Amazon S3 bucket or an Amazon
     * SNS topic of the existing delivery channel. To change the Amazon S3
     * bucket or an Amazon SNS topic, call this action and specify the
     * changed values for the S3 bucket and the SNS topic. If you specify a
     * different value for either the S3 bucket or the SNS topic, this action
     * will keep the existing value for the parameter that is not changed.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param putDeliveryChannelRequest Container for the necessary
     *           parameters to execute the PutDeliveryChannel service method on
     *           AmazonConfig.
     * 
     * 
     * @throws InvalidDeliveryChannelNameException
     * @throws InvalidS3KeyPrefixException
     * @throws NoAvailableConfigurationRecorderException
     * @throws NoSuchBucketException
     * @throws InvalidSNSTopicARNException
     * @throws InsufficientDeliveryPolicyException
     * @throws MaxNumberOfDeliveryChannelsExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void putDeliveryChannel(PutDeliveryChannelRequest putDeliveryChannelRequest) {
        ExecutionContext executionContext = createExecutionContext(putDeliveryChannelRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<PutDeliveryChannelRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new PutDeliveryChannelRequestMarshaller().marshall(super.beforeMarshalling(putDeliveryChannelRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Deletes the specified delivery channel.
     * </p>
     * <p>
     * The delivery channel cannot be deleted if it is the only delivery
     * channel and the configuration recorder is still running. To delete the
     * delivery channel, stop the running configuration recorder using the
     * StopConfigurationRecorder action.
     * </p>
     *
     * @param deleteDeliveryChannelRequest Container for the necessary
     *           parameters to execute the DeleteDeliveryChannel service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchDeliveryChannelException
     * @throws LastDeliveryChannelDeleteFailedException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteDeliveryChannel(DeleteDeliveryChannelRequest deleteDeliveryChannelRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteDeliveryChannelRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteDeliveryChannelRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteDeliveryChannelRequestMarshaller().marshall(super.beforeMarshalling(deleteDeliveryChannelRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Stops recording configurations of all the resources associated with
     * the account.
     * </p>
     *
     * @param stopConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the StopConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void stopConfigurationRecorder(StopConfigurationRecorderRequest stopConfigurationRecorderRequest) {
        ExecutionContext executionContext = createExecutionContext(stopConfigurationRecorderRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<StopConfigurationRecorderRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new StopConfigurationRecorderRequestMarshaller().marshall(super.beforeMarshalling(stopConfigurationRecorderRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Schedules delivery of a configuration snapshot to the Amazon S3
     * bucket in the specified delivery channel. After the delivery has
     * started, AWS Config sends following notifications using an Amazon SNS
     * topic that you have specified.
     * </p>
     * 
     * <ul>
     * <li>Notification of starting the delivery.</li>
     * <li>Notification of delivery completed, if the delivery was
     * successfully completed.</li>
     * <li>Notification of delivery failure, if the delivery failed to
     * complete.</li>
     * 
     * </ul>
     *
     * @param deliverConfigSnapshotRequest Container for the necessary
     *           parameters to execute the DeliverConfigSnapshot service method on
     *           AmazonConfig.
     * 
     * @return The response from the DeliverConfigSnapshot service method, as
     *         returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     * @throws NoAvailableConfigurationRecorderException
     * @throws NoRunningConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DeliverConfigSnapshotResult deliverConfigSnapshot(DeliverConfigSnapshotRequest deliverConfigSnapshotRequest) {
        ExecutionContext executionContext = createExecutionContext(deliverConfigSnapshotRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeliverConfigSnapshotRequest> request = null;
        Response<DeliverConfigSnapshotResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeliverConfigSnapshotRequestMarshaller().marshall(super.beforeMarshalling(deliverConfigSnapshotRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DeliverConfigSnapshotResult, JsonUnmarshallerContext> unmarshaller =
                new DeliverConfigSnapshotResultJsonUnmarshaller();
            JsonResponseHandler<DeliverConfigSnapshotResult> responseHandler =
                new JsonResponseHandler<DeliverConfigSnapshotResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Creates a new configuration recorder to record the resource
     * configurations.
     * </p>
     * <p>
     * You can use this action to change the role ( <code>roleARN</code> )
     * of an existing recorder. To change the role, call the action on the
     * existing configuration recorder and specify a role.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param putConfigurationRecorderRequest Container for the necessary
     *           parameters to execute the PutConfigurationRecorder service method on
     *           AmazonConfig.
     * 
     * 
     * @throws InvalidRoleException
     * @throws InvalidConfigurationRecorderNameException
     * @throws MaxNumberOfConfigurationRecordersExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void putConfigurationRecorder(PutConfigurationRecorderRequest putConfigurationRecorderRequest) {
        ExecutionContext executionContext = createExecutionContext(putConfigurationRecorderRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<PutConfigurationRecorderRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new PutConfigurationRecorderRequestMarshaller().marshall(super.beforeMarshalling(putConfigurationRecorderRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Returns a list of configuration items for the specified resource. The
     * list contains details about each state of the resource during the
     * specified time interval. You can specify a <code>limit</code> on the
     * number of results returned on the page. If a limit is specified, a
     * <code>nextToken</code> is returned as part of the result that you can
     * use to continue this request.
     * </p>
     * <p>
     * <b>NOTE:</b> Each call to the API is limited to span a duration of
     * seven days. It is likely that the number of records returned is
     * smaller than the specified limit. In such cases, you can make another
     * call, using the nextToken .
     * </p>
     *
     * @param getResourceConfigHistoryRequest Container for the necessary
     *           parameters to execute the GetResourceConfigHistory service method on
     *           AmazonConfig.
     * 
     * @return The response from the GetResourceConfigHistory service method,
     *         as returned by AmazonConfig.
     * 
     * @throws InvalidNextTokenException
     * @throws NoAvailableConfigurationRecorderException
     * @throws ValidationException
     * @throws ResourceNotDiscoveredException
     * @throws InvalidTimeRangeException
     * @throws InvalidLimitException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetResourceConfigHistoryResult getResourceConfigHistory(GetResourceConfigHistoryRequest getResourceConfigHistoryRequest) {
        ExecutionContext executionContext = createExecutionContext(getResourceConfigHistoryRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetResourceConfigHistoryRequest> request = null;
        Response<GetResourceConfigHistoryResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetResourceConfigHistoryRequestMarshaller().marshall(super.beforeMarshalling(getResourceConfigHistoryRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetResourceConfigHistoryResult, JsonUnmarshallerContext> unmarshaller =
                new GetResourceConfigHistoryResultJsonUnmarshaller();
            JsonResponseHandler<GetResourceConfigHistoryResult> responseHandler =
                new JsonResponseHandler<GetResourceConfigHistoryResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     *
     * @param describeDeliveryChannelsRequest Container for the necessary
     *           parameters to execute the DescribeDeliveryChannels service method on
     *           AmazonConfig.
     * 
     * @return The response from the DescribeDeliveryChannels service method,
     *         as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelsResult describeDeliveryChannels(DescribeDeliveryChannelsRequest describeDeliveryChannelsRequest) {
        ExecutionContext executionContext = createExecutionContext(describeDeliveryChannelsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeDeliveryChannelsRequest> request = null;
        Response<DescribeDeliveryChannelsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeDeliveryChannelsRequestMarshaller().marshall(super.beforeMarshalling(describeDeliveryChannelsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeDeliveryChannelsResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeDeliveryChannelsResultJsonUnmarshaller();
            JsonResponseHandler<DescribeDeliveryChannelsResult> responseHandler =
                new JsonResponseHandler<DescribeDeliveryChannelsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     *
     * @param describeConfigurationRecorderStatusRequest Container for the
     *           necessary parameters to execute the
     *           DescribeConfigurationRecorderStatus service method on AmazonConfig.
     * 
     * @return The response from the DescribeConfigurationRecorderStatus
     *         service method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecorderStatusResult describeConfigurationRecorderStatus(DescribeConfigurationRecorderStatusRequest describeConfigurationRecorderStatusRequest) {
        ExecutionContext executionContext = createExecutionContext(describeConfigurationRecorderStatusRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeConfigurationRecorderStatusRequest> request = null;
        Response<DescribeConfigurationRecorderStatusResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeConfigurationRecorderStatusRequestMarshaller().marshall(super.beforeMarshalling(describeConfigurationRecorderStatusRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeConfigurationRecorderStatusResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeConfigurationRecorderStatusResultJsonUnmarshaller();
            JsonResponseHandler<DescribeConfigurationRecorderStatusResult> responseHandler =
                new JsonResponseHandler<DescribeConfigurationRecorderStatusResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns the current status of the specified delivery channel. If a
     * delivery channel is not specified, this action returns the current
     * status of all delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one delivery channel per
     * account.
     * </p>
     * 
     * @return The response from the DescribeDeliveryChannelStatus service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelStatusResult describeDeliveryChannelStatus() throws AmazonServiceException, AmazonClientException {
        return describeDeliveryChannelStatus(new DescribeDeliveryChannelStatusRequest());
    }
    
    /**
     * <p>
     * Returns the name of one or more specified configuration recorders.
     * If the recorder name is not specified, this action returns the names
     * of all the configuration recorders associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     * 
     * @return The response from the DescribeConfigurationRecorders service
     *         method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecordersResult describeConfigurationRecorders() throws AmazonServiceException, AmazonClientException {
        return describeConfigurationRecorders(new DescribeConfigurationRecordersRequest());
    }
    
    /**
     * <p>
     * Returns details about the specified delivery channel. If a delivery
     * channel is not specified, this action returns the details of all
     * delivery channels associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b> Currently, you can specify only one delivery channel per
     * account.
     * </p>
     * 
     * @return The response from the DescribeDeliveryChannels service method,
     *         as returned by AmazonConfig.
     * 
     * @throws NoSuchDeliveryChannelException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeDeliveryChannelsResult describeDeliveryChannels() throws AmazonServiceException, AmazonClientException {
        return describeDeliveryChannels(new DescribeDeliveryChannelsRequest());
    }
    
    /**
     * <p>
     * Returns the current status of the specified configuration recorder.
     * If a configuration recorder is not specified, this action returns the
     * status of all configuration recorder associated with the account.
     * </p>
     * <p>
     * <b>NOTE:</b>Currently, you can specify only one configuration
     * recorder per account.
     * </p>
     * 
     * @return The response from the DescribeConfigurationRecorderStatus
     *         service method, as returned by AmazonConfig.
     * 
     * @throws NoSuchConfigurationRecorderException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonConfig indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeConfigurationRecorderStatusResult describeConfigurationRecorderStatus() throws AmazonServiceException, AmazonClientException {
        return describeConfigurationRecorderStatus(new DescribeConfigurationRecorderStatusRequest());
    }

    @Override
    public void setEndpoint(String endpoint) {
        super.setEndpoint(endpoint);
    }

    @Override
    public void setEndpoint(String endpoint, String serviceName, String regionId) throws IllegalArgumentException {
        super.setEndpoint(endpoint, serviceName, regionId);
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext) {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);

        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        AWSCredentials credentials;
        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
        try {
            credentials = awsCredentialsProvider.getCredentials();
        } finally {
            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
        }

        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(jsonErrorUnmarshallers);
        Response<X> result = client.execute(request, responseHandler,
                errorResponseHandler, executionContext);
        return result;
    }
}
        

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/ConfigStreamDeliveryInfo.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

/**
 * <p>
 * A list that contains the status of the delivery of the configuration
 * stream notification to the Amazon SNS topic.
 * </p>
 */
public class ConfigStreamDeliveryInfo implements Serializable, Cloneable {

    /**
     * Status of the last attempted delivery.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     */
    private String lastStatus;

    /**
     * The error code from the last attempted delivery.
     */
    private String lastErrorCode;

    /**
     * The error message from the last attempted delivery.
     */
    private String lastErrorMessage;

    /**
     * The time from the last status change.
     */
    private java.util.Date lastStatusChangeTime;

    /**
     * Status of the last attempted delivery.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     *
     * @return Status of the last attempted delivery.
     *
     * @see DeliveryStatus
     */
    public String getLastStatus() {
        return lastStatus;
    }
    
    /**
     * Status of the last attempted delivery.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     *
     * @param lastStatus Status of the last attempted delivery.
     *
     * @see DeliveryStatus
     */
    public void setLastStatus(String lastStatus) {
        this.lastStatus = lastStatus;
    }
    
    /**
     * Status of the last attempted delivery.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     *
     * @param lastStatus Status of the last attempted delivery.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see DeliveryStatus
     */
    public ConfigStreamDeliveryInfo withLastStatus(String lastStatus) {
        this.lastStatus = lastStatus;
        return this;
    }

    /**
     * Status of the last attempted delivery.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     *
     * @param lastStatus Status of the last attempted delivery.
     *
     * @see DeliveryStatus
     */
    public void setLastStatus(DeliveryStatus lastStatus) {
        this.lastStatus = lastStatus.toString();
    }
    
    /**
     * Status of the last attempted delivery.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Success, Failure, Not_Applicable
     *
     * @param lastStatus Status of the last attempted delivery.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see DeliveryStatus
     */
    public ConfigStreamDeliveryInfo withLastStatus(DeliveryStatus lastStatus) {
        this.lastStatus = lastStatus.toString();
        return this;
    }

    /**
     * The error code from the last attempted delivery.
     *
     * @return The error code from the last attempted delivery.
     */
    public String getLastErrorCode() {
        return lastErrorCode;
    }
    
    /**
     * The error code from the last attempted delivery.
     *
     * @param lastErrorCode The error code from the last attempted delivery.
     */
    public void setLastErrorCode(String lastErrorCode) {
        this.lastErrorCode = lastErrorCode;
    }
    
    /**
     * The error code from the last attempted delivery.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param lastErrorCode The error code from the last attempted delivery.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ConfigStreamDeliveryInfo withLastErrorCode(String lastErrorCode) {
        this.lastErrorCode = lastErrorCode;
        return this;
    }

    /**
     * The error message from the last attempted delivery.
     *
     * @return The error message from the last attempted delivery.
     */
    public String getLastErrorMessage() {
        return lastErrorMessage;
    }
    
    /**
     * The error message from the last attempted delivery.
     *
     * @param lastErrorMessage The error message from the last attempted delivery.
     */
    public void setLastErrorMessage(String lastErrorMessage) {
        this.lastErrorMessage = lastErrorMessage;
    }
    
    /**
     * The error message from the last attempted delivery.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param lastErrorMessage The error message from the last attempted delivery.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ConfigStreamDeliveryInfo withLastErrorMessage(String lastErrorMessage) {
        this.lastErrorMessage = lastErrorMessage;
        return this;
    }

    /**
     * The time from the last status change.
     *
     * @return The time from the last status change.
     */
    public java.util.Date getLastStatusChangeTime() {
        return lastStatusChangeTime;
    }
    
    /**
     * The time from the last status change.
     *
     * @param lastStatusChangeTime The time from the last status change.
     */
    public void setLastStatusChangeTime(java.util.Date lastStatusChangeTime) {
        this.lastStatusChangeTime = lastStatusChangeTime;
    }
    
    /**
     * The time from the last status change.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param lastStatusChangeTime The time from the last status change.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ConfigStreamDeliveryInfo withLastStatusChangeTime(java.util.Date lastStatusChangeTime) {
        this.lastStatusChangeTime = lastStatusChangeTime;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getLastStatus() != null) sb.append("LastStatus: " + getLastStatus() + ",");
        if (getLastErrorCode() != null) sb.append("LastErrorCode: " + getLastErrorCode() + ",");
        if (getLastErrorMessage() != null) sb.append("LastErrorMessage: " + getLastErrorMessage() + ",");
        if (getLastStatusChangeTime() != null) sb.append("LastStatusChangeTime: " + getLastStatusChangeTime() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getLastStatus() == null) ? 0 : getLastStatus().hashCode()); 
        hashCode = prime * hashCode + ((getLastErrorCode() == null) ? 0 : getLastErrorCode().hashCode()); 
        hashCode = prime * hashCode + ((getLastErrorMessage() == null) ? 0 : getLastErrorMessage().hashCode()); 
        hashCode = prime * hashCode + ((getLastStatusChangeTime() == null) ? 0 : getLastStatusChangeTime().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof ConfigStreamDeliveryInfo == false) return false;
        ConfigStreamDeliveryInfo other = (ConfigStreamDeliveryInfo)obj;
        
        if (other.getLastStatus() == null ^ this.getLastStatus() == null) return false;
        if (other.getLastStatus() != null && other.getLastStatus().equals(this.getLastStatus()) == false) return false; 
        if (other.getLastErrorCode() == null ^ this.getLastErrorCode() == null) return false;
        if (other.getLastErrorCode() != null && other.getLastErrorCode().equals(this.getLastErrorCode()) == false) return false; 
        if (other.getLastErrorMessage() == null ^ this.getLastErrorMessage() == null) return false;
        if (other.getLastErrorMessage() != null && other.getLastErrorMessage().equals(this.getLastErrorMessage()) == false) return false; 
        if (other.getLastStatusChangeTime() == null ^ this.getLastStatusChangeTime() == null) return false;
        if (other.getLastStatusChangeTime() != null && other.getLastStatusChangeTime().equals(this.getLastStatusChangeTime()) == false) return false; 
        return true;
    }
    
    @Override
    public ConfigStreamDeliveryInfo clone() {
        try {
            return (ConfigStreamDeliveryInfo) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/ConfigurationRecorder.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

/**
 * <p>
 * An object that represents the recording of configuration changes of an
 * AWS resource.
 * </p>
 */
public class ConfigurationRecorder implements Serializable, Cloneable {

    /**
     * The name of the recorder. By default, AWS Config automatically assigns
     * the name "default" when creating the configuration recorder. You
     * cannot change the assigned name.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String name;

    /**
     * Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     * resources associated with the account.
     */
    private String roleARN;

    /**
     * The name of the recorder. By default, AWS Config automatically assigns
     * the name "default" when creating the configuration recorder. You
     * cannot change the assigned name.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The name of the recorder. By default, AWS Config automatically assigns
     *         the name "default" when creating the configuration recorder. You
     *         cannot change the assigned name.
     */
    public String getName() {
        return name;
    }
    
    /**
     * The name of the recorder. By default, AWS Config automatically assigns
     * the name "default" when creating the configuration recorder. You
     * cannot change the assigned name.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param name The name of the recorder. By default, AWS Config automatically assigns
     *         the name "default" when creating the configuration recorder. You
     *         cannot change the assigned name.
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * The name of the recorder. By default, AWS Config automatically assigns
     * the name "default" when creating the configuration recorder. You
     * cannot change the assigned name.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param name The name of the recorder. By default, AWS Config automatically assigns
     *         the name "default" when creating the configuration recorder. You
     *         cannot change the assigned name.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ConfigurationRecorder withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     * resources associated with the account.
     *
     * @return Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     *         resources associated with the account.
     */
    public String getRoleARN() {
        return roleARN;
    }
    
    /**
     * Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     * resources associated with the account.
     *
     * @param roleARN Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     *         resources associated with the account.
     */
    public void setRoleARN(String roleARN) {
        this.roleARN = roleARN;
    }
    
    /**
     * Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     * resources associated with the account.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param roleARN Amazon Resource Name (ARN) of the IAM role used to describe the AWS
     *         resources associated with the account.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ConfigurationRecorder withRoleARN(String roleARN) {
        this.roleARN = roleARN;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getName() != null) sb.append("Name: " + getName() + ",");
        if (getRoleARN() != null) sb.append("RoleARN: " + getRoleARN() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode()); 
        hashCode = prime * hashCode + ((getRoleARN() == null) ? 0 : getRoleARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof ConfigurationRecorder == false) return false;
        ConfigurationRecorder other = (ConfigurationRecorder)obj;
        
        if (other.getName() == null ^ this.getName() == null) return false;
        if (other.getName() != null && other.getName().equals(this.getName()) == false) return false; 
        if (other.getRoleARN() == null ^ this.getRoleARN() == null) return false;
        if (other.getRoleARN() != null && other.getRoleARN().equals(this.getRoleARN()) == false) return false; 
        return true;
    }
    
    @Override
    public ConfigurationRecorder clone() {
        try {
            return (ConfigurationRecorder) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/PutConfigurationRecorderRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.config.AmazonConfig#putConfigurationRecorder(PutConfigurationRecorderRequest) PutConfigurationRecorder operation}.
 * <p>
 * Creates a new configuration recorder to record the resource
 * configurations.
 * </p>
 * <p>
 * You can use this action to change the role ( <code>roleARN</code> ) of
 * an existing recorder. To change the role, call the action on the
 * existing configuration recorder and specify a role.
 * </p>
 * <p>
 * <b>NOTE:</b> Currently, you can specify only one configuration
 * recorder per account.
 * </p>
 *
 * @see com.amazonaws.services.config.AmazonConfig#putConfigurationRecorder(PutConfigurationRecorderRequest)
 */
public class PutConfigurationRecorderRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The configuration recorder object that records each configuration
     * change made to the resources.
     */
    private ConfigurationRecorder configurationRecorder;

    /**
     * The configuration recorder object that records each configuration
     * change made to the resources.
     *
     * @return The configuration recorder object that records each configuration
     *         change made to the resources.
     */
    public ConfigurationRecorder getConfigurationRecorder() {
        return configurationRecorder;
    }
    
    /**
     * The configuration recorder object that records each configuration
     * change made to the resources.
     *
     * @param configurationRecorder The configuration recorder object that records each configuration
     *         change made to the resources.
     */
    public void setConfigurationRecorder(ConfigurationRecorder configurationRecorder) {
        this.configurationRecorder = configurationRecorder;
    }
    
    /**
     * The configuration recorder object that records each configuration
     * change made to the resources.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param configurationRecorder The configuration recorder object that records each configuration
     *         change made to the resources.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public PutConfigurationRecorderRequest withConfigurationRecorder(ConfigurationRecorder configurationRecorder) {
        this.configurationRecorder = configurationRecorder;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getConfigurationRecorder() != null) sb.append("ConfigurationRecorder: " + getConfigurationRecorder() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getConfigurationRecorder() == null) ? 0 : getConfigurationRecorder().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof PutConfigurationRecorderRequest == false) return false;
        PutConfigurationRecorderRequest other = (PutConfigurationRecorderRequest)obj;
        
        if (other.getConfigurationRecorder() == null ^ this.getConfigurationRecorder() == null) return false;
        if (other.getConfigurationRecorder() != null && other.getConfigurationRecorder().equals(this.getConfigurationRecorder()) == false) return false; 
        return true;
    }
    
    @Override
    public PutConfigurationRecorderRequest clone() {
        
            return (PutConfigurationRecorderRequest) super.clone();
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/Relationship.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

/**
 * <p>
 * The relationship of the related resource to the main resource.
 * </p>
 */
public class Relationship implements Serializable, Cloneable {

    /**
     * The resource type of the related resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     */
    private String resourceType;

    /**
     * The resource ID of the related resource (for example,
     * <code>sg-xxxxxx</code>.
     */
    private String resourceId;

    /**
     * The name of the related resource.
     */
    private String relationshipName;

    /**
     * The resource type of the related resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     *
     * @return The resource type of the related resource.
     *
     * @see ResourceType
     */
    public String getResourceType() {
        return resourceType;
    }
    
    /**
     * The resource type of the related resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     *
     * @param resourceType The resource type of the related resource.
     *
     * @see ResourceType
     */
    public void setResourceType(String resourceType) {
        this.resourceType = resourceType;
    }
    
    /**
     * The resource type of the related resource.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     *
     * @param resourceType The resource type of the related resource.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ResourceType
     */
    public Relationship withResourceType(String resourceType) {
        this.resourceType = resourceType;
        return this;
    }

    /**
     * The resource type of the related resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     *
     * @param resourceType The resource type of the related resource.
     *
     * @see ResourceType
     */
    public void setResourceType(ResourceType resourceType) {
        this.resourceType = resourceType.toString();
    }
    
    /**
     * The resource type of the related resource.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>AWS::EC2::CustomerGateway, AWS::EC2::EIP, AWS::EC2::Instance, AWS::EC2::InternetGateway, AWS::EC2::NetworkAcl, AWS::EC2::NetworkInterface, AWS::EC2::RouteTable, AWS::EC2::SecurityGroup, AWS::EC2::Subnet, AWS::CloudTrail::Trail, AWS::EC2::Volume, AWS::EC2::VPC, AWS::EC2::VPNConnection, AWS::EC2::VPNGateway
     *
     * @param resourceType The resource type of the related resource.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see ResourceType
     */
    public Relationship withResourceType(ResourceType resourceType) {
        this.resourceType = resourceType.toString();
        return this;
    }

    /**
     * The resource ID of the related resource (for example,
     * <code>sg-xxxxxx</code>.
     *
     * @return The resource ID of the related resource (for example,
     *         <code>sg-xxxxxx</code>.
     */
    public String getResourceId() {
        return resourceId;
    }
    
    /**
     * The resource ID of the related resource (for example,
     * <code>sg-xxxxxx</code>.
     *
     * @param resourceId The resource ID of the related resource (for example,
     *         <code>sg-xxxxxx</code>.
     */
    public void setResourceId(String resourceId) {
        this.resourceId = resourceId;
    }
    
    /**
     * The resource ID of the related resource (for example,
     * <code>sg-xxxxxx</code>.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param resourceId The resource ID of the related resource (for example,
     *         <code>sg-xxxxxx</code>.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Relationship withResourceId(String resourceId) {
        this.resourceId = resourceId;
        return this;
    }

    /**
     * The name of the related resource.
     *
     * @return The name of the related resource.
     */
    public String getRelationshipName() {
        return relationshipName;
    }
    
    /**
     * The name of the related resource.
     *
     * @param relationshipName The name of the related resource.
     */
    public void setRelationshipName(String relationshipName) {
        this.relationshipName = relationshipName;
    }
    
    /**
     * The name of the related resource.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param relationshipName The name of the related resource.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Relationship withRelationshipName(String relationshipName) {
        this.relationshipName = relationshipName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getResourceType() != null) sb.append("ResourceType: " + getResourceType() + ",");
        if (getResourceId() != null) sb.append("ResourceId: " + getResourceId() + ",");
        if (getRelationshipName() != null) sb.append("RelationshipName: " + getRelationshipName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getResourceType() == null) ? 0 : getResourceType().hashCode()); 
        hashCode = prime * hashCode + ((getResourceId() == null) ? 0 : getResourceId().hashCode()); 
        hashCode = prime * hashCode + ((getRelationshipName() == null) ? 0 : getRelationshipName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof Relationship == false) return false;
        Relationship other = (Relationship)obj;
        
        if (other.getResourceType() == null ^ this.getResourceType() == null) return false;
        if (other.getResourceType() != null && other.getResourceType().equals(this.getResourceType()) == false) return false; 
        if (other.getResourceId() == null ^ this.getResourceId() == null) return false;
        if (other.getResourceId() != null && other.getResourceId().equals(this.getResourceId()) == false) return false; 
        if (other.getRelationshipName() == null ^ this.getRelationshipName() == null) return false;
        if (other.getRelationshipName() != null && other.getRelationshipName().equals(this.getRelationshipName()) == false) return false; 
        return true;
    }
    
    @Override
    public Relationship clone() {
        try {
            return (Relationship) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/StartConfigurationRecorderRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.config.AmazonConfig#startConfigurationRecorder(StartConfigurationRecorderRequest) StartConfigurationRecorder operation}.
 * <p>
 * Starts recording configurations of all the resources associated with
 * the account.
 * </p>
 * <p>
 * You must have created at least one delivery channel to successfully
 * start the configuration recorder.
 * </p>
 *
 * @see com.amazonaws.services.config.AmazonConfig#startConfigurationRecorder(StartConfigurationRecorderRequest)
 */
public class StartConfigurationRecorderRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String configurationRecorderName;

    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The name of the recorder object that records each configuration change
     *         made to the resources.
     */
    public String getConfigurationRecorderName() {
        return configurationRecorderName;
    }
    
    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param configurationRecorderName The name of the recorder object that records each configuration change
     *         made to the resources.
     */
    public void setConfigurationRecorderName(String configurationRecorderName) {
        this.configurationRecorderName = configurationRecorderName;
    }
    
    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param configurationRecorderName The name of the recorder object that records each configuration change
     *         made to the resources.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public StartConfigurationRecorderRequest withConfigurationRecorderName(String configurationRecorderName) {
        this.configurationRecorderName = configurationRecorderName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getConfigurationRecorderName() != null) sb.append("ConfigurationRecorderName: " + getConfigurationRecorderName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getConfigurationRecorderName() == null) ? 0 : getConfigurationRecorderName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof StartConfigurationRecorderRequest == false) return false;
        StartConfigurationRecorderRequest other = (StartConfigurationRecorderRequest)obj;
        
        if (other.getConfigurationRecorderName() == null ^ this.getConfigurationRecorderName() == null) return false;
        if (other.getConfigurationRecorderName() != null && other.getConfigurationRecorderName().equals(this.getConfigurationRecorderName()) == false) return false; 
        return true;
    }
    
    @Override
    public StartConfigurationRecorderRequest clone() {
        
            return (StartConfigurationRecorderRequest) super.clone();
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/StopConfigurationRecorderRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.config.AmazonConfig#stopConfigurationRecorder(StopConfigurationRecorderRequest) StopConfigurationRecorder operation}.
 * <p>
 * Stops recording configurations of all the resources associated with
 * the account.
 * </p>
 *
 * @see com.amazonaws.services.config.AmazonConfig#stopConfigurationRecorder(StopConfigurationRecorderRequest)
 */
public class StopConfigurationRecorderRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     */
    private String configurationRecorderName;

    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @return The name of the recorder object that records each configuration change
     *         made to the resources.
     */
    public String getConfigurationRecorderName() {
        return configurationRecorderName;
    }
    
    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param configurationRecorderName The name of the recorder object that records each configuration change
     *         made to the resources.
     */
    public void setConfigurationRecorderName(String configurationRecorderName) {
        this.configurationRecorderName = configurationRecorderName;
    }
    
    /**
     * The name of the recorder object that records each configuration change
     * made to the resources.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 256<br/>
     *
     * @param configurationRecorderName The name of the recorder object that records each configuration change
     *         made to the resources.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public StopConfigurationRecorderRequest withConfigurationRecorderName(String configurationRecorderName) {
        this.configurationRecorderName = configurationRecorderName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getConfigurationRecorderName() != null) sb.append("ConfigurationRecorderName: " + getConfigurationRecorderName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getConfigurationRecorderName() == null) ? 0 : getConfigurationRecorderName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof StopConfigurationRecorderRequest == false) return false;
        StopConfigurationRecorderRequest other = (StopConfigurationRecorderRequest)obj;
        
        if (other.getConfigurationRecorderName() == null ^ this.getConfigurationRecorderName() == null) return false;
        if (other.getConfigurationRecorderName() != null && other.getConfigurationRecorderName().equals(this.getConfigurationRecorderName()) == false) return false; 
        return true;
    }
    
    @Override
    public StopConfigurationRecorderRequest clone() {
        
            return (StopConfigurationRecorderRequest) super.clone();
    }

}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/transform/ConfigurationRecorderJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.config.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.config.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Configuration Recorder JSON Unmarshaller
 */
public class ConfigurationRecorderJsonUnmarshaller implements Unmarshaller<ConfigurationRecorder, JsonUnmarshallerContext> {

    public ConfigurationRecorder unmarshall(JsonUnmarshallerContext context) throws Exception {
        ConfigurationRecorder configurationRecorder = new ConfigurationRecorder();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("name", targetDepth)) {
                    context.nextToken();
                    configurationRecorder.setName(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("roleARN", targetDepth)) {
                    context.nextToken();
                    configurationRecorder.setRoleARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return configurationRecorder;
    }

    private static ConfigurationRecorderJsonUnmarshaller instance;
    public static ConfigurationRecorderJsonUnmarshaller getInstance() {
        if (instance == null) instance = new ConfigurationRecorderJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/model/transform/PutConfigurationRecorderRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.config.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.config.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Put Configuration Recorder Request Marshaller
 */
public class PutConfigurationRecorderRequestMarshaller implements Marshaller<Request<PutConfigurationRecorderRequest>, PutConfigurationRecorderRequest> {

    public Request<PutConfigurationRecorderRequest> marshall(PutConfigurationRecorderRequest putConfigurationRecorderRequest) {
        if (putConfigurationRecorderRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<PutConfigurationRecorderRequest> request = new DefaultRequest<PutConfigurationRecorderRequest>(putConfigurationRecorderRequest, "AmazonConfig");
        String target = "StarlingDoveService.PutConfigurationRecorder";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.POST);
        request.setResourcePath("");
        
        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();
          
            ConfigurationRecorder configurationRecorder = putConfigurationRecorderRequest.getConfigurationRecorder();
            if (configurationRecorder != null) {

                jsonWriter.key("ConfigurationRecorder");
                jsonWriter.object();

                if (configurationRecorder.getName() != null) {
                    jsonWriter.key("name").value(configurationRecorder.getName());
                }
                if (configurationRecorder.getRoleARN() != null) {
                    jsonWriter.key("roleARN").value(configurationRecorder.getRoleARN());
                }
                jsonWriter.endObject();
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-config/src/main/java/com/amazonaws/services/config/package-info.java

/**
 * Synchronous and asynchronous client classes for accessing AmazonConfig.
 *
 * AWS Config <p>
 * AWS Config provides a way to keep track of the configurations of all
 * the AWS resources associated with your AWS account. You can use AWS
 * Config to get the current and historical configurations of each AWS
 * resource and also to get information about the relationship between
 * the resources. An AWS resource can be an Amazon Compute Cloud (Amazon
 * EC2) instance, an Elastic Block Store (EBS) volume, an Elastic network
 * Interface (ENI), or a security group. For a complete list of resources
 * currently supported by AWS Config, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/config-concepts.html"> Supported AWS Resources </a>
 * .
 * </p>
 * <p>
 * You can access and manage AWS Config through the AWS Management
 * Console, the AWS Command Line Interface (AWS CLI), the AWS Config API,
 * or the AWS SDKs for AWS Config
 * </p>
 * <p>
 * This reference guide contains documentation for the AWS Config API and
 * the AWS CLI commands that you can use to manage AWS Config.
 * </p>
 * <p>
 * The AWS Config API uses the Signature Version 4 protocol for signing
 * requests. For more information about how to sign a request with this
 * protocol, see
 * <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html"> Signature Version 4 Signing Process </a>
 * .
 * </p>
 * <p>
 * For detailed information about AWS Config features and their
 * associated actions or commands, as well as how to work with AWS
 * Management Console, see
 * <a href="http://docs.aws.amazon.com/config/latest/developerguide/WhatIsConfig.html"> What Is AWS Config? </a>
 * in the <i>AWS Config Developer Guide</i> .
 * </p>
 */
 package com.amazonaws.services.config;
        

File: aws-java-sdk-core/src/main/java/com/amazonaws/regions/Regions.java
/*
 * Copyright 2013-2015 Amazon Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *    http://aws.amazon.com/apache2.0
 *
 * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and
 * limitations under the License.
 */
package com.amazonaws.regions;

import org.apache.commons.logging.LogFactory;

import com.amazonaws.AmazonClientException;
import com.amazonaws.util.EC2MetadataUtils;

/**
 * Enumeration of region names
 */
public enum Regions {

    GovCloud("us-gov-west-1"),
    US_EAST_1("us-east-1"),
    US_WEST_1("us-west-1"),
    US_WEST_2("us-west-2"),
    EU_WEST_1("eu-west-1"),
    EU_CENTRAL_1("eu-central-1"),
    AP_SOUTHEAST_1("ap-southeast-1"),
    AP_SOUTHEAST_2("ap-southeast-2"),
    AP_NORTHEAST_1("ap-northeast-1"),
    SA_EAST_1("sa-east-1"),
    CN_NORTH_1("cn-north-1");

    /**
     * The default region that new customers in the US are encouraged to use
     * when using AWS services for the first time.
     */
    public static final Regions DEFAULT_REGION = US_WEST_2;

    private final String name;

    private Regions(String name) {
        this.name = name;
    }

    /**
     * The name of this region, used in the regions.xml file to identify it.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a region enum corresponding to the given region name.
     *
     * @param regionName
     *            The name of the region. Ex.: eu-west-1
     * @return Region enum representing the given region name.
     */
    public static Regions fromName(String regionName) {
        for (Regions region : Regions.values()) {
            if (regionName.equals(region.getName())) {
                return region;
            }
        }
        throw new IllegalArgumentException("Cannot create enum from " + regionName + " value!");
    }

    /**
     * Returns a Region object representing the region the application is
     * running in, when running in EC2. If this method is called from a non-EC2
     * environment, it will return null.
     */
    public static Region getCurrentRegion() {
        try {
            final String region = EC2MetadataUtils.getEC2InstanceRegion();
            if (region != null)
                return Region.getRegion(fromName(region));
        } catch (AmazonClientException e) {
            LogFactory.getLog(Regions.class).debug(
                "Ignoring failure to retrieve the region: " + e.getMessage());
        }
        return null;
    }
}


File: aws-java-sdk-core/src/test/java/com/amazonaws/regions/RegionXmlTest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights
 * Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is
 * distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either
 * express or implied. See the License for the specific language
 * governing
 * permissions and limitations under the License.
 */
package com.amazonaws.regions;


import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class RegionXmlTest {
    
    @Test
    public void kms() {
        RegionUtils.initialize();
        assertEquals("/com/amazonaws/regions/regions.xml",
                RegionUtils.getSource());
        String[] regions = {
                "us-east-1",
                "us-west-1",
                "us-west-2",
                "ap-northeast-1",
                "ap-southeast-1",
                "ap-southeast-2",
                "sa-east-1",
                "eu-west-1",
                "eu-central-1"                
        };
        for (String region : regions) {
            assertEquals(
                    region,
                    RegionUtils.getRegionByEndpoint(
                            "kms." + region + ".amazonaws.com/bla").getName());
            assertEquals(
                    region,
                    RegionUtils.getRegionByEndpoint(
                            "https://kms." + region + ".amazonaws.com").getName());
            assertEquals("kms." + region + ".amazonaws.com", 
                    RegionUtils.getRegion(region).getServiceEndpoint("kms"));
        }
    }
}


File: aws-java-sdk-core/src/test/java/com/amazonaws/util/EC2MetadataUtilsTest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights
 * Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is
 * distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either
 * express or implied. See the License for the specific language
 * governing
 * permissions and limitations under the License.
 */
package com.amazonaws.util;

import java.io.*;
import java.net.*;
import java.util.*;

import org.junit.*;

import com.amazonaws.SDKGlobalConfiguration;

public class EC2MetadataUtilsTest {

    private static ServerSocket server;

    @BeforeClass
    public static void setUp() throws IOException {

        server = new ServerSocket(0, 1, InetAddress.getByName("localhost"));

        Thread thread = new Thread() {
            @Override
            public void run() {
                try {
                    runServer();
                } catch (IOException exception) {
                    if ((exception instanceof SocketException)
                            && (exception.getMessage().equals("Socket closed"))) {
                        return;
                    }
                    throw new RuntimeException("BOOM", exception);
                }
            }
        };
        thread.setDaemon(true);
        thread.start();

        System.setProperty(
                SDKGlobalConfiguration.EC2_METADATA_SERVICE_OVERRIDE_SYSTEM_PROPERTY,
                "http://localhost:" + server.getLocalPort());
    }

    @AfterClass
    public static void cleanUp() throws IOException {
        killServer();

        System.clearProperty(SDKGlobalConfiguration.EC2_METADATA_SERVICE_OVERRIDE_SYSTEM_PROPERTY);
    }

    @Test
    public void testIamInfo() {
        EC2MetadataUtils.IAMInfo info = EC2MetadataUtils
                .getIAMInstanceProfileInfo();

        Assert.assertEquals("Success", info.code);
        Assert.assertNull(info.message);
        Assert.assertEquals("2014-04-07T08:18:41Z", info.lastUpdated);
        Assert.assertEquals("foobar", info.instanceProfileArn);
        Assert.assertEquals("moobily", info.instanceProfileId);
    }

    @Test
    public void testIamCredentials() {
        Map<String, EC2MetadataUtils.IAMSecurityCredential> map = EC2MetadataUtils
                .getIAMSecurityCredentials();

        Assert.assertEquals(2, map.size());

        for (Map.Entry<String, EC2MetadataUtils.IAMSecurityCredential> entry : map
                .entrySet()) {

            Assert.assertNotNull(entry.getKey());
            Assert.assertNotNull(entry.getValue().code);
            Assert.assertNotNull(entry.getValue().lastUpdated);
            Assert.assertEquals("AWS-HMAC", entry.getValue().type);
            Assert.assertEquals("foobar", entry.getValue().accessKeyId);
            Assert.assertEquals("moobily", entry.getValue().secretAccessKey);
            Assert.assertEquals("beebop", entry.getValue().token);
            Assert.assertNotNull(entry.getValue().expiration);
        }
    }

    @Test
    public void testInstanceInfo() {
        EC2MetadataUtils.InstanceInfo info = EC2MetadataUtils.getInstanceInfo();
        Assert.assertEquals("2014-08-07T22:07:46Z", info.getPendingTime());
        Assert.assertEquals("m1.small", info.getInstanceType());
        Assert.assertEquals("ami-a49665cc", info.getImageId());
        Assert.assertEquals("i-6b2de041", info.getInstanceId());
        Assert.assertEquals("foo", info.getBillingProducts()[0]);
        Assert.assertEquals("x86_64", info.getArchitecture());
        Assert.assertEquals("599169622985", info.getAccountId());
        Assert.assertEquals("aki-919dcaf8", info.getKernelId());
        Assert.assertEquals("baz", info.getRamdiskId());
        Assert.assertEquals("us-east-1", info.getRegion());
        Assert.assertEquals("2010-08-31", info.getVersion());
        Assert.assertEquals("us-east-1b", info.getAvailabilityZone());
        Assert.assertEquals("10.201.215.38", info.getPrivateIp());
        Assert.assertEquals("bar", info.getDevpayProductCodes()[0]);
    }

    private static void runServer() throws IOException {
        while (true) {
            Socket sock = server.accept();
            BufferedReader reader = new BufferedReader(new InputStreamReader(
                    sock.getInputStream()));
            PrintWriter writer = new PrintWriter(sock.getOutputStream());

            handleConnection(reader, writer);

            writer.close();
            reader.close();
            sock.close();
        }
    }

    private static void handleConnection(BufferedReader input,
            PrintWriter output) throws IOException {

        String line = input.readLine();
        if (line == null) {
            return;
        }

        String[] parts = line.split(" ");
        if (parts.length != 3) {
            throw new RuntimeException("Bogus request: " + line);
        }
        if (!"GET".equals(parts[0])) {
            throw new RuntimeException("Bogus verb: " + line);
        }

        ignoreRequest(input);

        String path = parts[1];
        if (path.equals("/latest/meta-data/iam/info")) {
            outputIamInfo(output);

        } else if (path.equals("/latest/meta-data/iam/security-credentials")) {
            outputIamCredList(output);

        } else if (path
                .startsWith("/latest/meta-data/iam/security-credentials/")) {

            outputIamCred(output);

        } else if (path.equals("/latest/dynamic/instance-identity/document")) {
            outputInstanceInfo(output);
        } else {
            throw new RuntimeException("Unknown path: " + path);
        }
    }

    private static void ignoreRequest(BufferedReader input) throws IOException {

        while (true) {
            String line = input.readLine();
            if (line == null) {
                throw new RuntimeException("Unexpected end of input");
            }
            if (line.length() == 0) {
                return;
            }
        }
    }

    private static void outputIamInfo(PrintWriter output) throws IOException {

        String payload =
                "{"
                + "\"Code\":\"Success\","
                + "\"LastUpdated\":\"2014-04-07T08:18:41Z\","
                + "\"InstanceProfileArn\":\"foobar\","
                + "\"InstanceProfileId\":\"moobily\","
                + "\"NewFeature\":12345"
                + "}";

        output.println("HTTP/1.1 200 OK");
        output.println("Connection: close");
        output.println("Content-Length: " + payload.length());
        output.println();

        output.print(payload);
        output.flush();
    }

    private static void outputIamCredList(PrintWriter output)
            throws IOException {

        String payload = "test1\ntest2";

        output.println("HTTP/1.1 200 OK");
        output.println("Connection: close");
        output.println("Content-Length: " + payload.length());
        output.println();

        output.print(payload);
        output.flush();
    }

    private static void outputIamCred(PrintWriter output) throws IOException {

        String payload =
                "{"
                + "\"Code\":\"Success\","
                + "\"LastUpdated\":\"2014-04-07T08:18:41Z\","
                + "\"Type\":\"AWS-HMAC\","
                + "\"AccessKeyId\":\"foobar\","
                + "\"SecretAccessKey\":\"moobily\","
                + "\"Token\":\"beebop\","
                + "\"Expiration\":\"2014-04-08T23:16:53Z\""
                + "}";

        output.println("HTTP/1.1 200 OK");
        output.println("Connection: close");
        output.println("Content-Length: " + payload.length());
        output.println();

        output.print(payload);
        output.flush();
    }

    private static void outputInstanceInfo(PrintWriter output)
            throws IOException {
        String payload =
                "{"
                + "\"pendingTime\":\"2014-08-07T22:07:46Z\","
                + "\"instanceType\":\"m1.small\","
                + "\"imageId\":\"ami-a49665cc\","
                + "\"instanceId\":\"i-6b2de041\","
                + "\"billingProducts\":[\"foo\"],"
                + "\"architecture\":\"x86_64\","
                + "\"accountId\":\"599169622985\","
                + "\"kernelId\":\"aki-919dcaf8\","
                + "\"ramdiskId\":\"baz\","
                + "\"region\":\"us-east-1\","
                + "\"version\":\"2010-08-31\","
                + "\"availabilityZone\":\"us-east-1b\","
                + "\"privateIp\":\"10.201.215.38\","
                + "\"devpayProductCodes\":[\"bar\"]"
                + "}";

        output.println("HTTP/1.1 200 OK");
        output.println("Connection: close");
        output.println("Content-Length: " + payload.length());
        output.println();

        output.print(payload);
        output.flush();
    }

    private static void killServer() throws IOException {
        if (server != null) {
            server.close();
        }
    }
}


File: aws-java-sdk-dynamodb/src/main/java/com/amazonaws/services/dynamodbv2/datamodeling/DynamoDBMapper.java
/*
 * Copyright 2011-2015 Amazon Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *    http://aws.amazon.com/apache2.0
 *
 * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and
 * limitations under the License.
 */
package com.amazonaws.services.dynamodbv2.datamodeling;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.UUID;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.retry.RetryUtils;
import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.ConsistentReads;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.PaginationLoadingStrategy;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.SaveBehavior;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTableSchemaParser.TableIndexesInfo;
import com.amazonaws.services.dynamodbv2.model.AttributeAction;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.AttributeValueUpdate;
import com.amazonaws.services.dynamodbv2.model.BatchGetItemRequest;
import com.amazonaws.services.dynamodbv2.model.BatchGetItemResult;
import com.amazonaws.services.dynamodbv2.model.BatchWriteItemRequest;
import com.amazonaws.services.dynamodbv2.model.BatchWriteItemResult;
import com.amazonaws.services.dynamodbv2.model.ComparisonOperator;
import com.amazonaws.services.dynamodbv2.model.Condition;
import com.amazonaws.services.dynamodbv2.model.ConditionalCheckFailedException;
import com.amazonaws.services.dynamodbv2.model.ConditionalOperator;
import com.amazonaws.services.dynamodbv2.model.CreateTableRequest;
import com.amazonaws.services.dynamodbv2.model.DeleteItemRequest;
import com.amazonaws.services.dynamodbv2.model.DeleteRequest;
import com.amazonaws.services.dynamodbv2.model.ExpectedAttributeValue;
import com.amazonaws.services.dynamodbv2.model.GetItemRequest;
import com.amazonaws.services.dynamodbv2.model.GetItemResult;
import com.amazonaws.services.dynamodbv2.model.KeysAndAttributes;
import com.amazonaws.services.dynamodbv2.model.PutItemRequest;
import com.amazonaws.services.dynamodbv2.model.PutItemResult;
import com.amazonaws.services.dynamodbv2.model.PutRequest;
import com.amazonaws.services.dynamodbv2.model.QueryRequest;
import com.amazonaws.services.dynamodbv2.model.QueryResult;
import com.amazonaws.services.dynamodbv2.model.ReturnValue;
import com.amazonaws.services.dynamodbv2.model.ScanRequest;
import com.amazonaws.services.dynamodbv2.model.ScanResult;
import com.amazonaws.services.dynamodbv2.model.Select;
import com.amazonaws.services.dynamodbv2.model.UpdateItemRequest;
import com.amazonaws.services.dynamodbv2.model.UpdateItemResult;
import com.amazonaws.services.dynamodbv2.model.WriteRequest;
import com.amazonaws.services.s3.model.Region;
import com.amazonaws.util.VersionInfoUtils;

/**
 * Object mapper for domain-object interaction with DynamoDB.
 * <p>
 * To use, define a domain class that represents an item in a DynamoDB table and
 * annotate it with the annotations found in the
 * com.amazonaws.services.dynamodbv2.datamodeling package. In order to allow the
 * mapper to correctly persist the data, each modeled property in the domain
 * class should be accessible via getter and setter methods, and each property
 * annotation should be either applied to the getter method or the class field.
 * A minimal example using getter annotations:
 *
 * <pre class="brush: java">
 * &#064;DynamoDBTable(tableName = &quot;TestTable&quot;)
 * public class TestClass {
 *
 *     private Long key;
 *     private double rangeKey;
 *     private Long version;
 *
 *     private Set&lt;Integer&gt; integerSetAttribute;
 *
 *     &#064;DynamoDBHashKey
 *     public Long getKey() {
 *         return key;
 *     }
 *
 *     public void setKey(Long key) {
 *         this.key = key;
 *     }
 *
 *     &#064;DynamoDBRangeKey
 *     public double getRangeKey() {
 *         return rangeKey;
 *     }
 *
 *     public void setRangeKey(double rangeKey) {
 *         this.rangeKey = rangeKey;
 *     }
 *
 *     &#064;DynamoDBAttribute(attributeName = &quot;integerSetAttribute&quot;)
 *     public Set&lt;Integer&gt; getIntegerAttribute() {
 *         return integerSetAttribute;
 *     }
 *
 *     public void setIntegerAttribute(Set&lt;Integer&gt; integerAttribute) {
 *         this.integerSetAttribute = integerAttribute;
 *     }
 *
 *     &#064;DynamoDBVersionAttribute
 *     public Long getVersion() {
 *         return version;
 *     }
 *
 *     public void setVersion(Long version) {
 *         this.version = version;
 *     }
 * }
 * </pre>
 * <p>
 * Save instances of annotated classes to DynamoDB, retrieve them, and delete
 * them using the {@link DynamoDBMapper} class, as in the following example.
 *
 * <pre class="brush: java">
 * DynamoDBMapper mapper = new DynamoDBMapper(dynamoDBClient);
 * Long hashKey = 105L;
 * double rangeKey = 1.0d;
 * TestClass obj = mapper.load(TestClass.class, hashKey, rangeKey);
 * obj.getIntegerAttribute().add(42);
 * mapper.save(obj);
 * mapper.delete(obj);
 * </pre>
 * <p>
 * When using the save, load, and delete methods, {@link DynamoDBMapper} will
 * throw {@link DynamoDBMappingException}s to indicate that domain classes are
 * incorrectly annotated or otherwise incompatible with this class. Service
 * exceptions will always be propagated as {@link AmazonClientException}, and
 * DynamoDB-specific subclasses such as {@link ConditionalCheckFailedException}
 * will be used when possible.
 * <p>
 * This class is thread-safe and can be shared between threads. It's also very
 * lightweight, so it doesn't need to be.
 *
 * @see DynamoDBTable
 * @see DynamoDBHashKey
 * @see DynamoDBRangeKey
 * @see DynamoDBAutoGeneratedKey
 * @see DynamoDBAttribute
 * @see DynamoDBVersionAttribute
 * @see DynamoDBIgnore
 * @see DynamoDBMarshalling
 * @see DynamoDBMapperConfig
 */
public class DynamoDBMapper {

    private final S3ClientCache s3cc;
    private final AmazonDynamoDB db;
    private final DynamoDBMapperConfig config;
    private final DynamoDBReflector reflector = new DynamoDBReflector();
    private final DynamoDBTableSchemaParser schemaParser = new DynamoDBTableSchemaParser();
    private final VersionIncrementor incrementor = new VersionIncrementor();

    private final AttributeTransformer transformer;

    /** The max back off time for batch write */
    static final long MAX_BACKOFF_IN_MILLISECONDS = 1000 * 3;

    /** The max number of items allowed in a BatchWrite request */
    static final int MAX_ITEMS_PER_BATCH = 25;
    /**
     * This retry count is applicable only when every batch get item request
     * results in no data retrieved from server and the un processed keys is
     * same as request items
     */
    static final int BATCH_GET_MAX_RETRY_COUNT_ALL_KEYS = 5;

    /**
     * User agent for requests made using the {@link DynamoDBMapper}.
     */
    private static final String USER_AGENT =
            DynamoDBMapper.class.getName() + "/" + VersionInfoUtils.getVersion();
    private static final String USER_AGENT_BATCH_OPERATION  =
            DynamoDBMapper.class.getName() + "_batch_operation/" + VersionInfoUtils.getVersion();

    private static final String NO_RANGE_KEY = new String();

    private static final Log log = LogFactory.getLog(DynamoDBMapper.class);

    /**
     * Fail fast when trying to create a subclass of the DynamoDBMapper that
     * attempts to override one of the old {@code transformAttributes} methods.
     */
    private static void failFastOnIncompatibleSubclass(Class<?> clazz) {
        while (clazz != DynamoDBMapper.class) {
            Class<?>[] classOverride = new Class<?>[] {
                    Class.class,
                    Map.class
            };
            Class<?>[] nameOverride = new Class<?>[] {
                    String.class,
                    String.class,
                    Map.class
            };

            for (Method method : clazz.getDeclaredMethods()) {
                if (method.getName().equals("transformAttributes")) {
                    Class<?>[] params = method.getParameterTypes();
                    if (Arrays.equals(params, classOverride)
                            || Arrays.equals(params, nameOverride)) {

                        throw new IllegalStateException(
                                "The deprecated transformAttributes method is "
                                + "no longer supported as of 1.9.0. Use an "
                                + "AttributeTransformer to inject custom "
                                + "attribute transformation logic.");
                    }
                }
            }

            clazz = clazz.getSuperclass();
        }
    }



    /**
     * Constructs a new mapper with the service object given, using the default
     * configuration.
     *
     * @param dynamoDB
     *            The service object to use for all service calls.
     * @see DynamoDBMapperConfig#DEFAULT
     */
    public DynamoDBMapper(final AmazonDynamoDB dynamoDB) {
        this(dynamoDB, DynamoDBMapperConfig.DEFAULT, null, null);
    }

    /**
     * Constructs a new mapper with the service object and configuration given.
     *
     * @param dynamoDB
     *            The service object to use for all service calls.
     * @param config
     *            The default configuration to use for all service calls. It can
     *            be overridden on a per-operation basis.
     */
    public DynamoDBMapper(
            final AmazonDynamoDB dynamoDB,
            final DynamoDBMapperConfig config) {

        this(dynamoDB, config, null, null);
    }

    /**
     * Constructs a new mapper with the service object and S3 client cache
     * given, using the default configuration.
     *
     * @param ddb
     *            The service object to use for all service calls.
     * @param s3CredentialProvider
     *            The credentials provider for accessing S3.
     *            Relevant only if {@link S3Link} is involved.
     * @see DynamoDBMapperConfig#DEFAULT
     */
    public DynamoDBMapper(
            final AmazonDynamoDB ddb,
            final AWSCredentialsProvider s3CredentialProvider) {

        this(ddb, DynamoDBMapperConfig.DEFAULT, s3CredentialProvider);
    }

    /**
     * Constructs a new mapper with the given service object, configuration,
     * and transform hook.
     *
     * @param dynamoDB
     *            the service object to use for all service calls
     * @param config
     *            the default configuration to use for all service calls. It
     *            can be overridden on a per-operation basis
     * @param transformer
     *            The custom attribute transformer to invoke when serializing or
     *            deserializing an object.
     */
    public DynamoDBMapper(
            final AmazonDynamoDB dynamoDB,
            final DynamoDBMapperConfig config,
            final AttributeTransformer transformer) {

        this(dynamoDB, config, transformer, null);
    }

    /**
     * Constructs a new mapper with the service object, configuration, and S3
     * client cache given.
     *
     * @param dynamoDB
     *            The service object to use for all service calls.
     * @param config
     *            The default configuration to use for all service calls. It can
     *            be overridden on a per-operation basis.
     * @param s3CredentialProvider
     *            The credentials provider for accessing S3.
     *            Relevant only if {@link S3Link} is involved.
     */
    public DynamoDBMapper(
            final AmazonDynamoDB dynamoDB,
            final DynamoDBMapperConfig config,
            final AWSCredentialsProvider s3CredentialProvider) {

        this(dynamoDB, config, null, validate(s3CredentialProvider));
    }

    /**
     * Throws an exception if the given credentials provider is {@code null}.
     */
    private static AWSCredentialsProvider validate(
            final AWSCredentialsProvider provider) {
        if (provider == null) {
            throw new IllegalArgumentException(
                    "s3 credentials provider must not be null");
        }
        return provider;
    }

    /**
     * Constructor with all parameters.
     *
     * @param dynamoDB
     *            The service object to use for all service calls.
     * @param config
     *            The default configuration to use for all service calls. It can
     *            be overridden on a per-operation basis.
     * @param transformer
     *            The custom attribute transformer to invoke when serializing or
     *            deserializing an object.
     * @param s3CredentialProvider
     *            The credentials provider for accessing S3.
     *            Relevant only if {@link S3Link} is involved.
     */
    public DynamoDBMapper(
            final AmazonDynamoDB dynamoDB,
            final DynamoDBMapperConfig config,
            final AttributeTransformer transformer,
            final AWSCredentialsProvider s3CredentialsProvider) {

        failFastOnIncompatibleSubclass(getClass());

        this.db = dynamoDB;
        this.config = config;
        this.transformer = transformer;

        if (s3CredentialsProvider == null) {
            this.s3cc = null;
        } else {
            this.s3cc = new S3ClientCache(s3CredentialsProvider);
        }
    }


    /**
     * Loads an object with the hash key given and a configuration override.
     * This configuration overrides the default provided at object construction.
     *
     * @see DynamoDBMapper#load(Class, Object, Object, DynamoDBMapperConfig)
     */
    public <T extends Object> T load(Class<T> clazz, Object hashKey, DynamoDBMapperConfig config) {
        return load(clazz, hashKey, null, config);
    }

    /**
     * Loads an object with the hash key given, using the default configuration.
     *
     * @see DynamoDBMapper#load(Class, Object, Object, DynamoDBMapperConfig)
     */
    public <T extends Object> T load(Class<T> clazz, Object hashKey) {
        return load(clazz, hashKey, null, config);
    }

    /**
     * Loads an object with a hash and range key, using the default
     * configuration.
     *
     * @see DynamoDBMapper#load(Class, Object, Object, DynamoDBMapperConfig)
     */
    public <T extends Object> T load(Class<T> clazz, Object hashKey, Object rangeKey) {
        return load(clazz, hashKey, rangeKey, config);
    }

    /**
     * Returns an object whose keys match those of the prototype key object given,
     * or null if no such item exists.
     *
     * @param keyObject
     *            An object of the class to load with the keys values to match.
     *
     * @see DynamoDBMapper#load(Object, DynamoDBMapperConfig)
     */
    public <T extends Object> T load(T keyObject) {
        return load(keyObject, this.config);
    }

    /**
     * Returns an object whose keys match those of the prototype key object given,
     * or null if no such item exists.
     *
     * @param keyObject
     *            An object of the class to load with the keys values to match.
     * @param config
     *            Configuration for the service call to retrieve the object from
     *            DynamoDB. This configuration overrides the default given at
     *            construction.
     */
    public <T extends Object> T load(T keyObject, DynamoDBMapperConfig config) {
        @SuppressWarnings("unchecked")
        Class<T> clazz = (Class<T>) keyObject.getClass();

        config = mergeConfig(config);
        ItemConverter converter = getConverter(config);

        String tableName = getTableName(clazz, keyObject, config);

        GetItemRequest rq = new GetItemRequest()
            .withRequestMetricCollector(config.getRequestMetricCollector());

        Map<String, AttributeValue> key = getKey(converter, keyObject, clazz);

        rq.setKey(key);
        rq.setTableName(tableName);
        rq.setConsistentRead(config.getConsistentReads() == ConsistentReads.CONSISTENT);


        GetItemResult item = db.getItem(applyUserAgent(rq));
        Map<String, AttributeValue> itemAttributes = item.getItem();
        if ( itemAttributes == null ) {
            return null;
        }

        T object = privateMarshallIntoObject(
                converter,
                toParameters(itemAttributes, clazz, tableName, config));

        return object;
    }


    /**
     * Returns a key map for the key object given.
     *
     * @param keyObject
     *            The key object, corresponding to an item in a dynamo table.
     */
    @SuppressWarnings("unchecked")
    private <T> Map<String, AttributeValue> getKey(
            ItemConverter converter,
            T keyObject) {

        return getKey(converter, keyObject, (Class<T>) keyObject.getClass());
    }

    private <T> Map<String, AttributeValue> getKey(
            ItemConverter converter,
            T keyObject,
            Class<T> clazz) {

        Map<String, AttributeValue> key = new HashMap<String, AttributeValue>();
        for (Method keyGetter : reflector.getPrimaryKeyGetters(clazz)) {
            Object getterResult =
                    ReflectionUtils.safeInvoke(keyGetter, keyObject);

            AttributeValue keyAttributeValue =
                    converter.convert(keyGetter, getterResult);

            if (keyAttributeValue == null) {
                throw new DynamoDBMappingException(
                        "Null key found for " + keyGetter);
            }

            key.put(reflector.getAttributeName(keyGetter), keyAttributeValue);
        }

        if (key.isEmpty()) {
            throw new DynamoDBMappingException(
                    "Class must be annotated with " + DynamoDBHashKey.class
                    + " and " + DynamoDBRangeKey.class);
        }

        return key;
    }


    /**
     * Returns an object with the given hash key, or null if no such object
     * exists.
     *
     * @param clazz
     *            The class to load, corresponding to a DynamoDB table.
     * @param hashKey
     *            The key of the object.
     * @param rangeKey
     *            The range key of the object, or null for tables without a
     *            range key.
     * @param config
     *            Configuration for the service call to retrieve the object from
     *            DynamoDB. This configuration overrides the default given at
     *            construction.
     */
    public <T extends Object> T load(Class<T> clazz, Object hashKey, Object rangeKey, DynamoDBMapperConfig config) {
        config = mergeConfig(config);
        T keyObject = createKeyObject(clazz, hashKey, rangeKey);
        return load(keyObject, config);
    }

    /**
     * Creates a key prototype object for the class given with the single hash and range key given.
     */
    private <T> T createKeyObject(Class<T> clazz, Object hashKey, Object rangeKey) {
        T keyObject = null;
        try {
            keyObject = clazz.newInstance();
        } catch ( Exception e ) {
            throw new DynamoDBMappingException("Failed to instantiate class", e);
        }
        boolean seenHashKey = false;
        boolean seenRangeKey = false;
        for ( Method getter : reflector.getPrimaryKeyGetters(clazz) ) {
            if ( ReflectionUtils.getterOrFieldHasAnnotation(getter, DynamoDBHashKey.class) ) {
                if ( seenHashKey ) {
                    throw new DynamoDBMappingException("Found more than one method annotated with "
                            + DynamoDBHashKey.class + " for class " + clazz
                            + ". Use load(Object) for tables with more than a single hash and range key.");
                }
                seenHashKey = true;
                ReflectionUtils.safeInvoke(reflector.getSetter(getter), keyObject, hashKey);
            } else if ( ReflectionUtils.getterOrFieldHasAnnotation(getter, DynamoDBRangeKey.class) ) {
                if ( seenRangeKey ) {
                    throw new DynamoDBMappingException("Found more than one method annotated with "
                            + DynamoDBRangeKey.class + " for class " + clazz
                            + ". Use load(Object) for tables with more than a single hash and range key.");
                }
                seenRangeKey = true;
                ReflectionUtils.safeInvoke(reflector.getSetter(getter), keyObject, rangeKey);
            }
        }
        if ( !seenHashKey ) {
            throw new DynamoDBMappingException("No method annotated with " + DynamoDBHashKey.class + " for class "
                    + clazz + ".");
        } else if ( rangeKey != null && !seenRangeKey ) {
            throw new DynamoDBMappingException("No method annotated with " + DynamoDBRangeKey.class + " for class "
                    + clazz + ".");
        }
        return keyObject;
    }

    /**
     * Returns a map of attribute name to EQ condition for the key prototype
     * object given. This method considers attributes annotated with either
     * {@link DynamoDBHashKey} or {@link DynamoDBIndexHashKey}.
     *
     * @param obj
     *            The prototype object that includes the hash key value.
     * @return A map of hash key attribute name to EQ condition for the key
     *         prototype object, or an empty map if obj is null.
     */
    private Map<String, Condition> getHashKeyEqualsConditions(
            ItemConverter converter,
            Object obj) {

        Map<String, Condition> conditions = new HashMap<String, Condition>();
        if (obj == null) {
            return conditions;
        }

        for (Method getter : reflector.getRelevantGetters(obj.getClass())) {
            if (ReflectionUtils.getterOrFieldHasAnnotation(
                    getter, DynamoDBHashKey.class)
             || ReflectionUtils.getterOrFieldHasAnnotation(
                     getter, DynamoDBIndexHashKey.class) ) {

                Object getterReturnResult =
                        ReflectionUtils.safeInvoke(getter, obj);

                if (getterReturnResult != null) {
                    conditions.put(
                        reflector.getAttributeName(getter),
                        new Condition()
                            .withComparisonOperator(ComparisonOperator.EQ)
                            .withAttributeValueList(
                                converter.convert(getter, getterReturnResult)));
                }
            }
        }

        return conditions;
    }

    /**
     * Returns the table name for the class given.
     */
    protected final String getTableName(final Class<?> clazz,
                                        final DynamoDBMapperConfig config) {

        return internalGetTableName(clazz, null, config);
    }

    /**
     * Returns the table name for the class or object given.
     */
    protected final String getTableName(final Class<?> clazz,
                                        final Object object,
                                        final DynamoDBMapperConfig config) {

        return internalGetTableName(clazz, object, config);
    }

    static String internalGetTableName(final Class<?> clazz,
                                       final Object object,
                                       final DynamoDBMapperConfig config) {

        // Resolve by object, if possible and desired
        DynamoDBMapperConfig.ObjectTableNameResolver objectResolver = config.getObjectTableNameResolver();
        if (object != null && objectResolver != null) {
            return objectResolver.getTableName(object, config);
        }

        // Resolve by class
        DynamoDBMapperConfig.TableNameResolver classResolver = config.getTableNameResolver();
        if (classResolver == null) {
            classResolver = DynamoDBMapperConfig.DefaultTableNameResolver.INSTANCE;
        }
        return classResolver.getTableName(clazz, config);
    }

    /**
     * Creates and fills in the attributes on an instance of the class given
     * with the attributes given.
     * <p>
     * This is accomplished by looking for getter methods annotated with an
     * appropriate annotation, then looking for matching attribute names in the
     * item attribute map.
     * <p>
     * This method is no longer called by load/scan/query methods. If you are
     * overriding this method, please switch to using an AttributeTransformer
     *
     * @param clazz
     *            The class to instantiate and hydrate
     * @param itemAttributes
     *            The set of item attributes, keyed by attribute name.
     */
    public <T> T marshallIntoObject(
            Class<T> clazz,
            Map<String, AttributeValue> itemAttributes) {

        ItemConverter converter = getConverter(config);

        String tableName = getTableName(clazz, config);

        return privateMarshallIntoObject(
                converter,
                toParameters(itemAttributes, clazz, tableName, config));
    }

    /**
     * The one true implementation of marshallIntoObject.
     */
    private <T> T privateMarshallIntoObject(
            ItemConverter converter,
            AttributeTransformer.Parameters<T> parameters) {

        Class<T> clazz = parameters.getModelClass();
        Map<String, AttributeValue> values = untransformAttributes(parameters);

        return converter.unconvert(clazz, values);
    }

    /**
     * Unmarshalls the list of item attributes into objects of type clazz.
     * <p>
     * This method is no longer called by load/scan/query methods. If you are
     * overriding this method, please switch to using an AttributeTransformer
     *
     * @see DynamoDBMapper#marshallIntoObject(Class, Map)
     */
    public <T> List<T> marshallIntoObjects(Class<T> clazz, List<Map<String, AttributeValue>> itemAttributes) {
        List<T> result = new ArrayList<T>(itemAttributes.size());
        for (Map<String, AttributeValue> item : itemAttributes) {
            result.add(marshallIntoObject(clazz, item));
        }
        return result;
    }

    /**
     * A replacement for {@link #marshallIntoObjects(Class, List)} that takes
     * an extra set of parameters to be tunneled through to
     * {@code privateMarshalIntoObject} (if nothing along the way is
     * overridden). It's package-private because some of the Paginated*List
     * classes call back into it, but final because no one, even in this
     * package, should ever override it.
     */
    final <T> List<T> marshallIntoObjects(
            final List<AttributeTransformer.Parameters<T>> parameters
    ) {
        List<T> result = new ArrayList<T>(parameters.size());

        ItemConverter converter = null;
        if (!parameters.isEmpty()) {
            converter = getConverter(parameters.get(0).getMapperConfig());
        }

        for (AttributeTransformer.Parameters<T> entry : parameters) {
            result.add(privateMarshallIntoObject(converter, entry));
        }

        return result;
    }

    /**
     * Saves the object given into DynamoDB, using the default configuration.
     *
     * @see DynamoDBMapper#save(Object, DynamoDBSaveExpression, DynamoDBMapperConfig)
     */
    public <T extends Object> void save(T object) {
        save(object, null, config);
    }

    /**
     * Saves the object given into DynamoDB, using the default configuration and the specified saveExpression.
     *
     * @see DynamoDBMapper#save(Object, DynamoDBSaveExpression, DynamoDBMapperConfig)
     */
    public <T extends Object> void save(T object, DynamoDBSaveExpression saveExpression) {
        save(object, saveExpression, config);
    }

    private boolean needAutoGenerateAssignableKey(Class<?> clazz, Object object) {
        Collection<Method> keyGetters = reflector.getPrimaryKeyGetters(clazz);
        boolean forcePut = false;
        /*
         * Determine if there are any auto-assigned keys to assign. If so, force
         * a put and assign the keys.
         */
        boolean hashKeyGetterFound = false;
        for ( Method method : keyGetters ) {
            Object getterResult = ReflectionUtils.safeInvoke(method, object);
            if ( getterResult == null && reflector.isAssignableKey(method) ) {
                forcePut = true;
            }
            if ( ReflectionUtils.getterOrFieldHasAnnotation(method, DynamoDBHashKey.class) ) {
                hashKeyGetterFound = true;
            }
        }
        if ( !hashKeyGetterFound ) {
            throw new DynamoDBMappingException("No " + DynamoDBHashKey.class + " annotation found in class " + clazz);
        }
        return forcePut;
    }

    /**
     * Saves the object given into DynamoDB, using the specified configuration.
     *
     * @see DynamoDBMapper#save(Object, DynamoDBSaveExpression, DynamoDBMapperConfig)
     */
    public <T extends Object> void save(T object, DynamoDBMapperConfig config) {
        save(object, null, config);
    }

    /**
     * Saves an item in DynamoDB. The service method used is determined by the
     * {@link DynamoDBMapperConfig#getSaveBehavior()} value, to use either
     * {@link AmazonDynamoDB#putItem(PutItemRequest)} or
     * {@link AmazonDynamoDB#updateItem(UpdateItemRequest)}:
     * <ul>
     * <li><b>UPDATE</b> (default) : UPDATE will not affect unmodeled attributes
     * on a save operation and a null value for the modeled attribute will
     * remove it from that item in DynamoDB. Because of the limitation of
     * updateItem request, the implementation of UPDATE will send a putItem
     * request when a key-only object is being saved, and it will send another
     * updateItem request if the given key(s) already exists in the table.</li>
     * <li><b>UPDATE_SKIP_NULL_ATTRIBUTES</b> : Similar to UPDATE except that it
     * ignores any null value attribute(s) and will NOT remove them from that
     * item in DynamoDB. It also guarantees to send only one single updateItem
     * request, no matter the object is key-only or not.</li>
     * <li><b>CLOBBER</b> : CLOBBER will clear and replace all attributes,
     * included unmodeled ones, (delete and recreate) on save. Versioned field
     * constraints will also be disregarded.</li>
     * </ul>
     *
     *
     * Any options specified in the saveExpression parameter will be overlaid on
     * any constraints due to versioned attributes.
     *
     * @param object
     *            The object to save into DynamoDB
     * @param saveExpression
     *            The options to apply to this save request
     * @param config
     *            The configuration to use, which overrides the default provided
     *            at object construction.
     *
     * @see DynamoDBMapperConfig.SaveBehavior
     */
    public <T extends Object> void save(T object, DynamoDBSaveExpression saveExpression, final DynamoDBMapperConfig config) {
        final DynamoDBMapperConfig finalConfig = mergeConfig(config);
        final ItemConverter converter = getConverter(finalConfig);

        @SuppressWarnings("unchecked")
        Class<? extends T> clazz = (Class<? extends T>) object.getClass();
        String tableName = getTableName(clazz, object, finalConfig);

        /*
         * We force a putItem request instead of updateItem request either when
         * CLOBBER is configured, or part of the primary key of the object needs
         * to be auto-generated.
         */
        boolean forcePut = (finalConfig.getSaveBehavior() == SaveBehavior.CLOBBER)
                || needAutoGenerateAssignableKey(clazz, object);

        SaveObjectHandler saveObjectHandler;

        if (forcePut) {
            saveObjectHandler = this.new SaveObjectHandler(clazz, object,
                    tableName, finalConfig, converter, saveExpression) {

                @Override
                protected void onPrimaryKeyAttributeValue(String attributeName,
                        AttributeValue keyAttributeValue) {
                    /* Treat key values as common attribute value updates. */
                    getAttributeValueUpdates().put(attributeName,
                            new AttributeValueUpdate().withValue(keyAttributeValue)
                                    .withAction("PUT"));
                }

                /* Use default implementation of onNonKeyAttribute(...) */

                @Override
                protected void onNullNonKeyAttribute(String attributeName) {
                    /* When doing a force put, we can safely ignore the null-valued attributes. */
                    return;
                }

                @Override
                protected void executeLowLevelRequest() {
                    /* Send a putItem request */
                    doPutItem();
                }
            };
        } else {
            saveObjectHandler = this.new SaveObjectHandler(clazz, object,
                    tableName, finalConfig, converter, saveExpression) {

                @Override
                protected void onPrimaryKeyAttributeValue(String attributeName,
                        AttributeValue keyAttributeValue) {
                    /* Put it in the key collection which is later used in the updateItem request. */
                    getPrimaryKeyAttributeValues().put(attributeName, keyAttributeValue);
                }


                @Override
                protected void onNonKeyAttribute(String attributeName,
                        AttributeValue currentValue) {
                    /* If it's a set attribute and the mapper is configured with APPEND_SET,
                     * we do an "ADD" update instead of the default "PUT".
                     */
                    if (getLocalSaveBehavior() == SaveBehavior.APPEND_SET) {
                        if (currentValue.getBS() != null
                                || currentValue.getNS() != null
                                || currentValue.getSS() != null) {
                            getAttributeValueUpdates().put(
                                    attributeName,
                                    new AttributeValueUpdate().withValue(
                                            currentValue).withAction("ADD"));
                            return;
                        }
                    }
                    /* Otherwise, we do the default "PUT" update. */
                    super.onNonKeyAttribute(attributeName, currentValue);
                }

                @Override
                protected void onNullNonKeyAttribute(String attributeName) {
                    /*
                     * If UPDATE_SKIP_NULL_ATTRIBUTES or APPEND_SET is
                     * configured, we don't delete null value attributes.
                     */
                    if (getLocalSaveBehavior() == SaveBehavior.UPDATE_SKIP_NULL_ATTRIBUTES
                            || getLocalSaveBehavior() == SaveBehavior.APPEND_SET) {
                        return;
                    }

                    else {
                        /* Delete attributes that are set as null in the object. */
                        getAttributeValueUpdates()
                                .put(attributeName,
                                        new AttributeValueUpdate()
                                                .withAction("DELETE"));
                    }
                }

                @Override
                protected void executeLowLevelRequest() {
                    UpdateItemResult updateItemResult = doUpdateItem();

                    // The UpdateItem request is specified to return ALL_NEW
                    // attributes of the affected item. So if the returned
                    // UpdateItemResult does not include any ReturnedAttributes,
                    // it indicates the UpdateItem failed silently (e.g. the
                    // key-only-put nightmare -
                    // https://forums.aws.amazon.com/thread.jspa?threadID=86798&tstart=25),
                    // in which case we should re-send a PutItem
                    // request instead.
                    if (updateItemResult.getAttributes() == null
                            || updateItemResult.getAttributes().isEmpty()) {
                        // Before we proceed with PutItem, we need to put all
                        // the key attributes (prepared for the
                        // UpdateItemRequest) into the AttributeValueUpdates
                        // collection.
                        for (String keyAttributeName : getPrimaryKeyAttributeValues().keySet()) {
                            getAttributeValueUpdates().put(keyAttributeName,
                                    new AttributeValueUpdate()
                                            .withValue(getPrimaryKeyAttributeValues().get(keyAttributeName))
                                            .withAction("PUT"));
                        }

                        doPutItem();
                    }
                }
            };
        }

        saveObjectHandler.execute();
    }

    /**
     * The handler for saving object using DynamoDBMapper. Caller should
     * implement the abstract methods to provide the expected behavior on each
     * scenario, and this handler will take care of all the other basic workflow
     * and common operations.
     */
    protected abstract class SaveObjectHandler {

        protected final Object object;
        protected final Class<?> clazz;
        private final String tableName;
        private final DynamoDBMapperConfig saveConfig;
        private final ItemConverter converter;

        private final Map<String, AttributeValue> primaryKeys;
        private final Map<String, AttributeValueUpdate> updateValues;

        /**
         * Any expected value conditions specified by the implementation of
         * DynamoDBMapper, e.g. value assertions on versioned attributes.
         */
        private final Map<String, ExpectedAttributeValue> internalExpectedValueAssertions;

        /**
         * Additional expected value conditions specified by the user.
         */
        protected final Map<String, ExpectedAttributeValue> userProvidedExpectedValueConditions;

        /**
         * Condition operator on the additional expected value conditions
         * specified by the user.
         */
        protected final String userProvidedConditionOperator;

        private final List<ValueUpdate> inMemoryUpdates;

        /**
         * Constructs a handler for saving the specified model object.
         *
         * @param object            The model object to be saved.
         * @param clazz             The domain class of the object.
         * @param tableName         The table name.
         * @param saveConifg        The mapper configuration used for this save.
         * @param saveExpression    The save expression, including the user-provided conditions and an optional logic operator.
         */
        public SaveObjectHandler(
                Class<?> clazz,
                Object object,
                String tableName,
                DynamoDBMapperConfig saveConfig,
                ItemConverter converter,
                DynamoDBSaveExpression saveExpression) {

            this.clazz = clazz;
            this.object = object;
            this.tableName = tableName;
            this.saveConfig = saveConfig;
            this.converter = converter;

            if (saveExpression != null) {
                userProvidedExpectedValueConditions = saveExpression
                        .getExpected();
                userProvidedConditionOperator = saveExpression
                        .getConditionalOperator();
            } else {
                userProvidedExpectedValueConditions = null;
                userProvidedConditionOperator = null;
            }

            updateValues = new HashMap<String, AttributeValueUpdate>();
            internalExpectedValueAssertions = new HashMap<String, ExpectedAttributeValue>();
            inMemoryUpdates = new LinkedList<ValueUpdate>();
            primaryKeys = new HashMap<String, AttributeValue>();
        }

        /**
         * The general workflow of a save operation.
         */
        public void execute() {
            Collection<Method> primaryKeyGetters = reflector.getPrimaryKeyGetters(clazz);

            /*
             * First handle primary keys
             */
            for ( Method method : primaryKeyGetters ) {
                Object getterResult = ReflectionUtils.safeInvoke(method, object);
                String attributeName = reflector.getAttributeName(method);

                if ( getterResult == null && reflector.isAssignableKey(method) ) {
                    onAutoGenerateAssignableKey(method, attributeName);

                } else {
                    AttributeValue newAttributeValue = converter.convert(method, getterResult);
                    if ( newAttributeValue == null ) {
                        throw new DynamoDBMappingException(
                                "Null or empty value for primary key: " + method);
                    }

                    if ( newAttributeValue.getS() == null
                            && newAttributeValue.getN() == null
                            && newAttributeValue.getB() == null) {

                        throw new DynamoDBMappingException(
                                "Keys must be scalar values (String, Number, "
                                + "or Binary). Got " + newAttributeValue
                                + " for key " + method);
                    }

                    onPrimaryKeyAttributeValue(attributeName, newAttributeValue);
                }
            }

            /*
             * Next construct an update for every non-key property
             */
            for ( Method method : reflector.getRelevantGetters(clazz) ) {

                // Skip any key methods, since they are handled separately
                if ( primaryKeyGetters.contains(method) ) {
                    continue;
                }

                Object getterResult = ReflectionUtils.safeInvoke(method, object);
                String attributeName = reflector.getAttributeName(method);

                if ( getterResult == null && reflector.isAssignableKey(method) ) {
                    /*
                     * There still might be index keys that need to be auto-generated
                     */
                    onAutoGenerateAssignableKey(method, attributeName);
                } else if ( reflector.isVersionAttributeGetter(method) ) {
                    /*
                     * If this is a versioned field, update it
                     */
                    onVersionAttribute(method, getterResult, attributeName);
                } else {
                    /*
                     * Otherwise apply the update value for this attribute.
                     */
                    AttributeValue currentValue = converter.convert(method, getterResult);
                    if ( currentValue != null ) {
                        onNonKeyAttribute(attributeName, currentValue);
                    } else {
                        onNullNonKeyAttribute(attributeName);
                    }
                }
            }

            /*
             * Execute the implementation of the low level request.
             */
            executeLowLevelRequest();

            /*
             * Finally, after the service call has succeeded, update the
             * in-memory object with new field values as appropriate. This
             * currently takes into account of auto-generated keys and versioned
             * attributes.
             */
            for ( ValueUpdate update : inMemoryUpdates ) {
                update.apply();
            }
        }

        /**
         * Implement this method to do the necessary operations when a primary key
         * attribute is set with some value.
         *
         * @param attributeName
         *            The name of the primary key attribute.
         * @param keyAttributeValue
         *            The AttributeValue of the primary key attribute as specified in
         *            the object.
         */
        protected abstract void onPrimaryKeyAttributeValue(String attributeName, AttributeValue keyAttributeValue);

        /**
         * Implement this method for necessary operations when a non-key
         * attribute is set a non-null value in the object.
         * The default implementation simply adds a "PUT" update for the given attribute.
         *
         * @param attributeName
         *            The name of the non-key attribute.
         * @param currentValue
         *            The updated value of the given attribute.
         */
        protected void onNonKeyAttribute(String attributeName, AttributeValue currentValue) {
            updateValues.put(attributeName, new AttributeValueUpdate()
                    .withValue(currentValue).withAction("PUT"));
        }

        /**
         * Implement this method for necessary operations when a non-key
         * attribute is set null in the object.
         *
         * @param attributeName
         *            The name of the non-key attribute.
         */
        protected abstract void onNullNonKeyAttribute(String attributeName);

        /**
         * Implement this method to send the low-level request that is necessary
         * to complete the save operation.
         */
        protected abstract void executeLowLevelRequest();

        /** Get the SaveBehavior used locally for this save operation. **/
        protected SaveBehavior getLocalSaveBehavior() {
            return saveConfig.getSaveBehavior();
        }

        /** Get the table name **/
        protected String getTableName() {
            return tableName;
        }

        /** Get the map of all the specified primamry keys of the saved object. **/
        protected Map<String, AttributeValue> getPrimaryKeyAttributeValues() {
            return primaryKeys;
        }

        /** Get the map of AttributeValueUpdate on each modeled attribute. **/
        protected Map<String, AttributeValueUpdate> getAttributeValueUpdates() {
            return updateValues;
        }

        /**
         * Merge and return all the expected value conditions (either
         * user-specified or imposed by the internal implementation of
         * DynamoDBMapper) for this save operation.
         */
        protected Map<String, ExpectedAttributeValue> mergeExpectedAttributeValueConditions() {
            return DynamoDBMapper.mergeExpectedAttributeValueConditions(
                    internalExpectedValueAssertions,
                    userProvidedExpectedValueConditions,
                    userProvidedConditionOperator);
        }

        /** Get the list of all the necessary in-memory update on the object. **/
        protected List<ValueUpdate> getInMemoryUpdates() {
            return inMemoryUpdates;
        }

        /**
         * Save the item using a UpdateItem request. The handler will call this
         * method if
         * <ul>
         * <li>CLOBBER configuration is not being used;
         * <li>AND the item does not contain auto-generated key value;
         * </ul>
         * <p>
         * The ReturnedValues parameter for the UpdateItem request is set as
         * ALL_NEW, which means the service should return all of the attributes
         * of the new version of the item after the update. The handler will use
         * the returned attributes to detect silent failure on the server-side.
         */
        protected UpdateItemResult doUpdateItem() {
            UpdateItemRequest req = new UpdateItemRequest()
                    .withTableName(getTableName())
                    .withKey(getPrimaryKeyAttributeValues())
                    .withAttributeUpdates(
                            transformAttributeUpdates(
                                    this.clazz,
                                    getTableName(),
                                    getPrimaryKeyAttributeValues(),
                                    getAttributeValueUpdates(),
                                    saveConfig))
                    .withExpected(mergeExpectedAttributeValueConditions())
                    .withConditionalOperator(userProvidedConditionOperator)
                    .withReturnValues(ReturnValue.ALL_NEW)
                    .withRequestMetricCollector(saveConfig.getRequestMetricCollector());

            return db.updateItem(applyUserAgent(req));
        }

        /**
         * Save the item using a PutItem request. The handler will call this
         * method if
         * <ul>
         *  <li> CLOBBER configuration is being used;
         *  <li> OR the item contains auto-generated key value;
         *  <li> OR an UpdateItem request has silently failed (200 response with
         *          no affected attribute), which indicates the key-only-put scenario
         *          that we used to handle by the keyOnlyPut(...) hack.
         * </ul>
         */
        protected PutItemResult doPutItem() {
            Map<String, AttributeValue> attributeValues = convertToItem(getAttributeValueUpdates());

            attributeValues = transformAttributes(
                    toParameters(attributeValues,
                                 this.clazz,
                                 getTableName(),
                                 saveConfig));
            PutItemRequest req = new PutItemRequest()
                    .withTableName(getTableName())
                    .withItem(attributeValues)
                    .withExpected(mergeExpectedAttributeValueConditions())
                    .withConditionalOperator(userProvidedConditionOperator)
                    .withRequestMetricCollector(saveConfig.getRequestMetricCollector());

            return db.putItem(applyUserAgent(req));
        }

        private void onAutoGenerateAssignableKey(Method method, String attributeName) {
            AttributeValue newVersionValue = getAutoGeneratedKeyAttributeValue(converter, method);

            updateValues.put(attributeName,
                    new AttributeValueUpdate().withAction("PUT").withValue(newVersionValue));
            inMemoryUpdates.add(new ValueUpdate(method, newVersionValue, object, converter));

            if ( getLocalSaveBehavior() != SaveBehavior.CLOBBER
                    && !internalExpectedValueAssertions.containsKey(attributeName)) {
                // Add an expect clause to make sure that the item
                // doesn't already exist, since it's supposed to be new
                ExpectedAttributeValue expected = new ExpectedAttributeValue();
                expected.setExists(false);
                internalExpectedValueAssertions.put(attributeName, expected);
            }
        }

        private void onVersionAttribute(Method method, Object getterResult,
                String attributeName) {
            if ( getLocalSaveBehavior() != SaveBehavior.CLOBBER
                    && !internalExpectedValueAssertions.containsKey(attributeName)) {
                // First establish the expected (current) value for the
                // update call
                ExpectedAttributeValue expected = new ExpectedAttributeValue();

                // For new objects, insist that the value doesn't exist.
                // For existing ones, insist it has the old value.
                AttributeValue currentValue = converter.convert(method, getterResult);
                expected.setExists(currentValue != null);
                if ( currentValue != null ) {
                    expected.setValue(currentValue);
                }
                internalExpectedValueAssertions.put(attributeName, expected);
            }

            Object newVersion = incrementor.increment(method, getterResult);
            AttributeValue newVersionValue = converter.convert(method, newVersion);
            updateValues.put(attributeName, new AttributeValueUpdate()
                        .withAction("PUT")
                        .withValue(newVersionValue));

            inMemoryUpdates.add(new ValueUpdate(method, newVersionValue, object, converter));
        }
    }

    /**
     * Deletes the given object from its DynamoDB table using the default configuration.
     */
    public void delete(Object object) {
        delete(object, null, this.config);
    }

    /**
     * Deletes the given object from its DynamoDB table using the specified deleteExpression and default configuration.
     */
    public void delete(Object object, DynamoDBDeleteExpression deleteExpression) {
        delete(object, deleteExpression, this.config);
    }

    /**
     * Deletes the given object from its DynamoDB table using the specified configuration.
     */
    public void delete(Object object, DynamoDBMapperConfig config) {
        delete(object, null, config);
    }

    /**
     * Deletes the given object from its DynamoDB table using the provided deleteExpression and provided configuration.
     * Any options specified in the deleteExpression parameter will be overlaid on any constraints due to
     * versioned attributes.
     * @param deleteExpression
     *            The options to apply to this delete request
     * @param config
     *            Config override object. If {@link SaveBehavior#CLOBBER} is
     *            supplied, version fields will not be considered when deleting
     *            the object.
     */
    public <T> void delete(T object, DynamoDBDeleteExpression deleteExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);
        ItemConverter converter = getConverter(config);

        @SuppressWarnings("unchecked")
        Class<T> clazz = (Class<T>) object.getClass();

        String tableName = getTableName(clazz, object, config);

        Map<String, AttributeValue> key = getKey(converter, object, clazz);

        /*
         * If there is a version field, make sure we assert its value. If the
         * version field is null (only should happen in unusual circumstances),
         * pretend it doesn't have a version field after all.
         */
        Map<String, ExpectedAttributeValue> internalAssertions = new HashMap<String, ExpectedAttributeValue>();
        if ( config.getSaveBehavior() != SaveBehavior.CLOBBER ) {
            for ( Method method : reflector.getRelevantGetters(clazz) ) {

                if ( reflector.isVersionAttributeGetter(method) ) {
                    Object getterResult = ReflectionUtils.safeInvoke(method, object);
                    String attributeName = reflector.getAttributeName(method);

                    ExpectedAttributeValue expected = new ExpectedAttributeValue();
                    AttributeValue currentValue = converter.convert(method, getterResult);
                    expected.setExists(currentValue != null);
                    if ( currentValue != null )
                        expected.setValue(currentValue);
                    internalAssertions.put(attributeName, expected);
                    break;
                }
            }
        }

        DeleteItemRequest req = new DeleteItemRequest().withKey(key)
                .withTableName(tableName).withExpected(internalAssertions)
                .withRequestMetricCollector(config.getRequestMetricCollector());

        if (deleteExpression != null) {
            String conditionalExpression = deleteExpression.getConditionExpression();

            if (conditionalExpression != null) {
                if (internalAssertions != null && !internalAssertions.isEmpty()) {
                    throw new AmazonClientException(
                            "Condition Expressions cannot be used if a versioned attribute is present");
                }

                req = req
                        .withConditionExpression(conditionalExpression)
                        .withExpressionAttributeNames(
                                deleteExpression.getExpressionAttributeNames())
                        .withExpressionAttributeValues(
                                deleteExpression.getExpressionAttributeValues());
            }

            req = req.withExpected(
                    mergeExpectedAttributeValueConditions(internalAssertions,
                            deleteExpression.getExpected(),
                            deleteExpression.getConditionalOperator()))
                    .withConditionalOperator(
                            deleteExpression.getConditionalOperator());

        }
        db.deleteItem(applyUserAgent(req));
    }

    /**
     * Deletes the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API. <b>No
     * version checks are performed</b>, as required by the API.
     *
     * @see DynamoDBMapper#batchWrite(List, List, DynamoDBMapperConfig)
     */
    public List<FailedBatch> batchDelete(List<? extends Object> objectsToDelete) {
        return batchWrite(Collections.emptyList(), objectsToDelete, this.config);
    }

    /**
     * Deletes the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API. <b>No
     * version checks are performed</b>, as required by the API.
     *
     * @see DynamoDBMapper#batchWrite(List, List, DynamoDBMapperConfig)
     */
    public List<FailedBatch> batchDelete(Object... objectsToDelete) {
        return batchWrite(Collections.emptyList(), Arrays.asList(objectsToDelete), this.config);
    }

    /**
     * Saves the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API. <b>No
     * version checks are performed</b>, as required by the API.
     * <p/>
     * <b>This method ignores any SaveBehavior set on the mapper</b>, and always
     * behaves as if SaveBehavior.CLOBBER was specified, as the
     * AmazonDynamoDB.batchWriteItem() request does not support updating
     * existing items.
     * <p>
     * This method fails to save the batch if the size of an individual object
     * in the batch exceeds 400 KB. For more information on batch restrictions
     * see, http://docs.aws.amazon
     * .com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     * </p>
     *
     * @see DynamoDBMapper#batchWrite(List, List, DynamoDBMapperConfig)
     */
    public List<FailedBatch> batchSave(List<? extends Object> objectsToSave) {
        return batchWrite(objectsToSave, Collections.emptyList(), this.config);
    }

    /**
     * Saves the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API. <b>No
     * version checks are performed</b>, as required by the API.
     * <p/>
     * <b>This method ignores any SaveBehavior set on the mapper</b>, and always
     * behaves as if SaveBehavior.CLOBBER was specified, as the
     * AmazonDynamoDB.batchWriteItem() request does not support updating
     * existing items. *
     * <p>
     * This method fails to save the batch if the size of an individual object
     * in the batch exceeds 400 KB. For more information on batch restrictions
     * see, http://docs.aws.amazon
     * .com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     * </p>
     *
     * @see DynamoDBMapper#batchWrite(List, List, DynamoDBMapperConfig)
     */
    public List<FailedBatch> batchSave(Object... objectsToSave) {
        return batchWrite(Arrays.asList(objectsToSave), Collections.emptyList(), this.config);
    }

    /**
     * Saves and deletes the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API. <b>No
     * version checks are performed</b>, as required by the API.
     * <p/>
     * <b>This method ignores any SaveBehavior set on the mapper</b>, and always
     * behaves as if SaveBehavior.CLOBBER was specified, as the
     * AmazonDynamoDB.batchWriteItem() request does not support updating
     * existing items.
     * <p>
     * This method fails to save the batch if the size of an individual object
     * in the batch exceeds 400 KB. For more information on batch restrictions
     * see, http://docs.aws.amazon
     * .com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     * </p>
     *
     * @see DynamoDBMapper#batchWrite(List, List, DynamoDBMapperConfig)
     */
    public List<FailedBatch> batchWrite(List<? extends Object> objectsToWrite, List<? extends Object> objectsToDelete) {
        return batchWrite(objectsToWrite, objectsToDelete, this.config);
    }

    /**
     * Saves and deletes the objects given using one or more calls to the
     * {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)} API.
     * <p>
     * This method fails to save the batch if the size of an individual object
     * in the batch exceeds 400 KB. For more information on batch restrictions
     * see, http://docs.aws.amazon
     * .com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
     * </p>
     *
     * @param objectsToWrite
     *            A list of objects to save to DynamoDB. <b>No version checks
     *            are performed</b>, as required by the
     *            {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)}
     *            API.
     * @param objectsToDelete
     *            A list of objects to delete from DynamoDB. <b>No version
     *            checks are performed</b>, as required by the
     *            {@link AmazonDynamoDB#batchWriteItem(BatchWriteItemRequest)}
     *            API.
     * @param config
     *            Only {@link DynamoDBMapperConfig#getTableNameOverride()} is
     *            considered; if specified, all objects in the two parameter
     *            lists will be considered to belong to the given table
     *            override. In particular, this method <b>always acts as if
     *            SaveBehavior.CLOBBER was specified</b> regardless of the value
     *            of the config parameter.
     * @return A list of failed batches which includes the unprocessed items and
     *         the exceptions causing the failure.
     */
    public List<FailedBatch> batchWrite(List<? extends Object> objectsToWrite, List<? extends Object> objectsToDelete, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        List<FailedBatch> totalFailedBatches = new LinkedList<FailedBatch>();

        HashMap<String, List<WriteRequest>> requestItems = new HashMap<String, List<WriteRequest>>();

        ItemConverter converter = getConverter(config);

        List<ValueUpdate> inMemoryUpdates = new LinkedList<ValueUpdate>();
        for ( Object toWrite : objectsToWrite ) {
            Class<?> clazz = toWrite.getClass();
            String tableName = getTableName(clazz, toWrite, config);

            Map<String, AttributeValue> attributeValues = new HashMap<String, AttributeValue>();

            // Look at every getter and construct a value object for it
            for ( Method method : reflector.getRelevantGetters(clazz) ) {
                Object getterResult =
                        ReflectionUtils.safeInvoke(method, toWrite);

                String attributeName = reflector.getAttributeName(method);

                AttributeValue currentValue = null;
                if ( getterResult == null && reflector.isAssignableKey(method) ) {
                    currentValue = getAutoGeneratedKeyAttributeValue(converter, method);
                    inMemoryUpdates.add(new ValueUpdate(method, currentValue, toWrite, converter));
                } else {
                    currentValue = converter.convert(method, getterResult);
                }

                if ( currentValue != null ) {
                    attributeValues.put(attributeName, currentValue);
                }
            }

            if ( !requestItems.containsKey(tableName) ) {
                requestItems.put(tableName, new LinkedList<WriteRequest>());
            }

            AttributeTransformer.Parameters<?> parameters =
                toParameters(attributeValues, clazz, tableName, config);

            requestItems.get(tableName).add(
                new WriteRequest().withPutRequest(
                    new PutRequest().withItem(
                        transformAttributes(parameters))));
        }

        for ( Object toDelete : objectsToDelete ) {
            Class<?> clazz = toDelete.getClass();

            String tableName = getTableName(clazz, toDelete, config);

            Map<String, AttributeValue> key = getKey(converter, toDelete);

            if ( !requestItems.containsKey(tableName) ) {
                requestItems.put(tableName, new LinkedList<WriteRequest>());
            }

            requestItems.get(tableName).add(
                    new WriteRequest().withDeleteRequest(new DeleteRequest().withKey(key)));
        }

        // Break into chunks of 25 items and make service requests to DynamoDB
        while ( !requestItems.isEmpty() ) {

            HashMap<String, List<WriteRequest>> batch =
                    new HashMap<String, List<WriteRequest>>();

            int i = 0;

            Iterator<Entry<String, List<WriteRequest>>> tableIter = requestItems.entrySet().iterator();
            while ( tableIter.hasNext() && i < MAX_ITEMS_PER_BATCH ) {

                Entry<String, List<WriteRequest>> tableRequest = tableIter.next();

                batch.put(tableRequest.getKey(), new LinkedList<WriteRequest>());
                Iterator<WriteRequest> writeRequestIter = tableRequest.getValue().iterator();

                while ( writeRequestIter.hasNext() && i++ < MAX_ITEMS_PER_BATCH ) {
                    WriteRequest writeRequest = writeRequestIter.next();
                    batch.get(tableRequest.getKey()).add(writeRequest);
                    writeRequestIter.remove();
                }

                // If we've processed all the write requests for this table,
                // remove it from the parent iterator.
                if ( !writeRequestIter.hasNext() ) {
                    tableIter.remove();
                }
            }

            List<FailedBatch> failedBatches = writeOneBatch(batch);
            if (failedBatches != null) {
                totalFailedBatches.addAll(failedBatches);

                // If contains throttling exception, we do a backoff
                if (containsThrottlingException(failedBatches)) {
                    try {
                        Thread.sleep(1000 * 2);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new AmazonClientException(e.getMessage(), e);
                    }
                }
            }
        }



        // Once the entire batch is processed, update assigned keys in memory
        for ( ValueUpdate update : inMemoryUpdates ) {
            update.apply();
        }

        return totalFailedBatches;
    }

    /**
     * Process one batch of requests(max 25). It will divide the batch if
     * receives request too large exception(the total size of the request is beyond 1M).
     */
    private List<FailedBatch> writeOneBatch(Map<String, List<WriteRequest>> batch) {

        List<FailedBatch> failedBatches = new LinkedList<FailedBatch>();
        Map<String, List<WriteRequest>> firstHalfBatch = new HashMap<String, List<WriteRequest>>();
        Map<String, List<WriteRequest>> secondHalfBatch = new HashMap<String, List<WriteRequest>>();
        FailedBatch failedBatch = callUntilCompletion(batch);

        if (failedBatch != null) {
            // If the exception is request entity too large, we divide the batch
            // into smaller parts.

            if (failedBatch.getException() instanceof AmazonServiceException
            && RetryUtils.isRequestEntityTooLargeException((AmazonServiceException) failedBatch.getException())) {

                // If only one item left, the item size must beyond 64k, which
                // exceedes the limit.

                if (computeFailedBatchSize(failedBatch) == 1) {
                    failedBatches.add(failedBatch);
                } else {
                    divideBatch(batch, firstHalfBatch, secondHalfBatch);
                    failedBatches.addAll(writeOneBatch(firstHalfBatch));
                    failedBatches.addAll(writeOneBatch(secondHalfBatch));
                }

            } else {
                failedBatches.add(failedBatch);
            }

        }
        return failedBatches;
    }

    /**
     * Check whether there are throttling exception in the failed batches.
     */
    private boolean containsThrottlingException (List<FailedBatch> failedBatches) {
        for (FailedBatch failedBatch : failedBatches) {
           Exception e = failedBatch.getException();
            if (e instanceof AmazonServiceException
                    && RetryUtils.isThrottlingException((AmazonServiceException) e)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Divide the batch of objects to save into two smaller batches. Each contains half of the elements.
     */
    private void divideBatch(Map<String, List<WriteRequest>> batch, Map<String, List<WriteRequest>> firstHalfBatch, Map<String, List<WriteRequest>> secondHalfBatch) {
        for (String key : batch.keySet()) {

            List<WriteRequest> requests = batch.get(key);

            List<WriteRequest> firstHalfRequests = requests.subList(0, requests.size() / 2);

            List<WriteRequest> secondHalfRequests = requests.subList(requests.size() / 2, requests.size());

            firstHalfBatch.put(key, firstHalfRequests);

            secondHalfBatch.put(key, secondHalfRequests);

        }

    }

    /**
     * Count the total number of unprocessed items in the failed batch.
     */

    private int computeFailedBatchSize(FailedBatch failedBatch) {

        int count = 0;

        for (String tableName : failedBatch.getUnprocessedItems().keySet()) {
            count += failedBatch.getUnprocessedItems().get(tableName).size();
        }
        return count;
    }

    /**
     * Continue trying to process the batch until it finishes or an exception
     * occurs.
     */

    private FailedBatch callUntilCompletion(Map<String, List<WriteRequest>> batch) {
        BatchWriteItemResult result = null;
        int retries = 0;
        FailedBatch failedBatch = null;
        while (true) {
            try {
                result = db.batchWriteItem(applyBatchOperationUserAgent(
                        new BatchWriteItemRequest().withRequestItems(batch)));
            } catch (Exception e) {
                failedBatch = new FailedBatch();
                failedBatch.setUnprocessedItems(batch);
                failedBatch.setException(e);
                return failedBatch;
            }
            retries++;
            batch = result.getUnprocessedItems();
            if (batch.size() > 0) {
                pauseExponentially(retries);
            } else {
                break;
            }
        }
        return failedBatch;
    }

    /**
     * Retrieves multiple items from multiple tables using their primary keys.
     *
     * @see DynamoDBMapper#batchLoad(List, DynamoDBMapperConfig)
     *
     * @return A map of the loaded objects. Each key in the map is the name of a
     *         DynamoDB table. Each value in the map is a list of objects that
     *         have been loaded from that table. All objects for each table can
     *         be cast to the associated user defined type that is annotated as
     *         mapping that table.
     */
    public Map<String, List<Object>> batchLoad(List<Object> itemsToGet) {
        return batchLoad(itemsToGet, this.config);
    }

    /**
     * Retrieves multiple items from multiple tables using their primary keys.
     *
     * @param itemsToGet
     *            Key objects, corresponding to the class to fetch, with their
     *            primary key values set.
     * @param config
     *            Only {@link DynamoDBMapperConfig#getTableNameOverride()} and
     *            {@link DynamoDBMapperConfig#getConsistentReads()} are
     *            considered.
     *
     * @return A map of the loaded objects. Each key in the map is the name of a
     *         DynamoDB table. Each value in the map is a list of objects that
     *         have been loaded from that table. All objects for each table can
     *         be cast to the associated user defined type that is annotated as
     *         mapping that table.
     */
    public Map<String, List<Object>> batchLoad(List<Object> itemsToGet, DynamoDBMapperConfig config) {
        config = mergeConfig(config);
        boolean consistentReads = (config.getConsistentReads() == ConsistentReads.CONSISTENT);

        if ( itemsToGet == null || itemsToGet.isEmpty() ) {
            return new HashMap<String, List<Object>>();
        }

        Map<String, KeysAndAttributes> requestItems = new HashMap<String, KeysAndAttributes>();
        Map<String, Class<?>> classesByTableName = new HashMap<String, Class<?>>();
        Map<String, List<Object>> resultSet = new HashMap<String, List<Object>>();
        int count = 0;

        ItemConverter converter = getConverter(config);

        for ( Object keyObject : itemsToGet ) {
            Class<?> clazz = keyObject.getClass();

            String tableName = getTableName(clazz, keyObject, config);
            classesByTableName.put(tableName, clazz);

            if ( !requestItems.containsKey(tableName) ) {
                requestItems.put(
                        tableName,
                        new KeysAndAttributes().withConsistentRead(consistentReads).withKeys(
                                new LinkedList<Map<String, AttributeValue>>()));
            }

            requestItems.get(tableName).getKeys().add(
                    getKey(converter, keyObject));

            // Reach the maximum number which can be handled in a single batchGet
            if ( ++count == 100 ) {
                processBatchGetRequest(classesByTableName, requestItems, resultSet, config, converter);
                requestItems.clear();
                count = 0;
            }
        }

        if ( count > 0 ) {
            processBatchGetRequest(classesByTableName, requestItems, resultSet, config, converter);
        }

        return resultSet;
    }

    /**
     * Retrieves the attributes for multiple items from multiple tables using
     * their primary keys.
     * {@link AmazonDynamoDB#batchGetItem(BatchGetItemRequest)} API.
     *
     * @return A map of the loaded objects. Each key in the map is the name of a
     *         DynamoDB table. Each value in the map is a list of objects that
     *         have been loaded from that table. All objects for each table can
     *         be cast to the associated user defined type that is annotated as
     *         mapping that table.
     *
     * @see #batchLoad(List, DynamoDBMapperConfig)
     * @see #batchLoad(Map, DynamoDBMapperConfig)
     */
    public Map<String, List<Object>> batchLoad(Map<Class<?>, List<KeyPair>> itemsToGet) {
        return batchLoad(itemsToGet, this.config);
    }

    /**
     * Retrieves multiple items from multiple tables using their primary keys.
     * Valid only for tables with a single hash key, or a single hash and range
     * key. For other schemas, use
     * {@link DynamoDBMapper#batchLoad(List, DynamoDBMapperConfig)}
     *
     * @param itemsToGet
     *            Map from class to load to list of primary key attributes.
     * @param config
     *            Only {@link DynamoDBMapperConfig#getTableNameOverride()} and
     *            {@link DynamoDBMapperConfig#getConsistentReads()} are
     *            considered.
     *
     * @return A map of the loaded objects. Each key in the map is the name of a
     *         DynamoDB table. Each value in the map is a list of objects that
     *         have been loaded from that table. All objects for each table can
     *         be cast to the associated user defined type that is annotated as
     *         mapping that table.
     */
    public Map<String, List<Object>> batchLoad(Map<Class<?>, List<KeyPair>> itemsToGet, DynamoDBMapperConfig config) {

        List<Object> keys = new ArrayList<Object>();
        if ( itemsToGet != null ) {
            for ( Class<?> clazz : itemsToGet.keySet() ) {
                if ( itemsToGet.get(clazz) != null ) {
                    for ( KeyPair keyPair : itemsToGet.get(clazz) ) {
                        keys.add(createKeyObject(clazz, keyPair.getHashKey(), keyPair.getRangeKey()));
                    }
                }
            }
        }

        return batchLoad(keys, config);
    }

    /**
     * @param config never null
     */
    private void processBatchGetRequest(
            final Map<String, Class<?>> classesByTableName,
            final Map<String, KeysAndAttributes> requestItems,
            final Map<String, List<Object>> resultSet,
            final DynamoDBMapperConfig config,
            final ItemConverter converter) {

        BatchGetItemResult batchGetItemResult = null;
        BatchGetItemRequest batchGetItemRequest = new BatchGetItemRequest()
            .withRequestMetricCollector(config.getRequestMetricCollector());
        batchGetItemRequest.setRequestItems(requestItems);

        int retries = 0;
        int noOfItemsInOriginalRequest = requestItems.size();

        do {
            if ( batchGetItemResult != null ) {
                retries++;

                if (noOfItemsInOriginalRequest == batchGetItemResult
                        .getUnprocessedKeys().size()){
                    pauseExponentially(retries);
                    if (retries > BATCH_GET_MAX_RETRY_COUNT_ALL_KEYS) {
                        throw new AmazonClientException(
                                "Batch Get Item request to server hasn't received any data. "
                                + "Please try again later.");
                    }
                }

                batchGetItemRequest.setRequestItems(
                        batchGetItemResult.getUnprocessedKeys());
            }

            batchGetItemResult = db.batchGetItem(
                    applyBatchOperationUserAgent(batchGetItemRequest));

            Map<String, List<Map<String, AttributeValue>>> responses = batchGetItemResult.getResponses();
            for ( String tableName : responses.keySet() ) {
                List<Object> objects = null;
                if ( resultSet.get(tableName) != null ) {
                    objects = resultSet.get(tableName);
                } else {
                    objects = new LinkedList<Object>();
                }

                Class<?> clazz = classesByTableName.get(tableName);

                for ( Map<String, AttributeValue> item : responses.get(tableName) ) {
                    AttributeTransformer.Parameters<?> parameters =
                        toParameters(item, clazz, tableName, config);
                    objects.add(privateMarshallIntoObject(converter, parameters));
                }

                resultSet.put(tableName, objects);
            }
            // To see whether there are unprocessed keys.
        } while ( batchGetItemResult.getUnprocessedKeys() != null && batchGetItemResult.getUnprocessedKeys().size() > 0 );

    }

    private final class ValueUpdate {

        private final Method method;
        private final AttributeValue newValue;
        private final Object target;
        private final ItemConverter converter;

        public ValueUpdate(
                Method method,
                AttributeValue newValue,
                Object target,
                ItemConverter converter) {

            this.method = method;
            this.newValue = newValue;
            this.target = target;
            this.converter = converter;
        }

        public void apply() {
            Method setter = reflector.getSetter(method);
            Object pojo = converter.unconvert(method, setter, newValue);
            ReflectionUtils.safeInvoke(setter, target, pojo);
        }
    }

    /**
     * Converts the {@link AttributeValueUpdate} map given to an equivalent
     * {@link AttributeValue} map.
     */
    private Map<String, AttributeValue> convertToItem(Map<String, AttributeValueUpdate> putValues) {
        Map<String, AttributeValue> map = new HashMap<String, AttributeValue>();
        for ( Entry<String, AttributeValueUpdate> entry : putValues.entrySet() ) {
            String attributeName = entry.getKey();
            AttributeValue attributeValue = entry.getValue().getValue();
            String attributeAction = entry.getValue().getAction();

            /*
             * AttributeValueUpdate allows nulls for its values, since they are
             * semantically meaningful. AttributeValues never have null values.
             */
            if ( attributeValue != null
                    && !AttributeAction.DELETE.toString().equals(attributeAction)) {
                map.put(attributeName, attributeValue);
            }
        }
        return map;
    }

    private AttributeValue getAutoGeneratedKeyAttributeValue(
            ItemConverter converter,
            Method getter) {

        Class<?> returnType = getter.getReturnType();
        if (String.class.isAssignableFrom(returnType)) {
            return converter.convert(getter, UUID.randomUUID().toString());
        }

        throw new DynamoDBMappingException(
                "Unsupported type for " + getter + ": " + returnType
                + ".  Only Strings are supported when auto-generating keys.");
    }

    /**
     * Scans through an Amazon DynamoDB table and returns the matching results as
     * an unmodifiable list of instantiated objects, using the default configuration.
     *
     * @see DynamoDBMapper#scan(Class, DynamoDBScanExpression, DynamoDBMapperConfig)
     */
    public <T> PaginatedScanList<T> scan(Class<T> clazz, DynamoDBScanExpression scanExpression) {
        return scan(clazz, scanExpression, config);
    }

    /**
     * Scans through an Amazon DynamoDB table and returns the matching results as
     * an unmodifiable list of instantiated objects. The table to scan is
     * determined by looking at the annotations on the specified class, which
     * declares where to store the object data in Amazon DynamoDB, and the scan
     * expression parameter allows the caller to filter results and control how
     * the scan is executed.
     * <p>
     * Callers should be aware that the returned list is unmodifiable, and any
     * attempts to modify the list will result in an
     * UnsupportedOperationException.
     * <p>
     * You can specify the pagination loading strategy for this scan operation.
     * By default, the list returned is lazily loaded when possible.
     *
     * @param <T>
     *            The type of the objects being returned.
     * @param clazz
     *            The class annotated with DynamoDB annotations describing how
     *            to store the object data in Amazon DynamoDB.
     * @param scanExpression
     *            Details on how to run the scan, including any filters to apply
     *            to limit results.
     * @param config
     *            The configuration to use for this scan, which overrides the
     *            default provided at object construction.
     * @return An unmodifiable list of the objects constructed from the results
     *         of the scan operation.
     * @see PaginatedScanList
     * @see PaginationLoadingStrategy
     */
    public <T> PaginatedScanList<T> scan(Class<T> clazz, DynamoDBScanExpression scanExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        ScanRequest scanRequest = createScanRequestFromExpression(clazz, scanExpression, config);

        ScanResult scanResult = db.scan(applyUserAgent(scanRequest));
        return new PaginatedScanList<T>(this, clazz, db, scanRequest, scanResult, config.getPaginationLoadingStrategy(), config);
    }

    /**
     * Scans through an Amazon DynamoDB table on logically partitioned segments
     * in parallel and returns the matching results in one unmodifiable list of
     * instantiated objects, using the default configuration.
     *
     * @see DynamoDBMapper#parallelScan(Class, DynamoDBScanExpression,int,
     *      DynamoDBMapperConfig)
     */
    public <T> PaginatedParallelScanList<T> parallelScan(Class<T> clazz, DynamoDBScanExpression scanExpression, int totalSegments) {
        return parallelScan(clazz, scanExpression, totalSegments, config);
    }

    /**
     * Scans through an Amazon DynamoDB table on logically partitioned segments
     * in parallel. This method will create a thread pool of the specified size,
     * and each thread will issue scan requests for its assigned segment,
     * following the returned continuation token, until the end of its segment.
     * Callers should be responsible for setting the appropriate number of total
     * segments. More scan segments would result in better performance but more
     * consumed capacity of the table. The results are returned in one
     * unmodifiable list of instantiated objects. The table to scan is
     * determined by looking at the annotations on the specified class, which
     * declares where to store the object data in Amazon DynamoDB, and the scan
     * expression parameter allows the caller to filter results and control how
     * the scan is executed.
     * <p>
     * Callers should be aware that the returned list is unmodifiable, and any
     * attempts to modify the list will result in an
     * UnsupportedOperationException.
     * <p>
     * You can specify the pagination loading strategy for this parallel scan operation.
     * By default, the list returned is lazily loaded when possible.
     *
     * @param <T>
     *            The type of the objects being returned.
     * @param clazz
     *            The class annotated with DynamoDB annotations describing how
     *            to store the object data in Amazon DynamoDB.
     * @param scanExpression
     *            Details on how to run the scan, including any filters to apply
     *            to limit results.
     * @param totalSegments
     *            Number of total parallel scan segments.
     *            <b>Range: </b>1 - 4096
     * @param config
     *            The configuration to use for this scan, which overrides the
     *            default provided at object construction.
     * @return An unmodifiable list of the objects constructed from the results
     *         of the scan operation.
     * @see PaginatedParallelScanList
     * @see PaginationLoadingStrategy
     */
    public <T> PaginatedParallelScanList<T> parallelScan(Class<T> clazz, DynamoDBScanExpression scanExpression, int totalSegments, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        // Create hard copies of the original scan request with difference segment number.
        List<ScanRequest> parallelScanRequests = createParallelScanRequestsFromExpression(clazz, scanExpression, totalSegments, config);
        ParallelScanTask parallelScanTask = new ParallelScanTask(db, parallelScanRequests);

        return new PaginatedParallelScanList<T>(this, clazz, db, parallelScanTask, config.getPaginationLoadingStrategy(), config);
    }

    /**
     * Scans through an Amazon DynamoDB table and returns a single page of matching
     * results. The table to scan is determined by looking at the annotations on
     * the specified class, which declares where to store the object data in AWS
     * DynamoDB, and the scan expression parameter allows the caller to filter
     * results and control how the scan is executed.
     *
     * @param <T>
     *            The type of the objects being returned.
     * @param clazz
     *            The class annotated with DynamoDB annotations describing how
     *            to store the object data in Amazon DynamoDB.
     * @param scanExpression
     *            Details on how to run the scan, including any filters to apply
     *            to limit results.
     * @param config
     *            The configuration to use for this scan, which overrides the
     *            default provided at object construction.
     */
    public <T> ScanResultPage<T> scanPage(Class<T> clazz, DynamoDBScanExpression scanExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        ScanRequest scanRequest = createScanRequestFromExpression(clazz, scanExpression, config);

        ScanResult scanResult = db.scan(applyUserAgent(scanRequest));
        ScanResultPage<T> result = new ScanResultPage<T>();
        List<AttributeTransformer.Parameters<T>> parameters =
            toParameters(scanResult.getItems(), clazz, scanRequest.getTableName(), config);

        result.setResults(marshallIntoObjects(parameters));
        result.setLastEvaluatedKey(scanResult.getLastEvaluatedKey());
        result.setCount(scanResult.getCount());
        result.setScannedCount(scanResult.getScannedCount());
        result.setConsumedCapacity(scanResult.getConsumedCapacity());

        return result;
    }

    /**
     * Scans through an Amazon DynamoDB table and returns a single page of matching
     * results.
     *
     * @see DynamoDBMapper#scanPage(Class, DynamoDBScanExpression, DynamoDBMapperConfig)
     */
    public <T> ScanResultPage<T> scanPage(Class<T> clazz, DynamoDBScanExpression scanExpression) {
        return scanPage(clazz, scanExpression, this.config);
    }

    /**
     * Queries an Amazon DynamoDB table and returns the matching results as an
     * unmodifiable list of instantiated objects, using the default
     * configuration.
     *
     * @see DynamoDBMapper#query(Class, DynamoDBQueryExpression,
     *      DynamoDBMapperConfig)
     */
    public <T> PaginatedQueryList<T> query(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression) {
        return query(clazz, queryExpression, config);
    }

    /**
     * Queries an Amazon DynamoDB table and returns the matching results as an
     * unmodifiable list of instantiated objects. The table to query is
     * determined by looking at the annotations on the specified class, which
     * declares where to store the object data in Amazon DynamoDB, and the query
     * expression parameter allows the caller to filter results and control how
     * the query is executed.
     * <p>
     * When the query is on any local/global secondary index, callers should be aware that
     * the returned object(s) will only contain item attributes that are projected
     * into the index. All the other unprojected attributes will be saved as type
     * default values.
     * <p>
     * Callers should also be aware that the returned list is unmodifiable, and any
     * attempts to modify the list will result in an
     * UnsupportedOperationException.
     * <p>
     * You can specify the pagination loading strategy for this query operation.
     * By default, the list returned is lazily loaded when possible.
     *
     * @param <T>
     *            The type of the objects being returned.
     * @param clazz
     *            The class annotated with DynamoDB annotations describing how
     *            to store the object data in Amazon DynamoDB.
     * @param queryExpression
     *            Details on how to run the query, including any conditions on
     *            the key values
     * @param config
     *            The configuration to use for this query, which overrides the
     *            default provided at object construction.
     * @return An unmodifiable list of the objects constructed from the results
     *         of the query operation.
     * @see PaginatedQueryList
     * @see PaginationLoadingStrategy
     */
    public <T> PaginatedQueryList<T> query(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        QueryRequest queryRequest = createQueryRequestFromExpression(clazz, queryExpression, config);

        QueryResult queryResult = db.query(applyUserAgent(queryRequest));
        return new PaginatedQueryList<T>(this, clazz, db, queryRequest, queryResult, config.getPaginationLoadingStrategy(), config);
    }

    /**
     * Queries an Amazon DynamoDB table and returns a single page of matching
     * results. The table to query is determined by looking at the annotations
     * on the specified class, which declares where to store the object data in
     * Amazon DynamoDB, and the query expression parameter allows the caller to
     * filter results and control how the query is executed.
     *
     * @see DynamoDBMapper#queryPage(Class, DynamoDBQueryExpression, DynamoDBMapperConfig)
     */
    public <T> QueryResultPage<T> queryPage(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression) {
        return queryPage(clazz, queryExpression, this.config);
    }

    /**
     * Queries an Amazon DynamoDB table and returns a single page of matching
     * results. The table to query is determined by looking at the annotations
     * on the specified class, which declares where to store the object data in
     * Amazon DynamoDB, and the query expression parameter allows the caller to
     * filter results and control how the query is executed.
     *
     * @param <T>
     *            The type of the objects being returned.
     * @param clazz
     *            The class annotated with DynamoDB annotations describing how
     *            to store the object data in AWS DynamoDB.
     * @param queryExpression
     *            Details on how to run the query, including any conditions on
     *            the key values
     * @param config
     *            The configuration to use for this query, which overrides the
     *            default provided at object construction.
     */
    public <T> QueryResultPage<T> queryPage(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        QueryRequest queryRequest = createQueryRequestFromExpression(clazz, queryExpression, config);

        QueryResult queryResult = db.query(applyUserAgent(queryRequest));
        QueryResultPage<T> result = new QueryResultPage<T>();
        List<AttributeTransformer.Parameters<T>> parameters =
            toParameters(queryResult.getItems(), clazz, queryRequest.getTableName(), config);

        result.setResults(marshallIntoObjects(parameters));
        result.setLastEvaluatedKey(queryResult.getLastEvaluatedKey());
        result.setCount(queryResult.getCount());
        result.setScannedCount(queryResult.getScannedCount());
        result.setConsumedCapacity(queryResult.getConsumedCapacity());

        return result;
    }

    /**
     * Evaluates the specified scan expression and returns the count of matching
     * items, without returning any of the actual item data, using the default configuration.
     *
     * @see DynamoDBMapper#count(Class, DynamoDBScanExpression, DynamoDBMapperConfig)
     */
    public int count(Class<?> clazz, DynamoDBScanExpression scanExpression) {
        return count(clazz, scanExpression, config);
    }

    /**
     * Evaluates the specified scan expression and returns the count of matching
     * items, without returning any of the actual item data.
     * <p>
     * This operation will scan your entire table, and can therefore be very
     * expensive. Use with caution.
     *
     * @param clazz
     *            The class mapped to a DynamoDB table.
     * @param scanExpression
     *            The parameters for running the scan.
     * @param config
     *            The configuration to use for this scan, which overrides the
     *            default provided at object construction.
     * @return The count of matching items, without returning any of the actual
     *         item data.
     */
    public int count(Class<?> clazz, DynamoDBScanExpression scanExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        ScanRequest scanRequest = createScanRequestFromExpression(clazz, scanExpression, config);
        scanRequest.setSelect(Select.COUNT);

        // Count scans can also be truncated for large datasets
        int count = 0;
        ScanResult scanResult = null;
        do {
            scanResult = db.scan(applyUserAgent(scanRequest));
            count += scanResult.getCount();
            scanRequest.setExclusiveStartKey(scanResult.getLastEvaluatedKey());
        } while (scanResult.getLastEvaluatedKey() != null);

        return count;
    }


    /**
     * Evaluates the specified query expression and returns the count of matching
     * items, without returning any of the actual item data, using the default configuration.
     *
     * @see DynamoDBMapper#count(Class, DynamoDBQueryExpression, DynamoDBMapperConfig)
     */
    public <T> int count(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression) {
        return count(clazz, queryExpression, config);
    }

    /**
     * Evaluates the specified query expression and returns the count of
     * matching items, without returning any of the actual item data.
     *
     * @param clazz
     *            The class mapped to a DynamoDB table.
     * @param queryExpression
     *            The parameters for running the scan.
     * @param config
     *            The mapper configuration to use for the query, which overrides
     *            the default provided at object construction.
     * @return The count of matching items, without returning any of the actual
     *         item data.
     */
    public <T> int count(Class<T> clazz, DynamoDBQueryExpression<T> queryExpression, DynamoDBMapperConfig config) {
        config = mergeConfig(config);

        QueryRequest queryRequest = createQueryRequestFromExpression(clazz, queryExpression, config);
        queryRequest.setSelect(Select.COUNT);

        // Count queries can also be truncated for large datasets
        int count = 0;
        QueryResult queryResult = null;
        do {
            queryResult = db.query(applyUserAgent(queryRequest));
            count += queryResult.getCount();
            queryRequest.setExclusiveStartKey(queryResult.getLastEvaluatedKey());
        } while (queryResult.getLastEvaluatedKey() != null);

        return count;
    }

    /**
     * Merges the config object given with the one specified at construction and
     * returns the result.
     */
    private DynamoDBMapperConfig mergeConfig(DynamoDBMapperConfig config) {
        if ( config != this.config )
            config = new DynamoDBMapperConfig(this.config, config);
        return config;
    }

    /**
     * @param config never null
     */
    private ScanRequest createScanRequestFromExpression(Class<?> clazz, DynamoDBScanExpression scanExpression, DynamoDBMapperConfig config) {
        ScanRequest scanRequest = new ScanRequest();
        scanRequest.setTableName(getTableName(clazz, config));
        scanRequest.setIndexName(scanExpression.getIndexName());
        scanRequest.setScanFilter(scanExpression.getScanFilter());
        scanRequest.setLimit(scanExpression.getLimit());
        scanRequest.setExclusiveStartKey(scanExpression.getExclusiveStartKey());
        scanRequest.setTotalSegments(scanExpression.getTotalSegments());
        scanRequest.setSegment(scanExpression.getSegment());
        scanRequest.setConditionalOperator(scanExpression.getConditionalOperator());
        scanRequest.setFilterExpression(scanExpression.getFilterExpression());
        scanRequest.setExpressionAttributeNames(scanExpression
                .getExpressionAttributeNames());
        scanRequest.setExpressionAttributeValues(scanExpression
                .getExpressionAttributeValues());
        scanRequest.setRequestMetricCollector(config.getRequestMetricCollector());
        scanRequest.setSelect(scanExpression.getSelect());
        scanRequest.setProjectionExpression(scanExpression.getProjectionExpression());
        scanRequest.setReturnConsumedCapacity(scanExpression.getReturnConsumedCapacity());

        return applyUserAgent(scanRequest);
    }

    /**
     * @param config never null
     */
    private List<ScanRequest> createParallelScanRequestsFromExpression(Class<?> clazz, DynamoDBScanExpression scanExpression, int totalSegments, DynamoDBMapperConfig config) {
        if (totalSegments < 1) {
            throw new IllegalArgumentException("Parallel scan should have at least one scan segment.");
        }
        if (scanExpression.getExclusiveStartKey() != null) {
            log.info("The ExclusiveStartKey parameter specified in the DynamoDBScanExpression is ignored,"
                    + " since the individual parallel scan request on each segment is applied on a separate key scope.");
        }
        if (scanExpression.getSegment() != null || scanExpression.getTotalSegments() != null) {
            log.info("The Segment and TotalSegments parameters specified in the DynamoDBScanExpression are ignored.");
        }

        List<ScanRequest> parallelScanRequests= new LinkedList<ScanRequest>();
        for (int segment = 0; segment < totalSegments; segment++) {
            ScanRequest scanRequest = createScanRequestFromExpression(clazz, scanExpression, config);
            parallelScanRequests.add(scanRequest
                    .withSegment(segment).withTotalSegments(totalSegments)
                    .withExclusiveStartKey(null));
        }
        return parallelScanRequests;
    }

    private <T> QueryRequest createQueryRequestFromExpression(Class<T> clazz,
            DynamoDBQueryExpression<T> xpress, DynamoDBMapperConfig config) {
        QueryRequest req = new QueryRequest();
        req.setConsistentRead(xpress.isConsistentRead());
        req.setTableName(getTableName(clazz, xpress.getHashKeyValues(), config));
        req.setIndexName(xpress.getIndexName());

        ItemConverter converter = getConverter(config);

        // Hash key (primary or index) conditions
        Map<String, Condition> hashKeyConditions = getHashKeyEqualsConditions(
                converter, xpress.getHashKeyValues());

        // Range key (primary or index) conditions
        Map<String, Condition> rangeKeyConditions = xpress.getRangeKeyConditions();
        req.setKeyConditionExpression(xpress.getKeyConditionExpression());
        processKeyConditions(clazz, req, hashKeyConditions, rangeKeyConditions);

        req.withScanIndexForward(xpress.isScanIndexForward())
           .withLimit(xpress.getLimit())
           .withExclusiveStartKey(xpress.getExclusiveStartKey())
           .withQueryFilter(xpress.getQueryFilter())
           .withConditionalOperator(xpress.getConditionalOperator())
           .withSelect(xpress.getSelect())
           .withProjectionExpression(xpress.getProjectionExpression())
           .withFilterExpression(xpress.getFilterExpression())
           .withExpressionAttributeNames(xpress.getExpressionAttributeNames())
           .withExpressionAttributeValues(xpress.getExpressionAttributeValues())
           .withReturnConsumedCapacity(xpress.getReturnConsumedCapacity())
           .withRequestMetricCollector(config.getRequestMetricCollector())
           ;
        return applyUserAgent(req);
    }

    /**
     * Utility method for checking the validity of both hash and range key
     * conditions. It also tries to infer the correct index name from the POJO
     * annotation, if such information is not directly specified by the user.
     *
     * @param clazz
     *            The domain class of the queried items.
     * @param queryRequest
     *            The QueryRequest object to be sent to service.
     * @param hashKeyConditions
     *            All the hash key EQ conditions extracted from the POJO object.
     *            The mapper will choose one of them that could be applied together with
     *            the user-specified (if any) index name and range key conditions. Or it
     *            throws error if more than one conditions are applicable for the query.
     * @param rangeKeyConditions
     *            The range conditions specified by the user. We currently only
     *            allow at most one range key condition.
     */
    private void processKeyConditions(Class<?> clazz,
                                      QueryRequest queryRequest,
                                      Map<String, Condition> hashKeyConditions,
                                      Map<String, Condition> rangeKeyConditions) {
        // There should be least one hash key condition.
        final String keyCondExpression = queryRequest.getKeyConditionExpression();
        if (keyCondExpression == null) {
            if (hashKeyConditions == null || hashKeyConditions.isEmpty()) {
                throw new IllegalArgumentException(
                    "Illegal query expression: No hash key condition is found in the query");
            }
        } else {
            if (hashKeyConditions != null && !hashKeyConditions.isEmpty()) {
                throw new IllegalArgumentException(
                    "Illegal query expression: Either the hash key conditions or the key condition expression must be specified but not both.");
            }
            if (rangeKeyConditions != null && !rangeKeyConditions.isEmpty()) {
                throw new IllegalArgumentException(
                    "Illegal query expression: The range key conditions can only be specified when the key condition expression is not specified.");
            }
            // key condition expression is in use
            return;
        }
        // We don't allow multiple range key conditions.
        if (rangeKeyConditions != null && rangeKeyConditions.size() > 1) {
            throw new IllegalArgumentException(
                    "Illegal query expression: Conditions on multiple range keys ("
                    + rangeKeyConditions.keySet().toString()
                    + ") are found in the query. DynamoDB service only accepts up to ONE range key condition.");
        }
        final boolean hasRangeKeyCondition = (rangeKeyConditions != null)
                                            && (!rangeKeyConditions.isEmpty());
        final String userProvidedIndexName = queryRequest.getIndexName();
        final String primaryHashKeyName = reflector.getPrimaryHashKeyName(clazz);
        final TableIndexesInfo parsedIndexesInfo = schemaParser.parseTableIndexes(clazz, reflector);

        // First collect the names of all the global/local secondary indexes that could be applied to this query.
        // If the user explicitly specified an index name, we also need to
        //   1) check the index is applicable for both hash and range key conditions
        //   2) choose one hash key condition if there are more than one of them
        boolean hasPrimaryHashKeyCondition = false;
        final Map<String, Set<String>> annotatedGSIsOnHashKeys = new HashMap<String, Set<String>>();
        String hashKeyNameForThisQuery = null;

        boolean hasPrimaryRangeKeyCondition = false;
        final Set<String> annotatedLSIsOnRangeKey = new HashSet<String>();
        final Set<String> annotatedGSIsOnRangeKey = new HashSet<String>();

        // Range key condition
        String rangeKeyNameForThisQuery = null;
        if (hasRangeKeyCondition) {
            for (String rangeKeyName : rangeKeyConditions.keySet()) {
                rangeKeyNameForThisQuery = rangeKeyName;

                if (reflector.hasPrimaryRangeKey(clazz)
                    && rangeKeyName.equals(reflector.getPrimaryRangeKeyName(clazz))) {
                    hasPrimaryRangeKeyCondition = true;
                }

                Collection<String> annotatedLSI = parsedIndexesInfo.getLsiNamesByIndexRangeKey(rangeKeyName);
                if (annotatedLSI != null) {
                    annotatedLSIsOnRangeKey.addAll(annotatedLSI);
                }
                Collection<String> annotatedGSI = parsedIndexesInfo.getGsiNamesByIndexRangeKey(rangeKeyName);
                if (annotatedGSI != null) {
                    annotatedGSIsOnRangeKey.addAll(annotatedGSI);
                }
            }

            if ( !hasPrimaryRangeKeyCondition
                 && annotatedLSIsOnRangeKey.isEmpty()
                 && annotatedGSIsOnRangeKey.isEmpty()) {
                throw new DynamoDBMappingException(
                        "The query contains a condition on a range key (" +
                        rangeKeyNameForThisQuery + ") " +
                        "that is not annotated with either @DynamoDBRangeKey or @DynamoDBIndexRangeKey.");
            }
        }

        final boolean userProvidedLSIWithRangeKeyCondition = (userProvidedIndexName != null)
                                        && (annotatedLSIsOnRangeKey.contains(userProvidedIndexName));
        final boolean hashOnlyLSIQuery = (userProvidedIndexName != null)
                                        && ( !hasRangeKeyCondition )
                                        && parsedIndexesInfo.getAllLsiNames().contains(userProvidedIndexName);
        final boolean userProvidedLSI = userProvidedLSIWithRangeKeyCondition || hashOnlyLSIQuery;

        final boolean userProvidedGSIWithRangeKeyCondition = (userProvidedIndexName != null)
                                        && (annotatedGSIsOnRangeKey.contains(userProvidedIndexName));
        final boolean hashOnlyGSIQuery = (userProvidedIndexName != null)
                                        && ( !hasRangeKeyCondition )
                                        && parsedIndexesInfo.getAllGsiNames().contains(userProvidedIndexName);
        final boolean userProvidedGSI = userProvidedGSIWithRangeKeyCondition || hashOnlyGSIQuery;

        if (userProvidedLSI && userProvidedGSI ) {
            throw new DynamoDBMappingException(
                    "Invalid query: " +
                    "Index \"" + userProvidedIndexName + "\" " +
                    "is annotateded as both a LSI and a GSI for attribute.");
        }

        // Hash key conditions
        for (String hashKeyName : hashKeyConditions.keySet()) {
            if (hashKeyName.equals(primaryHashKeyName)) {
                hasPrimaryHashKeyCondition = true;
            }

            Collection<String> annotatedGSINames = parsedIndexesInfo.getGsiNamesByIndexHashKey(hashKeyName);
            annotatedGSIsOnHashKeys.put(hashKeyName,
                    annotatedGSINames == null ? new HashSet<String>() : new HashSet<String>(annotatedGSINames));

            // Additional validation if the user provided an index name.
            if (userProvidedIndexName != null) {
                boolean foundHashKeyConditionValidWithUserProvidedIndex = false;
                if (userProvidedLSI && hashKeyName.equals(primaryHashKeyName)) {
                    // found an applicable hash key condition (primary hash + LSI range)
                    foundHashKeyConditionValidWithUserProvidedIndex = true;
                } else if (userProvidedGSI &&
                        annotatedGSINames != null && annotatedGSINames.contains(userProvidedIndexName)) {
                    // found an applicable hash key condition (GSI hash + range)
                    foundHashKeyConditionValidWithUserProvidedIndex = true;
                }
                if (foundHashKeyConditionValidWithUserProvidedIndex) {
                    if ( hashKeyNameForThisQuery != null ) {
                        throw new IllegalArgumentException(
                                "Ambiguous query expression: More than one hash key EQ conditions (" +
                                hashKeyNameForThisQuery + ", " + hashKeyName +
                                ") are applicable to the specified index ("
                                + userProvidedIndexName + "). " +
                                "Please provide only one of them in the query expression.");
                    } else {
                        // found an applicable hash key condition
                        hashKeyNameForThisQuery = hashKeyName;
                    }
                }
            }
        }

        // Collate all the key conditions
        Map<String, Condition> keyConditions = new HashMap<String, Condition>();

        // With user-provided index name
        if (userProvidedIndexName != null) {
            if (hasRangeKeyCondition
                    && ( !userProvidedLSI )
                    && ( !userProvidedGSI )) {
                throw new IllegalArgumentException(
                        "Illegal query expression: No range key condition is applicable to the specified index ("
                        + userProvidedIndexName + "). ");
            }
            if (hashKeyNameForThisQuery == null) {
                throw new IllegalArgumentException(
                        "Illegal query expression: No hash key condition is applicable to the specified index ("
                        + userProvidedIndexName + "). ");
            }

            keyConditions.put(hashKeyNameForThisQuery, hashKeyConditions.get(hashKeyNameForThisQuery));
            if (hasRangeKeyCondition) {
                keyConditions.putAll(rangeKeyConditions);
            }
        }
        // Infer the index name by finding the index shared by both hash and range key annotations.
        else {
            if (hasRangeKeyCondition) {
                String inferredIndexName = null;
                hashKeyNameForThisQuery = null;
                if (hasPrimaryHashKeyCondition && hasPrimaryRangeKeyCondition) {
                    // Found valid query: primary hash + range key conditions
                    hashKeyNameForThisQuery = primaryHashKeyName;
                } else {
                    // Intersect the set of all the indexes applicable to the range key
                    // with the set of indexes applicable to each hash key condition.
                    for (String hashKeyName : annotatedGSIsOnHashKeys.keySet()) {
                        boolean foundValidQueryExpressionWithInferredIndex = false;
                        String indexNameInferredByThisHashKey = null;
                        if (hashKeyName.equals(primaryHashKeyName)) {
                            if (annotatedLSIsOnRangeKey.size() == 1) {
                                // Found valid query (Primary hash + LSI range conditions)
                                foundValidQueryExpressionWithInferredIndex = true;
                                indexNameInferredByThisHashKey = annotatedLSIsOnRangeKey.iterator().next();
                            }
                        }

                        Set<String> annotatedGSIsOnHashKey = annotatedGSIsOnHashKeys.get(hashKeyName);
                        // We don't need the data in annotatedGSIsOnHashKeys afterwards,
                        // so it's safe to do the intersection in-place.
                        annotatedGSIsOnHashKey.retainAll(annotatedGSIsOnRangeKey);
                        if (annotatedGSIsOnHashKey.size() == 1) {
                            // Found valid query (Hash + range conditions on a GSI)
                            if (foundValidQueryExpressionWithInferredIndex) {
                                hashKeyNameForThisQuery = hashKeyName;
                                inferredIndexName = indexNameInferredByThisHashKey;
                            }

                            foundValidQueryExpressionWithInferredIndex = true;
                            indexNameInferredByThisHashKey = annotatedGSIsOnHashKey.iterator().next();
                        }

                        if (foundValidQueryExpressionWithInferredIndex) {
                            if (hashKeyNameForThisQuery != null) {
                                throw new IllegalArgumentException(
                                        "Ambiguous query expression: Found multiple valid queries: " +
                                        "(Hash: \"" + hashKeyNameForThisQuery + "\", Range: \"" + rangeKeyNameForThisQuery + "\", Index: \"" + inferredIndexName + "\") and " +
                                        "(Hash: \"" + hashKeyName + "\", Range: \"" + rangeKeyNameForThisQuery + "\", Index: \"" + indexNameInferredByThisHashKey + "\").");
                            } else {
                                hashKeyNameForThisQuery = hashKeyName;
                                inferredIndexName = indexNameInferredByThisHashKey;
                            }
                        }
                    }
                }

                if (hashKeyNameForThisQuery != null) {
                    keyConditions.put(hashKeyNameForThisQuery, hashKeyConditions.get(hashKeyNameForThisQuery));
                    keyConditions.putAll(rangeKeyConditions);
                    queryRequest.setIndexName(inferredIndexName);
                } else {
                    throw new IllegalArgumentException(
                            "Illegal query expression: Cannot infer the index name from the query expression.");
                }

            } else {
                // No range key condition is specified.
                if (hashKeyConditions.size() > 1) {
                    if ( hasPrimaryHashKeyCondition ) {
                        keyConditions.put(primaryHashKeyName, hashKeyConditions.get(primaryHashKeyName));
                    } else {
                        throw new IllegalArgumentException(
                                "Ambiguous query expression: More than one index hash key EQ conditions (" +
                                hashKeyConditions.keySet() +
                                ") are applicable to the query. " +
                                "Please provide only one of them in the query expression, or specify the appropriate index name.");
                    }

                } else {
                    // Only one hash key condition
                    String hashKeyName = annotatedGSIsOnHashKeys.keySet().iterator().next();
                    if ( !hasPrimaryHashKeyCondition ) {
                        if (annotatedGSIsOnHashKeys.get(hashKeyName).size() == 1) {
                            // Set the index if the index hash key is only annotated with one GSI.
                            queryRequest.setIndexName(annotatedGSIsOnHashKeys.get(hashKeyName).iterator().next());
                        } else if (annotatedGSIsOnHashKeys.get(hashKeyName).size() > 1) {
                            throw new IllegalArgumentException(
                                    "Ambiguous query expression: More than one GSIs (" +
                                    annotatedGSIsOnHashKeys.get(hashKeyName) +
                                    ") are applicable to the query. " +
                                    "Please specify one of them in your query expression.");
                        } else {
                            throw new IllegalArgumentException(
                                    "Illegal query expression: No GSI is found in the @DynamoDBIndexHashKey annotation for attribute " +
                                    "\"" + hashKeyName + "\".");
                        }
                    }
                    keyConditions.putAll(hashKeyConditions);
                }

            }
        }

        queryRequest.setKeyConditions(keyConditions);
    }

    private <T> AttributeTransformer.Parameters<T> toParameters(
            final Map<String, AttributeValue> attributeValues,
            final Class<T> modelClass,
            final String tableName,
            final DynamoDBMapperConfig mapperConfig) {

        return toParameters(attributeValues, false, modelClass, tableName, mapperConfig);
    }

    private <T> AttributeTransformer.Parameters<T> toParameters(
            final Map<String, AttributeValue> attributeValues,
            final boolean partialUpdate,
            final Class<T> modelClass,
            final String tableName,
            final DynamoDBMapperConfig mapperConfig) {

        return new TransformerParameters<T>(
                reflector,
                attributeValues,
                partialUpdate,
                modelClass,
                mapperConfig,
                tableName);
    }

    final <T> List<AttributeTransformer.Parameters<T>> toParameters(
            final List<Map<String, AttributeValue>> attributeValues,
            final Class<T> modelClass,
            final String tableName,
            final DynamoDBMapperConfig mapperConfig
    ) {
        List<AttributeTransformer.Parameters<T>> rval =
            new ArrayList<AttributeTransformer.Parameters<T>>(
                attributeValues.size());

        for (Map<String, AttributeValue> item : attributeValues) {
            rval.add(toParameters(item, modelClass, tableName, mapperConfig));
        }

        return rval;
    }

    /**
     * The one true implementation of AttributeTransformer.Parameters.
     */
    private static class TransformerParameters<T>
            implements AttributeTransformer.Parameters<T> {

        private final DynamoDBReflector reflector;
        private final Map<String, AttributeValue> attributeValues;
        private final boolean partialUpdate;
        private final Class<T> modelClass;
        private final DynamoDBMapperConfig mapperConfig;
        private final String tableName;

        private String hashKeyName;
        private String rangeKeyName;

        public TransformerParameters(
                final DynamoDBReflector reflector,
                final Map<String, AttributeValue> attributeValues,
                final boolean partialUpdate,
                final Class<T> modelClass,
                final DynamoDBMapperConfig mapperConfig,
                final String tableName) {

            this.reflector = reflector;
            this.attributeValues =
                Collections.unmodifiableMap(attributeValues);
            this.partialUpdate = partialUpdate;
            this.modelClass = modelClass;
            this.mapperConfig = mapperConfig;
            this.tableName = tableName;
        }

        @Override
        public Map<String, AttributeValue> getAttributeValues() {
            return attributeValues;
        }

        @Override
        public boolean isPartialUpdate() {
            return partialUpdate;
        }

        @Override
        public Class<T> getModelClass() {
            return modelClass;
        }

        @Override
        public DynamoDBMapperConfig getMapperConfig() {
            return mapperConfig;
        }

        @Override
        public String getTableName() {
            return tableName;
        }

        @Override
        public String getHashKeyName() {
            if (hashKeyName == null) {
                Method hashKeyGetter = reflector.getPrimaryHashKeyGetter(modelClass);
                hashKeyName = reflector.getAttributeName(hashKeyGetter);
            }
            return hashKeyName;
        }

        @Override
        public String getRangeKeyName() {
            if (rangeKeyName == null) {
                Method rangeKeyGetter =
                        reflector.getPrimaryRangeKeyGetter(modelClass);
                if (rangeKeyGetter == null) {
                    rangeKeyName = NO_RANGE_KEY;
                } else {
                    rangeKeyName = reflector.getAttributeName(rangeKeyGetter);
                }
            }
            if (rangeKeyName == NO_RANGE_KEY) {
                return null;
            }
            return rangeKeyName;
        }
    }

    private Map<String, AttributeValue> untransformAttributes(
            final AttributeTransformer.Parameters<?> parameters
    ) {
        if (transformer != null) {
            return transformer.untransform(parameters);
        } else {
            return parameters.getAttributeValues();
        }
    }

    private Map<String, AttributeValue> transformAttributes(
            final AttributeTransformer.Parameters<?> parameters) {

        if (transformer != null) {
            return transformer.transform(parameters);
        } else {
            return parameters.getAttributeValues();
        }
    }

    private Map<String, AttributeValueUpdate> transformAttributeUpdates(
            final Class<?> clazz,
            final String tableName,
            final Map<String, AttributeValue> keys,
            final Map<String, AttributeValueUpdate> updateValues,
            final DynamoDBMapperConfig config
    ) {
        Map<String, AttributeValue> item = convertToItem(updateValues);

        HashSet<String> keysAdded = new HashSet<String>();
        for (Map.Entry<String, AttributeValue> e : keys.entrySet()) {
            if (!item.containsKey(e.getKey())) {
                keysAdded.add(e.getKey());
                item.put(e.getKey(), e.getValue());
            }
        }

        AttributeTransformer.Parameters<?> parameters =
            toParameters(item, true, clazz, tableName, config);

        String hashKey = parameters.getHashKeyName();

        if (!item.containsKey(hashKey)) {
            item.put(hashKey, keys.get(hashKey));
        }

        item = transformAttributes(parameters);

        for(Map.Entry<String, AttributeValue> entry: item.entrySet()) {
            if (keysAdded.contains(entry.getKey())) {
                // This was added in for context before calling
                // transformAttributes, but isn't actually being changed.
                continue;
            }

            AttributeValueUpdate update = updateValues.get(entry.getKey());
            if (update != null) {
                update.getValue()
                    .withB( entry.getValue().getB() )
                    .withBS(entry.getValue().getBS())
                    .withN( entry.getValue().getN() )
                    .withNS(entry.getValue().getNS())
                    .withS( entry.getValue().getS() )
                    .withSS(entry.getValue().getSS());
            } else {
                updateValues.put(entry.getKey(),
                                 new AttributeValueUpdate(entry.getValue(),
                                                          "PUT"));
            }
        }

        return updateValues;
    }

    private ItemConverter getConverter(DynamoDBMapperConfig config) {
        ConversionSchema schema = config.getConversionSchema();

        ConversionSchema.Dependencies params = new ConversionSchema.Dependencies()
                .with(DynamoDBReflector.class, reflector)
                .with(S3ClientCache.class, s3cc);

        return schema.getConverter(params);
    }

    private void pauseExponentially(int retries) {
        if (retries == 0) {
            return;
        }

        Random random = new Random();
        long delay = 0;
        long scaleFactor = 500 + random.nextInt(100);
        delay = (long) (Math.pow(2, retries) * scaleFactor);
        delay = Math.min(delay, MAX_BACKOFF_IN_MILLISECONDS);

        try {
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new AmazonClientException(e.getMessage(), e);
        }
    }

    /**
     * Returns a new map object that merges the two sets of expected value
     * conditions (user-specified or imposed by the internal implementation of
     * DynamoDBMapper). Internal assertion on an attribute will be overridden by
     * any user-specified condition on the same attribute.
     * <p>
     * Exception is thrown if the two sets of conditions cannot be combined
     * together.
     */
    private static Map<String, ExpectedAttributeValue> mergeExpectedAttributeValueConditions(
            Map<String, ExpectedAttributeValue> internalAssertions,
            Map<String, ExpectedAttributeValue> userProvidedConditions,
            String userProvidedConditionOperator) {
        // If any of the condition map is null, simply return a copy of the other one.
        if ((internalAssertions == null || internalAssertions.isEmpty())
                && (userProvidedConditions == null || userProvidedConditions.isEmpty())) {
            return null;
        } else if (internalAssertions == null) {
            return new HashMap<String, ExpectedAttributeValue>(userProvidedConditions);
        } else if (userProvidedConditions == null) {
            return new HashMap<String, ExpectedAttributeValue>(internalAssertions);
        }

        // Start from a copy of the internal conditions
        Map<String, ExpectedAttributeValue> mergedExpectedValues =
                new HashMap<String, ExpectedAttributeValue>(internalAssertions);

        // Remove internal conditions that are going to be overlaid by user-provided ones.
        for (String attrName : userProvidedConditions.keySet()) {
            mergedExpectedValues.remove(attrName);
        }

        // All the generated internal conditions must be joined by AND.
        // Throw an exception if the user specifies an OR operator, and that the
        // internal conditions are not totally overlaid by the user-provided
        // ones.
        if ( ConditionalOperator.OR.toString().equals(userProvidedConditionOperator)
                && !mergedExpectedValues.isEmpty() ) {
            throw new IllegalArgumentException("Unable to assert the value of the fields "
                    + mergedExpectedValues.keySet() + ", since the expected value conditions cannot be combined "
                    + "with user-specified conditions joined by \"OR\". You can use SaveBehavior.CLOBBER to "
                    + "skip the assertion on these fields.");
        }

        mergedExpectedValues.putAll(userProvidedConditions);

        return mergedExpectedValues;
    }

    static <X extends AmazonWebServiceRequest> X applyUserAgent(X request) {
        request.getRequestClientOptions().appendUserAgent(USER_AGENT);
        return request;
    }

    static <X extends AmazonWebServiceRequest> X applyBatchOperationUserAgent(X request) {
        request.getRequestClientOptions().appendUserAgent(USER_AGENT_BATCH_OPERATION);
        return request;
    }

    /**
     * The return type of batchWrite, batchDelete and batchSave. It contains the information about the unprocessed items
     * and the exception causing the failure.
     *
     */
    public static class FailedBatch {

        private Map<String, java.util.List<WriteRequest>> unprocessedItems;

        private Exception exception;

        public void setUnprocessedItems(Map<String, java.util.List<WriteRequest>> unprocessedItems) {
            this.unprocessedItems = unprocessedItems;
        }

        public Map<String, java.util.List<WriteRequest>> getUnprocessedItems() {
            return unprocessedItems;
        }

        public void setException(Exception excetpion) {
            this.exception = excetpion;
        }

        public Exception getException() {
            return exception;
        }

    }

    /**
     * Returns the underlying {@link S3ClientCache} for accessing S3.
     */
    public S3ClientCache getS3ClientCache() {
        return s3cc;
    }

    /**
     * Creates an S3Link with the specified bucket name and key using the
     * default S3 region.
     * This method requires the mapper to have been initialized with the
     * necessary credentials for accessing S3.
     *
     * @throws IllegalStateException if the mapper has not been constructed
     * with the necessary S3 AWS credentials.
     */
    public S3Link createS3Link(String bucketName, String key) {
        return createS3Link(null, bucketName , key);
    }

    /**
     * Creates an S3Link with the specified region, bucket name and key.
     * This method requires the mapper to have been initialized with the
     * necessary credentials for accessing S3.
     *
     * @throws IllegalStateException if the mapper has not been constructed
     * with the necessary S3 AWS credentials.
     */
    public S3Link createS3Link(Region s3region, String bucketName, String key) {
        if ( s3cc == null ) {
            throw new IllegalStateException("Mapper must be constructed with S3 AWS Credentials to create S3Link");
        }
        return new S3Link(s3cc, s3region, bucketName , key);
    }

    /**
     * Parse the given POJO class and return the CreateTableRequest for the
     * DynamoDB table it represents. Note that the returned request does not
     * include the required ProvisionedThroughput parameters for the primary
     * table and the GSIs, and that all secondary indexes are initialized with
     * the default projection type - KEY_ONLY.
     */
    public CreateTableRequest generateCreateTableRequest(Class<?> clazz) {
        ItemConverter converter = getConverter(config);
        return schemaParser.parseTablePojoToCreateTableRequest(
                clazz, config, reflector, converter);
    }
}


File: aws-java-sdk-dynamodb/src/main/java/com/amazonaws/services/dynamodbv2/datamodeling/DynamoDBMapperConfig.java
/*
 * Copyright 2011-2015 Amazon Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *    http://aws.amazon.com/apache2.0
 *
 * This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and
 * limitations under the License.
 */
package com.amazonaws.services.dynamodbv2.datamodeling;

import com.amazonaws.metrics.RequestMetricCollector;

/**
 * Immutable configuration object for service call behavior. An instance of this
 * configuration is supplied to every {@link DynamoDBMapper} at construction; if
 * not provided explicitly, {@link DynamoDBMapperConfig#DEFAULT} is used. New
 * instances can be given to the mapper object on individual save, load, and
 * delete operations to override the defaults. For example:
 *
 * <pre class="brush: java">
 * DynamoDBMapper mapper = new DynamoDBMapper(dynamoDBClient);
 * // Force this read to be consistent
 * DomainClass obj = mapper.load(DomainClass.class, key, new DynamoDBMapperConfig(ConsistentReads.CONSISTENT));
 * // Force this save operation to use putItem rather than updateItem
 * mapper.save(obj, new DynamoDBMapperConfig(SaveBehavior.CLOBBER));
 * // Save the object into a different table
 * mapper.save(obj, new DynamoDBMapperConfig(new TableNameOverride("AnotherTable")));
 * // Delete the object even if the version field is out of date
 * mapper.delete(obj, new DynamoDBMapperConfig(SaveBehavior.CLOBBER));
 * </pre>
 */
public class DynamoDBMapperConfig {

    /**
     * A fluent builder for DynamoDBMapperConfig objects.
     */
    public static class Builder {

        private SaveBehavior saveBehavior;
        private ConsistentReads consistentReads;
        private TableNameOverride tableNameOverride;
        private TableNameResolver tableNameResolver;
        private ObjectTableNameResolver objectTableNameResolver;
        private PaginationLoadingStrategy paginationLoadingStrategy;
        private RequestMetricCollector requestMetricCollector;
        private ConversionSchema conversionSchema;

        /**
         * Creates a new builder initialized with the {@link #DEFAULT} values.
         */
        public Builder() {
            saveBehavior = DEFAULT.getSaveBehavior();
            consistentReads = DEFAULT.getConsistentReads();
            tableNameOverride = DEFAULT.getTableNameOverride();
            tableNameResolver = DEFAULT.getTableNameResolver();
            objectTableNameResolver = DEFAULT.getObjectTableNameResolver();
            paginationLoadingStrategy = DEFAULT.getPaginationLoadingStrategy();
            requestMetricCollector = DEFAULT.getRequestMetricCollector();
            conversionSchema = DEFAULT.getConversionSchema();
        }

        /**
         * @return the currently-configured save behavior
         */
        public SaveBehavior getSaveBehavior() {
            return saveBehavior;
        }

        /**
         * @param value the new save behavior
         */
        public void setSaveBehavior(SaveBehavior value) {
            saveBehavior = value;
        }

        /**
         * @param value the new save behavior
         * @return this builder
         */
        public Builder withSaveBehavior(SaveBehavior value) {
            setSaveBehavior(value);
            return this;
        }


        /**
         * @return the currently-configured consistent read behavior
         */
        public ConsistentReads getConsistentReads() {
            return consistentReads;
        }

        /**
         * @param value the new consistent read behavior
         */
        public void setConsistentReads(ConsistentReads value) {
            consistentReads = value;
        }

        /**
         * @param value the new consistent read behavior
         * @return this builder
         */
        public Builder withConsistentReads(ConsistentReads value) {
            setConsistentReads(value);
            return this;
        }


        /**
         * @return the current table name override
         */
        public TableNameOverride getTableNameOverride() {
            return tableNameOverride;
        }

        /**
         * @param value the new table name override
         */
        public void setTableNameOverride(TableNameOverride value) {
            tableNameOverride = value;
        }

        /**
         * @param value the new table name override
         * @return this builder
         */
        public Builder withTableNameOverride(TableNameOverride value) {
            setTableNameOverride(value);
            return this;
        }


        /**
         * @return the current table name resolver
         */
        public TableNameResolver getTableNameResolver() {
            return tableNameResolver;
        }

        /**
         * @param value the new table name resolver
         */
        public void setTableNameResolver(TableNameResolver value) {
            tableNameResolver = value;
        }

        /**
         * @param value the new table name resolver
         * @return this builder
         */
        public Builder withTableNameResolver(TableNameResolver value) {
            setTableNameResolver(value);
            return this;
        }


        /**
         * @return the current object table name resolver
         */
        public ObjectTableNameResolver getObjectTableNameResolver() {
            return objectTableNameResolver;
        }

        /**
         * @param value the new object table name resolver
         */
        public void setObjectTableNameResolver(ObjectTableNameResolver value) {
            objectTableNameResolver = value;
        }

        /**
         * @param value the new object table name resolver
         * @return this builder
         */
        public Builder withObjectTableNameResolver(ObjectTableNameResolver value) {
            setObjectTableNameResolver(value);
            return this;
        }

        /**
         * @return the currently-configured pagination loading strategy
         */
        public PaginationLoadingStrategy getPaginationLoadingStrategy() {
            return paginationLoadingStrategy;
        }

        /**
         * @param value the new pagination loading strategy
         */
        public void setPaginationLoadingStrategy(
                PaginationLoadingStrategy value) {

            paginationLoadingStrategy = value;
        }

        /**
         * @param value the new pagination loading strategy
         * @return this builder
         */
        public Builder withPaginationLoadingStrategy(
                PaginationLoadingStrategy value) {

            setPaginationLoadingStrategy(value);
            return this;
        }


        /**
         * @return the currently-configured request metric collector
         */
        public RequestMetricCollector getRequestMetricCollector() {
            return requestMetricCollector;
        }

        /**
         * @param value the new request metric collector
         */
        public void setRequestMetricCollector(RequestMetricCollector value) {
            requestMetricCollector = value;
        }

        /**
         * @param value the new request metric collector
         * @return this builder
         */
        public Builder withRequestMetricCollector(RequestMetricCollector value) {
            setRequestMetricCollector(value);
            return this;
        }


        /**
         * @return the current conversion schema
         */
        public ConversionSchema getConversionSchema() {
            return conversionSchema;
        }

        /**
         * @param value the new conversion schema
         */
        public void setConversionSchema(ConversionSchema value) {
            conversionSchema = value;
        }

        /**
         * @param value the new conversion schema
         * @return this builder
         */
        public Builder withConversionSchema(ConversionSchema value) {
            setConversionSchema(value);
            return this;
        }


        /**
         * Builds a new {@code DynamoDBMapperConfig} object.
         *
         * @return the new, immutable config object
         */
        public DynamoDBMapperConfig build() {
            return new DynamoDBMapperConfig(
                    saveBehavior,
                    consistentReads,
                    tableNameOverride,
                    tableNameResolver,
                    objectTableNameResolver,
                    paginationLoadingStrategy,
                    requestMetricCollector,
                    conversionSchema);
        }
    }

    /**
     * Enumeration of behaviors for the save operation.
     */
    public static enum SaveBehavior {
        /**
         * UPDATE will not affect unmodeled attributes on a save operation and a
         * null value for the modeled attribute will remove it from that item in
         * DynamoDB.
         * <p>
         * Because of the limitation of updateItem request, the implementation
         * of UPDATE will send a putItem request when a key-only object is being
         * saved, and it will send another updateItem request if the given
         * key(s) already exists in the table.
         * <p>
         * By default, the mapper uses UPDATE.
         */
        UPDATE,

        /**
         * UPDATE_SKIP_NULL_ATTRIBUTES is similar to UPDATE, except that it
         * ignores any null value attribute(s) and will NOT remove them from
         * that item in DynamoDB. It also guarantees to send only one single
         * updateItem request, no matter the object is key-only or not.
         */
        UPDATE_SKIP_NULL_ATTRIBUTES,

        /**
         * CLOBBER will clear and replace all attributes, included unmodeled
         * ones, (delete and recreate) on save. Versioned field constraints will
         * also be disregarded.
         */
        CLOBBER,

        /**
         * APPEND_SET treats scalar attributes (String, Number, Binary) the same
         * as UPDATE_SKIP_NULL_ATTRIBUTES does. However, for set attributes, it
         * will append to the existing attribute value, instead of overriding
         * it. Caller needs to make sure that the modeled attribute type matches
         * the existing set type, otherwise it would result in a service
         * exception.
         */
        APPEND_SET
    };

    /**
     * Enumeration of consistent read behavior.
     * <p>
     * CONSISTENT uses consistent reads, EVENTUAL does not. Consistent reads
     * have implications for performance and billing; see the service
     * documentation for details.
     * <p>
     * By default, the mapper uses eventual consistency.
     */
    public static enum ConsistentReads {
        CONSISTENT,
        EVENTUAL
    };

    /**
     * Enumeration of pagination loading strategy.
     */
    public static enum PaginationLoadingStrategy {
        /**
         * Paginated list is lazily loaded when possible, and all loaded results
         * are kept in the memory.
         * <p>
         * By default, the mapper uses LAZY_LOADING.
         */
        LAZY_LOADING,

        /**
         * Only supports using iterator to read from the paginated list. All
         * other list operations will return UnsupportedOperationException
         * immediately. During the iteration, the list will clear all the
         * previous results before loading the next page, so that the list will
         * keep at most one page of the loaded results in memory. This also
         * means the list could only be iterated once.
         * <p>
         * Use this configuration to reduce the memory overhead when handling
         * large DynamoDB items.
         */
        ITERATION_ONLY,

        /**
         * Paginated list will eagerly load all the paginated results from
         * DynamoDB as soon as the list is initialized.
         */
        EAGER_LOADING
    }

    /**
     * Allows overriding the table name declared on a domain class by the
     * {@link DynamoDBTable} annotation.
     */
    public static final class TableNameOverride {

        private final String tableNameOverride;
        private final String tableNamePrefix;

        /**
         * Returns a new {@link TableNameOverride} object that will prepend the
         * given string to every table name.
         */
        public static TableNameOverride withTableNamePrefix(
                String tableNamePrefix) {

            return new TableNameOverride(null, tableNamePrefix);
        }

        /**
         * Returns a new {@link TableNameOverride} object that will replace
         * every table name in requests with the given string.
         */
        public static TableNameOverride withTableNameReplacement(
                String tableNameReplacement) {

            return new TableNameOverride(tableNameReplacement, null);
        }

        private TableNameOverride(
                String tableNameOverride,
                String tableNamePrefix) {

            this.tableNameOverride = tableNameOverride;
            this.tableNamePrefix = tableNamePrefix;
        }

        /**
         * @see TableNameOverride#withTableNameReplacement(String)
         */
        public TableNameOverride(String tableNameOverride) {
            this(tableNameOverride, null);
        }

        /**
         * Returns the table name to use for all requests. Exclusive with
         * {@link TableNameOverride#getTableNamePrefix()}
         *
         * @see DynamoDBMapperConfig#getTableNameOverride()
         */
        public String getTableName() {
            return tableNameOverride;
        }

        /**
         * Returns the table name prefix to prepend the table name for all
         * requests. Exclusive with {@link TableNameOverride#getTableName()}
         *
         * @see DynamoDBMapperConfig#getTableNameOverride()
         */
        public String getTableNamePrefix() {
            return tableNamePrefix;
        }
    }

    /**
     * Interface for a strategy used to determine the table name of an object based on it's class.
     * This resolver is used when an object isn't available such as in
     * {@link DynamoDBMapper#query(Class, DynamoDBQueryExpression)}
     *
     * @see ObjectTableNameResolver
     * @author Raniz
     */
    public static interface TableNameResolver {

        /**
         * Get the table name for a class. This method is used when an object is not available
         * such as when creating requests for scan or query operations.
         *
         * @param clazz The class to get the table name for
         * @param config The {@link DynamoDBMapperConfig}
         * @return The table name to use for instances of clazz
         */
        public String getTableName(Class<?> clazz, DynamoDBMapperConfig config);
    }

    /**
     * Interface for a strategy used to determine the table name of an object based on it's class.
     * This resolver is used when an object is available such as in
     * {@link DynamoDBMapper#batchLoad(java.util.List)}.
     *
     * If no table name resolver for objects is set, {@link DynamoDBMapper} reverts to using the
     * {@link TableNameResolver} on each object's class.
     *
     * @see TableNameResolver
     * @author Raniz
     */
    public static interface ObjectTableNameResolver {

        /**
         * Get the table name for an object.
         *
         * @param object The object to get the table name for
         * @param config The {@link DynamoDBMapperConfig}
         * @return The table name to use for object
         */
        public String getTableName(Object object, DynamoDBMapperConfig config);

    }

    /**
     * Default implementation of {@link TableNameResolver} that mimics the behavior
     * of DynamoDBMapper before the addition of {@link TableNameResolver}.
     *
     * @author Raniz
     */
    public static class DefaultTableNameResolver implements TableNameResolver {
        public static final DefaultTableNameResolver INSTANCE = new DefaultTableNameResolver();
        private final DynamoDBReflector reflector = new DynamoDBReflector();

        @Override
        public String getTableName(Class<?> clazz, DynamoDBMapperConfig config) {
            final TableNameOverride override = config.getTableNameOverride();

            if (override != null) {
                final String tableName = override.getTableName();
                if (tableName != null) {
                    return tableName;
                }
            }

            final String tableName = reflector.getTable(clazz).tableName();
            final String prefix = override == null
                ? null : override.getTableNamePrefix();
            return prefix == null ? tableName : prefix + tableName;
        }
    }

    private final SaveBehavior saveBehavior;
    private final ConsistentReads consistentReads;
    private final TableNameOverride tableNameOverride;
    private final TableNameResolver tableNameResolver;
    private final ObjectTableNameResolver objectTableNameResolver;
    private final PaginationLoadingStrategy paginationLoadingStrategy;
    private final RequestMetricCollector requestMetricCollector;
    private final ConversionSchema conversionSchema;

    /**
     * Legacy constructor, using default PaginationLoadingStrategy
     * @deprecated in favor of the fluent {@link Builder}
     **/
    @Deprecated
    public DynamoDBMapperConfig(
            SaveBehavior saveBehavior,
            ConsistentReads consistentReads,
            TableNameOverride tableNameOverride) {

        this(saveBehavior, consistentReads, tableNameOverride, null, null);
    }

    /**
     * Constructs a new configuration object with the save behavior, consistent
     * read behavior, and table name override given.
     *
     * @param saveBehavior
     *            The {@link SaveBehavior} to use, or null for default.
     * @param consistentReads
     *            The {@link ConsistentReads} to use, or null for default.
     * @param tableNameOverride
     *            An override for the table name, or null for no override.
     * @param paginationLoadingStrategy
     *            The pagination loading strategy, or null for default.
     * @deprecated in favor of the fluent {@code Builder}
     */
    @Deprecated
    public DynamoDBMapperConfig(
            SaveBehavior saveBehavior,
            ConsistentReads consistentReads,
            TableNameOverride tableNameOverride,
            PaginationLoadingStrategy paginationLoadingStrategy) {
        this(saveBehavior, consistentReads, tableNameOverride,
                paginationLoadingStrategy, null);
    }

    /**
     * Constructs a new configuration object with the save behavior, consistent
     * read behavior, and table name override given.
     *
     * @param saveBehavior
     *            The {@link SaveBehavior} to use, or null for default.
     * @param consistentReads
     *            The {@link ConsistentReads} to use, or null for default.
     * @param tableNameOverride
     *            An override for the table name, or null for no override.
     * @param paginationLoadingStrategy
     *            The pagination loading strategy, or null for default.
     * @param requestMetricCollector
     *            optional request metric collector
     * @deprecated in favor of the fluent {@code Builder}
     */
    @Deprecated
    public DynamoDBMapperConfig(
            SaveBehavior saveBehavior,
            ConsistentReads consistentReads,
            TableNameOverride tableNameOverride,
            PaginationLoadingStrategy paginationLoadingStrategy,
            RequestMetricCollector requestMetricCollector) {

        this(saveBehavior,
                consistentReads,
                tableNameOverride,
                null,
                null,
                paginationLoadingStrategy,
                requestMetricCollector,
                ConversionSchemas.DEFAULT);
    }

    private DynamoDBMapperConfig(
            SaveBehavior saveBehavior,
            ConsistentReads consistentReads,
            TableNameOverride tableNameOverride,
            TableNameResolver tableNameResolver,
            ObjectTableNameResolver objectTableNameResolver,
            PaginationLoadingStrategy paginationLoadingStrategy,
            RequestMetricCollector requestMetricCollector,
            ConversionSchema conversionSchema) {

        this.saveBehavior = saveBehavior;
        this.consistentReads = consistentReads;
        this.tableNameOverride = tableNameOverride;
        this.tableNameResolver = tableNameResolver;
        this.objectTableNameResolver = objectTableNameResolver;
        this.paginationLoadingStrategy = paginationLoadingStrategy;
        this.requestMetricCollector = requestMetricCollector;
        this.conversionSchema = conversionSchema;
    }

    /**
     * Constructs a new configuration object with the save behavior given.
     */
    public DynamoDBMapperConfig(SaveBehavior saveBehavior) {
        this(saveBehavior, null, null, null, null, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the consistent read behavior
     * given.
     */
    public DynamoDBMapperConfig(ConsistentReads consistentReads) {
        this(null, consistentReads, null, null, null, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the table name override given.
     */
    public DynamoDBMapperConfig(TableNameOverride tableNameOverride) {
        this(null, null, tableNameOverride, null, null, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the table name resolver strategy given.
     */
    public DynamoDBMapperConfig(TableNameResolver tableNameResolver) {
        this(null, null, null, tableNameResolver, null, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the object table name resolver strategy given.
     */
    public DynamoDBMapperConfig(ObjectTableNameResolver objectTableNameResolver) {
        this(null, null, null, null, objectTableNameResolver, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the table name resolver strategies given.
     */
    public DynamoDBMapperConfig(TableNameResolver tableNameResolver, ObjectTableNameResolver objectTableNameResolver) {
        this(null, null, null, tableNameResolver, objectTableNameResolver, null, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the pagination loading
     * strategy given.
     */
    public DynamoDBMapperConfig(
            PaginationLoadingStrategy paginationLoadingStrategy) {

        this(null, null, null, null, null, paginationLoadingStrategy, null,
                ConversionSchemas.DEFAULT);
    }

    /**
     * Constructs a new configuration object with the conversion schema given.
     */
    public DynamoDBMapperConfig(ConversionSchema conversionSchema) {
        this(null, null, null, null, null, null, null, conversionSchema);
    }

    /**
     * Constructs a new configuration object from two others: a set of defaults
     * and a set of overrides. Any non-null overrides will be applied to the
     * defaults.
     * <p>
     * Used internally to merge the {@link DynamoDBMapperConfig} provided at
     * construction with an overriding object for a particular operation.
     *
     * @param defaults
     *            The default mapper configuration values.
     * @param overrides
     *            The overridden mapper configuration values. Any non-null
     *            config settings will be applied to the returned object.
     */
    public DynamoDBMapperConfig(
            DynamoDBMapperConfig defaults,
            DynamoDBMapperConfig overrides) {

        if ( overrides == null ) {

            this.saveBehavior = defaults.getSaveBehavior();
            this.consistentReads = defaults.getConsistentReads();
            this.tableNameOverride = defaults.getTableNameOverride();
            this.tableNameResolver = defaults.getTableNameResolver();
            this.objectTableNameResolver = defaults.getObjectTableNameResolver();
            this.paginationLoadingStrategy =
                    defaults.getPaginationLoadingStrategy();
            this.requestMetricCollector = defaults.getRequestMetricCollector();
            this.conversionSchema = defaults.getConversionSchema();

        } else {

            this.saveBehavior = (overrides.getSaveBehavior() == null)
                    ? defaults.getSaveBehavior()
                    : overrides.getSaveBehavior();

            this.consistentReads = (overrides.getConsistentReads() == null)
                    ? defaults.getConsistentReads()
                    : overrides.getConsistentReads();

            this.tableNameOverride = (overrides.getTableNameOverride() == null)
                    ? defaults.getTableNameOverride()
                    : overrides.getTableNameOverride();

            this.tableNameResolver = (overrides.getTableNameResolver() == null)
                    ? defaults.getTableNameResolver()
                    : overrides.getTableNameResolver();

            this.objectTableNameResolver = (overrides.getObjectTableNameResolver() == null)
                    ? defaults.getObjectTableNameResolver()
                    : overrides.getObjectTableNameResolver();

            this.paginationLoadingStrategy =
                    (overrides.getPaginationLoadingStrategy() == null)
                    ? defaults.getPaginationLoadingStrategy()
                    : overrides.getPaginationLoadingStrategy();

            this.requestMetricCollector =
                    (overrides.getRequestMetricCollector() == null)
                    ? defaults.getRequestMetricCollector()
                    : overrides.getRequestMetricCollector();

            this.conversionSchema = (overrides.getConversionSchema() == null)
                    ? defaults.getConversionSchema()
                    : overrides.getConversionSchema();

        }
    }

    /**
     * Returns the save behavior for this configuration.
     */
    public SaveBehavior getSaveBehavior() {
        return saveBehavior;
    }

    /**
     * Returns the consistent read behavior for this configuration.
     */
    public ConsistentReads getConsistentReads() {
        return consistentReads;
    }

    /**
     * Returns the table name override for this configuration. This value will
     * override the table name specified in a {@link DynamoDBTable} annotation,
     * either by replacing the table name entirely or else by pre-pending a
     * string to each table name. This is useful for partitioning data in
     * multiple tables at runtime.
     *
     * @see TableNameOverride#withTableNamePrefix(String)
     * @see TableNameOverride#withTableNameReplacement(String)
     */
    public TableNameOverride getTableNameOverride() {
        return tableNameOverride;
    }

    /**
     * Returns the table name resolver for this configuration. This value will
     * be used to determine the table name for classes. It can be
     * used for more powerful customization of table name than is possible using
     * only {@link TableNameOverride}.
     *
     * @see TableNameResolver#getTableName(Class, DynamoDBMapperConfig)
     */
    public TableNameResolver getTableNameResolver() {
        return tableNameResolver;
    }

    /**
     * Returns the object table name resolver for this configuration. This value will
     * be used to determine the table name for objects. It can be
     * used for more powerful customization of table name than is possible using
     * only {@link TableNameOverride}.
     *
     * @see ObjectTableNameResolver#getTableName(Object, DynamoDBMapperConfig)
     */
    public ObjectTableNameResolver getObjectTableNameResolver() {
        return objectTableNameResolver;
    }

    /**
     * Returns the pagination loading strategy for this configuration.
     */
    public PaginationLoadingStrategy getPaginationLoadingStrategy() {
        return paginationLoadingStrategy;
    }

    /**
     * Returns the request metric collector or null if not specified.
     */
    public RequestMetricCollector getRequestMetricCollector() {
        return requestMetricCollector;
    }

    /**
     * @return the conversion schema for this config object
     */
    public ConversionSchema getConversionSchema() {
        return conversionSchema;
    }

    /**
     * Default configuration uses UPDATE behavior for saves and EVENTUALly
     * consistent reads, with no table name override and lazy-loading strategy.
     */
    public static final DynamoDBMapperConfig DEFAULT = new DynamoDBMapperConfig(
            SaveBehavior.UPDATE,
            ConsistentReads.EVENTUAL,
            null,  // TableNameOverride
            null, // TableNameResolver
            null, // ObjectTableNameResolver
            PaginationLoadingStrategy.LAZY_LOADING,
            null,  // RequestMetricCollector
            ConversionSchemas.DEFAULT);
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/AmazonElasticFileSystem.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.elasticfilesystem.model.*;

/**
 * Interface for accessing AmazonElasticFileSystem.
 * Amazon Elastic File System
 */
public interface AmazonElasticFileSystem {

    /**
     * Overrides the default endpoint for this client ("elasticfilesystem.us-east-1.amazonaws.com").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "elasticfilesystem.us-east-1.amazonaws.com") or a full
     * URL, including the protocol (ex: "elasticfilesystem.us-east-1.amazonaws.com"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "elasticfilesystem.us-east-1.amazonaws.com") or a full URL,
     *            including the protocol (ex: "elasticfilesystem.us-east-1.amazonaws.com") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonElasticFileSystem#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the CreateFileSystem service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws FileSystemAlreadyExistsException
     * @throws FileSystemLimitExceededException
     * @throws BadRequestException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateFileSystemResult createFileSystem(CreateFileSystemRequest createFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget service method on
     *           AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws DependencyTimeoutException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteMountTarget(DeleteMountTargetRequest deleteMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeFileSystems service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeFileSystemsResult describeFileSystems(DescribeFileSystemsRequest describeFileSystemsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void createTags(CreateTagsRequest createTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem service method on
     *           AmazonElasticFileSystem.
     * 
     * 
     * @throws FileSystemInUseException
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteFileSystem(DeleteFileSystemRequest deleteFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeMountTargets service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeMountTargetsResult describeMountTargets(DescribeMountTargetsRequest describeMountTargetsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the CreateMountTarget service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws SecurityGroupLimitExceededException
     * @throws IncorrectFileSystemLifeCycleStateException
     * @throws SubnetNotFoundException
     * @throws BadRequestException
     * @throws MountTargetConflictException
     * @throws SecurityGroupNotFoundException
     * @throws FileSystemNotFoundException
     * @throws NoFreeAddressesInSubnetException
     * @throws IpAddressInUseException
     * @throws NetworkInterfaceLimitExceededException
     * @throws UnsupportedAvailabilityZoneException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateMountTargetResult createMountTarget(CreateMountTargetRequest createMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           service method on AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeMountTargetSecurityGroups
     *         service method, as returned by AmazonElasticFileSystem.
     * 
     * @throws IncorrectMountTargetStateException
     * @throws BadRequestException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeMountTargetSecurityGroupsResult describeMountTargetSecurityGroups(DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws IncorrectMountTargetStateException
     * @throws SecurityGroupLimitExceededException
     * @throws BadRequestException
     * @throws SecurityGroupNotFoundException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void modifyMountTargetSecurityGroups(ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags service method on AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeTags service method, as returned
     *         by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeTagsResult describeTags(DescribeTagsRequest describeTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteTags(DeleteTagsRequest deleteTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     * 
     * @return The response from the DescribeFileSystems service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeFileSystemsResult describeFileSystems() throws AmazonServiceException, AmazonClientException;
    
    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/AmazonElasticFileSystemAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.elasticfilesystem.model.*;

/**
 * Interface for accessing AmazonElasticFileSystem asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * Amazon Elastic File System
 */
public interface AmazonElasticFileSystemAsync extends AmazonElasticFileSystem {
    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateFileSystemResult> createFileSystemAsync(CreateFileSystemRequest createFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateFileSystemResult> createFileSystemAsync(CreateFileSystemRequest createFileSystemRequest,
            AsyncHandler<CreateFileSystemRequest, CreateFileSystemResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteMountTargetAsync(DeleteMountTargetRequest deleteMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteMountTargetAsync(DeleteMountTargetRequest deleteMountTargetRequest,
            AsyncHandler<DeleteMountTargetRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems operation on
     *           AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeFileSystems service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeFileSystemsResult> describeFileSystemsAsync(DescribeFileSystemsRequest describeFileSystemsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems operation on
     *           AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeFileSystems service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeFileSystemsResult> describeFileSystemsAsync(DescribeFileSystemsRequest describeFileSystemsRequest,
            AsyncHandler<DescribeFileSystemsRequest, DescribeFileSystemsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> createTagsAsync(CreateTagsRequest createTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> createTagsAsync(CreateTagsRequest createTagsRequest,
            AsyncHandler<CreateTagsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteFileSystemAsync(DeleteFileSystemRequest deleteFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteFileSystemAsync(DeleteFileSystemRequest deleteFileSystemRequest,
            AsyncHandler<DeleteFileSystemRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets operation on
     *           AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargets service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetsResult> describeMountTargetsAsync(DescribeMountTargetsRequest describeMountTargetsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets operation on
     *           AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargets service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetsResult> describeMountTargetsAsync(DescribeMountTargetsRequest describeMountTargetsRequest,
            AsyncHandler<DescribeMountTargetsRequest, DescribeMountTargetsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateMountTargetResult> createMountTargetAsync(CreateMountTargetRequest createMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateMountTargetResult> createMountTargetAsync(CreateMountTargetRequest createMountTargetRequest,
            AsyncHandler<CreateMountTargetRequest, CreateMountTargetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetSecurityGroupsResult> describeMountTargetSecurityGroupsAsync(DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetSecurityGroupsResult> describeMountTargetSecurityGroupsAsync(DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest,
            AsyncHandler<DescribeMountTargetSecurityGroupsRequest, DescribeMountTargetSecurityGroupsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         ModifyMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> modifyMountTargetSecurityGroupsAsync(ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ModifyMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> modifyMountTargetSecurityGroupsAsync(ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest,
            AsyncHandler<ModifyMountTargetSecurityGroupsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeTagsResult> describeTagsAsync(DescribeTagsRequest describeTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeTagsResult> describeTagsAsync(DescribeTagsRequest describeTagsRequest,
            AsyncHandler<DescribeTagsRequest, DescribeTagsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteTagsAsync(DeleteTagsRequest deleteTagsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteTagsAsync(DeleteTagsRequest deleteTagsRequest,
            AsyncHandler<DeleteTagsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/AmazonElasticFileSystemAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.elasticfilesystem.model.*;

/**
 * Asynchronous client for accessing AmazonElasticFileSystem.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * Amazon Elastic File System
 */
public class AmazonElasticFileSystemAsyncClient extends AmazonElasticFileSystemClient
        implements AmazonElasticFileSystemAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonElasticFileSystemAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonElasticFileSystem
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonElasticFileSystemAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonElasticFileSystemAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateFileSystemResult> createFileSystemAsync(final CreateFileSystemRequest createFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateFileSystemResult>() {
            public CreateFileSystemResult call() throws Exception {
                return createFileSystem(createFileSystemRequest);
        }
    });
    }

    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateFileSystemResult> createFileSystemAsync(
            final CreateFileSystemRequest createFileSystemRequest,
            final AsyncHandler<CreateFileSystemRequest, CreateFileSystemResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateFileSystemResult>() {
            public CreateFileSystemResult call() throws Exception {
              CreateFileSystemResult result;
                try {
                result = createFileSystem(createFileSystemRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createFileSystemRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteMountTargetAsync(final DeleteMountTargetRequest deleteMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteMountTarget(deleteMountTargetRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteMountTargetAsync(
            final DeleteMountTargetRequest deleteMountTargetRequest,
            final AsyncHandler<DeleteMountTargetRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteMountTarget(deleteMountTargetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteMountTargetRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems operation on
     *           AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeFileSystems service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeFileSystemsResult> describeFileSystemsAsync(final DescribeFileSystemsRequest describeFileSystemsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeFileSystemsResult>() {
            public DescribeFileSystemsResult call() throws Exception {
                return describeFileSystems(describeFileSystemsRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems operation on
     *           AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeFileSystems service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeFileSystemsResult> describeFileSystemsAsync(
            final DescribeFileSystemsRequest describeFileSystemsRequest,
            final AsyncHandler<DescribeFileSystemsRequest, DescribeFileSystemsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeFileSystemsResult>() {
            public DescribeFileSystemsResult call() throws Exception {
              DescribeFileSystemsResult result;
                try {
                result = describeFileSystems(describeFileSystemsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeFileSystemsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> createTagsAsync(final CreateTagsRequest createTagsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                createTags(createTagsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> createTagsAsync(
            final CreateTagsRequest createTagsRequest,
            final AsyncHandler<CreateTagsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                createTags(createTagsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createTagsRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteFileSystemAsync(final DeleteFileSystemRequest deleteFileSystemRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteFileSystem(deleteFileSystemRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteFileSystem service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteFileSystemAsync(
            final DeleteFileSystemRequest deleteFileSystemRequest,
            final AsyncHandler<DeleteFileSystemRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteFileSystem(deleteFileSystemRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteFileSystemRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets operation on
     *           AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargets service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetsResult> describeMountTargetsAsync(final DescribeMountTargetsRequest describeMountTargetsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeMountTargetsResult>() {
            public DescribeMountTargetsResult call() throws Exception {
                return describeMountTargets(describeMountTargetsRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets operation on
     *           AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargets service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetsResult> describeMountTargetsAsync(
            final DescribeMountTargetsRequest describeMountTargetsRequest,
            final AsyncHandler<DescribeMountTargetsRequest, DescribeMountTargetsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeMountTargetsResult>() {
            public DescribeMountTargetsResult call() throws Exception {
              DescribeMountTargetsResult result;
                try {
                result = describeMountTargets(describeMountTargetsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeMountTargetsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         CreateMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateMountTargetResult> createMountTargetAsync(final CreateMountTargetRequest createMountTargetRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateMountTargetResult>() {
            public CreateMountTargetResult call() throws Exception {
                return createMountTarget(createMountTargetRequest);
        }
    });
    }

    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateMountTarget service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateMountTargetResult> createMountTargetAsync(
            final CreateMountTargetRequest createMountTargetRequest,
            final AsyncHandler<CreateMountTargetRequest, CreateMountTargetResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateMountTargetResult>() {
            public CreateMountTargetResult call() throws Exception {
              CreateMountTargetResult result;
                try {
                result = createMountTarget(createMountTargetRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createMountTargetRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetSecurityGroupsResult> describeMountTargetSecurityGroupsAsync(final DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeMountTargetSecurityGroupsResult>() {
            public DescribeMountTargetSecurityGroupsResult call() throws Exception {
                return describeMountTargetSecurityGroups(describeMountTargetSecurityGroupsRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeMountTargetSecurityGroupsResult> describeMountTargetSecurityGroupsAsync(
            final DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest,
            final AsyncHandler<DescribeMountTargetSecurityGroupsRequest, DescribeMountTargetSecurityGroupsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeMountTargetSecurityGroupsResult>() {
            public DescribeMountTargetSecurityGroupsResult call() throws Exception {
              DescribeMountTargetSecurityGroupsResult result;
                try {
                result = describeMountTargetSecurityGroups(describeMountTargetSecurityGroupsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeMountTargetSecurityGroupsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         ModifyMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> modifyMountTargetSecurityGroupsAsync(final ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                modifyMountTargetSecurityGroups(modifyMountTargetSecurityGroupsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ModifyMountTargetSecurityGroups service method, as returned by
     *         AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> modifyMountTargetSecurityGroupsAsync(
            final ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest,
            final AsyncHandler<ModifyMountTargetSecurityGroupsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                modifyMountTargetSecurityGroups(modifyMountTargetSecurityGroupsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(modifyMountTargetSecurityGroupsRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeTagsResult> describeTagsAsync(final DescribeTagsRequest describeTagsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeTagsResult>() {
            public DescribeTagsResult call() throws Exception {
                return describeTags(describeTagsRequest);
        }
    });
    }

    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeTagsResult> describeTagsAsync(
            final DescribeTagsRequest describeTagsRequest,
            final AsyncHandler<DescribeTagsRequest, DescribeTagsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeTagsResult>() {
            public DescribeTagsResult call() throws Exception {
              DescribeTagsResult result;
                try {
                result = describeTags(describeTagsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeTagsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags operation on AmazonElasticFileSystem.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteTagsAsync(final DeleteTagsRequest deleteTagsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteTags(deleteTagsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags operation on AmazonElasticFileSystem.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteTags service method, as returned by AmazonElasticFileSystem.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteTagsAsync(
            final DeleteTagsRequest deleteTagsRequest,
            final AsyncHandler<DeleteTagsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteTags(deleteTagsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteTagsRequest, null);
                 return null;
        }
    });
    }
    
}
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/AmazonElasticFileSystemClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem;

import java.net.*;
import java.util.*;

import org.apache.commons.logging.*;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.regions.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;
import com.amazonaws.util.json.*;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.services.elasticfilesystem.model.transform.*;

/**
 * Client for accessing AmazonElasticFileSystem.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * Amazon Elastic File System
 */
public class AmazonElasticFileSystemClient extends AmazonWebServiceClient implements AmazonElasticFileSystem {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    private static final Log log = LogFactory.getLog(AmazonElasticFileSystem.class);

    /**
     * List of exception unmarshallers for all AmazonElasticFileSystem exceptions.
     */
    protected List<JsonErrorUnmarshaller> jsonErrorUnmarshallers;

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonElasticFileSystemClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonElasticFileSystem
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonElasticFileSystemClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonElasticFileSystemClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonElasticFileSystem
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonElasticFileSystemClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(adjustClientConfiguration(clientConfiguration));
        
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials provider.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonElasticFileSystemClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * provider and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonElasticFileSystem
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonElasticFileSystemClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonElasticFileSystem using the specified AWS account credentials
     * provider, client configuration options and request metric collector.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonElasticFileSystem
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonElasticFileSystemClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
        
        this.awsCredentialsProvider = awsCredentialsProvider;
        
        init();
    }

    private void init() {
        jsonErrorUnmarshallers = new ArrayList<JsonErrorUnmarshaller>();
        jsonErrorUnmarshallers.add(new SecurityGroupNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new FileSystemNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new MountTargetNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new IpAddressInUseExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new FileSystemLimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new IncorrectFileSystemLifeCycleStateExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new SubnetNotFoundExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new DependencyTimeoutExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new InternalServerErrorExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new IncorrectMountTargetStateExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new FileSystemAlreadyExistsExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NoFreeAddressesInSubnetExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new MountTargetConflictExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new UnsupportedAvailabilityZoneExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new NetworkInterfaceLimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new FileSystemInUseExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new SecurityGroupLimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new BadRequestExceptionUnmarshaller());
        
        jsonErrorUnmarshallers.add(new JsonErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("elasticfilesystem.us-east-1.amazonaws.com");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/elasticfilesystem/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/elasticfilesystem/request.handler2s"));
    }

    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
        ClientConfiguration config = orig;
        
        return config;
    }

    /**
     * <p>
     * Creates a new, empty file system. The operation requires a creation
     * token in the request that Amazon EFS uses to ensure idempotent
     * creation (calling the operation with same creation token has no
     * effect). If a file system does not currently exist that is owned by
     * the caller's AWS account with the specified creation token, this
     * operation does the following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new, empty file system. The file system will have an
     * Amazon EFS assigned ID, and an initial lifecycle state "creating".
     * </li>
     * <li> Returns with the description of the created file system. </li>
     * 
     * </ul>
     * <p>
     * Otherwise, this operation returns a
     * <code>FileSystemAlreadyExists</code> error with the ID of the existing
     * file system.
     * </p>
     * <p>
     * <b>NOTE:</b>For basic use cases, you can use a randomly generated
     * UUID for the creation token.
     * </p>
     * <p>
     * The idempotent operation allows you to retry a
     * <code>CreateFileSystem</code> call without risk of creating an extra
     * file system. This can happen when an initial call fails in a way that
     * leaves it uncertain whether or not a file system was actually created.
     * An example might be that a transport level timeout occurred or your
     * connection was reset. As long as you use the same creation token, if
     * the initial call had succeeded in creating a file system, the client
     * can learn of its existence from the
     * <code>FileSystemAlreadyExists</code> error.
     * </p>
     * <p>
     * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
     * lifecycle state is still "creating". You can check the file system
     * creation status by calling the DescribeFileSystems API, which among
     * other things returns the file system state.
     * </p>
     * <p>
     * After the file system is fully created, Amazon EFS sets its lifecycle
     * state to "available", at which point you can create one or more mount
     * targets for the file system (CreateMountTarget) in your VPC. You mount
     * your Amazon EFS file system on an EC2 instances in your VPC via the
     * mount target. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * 
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateFileSystem</code> action.
     * </p>
     *
     * @param createFileSystemRequest Container for the necessary parameters
     *           to execute the CreateFileSystem service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the CreateFileSystem service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws FileSystemAlreadyExistsException
     * @throws FileSystemLimitExceededException
     * @throws BadRequestException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateFileSystemResult createFileSystem(CreateFileSystemRequest createFileSystemRequest) {
        ExecutionContext executionContext = createExecutionContext(createFileSystemRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateFileSystemRequest> request = null;
        Response<CreateFileSystemResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateFileSystemRequestMarshaller().marshall(super.beforeMarshalling(createFileSystemRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<CreateFileSystemResult, JsonUnmarshallerContext> unmarshaller =
                new CreateFileSystemResultJsonUnmarshaller();
            JsonResponseHandler<CreateFileSystemResult> responseHandler =
                new JsonResponseHandler<CreateFileSystemResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Deletes the specified mount target.
     * </p>
     * <p>
     * This operation forcibly breaks any mounts of the file system via the
     * mount target being deleted, which might disrupt instances or
     * applications using those mounts. To avoid applications getting cut off
     * abruptly, you might consider unmounting any mounts of the mount
     * target, if feasible. The operation also deletes the associated network
     * interface. Uncommitted writes may be lost, but breaking a mount target
     * using this operation does not corrupt the file system itself. The file
     * system you created remains. You can mount an EC2 instance in your VPC
     * using another mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
     * state is still "deleting". You can check the mount target deletion by
     * calling the DescribeMountTargets API, which returns a list of mount
     * target descriptions for the given file system.
     * </p>
     * <p>
     * The operation also requires permission for the following Amazon EC2
     * action on the mount target's network interface:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DeleteNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param deleteMountTargetRequest Container for the necessary parameters
     *           to execute the DeleteMountTarget service method on
     *           AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws DependencyTimeoutException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteMountTarget(DeleteMountTargetRequest deleteMountTargetRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteMountTargetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteMountTargetRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteMountTargetRequestMarshaller().marshall(super.beforeMarshalling(deleteMountTargetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     *
     * @param describeFileSystemsRequest Container for the necessary
     *           parameters to execute the DescribeFileSystems service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeFileSystems service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeFileSystemsResult describeFileSystems(DescribeFileSystemsRequest describeFileSystemsRequest) {
        ExecutionContext executionContext = createExecutionContext(describeFileSystemsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeFileSystemsRequest> request = null;
        Response<DescribeFileSystemsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeFileSystemsRequestMarshaller().marshall(super.beforeMarshalling(describeFileSystemsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeFileSystemsResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeFileSystemsResultJsonUnmarshaller();
            JsonResponseHandler<DescribeFileSystemsResult> responseHandler =
                new JsonResponseHandler<DescribeFileSystemsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Creates or overwrites tags associated with a file system. Each tag is
     * a key-value pair. If a tag key specified in the request already exists
     * on the file system, this operation overwrites its value with the value
     * provided in the request. If you add the "Name" tag to your file
     * system, Amazon EFS returns it in the response to the
     * DescribeFileSystems API.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:CreateTags</code> action.
     * </p>
     *
     * @param createTagsRequest Container for the necessary parameters to
     *           execute the CreateTags service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void createTags(CreateTagsRequest createTagsRequest) {
        ExecutionContext executionContext = createExecutionContext(createTagsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateTagsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateTagsRequestMarshaller().marshall(super.beforeMarshalling(createTagsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Deletes a file system, permanently severing access to its contents.
     * Upon return, the file system no longer exists and you will not be able
     * to access any contents of the deleted file system.
     * </p>
     * <p>
     * You cannot delete a file system that is in use. That is, if the file
     * system has any mount targets, you must first delete them. For more
     * information, see DescribeMountTargets and DeleteMountTarget.
     * </p>
     * <p>
     * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
     * state is still "deleting". You can check the file system deletion
     * status by calling the DescribeFileSystems API, which returns a list of
     * file systems in your account. If you pass file system ID or creation
     * token for the deleted file system, the DescribeFileSystems will return
     * a 404 "FileSystemNotFound" error.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteFileSystem</code> action.
     * </p>
     *
     * @param deleteFileSystemRequest Container for the necessary parameters
     *           to execute the DeleteFileSystem service method on
     *           AmazonElasticFileSystem.
     * 
     * 
     * @throws FileSystemInUseException
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteFileSystem(DeleteFileSystemRequest deleteFileSystemRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteFileSystemRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteFileSystemRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteFileSystemRequestMarshaller().marshall(super.beforeMarshalling(deleteFileSystemRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Returns the descriptions of the current mount targets for a file
     * system. The order of mount targets returned in the response is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
     * system <code>FileSystemId</code> .
     * </p>
     *
     * @param describeMountTargetsRequest Container for the necessary
     *           parameters to execute the DescribeMountTargets service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeMountTargets service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeMountTargetsResult describeMountTargets(DescribeMountTargetsRequest describeMountTargetsRequest) {
        ExecutionContext executionContext = createExecutionContext(describeMountTargetsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeMountTargetsRequest> request = null;
        Response<DescribeMountTargetsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeMountTargetsRequestMarshaller().marshall(super.beforeMarshalling(describeMountTargetsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeMountTargetsResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeMountTargetsResultJsonUnmarshaller();
            JsonResponseHandler<DescribeMountTargetsResult> responseHandler =
                new JsonResponseHandler<DescribeMountTargetsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Creates a mount target for a file system. You can then mount the file
     * system on EC2 instances via the mount target.
     * </p>
     * <p>
     * You can create one mount target in each Availability Zone in your
     * VPC. All EC2 instances in a VPC within a given Availability Zone share
     * a single mount target for a given file system. If you have multiple
     * subnets in an Availability Zone, you create a mount target in one of
     * the subnets. EC2 instances do not need to be in the same subnet as the
     * mount target in order to access their file system. For more
     * information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
     * .
     * </p>
     * <p>
     * In the request, you also specify a file system ID for which you are
     * creating the mount target and the file system's lifecycle state must
     * be "available" (see DescribeFileSystems).
     * </p>
     * <p>
     * In the request, you also provide a subnet ID, which serves several
     * purposes:
     * </p>
     * 
     * <ul>
     * <li>It determines the VPC in which Amazon EFS creates the mount
     * target.</li>
     * <li>It determines the Availability Zone in which Amazon EFS creates
     * the mount target. </li>
     * <li>It determines the IP address range from which Amazon EFS selects
     * the IP address of the mount target if you don't specify an IP address
     * in the request. </li>
     * 
     * </ul>
     * <p>
     * After creating the mount target, Amazon EFS returns a response that
     * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
     * You use this IP address when mounting the file system in an EC2
     * instance. You can also use the mount target's DNS name when mounting
     * the file system. The EC2 instance on which you mount the file system
     * via the mount target can resolve the mount target's DNS name to its IP
     * address. For more information, see
     * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
     * 
     * </p>
     * <p>
     * Note that you can create mount targets for a file system in only one
     * VPC, and there can be only one mount target per Availability Zone.
     * That is, if the file system already has one or more mount targets
     * created for it, the request to add another mount target must meet the
     * following requirements:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * The subnet specified in the request must belong to the same VPC as
     * the subnets of the existing mount targets.
     * </p>
     * </li>
     * <li>The subnet specified in the request must not be in the same
     * Availability Zone as any of the subnets of the existing mount
     * targets.</li>
     * 
     * </ul>
     * <p>
     * If the request satisfies the requirements, Amazon EFS does the
     * following:
     * </p>
     * 
     * <ul>
     * <li>Creates a new mount target in the specified subnet. </li>
     * <li>Also creates a new network interface in the subnet as follows:
     * <ul>
     * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
     * assigns that IP address to the network interface. Otherwise, Amazon
     * EFS assigns a free address in the subnet (in the same way that the
     * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
     * request does not specify a primary private IP address).</li>
     * <li>If the request provides <code>SecurityGroups</code> , this
     * network interface is associated with those security groups. Otherwise,
     * it belongs to the default security group for the subnet's VPC.</li>
     * <li>Assigns the description <code>"Mount target fsmt-id for file
     * system fs-id"</code> where <code> fsmt-id </code> is the mount target
     * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
     * <li>Sets the <code>requesterManaged</code> property of the network
     * interface to "true", and the <code>requesterId</code> value to
     * "EFS".</li>
     * 
     * </ul>
     * <p>
     * Each Amazon EFS mount target has one corresponding requestor-managed
     * EC2 network interface. After the network interface is created, Amazon
     * EFS sets the <code>NetworkInterfaceId</code> field in the mount
     * target's description to the network interface ID, and the
     * <code>IpAddress</code> field to its address. If network interface
     * creation fails, the entire <code>CreateMountTarget</code> operation
     * fails.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b>The CreateMountTarget call returns only after creating
     * the network interface, but while the mount target state is still
     * "creating". You can check the mount target creation status by calling
     * the DescribeFileSystems API, which among other things returns the
     * mount target state.
     * </p>
     * <p>
     * We recommend you create a mount target in each of the Availability
     * Zones. There are cost considerations for using a file system in an
     * Availability Zone through a mount target created in another
     * Availability Zone. For more information, go to
     * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
     * product detail page. In addition, by always using a mount target
     * local to the instance's Availability Zone, you eliminate a partial
     * failure scenario; if the Availablity Zone in which your mount target
     * is created goes down, then you won't be able to access your file
     * system through that mount target.
     * </p>
     * <p>
     * This operation requires permission for the following action on the
     * file system:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
     * 
     * </ul>
     * <p>
     * This operation also requires permission for the following Amazon EC2
     * actions:
     * </p>
     * 
     * <ul>
     * <li> <code>ec2:DescribeSubnets</code> </li>
     * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
     * <li> <code>ec2:CreateNetworkInterface</code> </li>
     * 
     * </ul>
     *
     * @param createMountTargetRequest Container for the necessary parameters
     *           to execute the CreateMountTarget service method on
     *           AmazonElasticFileSystem.
     * 
     * @return The response from the CreateMountTarget service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws SecurityGroupLimitExceededException
     * @throws IncorrectFileSystemLifeCycleStateException
     * @throws SubnetNotFoundException
     * @throws BadRequestException
     * @throws MountTargetConflictException
     * @throws SecurityGroupNotFoundException
     * @throws FileSystemNotFoundException
     * @throws NoFreeAddressesInSubnetException
     * @throws IpAddressInUseException
     * @throws NetworkInterfaceLimitExceededException
     * @throws UnsupportedAvailabilityZoneException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateMountTargetResult createMountTarget(CreateMountTargetRequest createMountTargetRequest) {
        ExecutionContext executionContext = createExecutionContext(createMountTargetRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateMountTargetRequest> request = null;
        Response<CreateMountTargetResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateMountTargetRequestMarshaller().marshall(super.beforeMarshalling(createMountTargetRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<CreateMountTargetResult, JsonUnmarshallerContext> unmarshaller =
                new CreateMountTargetResultJsonUnmarshaller();
            JsonResponseHandler<CreateMountTargetResult> responseHandler =
                new JsonResponseHandler<CreateMountTargetResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Returns the security groups currently in effect for a mount target.
     * This operation requires that the network interface of the mount target
     * has been created and the life cycle state of the mount target is not
     * "deleted".
     * </p>
     * <p>
     * This operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param describeMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the DescribeMountTargetSecurityGroups
     *           service method on AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeMountTargetSecurityGroups
     *         service method, as returned by AmazonElasticFileSystem.
     * 
     * @throws IncorrectMountTargetStateException
     * @throws BadRequestException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeMountTargetSecurityGroupsResult describeMountTargetSecurityGroups(DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest) {
        ExecutionContext executionContext = createExecutionContext(describeMountTargetSecurityGroupsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeMountTargetSecurityGroupsRequest> request = null;
        Response<DescribeMountTargetSecurityGroupsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeMountTargetSecurityGroupsRequestMarshaller().marshall(super.beforeMarshalling(describeMountTargetSecurityGroupsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeMountTargetSecurityGroupsResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeMountTargetSecurityGroupsResultJsonUnmarshaller();
            JsonResponseHandler<DescribeMountTargetSecurityGroupsResult> responseHandler =
                new JsonResponseHandler<DescribeMountTargetSecurityGroupsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Modifies the set of security groups in effect for a mount target.
     * </p>
     * <p>
     * When you create a mount target, Amazon EFS also creates a new network
     * interface (see CreateMountTarget). This operation replaces the
     * security groups in effect for the network interface associated with a
     * mount target, with the <code>SecurityGroups</code> provided in the
     * request. This operation requires that the network interface of the
     * mount target has been created and the life cycle state of the mount
     * target is not "deleted".
     * </p>
     * <p>
     * The operation requires permissions for the following actions:
     * </p>
     * 
     * <ul>
     * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
     * action on the mount target's file system. </li>
     * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
     * mount target's network interface. </li>
     * 
     * </ul>
     *
     * @param modifyMountTargetSecurityGroupsRequest Container for the
     *           necessary parameters to execute the ModifyMountTargetSecurityGroups
     *           service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws IncorrectMountTargetStateException
     * @throws SecurityGroupLimitExceededException
     * @throws BadRequestException
     * @throws SecurityGroupNotFoundException
     * @throws MountTargetNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void modifyMountTargetSecurityGroups(ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest) {
        ExecutionContext executionContext = createExecutionContext(modifyMountTargetSecurityGroupsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ModifyMountTargetSecurityGroupsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ModifyMountTargetSecurityGroupsRequestMarshaller().marshall(super.beforeMarshalling(modifyMountTargetSecurityGroupsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Returns the tags associated with a file system. The order of tags
     * returned in the response of one <code>DescribeTags</code> call, and
     * the order of tags returned across the responses of a multi-call
     * iteration (when using pagination), is unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeTags</code> action.
     * </p>
     *
     * @param describeTagsRequest Container for the necessary parameters to
     *           execute the DescribeTags service method on AmazonElasticFileSystem.
     * 
     * @return The response from the DescribeTags service method, as returned
     *         by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeTagsResult describeTags(DescribeTagsRequest describeTagsRequest) {
        ExecutionContext executionContext = createExecutionContext(describeTagsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeTagsRequest> request = null;
        Response<DescribeTagsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeTagsRequestMarshaller().marshall(super.beforeMarshalling(describeTagsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeTagsResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeTagsResultJsonUnmarshaller();
            JsonResponseHandler<DescribeTagsResult> responseHandler =
                new JsonResponseHandler<DescribeTagsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * Deletes the specified tags from a file system. If the
     * <code>DeleteTags</code> request includes a tag key that does not
     * exist, Amazon EFS ignores it; it is not an error. For more information
     * about tags and related restrictions, go to
     * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
     * in the <i>AWS Billing and Cost Management User Guide</i> .
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DeleteTags</code> action.
     * </p>
     *
     * @param deleteTagsRequest Container for the necessary parameters to
     *           execute the DeleteTags service method on AmazonElasticFileSystem.
     * 
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteTags(DeleteTagsRequest deleteTagsRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteTagsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteTagsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteTagsRequestMarshaller().marshall(super.beforeMarshalling(deleteTagsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * Returns the description of a specific Amazon EFS file system if
     * either the file system <code>CreationToken</code> or the
     * <code>FileSystemId</code> is provided; otherwise, returns descriptions
     * of all file systems owned by the caller's AWS account in the AWS
     * region of the endpoint that you're calling.
     * </p>
     * <p>
     * When retrieving all file system descriptions, you can optionally
     * specify the <code>MaxItems</code> parameter to limit the number of
     * descriptions in a response. If more file system descriptions remain,
     * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
     * response. In this case, you should send a subsequent request with the
     * <code>Marker</code> request parameter set to the value of
     * <code>NextMarker</code> .
     * </p>
     * <p>
     * So to retrieve a list of your file system descriptions, the expected
     * usage of this API is an iterative process of first calling
     * <code>DescribeFileSystems</code> without the <code>Marker</code> and
     * then continuing to call it with the <code>Marker</code> parameter set
     * to the value of the <code>NextMarker</code> from the previous response
     * until the response has no <code>NextMarker</code> .
     * </p>
     * <p>
     * Note that the implementation may return fewer than
     * <code>MaxItems</code> file system descriptions while still including a
     * <code>NextMarker</code> value.
     * </p>
     * <p>
     * The order of file systems returned in the response of one
     * <code>DescribeFileSystems</code> call, and the order of file systems
     * returned across the responses of a multi-call iteration, is
     * unspecified.
     * </p>
     * <p>
     * This operation requires permission for the
     * <code>elasticfilesystem:DescribeFileSystems</code> action.
     * </p>
     * 
     * @return The response from the DescribeFileSystems service method, as
     *         returned by AmazonElasticFileSystem.
     * 
     * @throws BadRequestException
     * @throws FileSystemNotFoundException
     * @throws InternalServerErrorException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonElasticFileSystem indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeFileSystemsResult describeFileSystems() throws AmazonServiceException, AmazonClientException {
        return describeFileSystems(new DescribeFileSystemsRequest());
    }

    @Override
    public void setEndpoint(String endpoint) {
        super.setEndpoint(endpoint);
    }

    @Override
    public void setEndpoint(String endpoint, String serviceName, String regionId) throws IllegalArgumentException {
        super.setEndpoint(endpoint, serviceName, regionId);
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext) {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);

        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        AWSCredentials credentials;
        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
        try {
            credentials = awsCredentialsProvider.getCredentials();
        } finally {
            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
        }

        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(jsonErrorUnmarshallers);
        Response<X> result = client.execute(request, responseHandler,
                errorResponseHandler, executionContext);
        return result;
    }
}
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/BadRequestException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the request is malformed or contains an error such as an
 * invalid parameter value or a missing required parameter.
 * </p>
 */        
public class BadRequestException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new BadRequestException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public BadRequestException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/CreateFileSystemRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createFileSystem(CreateFileSystemRequest) CreateFileSystem operation}.
 * <p>
 * Creates a new, empty file system. The operation requires a creation
 * token in the request that Amazon EFS uses to ensure idempotent
 * creation (calling the operation with same creation token has no
 * effect). If a file system does not currently exist that is owned by
 * the caller's AWS account with the specified creation token, this
 * operation does the following:
 * </p>
 * 
 * <ul>
 * <li>Creates a new, empty file system. The file system will have an
 * Amazon EFS assigned ID, and an initial lifecycle state "creating".
 * </li>
 * <li> Returns with the description of the created file system. </li>
 * 
 * </ul>
 * <p>
 * Otherwise, this operation returns a
 * <code>FileSystemAlreadyExists</code> error with the ID of the existing
 * file system.
 * </p>
 * <p>
 * <b>NOTE:</b>For basic use cases, you can use a randomly generated UUID
 * for the creation token.
 * </p>
 * <p>
 * The idempotent operation allows you to retry a
 * <code>CreateFileSystem</code> call without risk of creating an extra
 * file system. This can happen when an initial call fails in a way that
 * leaves it uncertain whether or not a file system was actually created.
 * An example might be that a transport level timeout occurred or your
 * connection was reset. As long as you use the same creation token, if
 * the initial call had succeeded in creating a file system, the client
 * can learn of its existence from the
 * <code>FileSystemAlreadyExists</code> error.
 * </p>
 * <p>
 * <b>NOTE:</b>The CreateFileSystem call returns while the file system's
 * lifecycle state is still "creating". You can check the file system
 * creation status by calling the DescribeFileSystems API, which among
 * other things returns the file system state.
 * </p>
 * <p>
 * After the file system is fully created, Amazon EFS sets its lifecycle
 * state to "available", at which point you can create one or more mount
 * targets for the file system (CreateMountTarget) in your VPC. You mount
 * your Amazon EFS file system on an EC2 instances in your VPC via the
 * mount target. For more information, see
 * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
 * 
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:CreateFileSystem</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createFileSystem(CreateFileSystemRequest)
 */
public class CreateFileSystemRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     * idempotent creation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     */
    private String creationToken;

    /**
     * String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     * idempotent creation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @return String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     *         idempotent creation.
     */
    public String getCreationToken() {
        return creationToken;
    }
    
    /**
     * String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     * idempotent creation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     *         idempotent creation.
     */
    public void setCreationToken(String creationToken) {
        this.creationToken = creationToken;
    }
    
    /**
     * String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     * idempotent creation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken String of up to 64 ASCII characters. Amazon EFS uses this to ensure
     *         idempotent creation.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemRequest withCreationToken(String creationToken) {
        this.creationToken = creationToken;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getCreationToken() != null) sb.append("CreationToken: " + getCreationToken() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getCreationToken() == null) ? 0 : getCreationToken().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateFileSystemRequest == false) return false;
        CreateFileSystemRequest other = (CreateFileSystemRequest)obj;
        
        if (other.getCreationToken() == null ^ this.getCreationToken() == null) return false;
        if (other.getCreationToken() != null && other.getCreationToken().equals(this.getCreationToken()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateFileSystemRequest clone() {
        
            return (CreateFileSystemRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/CreateFileSystemResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * This object provides description of a file system.
 * </p>
 */
public class CreateFileSystemResult implements Serializable, Cloneable {

    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     */
    private String ownerId;

    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     */
    private String creationToken;

    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     */
    private java.util.Date creationTime;

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     */
    private String lifeCycleState;

    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     */
    private String name;

    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     */
    private Integer numberOfMountTargets;

    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     */
    private FileSystemSize sizeInBytes;

    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @return The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     */
    public String getOwnerId() {
        return ownerId;
    }
    
    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     */
    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }
    
    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withOwnerId(String ownerId) {
        this.ownerId = ownerId;
        return this;
    }

    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @return Opaque string specified in the request.
     */
    public String getCreationToken() {
        return creationToken;
    }
    
    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Opaque string specified in the request.
     */
    public void setCreationToken(String creationToken) {
        this.creationToken = creationToken;
    }
    
    /**
     * Opaque string specified in the request.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Opaque string specified in the request.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withCreationToken(String creationToken) {
        this.creationToken = creationToken;
        return this;
    }

    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The file system ID assigned by Amazon EFS.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The file system ID assigned by Amazon EFS.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The file system ID assigned by Amazon EFS.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     *
     * @return The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     */
    public java.util.Date getCreationTime() {
        return creationTime;
    }
    
    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     *
     * @param creationTime The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     */
    public void setCreationTime(java.util.Date creationTime) {
        this.creationTime = creationTime;
    }
    
    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param creationTime The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withCreationTime(java.util.Date creationTime) {
        this.creationTime = creationTime;
        return this;
    }

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @return A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public String getLifeCycleState() {
        return lifeCycleState;
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public CreateFileSystemResult withLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
        return this;
    }

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public CreateFileSystemResult withLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
        return this;
    }

    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @return You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     */
    public String getName() {
        return name;
    }
    
    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param name You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param name You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @return The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     */
    public Integer getNumberOfMountTargets() {
        return numberOfMountTargets;
    }
    
    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param numberOfMountTargets The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     */
    public void setNumberOfMountTargets(Integer numberOfMountTargets) {
        this.numberOfMountTargets = numberOfMountTargets;
    }
    
    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param numberOfMountTargets The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withNumberOfMountTargets(Integer numberOfMountTargets) {
        this.numberOfMountTargets = numberOfMountTargets;
        return this;
    }

    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     *
     * @return This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     */
    public FileSystemSize getSizeInBytes() {
        return sizeInBytes;
    }
    
    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     *
     * @param sizeInBytes This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     */
    public void setSizeInBytes(FileSystemSize sizeInBytes) {
        this.sizeInBytes = sizeInBytes;
    }
    
    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param sizeInBytes This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateFileSystemResult withSizeInBytes(FileSystemSize sizeInBytes) {
        this.sizeInBytes = sizeInBytes;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getOwnerId() != null) sb.append("OwnerId: " + getOwnerId() + ",");
        if (getCreationToken() != null) sb.append("CreationToken: " + getCreationToken() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getCreationTime() != null) sb.append("CreationTime: " + getCreationTime() + ",");
        if (getLifeCycleState() != null) sb.append("LifeCycleState: " + getLifeCycleState() + ",");
        if (getName() != null) sb.append("Name: " + getName() + ",");
        if (getNumberOfMountTargets() != null) sb.append("NumberOfMountTargets: " + getNumberOfMountTargets() + ",");
        if (getSizeInBytes() != null) sb.append("SizeInBytes: " + getSizeInBytes() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getOwnerId() == null) ? 0 : getOwnerId().hashCode()); 
        hashCode = prime * hashCode + ((getCreationToken() == null) ? 0 : getCreationToken().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getCreationTime() == null) ? 0 : getCreationTime().hashCode()); 
        hashCode = prime * hashCode + ((getLifeCycleState() == null) ? 0 : getLifeCycleState().hashCode()); 
        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode()); 
        hashCode = prime * hashCode + ((getNumberOfMountTargets() == null) ? 0 : getNumberOfMountTargets().hashCode()); 
        hashCode = prime * hashCode + ((getSizeInBytes() == null) ? 0 : getSizeInBytes().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateFileSystemResult == false) return false;
        CreateFileSystemResult other = (CreateFileSystemResult)obj;
        
        if (other.getOwnerId() == null ^ this.getOwnerId() == null) return false;
        if (other.getOwnerId() != null && other.getOwnerId().equals(this.getOwnerId()) == false) return false; 
        if (other.getCreationToken() == null ^ this.getCreationToken() == null) return false;
        if (other.getCreationToken() != null && other.getCreationToken().equals(this.getCreationToken()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getCreationTime() == null ^ this.getCreationTime() == null) return false;
        if (other.getCreationTime() != null && other.getCreationTime().equals(this.getCreationTime()) == false) return false; 
        if (other.getLifeCycleState() == null ^ this.getLifeCycleState() == null) return false;
        if (other.getLifeCycleState() != null && other.getLifeCycleState().equals(this.getLifeCycleState()) == false) return false; 
        if (other.getName() == null ^ this.getName() == null) return false;
        if (other.getName() != null && other.getName().equals(this.getName()) == false) return false; 
        if (other.getNumberOfMountTargets() == null ^ this.getNumberOfMountTargets() == null) return false;
        if (other.getNumberOfMountTargets() != null && other.getNumberOfMountTargets().equals(this.getNumberOfMountTargets()) == false) return false; 
        if (other.getSizeInBytes() == null ^ this.getSizeInBytes() == null) return false;
        if (other.getSizeInBytes() != null && other.getSizeInBytes().equals(this.getSizeInBytes()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateFileSystemResult clone() {
        try {
            return (CreateFileSystemResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/CreateMountTargetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createMountTarget(CreateMountTargetRequest) CreateMountTarget operation}.
 * <p>
 * Creates a mount target for a file system. You can then mount the file
 * system on EC2 instances via the mount target.
 * </p>
 * <p>
 * You can create one mount target in each Availability Zone in your VPC.
 * All EC2 instances in a VPC within a given Availability Zone share a
 * single mount target for a given file system. If you have multiple
 * subnets in an Availability Zone, you create a mount target in one of
 * the subnets. EC2 instances do not need to be in the same subnet as the
 * mount target in order to access their file system. For more
 * information, see
 * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html"> Amazon EFS: How it Works </a>
 * .
 * </p>
 * <p>
 * In the request, you also specify a file system ID for which you are
 * creating the mount target and the file system's lifecycle state must
 * be "available" (see DescribeFileSystems).
 * </p>
 * <p>
 * In the request, you also provide a subnet ID, which serves several
 * purposes:
 * </p>
 * 
 * <ul>
 * <li>It determines the VPC in which Amazon EFS creates the mount
 * target.</li>
 * <li>It determines the Availability Zone in which Amazon EFS creates
 * the mount target. </li>
 * <li>It determines the IP address range from which Amazon EFS selects
 * the IP address of the mount target if you don't specify an IP address
 * in the request. </li>
 * 
 * </ul>
 * <p>
 * After creating the mount target, Amazon EFS returns a response that
 * includes, a <code>MountTargetId</code> and an <code>IpAddress</code> .
 * You use this IP address when mounting the file system in an EC2
 * instance. You can also use the mount target's DNS name when mounting
 * the file system. The EC2 instance on which you mount the file system
 * via the mount target can resolve the mount target's DNS name to its IP
 * address. For more information, see
 * <a href="http://docs.aws.amazon.com/efs/latest/ug/how-it-works.html#how-it-works-implementation"> How it Works: Implementation Overview </a>
 * 
 * </p>
 * <p>
 * Note that you can create mount targets for a file system in only one
 * VPC, and there can be only one mount target per Availability Zone.
 * That is, if the file system already has one or more mount targets
 * created for it, the request to add another mount target must meet the
 * following requirements:
 * </p>
 * 
 * <ul>
 * <li> <p>
 * The subnet specified in the request must belong to the same VPC as the
 * subnets of the existing mount targets.
 * </p>
 * </li>
 * <li>The subnet specified in the request must not be in the same
 * Availability Zone as any of the subnets of the existing mount
 * targets.</li>
 * 
 * </ul>
 * <p>
 * If the request satisfies the requirements, Amazon EFS does the
 * following:
 * </p>
 * 
 * <ul>
 * <li>Creates a new mount target in the specified subnet. </li>
 * <li>Also creates a new network interface in the subnet as follows:
 * <ul>
 * <li>If the request provides an <code>IpAddress</code> , Amazon EFS
 * assigns that IP address to the network interface. Otherwise, Amazon
 * EFS assigns a free address in the subnet (in the same way that the
 * Amazon EC2 <code>CreateNetworkInterface</code> call does when a
 * request does not specify a primary private IP address).</li>
 * <li>If the request provides <code>SecurityGroups</code> , this
 * network interface is associated with those security groups. Otherwise,
 * it belongs to the default security group for the subnet's VPC.</li>
 * <li>Assigns the description <code>"Mount target fsmt-id for file
 * system fs-id"</code> where <code> fsmt-id </code> is the mount target
 * ID, and <code> fs-id </code> is the <code>FileSystemId</code> .</li>
 * <li>Sets the <code>requesterManaged</code> property of the network
 * interface to "true", and the <code>requesterId</code> value to
 * "EFS".</li>
 * 
 * </ul>
 * <p>
 * Each Amazon EFS mount target has one corresponding requestor-managed
 * EC2 network interface. After the network interface is created, Amazon
 * EFS sets the <code>NetworkInterfaceId</code> field in the mount
 * target's description to the network interface ID, and the
 * <code>IpAddress</code> field to its address. If network interface
 * creation fails, the entire <code>CreateMountTarget</code> operation
 * fails.
 * </p>
 * </li>
 * 
 * </ul>
 * <p>
 * <b>NOTE:</b>The CreateMountTarget call returns only after creating the
 * network interface, but while the mount target state is still
 * "creating". You can check the mount target creation status by calling
 * the DescribeFileSystems API, which among other things returns the
 * mount target state.
 * </p>
 * <p>
 * We recommend you create a mount target in each of the Availability
 * Zones. There are cost considerations for using a file system in an
 * Availability Zone through a mount target created in another
 * Availability Zone. For more information, go to
 * <a href="http://aws.amazon.com/efs/"> Amazon EFS </a>
 * product detail page. In addition, by always using a mount target
 * local to the instance's Availability Zone, you eliminate a partial
 * failure scenario; if the Availablity Zone in which your mount target
 * is created goes down, then you won't be able to access your file
 * system through that mount target.
 * </p>
 * <p>
 * This operation requires permission for the following action on the
 * file system:
 * </p>
 * 
 * <ul>
 * <li> <code>elasticfilesystem:CreateMountTarget</code> </li>
 * 
 * </ul>
 * <p>
 * This operation also requires permission for the following Amazon EC2
 * actions:
 * </p>
 * 
 * <ul>
 * <li> <code>ec2:DescribeSubnets</code> </li>
 * <li> <code>ec2:DescribeNetworkInterfaces</code> </li>
 * <li> <code>ec2:CreateNetworkInterface</code> </li>
 * 
 * </ul>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createMountTarget(CreateMountTargetRequest)
 */
public class CreateMountTargetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The ID of the file system for which to create the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The ID of the subnet to add the mount target in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     */
    private String subnetId;

    /**
     * A valid IPv4 address within the address range of the specified subnet.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     */
    private String ipAddress;

    /**
     * Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     * be for the same VPC as subnet specified.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroups;

    /**
     * The ID of the file system for which to create the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The ID of the file system for which to create the mount target.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The ID of the file system for which to create the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which to create the mount target.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The ID of the file system for which to create the mount target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which to create the mount target.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * The ID of the subnet to add the mount target in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @return The ID of the subnet to add the mount target in.
     */
    public String getSubnetId() {
        return subnetId;
    }
    
    /**
     * The ID of the subnet to add the mount target in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet to add the mount target in.
     */
    public void setSubnetId(String subnetId) {
        this.subnetId = subnetId;
    }
    
    /**
     * The ID of the subnet to add the mount target in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet to add the mount target in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetRequest withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * A valid IPv4 address within the address range of the specified subnet.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @return A valid IPv4 address within the address range of the specified subnet.
     */
    public String getIpAddress() {
        return ipAddress;
    }
    
    /**
     * A valid IPv4 address within the address range of the specified subnet.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress A valid IPv4 address within the address range of the specified subnet.
     */
    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }
    
    /**
     * A valid IPv4 address within the address range of the specified subnet.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress A valid IPv4 address within the address range of the specified subnet.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetRequest withIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
        return this;
    }

    /**
     * Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     * be for the same VPC as subnet specified.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @return Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     *         be for the same VPC as subnet specified.
     */
    public java.util.List<String> getSecurityGroups() {
        if (securityGroups == null) {
              securityGroups = new com.amazonaws.internal.ListWithAutoConstructFlag<String>();
              securityGroups.setAutoConstruct(true);
        }
        return securityGroups;
    }
    
    /**
     * Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     * be for the same VPC as subnet specified.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     *         be for the same VPC as subnet specified.
     */
    public void setSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
        securityGroupsCopy.addAll(securityGroups);
        this.securityGroups = securityGroupsCopy;
    }
    
    /**
     * Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     * be for the same VPC as subnet specified.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setSecurityGroups(java.util.Collection)} or {@link
     * #withSecurityGroups(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     *         be for the same VPC as subnet specified.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetRequest withSecurityGroups(String... securityGroups) {
        if (getSecurityGroups() == null) setSecurityGroups(new java.util.ArrayList<String>(securityGroups.length));
        for (String value : securityGroups) {
            getSecurityGroups().add(value);
        }
        return this;
    }
    
    /**
     * Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     * be for the same VPC as subnet specified.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups Up to 5 VPC security group IDs, of the form "sg-xxxxxxxx". These must
     *         be for the same VPC as subnet specified.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetRequest withSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
            securityGroupsCopy.addAll(securityGroups);
            this.securityGroups = securityGroupsCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getSubnetId() != null) sb.append("SubnetId: " + getSubnetId() + ",");
        if (getIpAddress() != null) sb.append("IpAddress: " + getIpAddress() + ",");
        if (getSecurityGroups() != null) sb.append("SecurityGroups: " + getSecurityGroups() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getSubnetId() == null) ? 0 : getSubnetId().hashCode()); 
        hashCode = prime * hashCode + ((getIpAddress() == null) ? 0 : getIpAddress().hashCode()); 
        hashCode = prime * hashCode + ((getSecurityGroups() == null) ? 0 : getSecurityGroups().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateMountTargetRequest == false) return false;
        CreateMountTargetRequest other = (CreateMountTargetRequest)obj;
        
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getSubnetId() == null ^ this.getSubnetId() == null) return false;
        if (other.getSubnetId() != null && other.getSubnetId().equals(this.getSubnetId()) == false) return false; 
        if (other.getIpAddress() == null ^ this.getIpAddress() == null) return false;
        if (other.getIpAddress() != null && other.getIpAddress().equals(this.getIpAddress()) == false) return false; 
        if (other.getSecurityGroups() == null ^ this.getSecurityGroups() == null) return false;
        if (other.getSecurityGroups() != null && other.getSecurityGroups().equals(this.getSecurityGroups()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateMountTargetRequest clone() {
        
            return (CreateMountTargetRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/CreateMountTargetResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * This object provides description of a mount target.
 * </p>
 */
public class CreateMountTargetResult implements Serializable, Cloneable {

    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     */
    private String ownerId;

    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     */
    private String mountTargetId;

    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     */
    private String subnetId;

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     */
    private String lifeCycleState;

    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     */
    private String ipAddress;

    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     */
    private String networkInterfaceId;

    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @return The AWS account ID that owns the resource.
     */
    public String getOwnerId() {
        return ownerId;
    }
    
    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account ID that owns the resource.
     */
    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }
    
    /**
     * The AWS account ID that owns the resource.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account ID that owns the resource.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withOwnerId(String ownerId) {
        this.ownerId = ownerId;
        return this;
    }

    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @return The system-assigned mount target ID.
     */
    public String getMountTargetId() {
        return mountTargetId;
    }
    
    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The system-assigned mount target ID.
     */
    public void setMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
    }
    
    /**
     * The system-assigned mount target ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The system-assigned mount target ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
        return this;
    }

    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The ID of the file system for which the mount target is intended.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which the mount target is intended.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which the mount target is intended.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @return The ID of the subnet that the mount target is in.
     */
    public String getSubnetId() {
        return subnetId;
    }
    
    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet that the mount target is in.
     */
    public void setSubnetId(String subnetId) {
        this.subnetId = subnetId;
    }
    
    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet that the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @return The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public String getLifeCycleState() {
        return lifeCycleState;
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public CreateMountTargetResult withLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
        return this;
    }

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public CreateMountTargetResult withLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
        return this;
    }

    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @return The address at which the file system may be mounted via the mount
     *         target.
     */
    public String getIpAddress() {
        return ipAddress;
    }
    
    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress The address at which the file system may be mounted via the mount
     *         target.
     */
    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }
    
    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress The address at which the file system may be mounted via the mount
     *         target.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
        return this;
    }

    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @return The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     */
    public String getNetworkInterfaceId() {
        return networkInterfaceId;
    }
    
    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @param networkInterfaceId The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     */
    public void setNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
    }
    
    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @param networkInterfaceId The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateMountTargetResult withNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getOwnerId() != null) sb.append("OwnerId: " + getOwnerId() + ",");
        if (getMountTargetId() != null) sb.append("MountTargetId: " + getMountTargetId() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getSubnetId() != null) sb.append("SubnetId: " + getSubnetId() + ",");
        if (getLifeCycleState() != null) sb.append("LifeCycleState: " + getLifeCycleState() + ",");
        if (getIpAddress() != null) sb.append("IpAddress: " + getIpAddress() + ",");
        if (getNetworkInterfaceId() != null) sb.append("NetworkInterfaceId: " + getNetworkInterfaceId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getOwnerId() == null) ? 0 : getOwnerId().hashCode()); 
        hashCode = prime * hashCode + ((getMountTargetId() == null) ? 0 : getMountTargetId().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getSubnetId() == null) ? 0 : getSubnetId().hashCode()); 
        hashCode = prime * hashCode + ((getLifeCycleState() == null) ? 0 : getLifeCycleState().hashCode()); 
        hashCode = prime * hashCode + ((getIpAddress() == null) ? 0 : getIpAddress().hashCode()); 
        hashCode = prime * hashCode + ((getNetworkInterfaceId() == null) ? 0 : getNetworkInterfaceId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateMountTargetResult == false) return false;
        CreateMountTargetResult other = (CreateMountTargetResult)obj;
        
        if (other.getOwnerId() == null ^ this.getOwnerId() == null) return false;
        if (other.getOwnerId() != null && other.getOwnerId().equals(this.getOwnerId()) == false) return false; 
        if (other.getMountTargetId() == null ^ this.getMountTargetId() == null) return false;
        if (other.getMountTargetId() != null && other.getMountTargetId().equals(this.getMountTargetId()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getSubnetId() == null ^ this.getSubnetId() == null) return false;
        if (other.getSubnetId() != null && other.getSubnetId().equals(this.getSubnetId()) == false) return false; 
        if (other.getLifeCycleState() == null ^ this.getLifeCycleState() == null) return false;
        if (other.getLifeCycleState() != null && other.getLifeCycleState().equals(this.getLifeCycleState()) == false) return false; 
        if (other.getIpAddress() == null ^ this.getIpAddress() == null) return false;
        if (other.getIpAddress() != null && other.getIpAddress().equals(this.getIpAddress()) == false) return false; 
        if (other.getNetworkInterfaceId() == null ^ this.getNetworkInterfaceId() == null) return false;
        if (other.getNetworkInterfaceId() != null && other.getNetworkInterfaceId().equals(this.getNetworkInterfaceId()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateMountTargetResult clone() {
        try {
            return (CreateMountTargetResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/CreateTagsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createTags(CreateTagsRequest) CreateTags operation}.
 * <p>
 * Creates or overwrites tags associated with a file system. Each tag is
 * a key-value pair. If a tag key specified in the request already exists
 * on the file system, this operation overwrites its value with the value
 * provided in the request. If you add the "Name" tag to your file
 * system, Amazon EFS returns it in the response to the
 * DescribeFileSystems API.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:CreateTags</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#createTags(CreateTagsRequest)
 */
public class CreateTagsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * String. The ID of the file system whose tags you want to modify. This
     * operation modifies only the tags and not the file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     * object is a key-value pair.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tags;

    /**
     * String. The ID of the file system whose tags you want to modify. This
     * operation modifies only the tags and not the file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return String. The ID of the file system whose tags you want to modify. This
     *         operation modifies only the tags and not the file system.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose tags you want to modify. This
     * operation modifies only the tags and not the file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose tags you want to modify. This
     *         operation modifies only the tags and not the file system.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose tags you want to modify. This
     * operation modifies only the tags and not the file system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose tags you want to modify. This
     *         operation modifies only the tags and not the file system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateTagsRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     * object is a key-value pair.
     *
     * @return An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     *         object is a key-value pair.
     */
    public java.util.List<Tag> getTags() {
        if (tags == null) {
              tags = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>();
              tags.setAutoConstruct(true);
        }
        return tags;
    }
    
    /**
     * An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     * object is a key-value pair.
     *
     * @param tags An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     *         object is a key-value pair.
     */
    public void setTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tagsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>(tags.size());
        tagsCopy.addAll(tags);
        this.tags = tagsCopy;
    }
    
    /**
     * An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     * object is a key-value pair.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setTags(java.util.Collection)} or {@link
     * #withTags(java.util.Collection)} if you want to override the existing
     * values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     *         object is a key-value pair.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateTagsRequest withTags(Tag... tags) {
        if (getTags() == null) setTags(new java.util.ArrayList<Tag>(tags.length));
        for (Tag value : tags) {
            getTags().add(value);
        }
        return this;
    }
    
    /**
     * An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     * object is a key-value pair.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags An array of <code>Tag</code> objects to add. Each <code>Tag</code>
     *         object is a key-value pair.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateTagsRequest withTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tagsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>(tags.size());
            tagsCopy.addAll(tags);
            this.tags = tagsCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getTags() != null) sb.append("Tags: " + getTags() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getTags() == null) ? 0 : getTags().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateTagsRequest == false) return false;
        CreateTagsRequest other = (CreateTagsRequest)obj;
        
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getTags() == null ^ this.getTags() == null) return false;
        if (other.getTags() != null && other.getTags().equals(this.getTags()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateTagsRequest clone() {
        
            return (CreateTagsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DeleteFileSystemRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteFileSystem(DeleteFileSystemRequest) DeleteFileSystem operation}.
 * <p>
 * Deletes a file system, permanently severing access to its contents.
 * Upon return, the file system no longer exists and you will not be able
 * to access any contents of the deleted file system.
 * </p>
 * <p>
 * You cannot delete a file system that is in use. That is, if the file
 * system has any mount targets, you must first delete them. For more
 * information, see DescribeMountTargets and DeleteMountTarget.
 * </p>
 * <p>
 * <b>NOTE:</b>The DeleteFileSystem call returns while the file system
 * state is still "deleting". You can check the file system deletion
 * status by calling the DescribeFileSystems API, which returns a list of
 * file systems in your account. If you pass file system ID or creation
 * token for the deleted file system, the DescribeFileSystems will return
 * a 404 "FileSystemNotFound" error.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:DeleteFileSystem</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteFileSystem(DeleteFileSystemRequest)
 */
public class DeleteFileSystemRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The ID of the file system you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The ID of the file system you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The ID of the file system you want to delete.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The ID of the file system you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system you want to delete.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The ID of the file system you want to delete.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system you want to delete.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteFileSystemRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteFileSystemRequest == false) return false;
        DeleteFileSystemRequest other = (DeleteFileSystemRequest)obj;
        
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteFileSystemRequest clone() {
        
            return (DeleteFileSystemRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DeleteMountTargetRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteMountTarget(DeleteMountTargetRequest) DeleteMountTarget operation}.
 * <p>
 * Deletes the specified mount target.
 * </p>
 * <p>
 * This operation forcibly breaks any mounts of the file system via the
 * mount target being deleted, which might disrupt instances or
 * applications using those mounts. To avoid applications getting cut off
 * abruptly, you might consider unmounting any mounts of the mount
 * target, if feasible. The operation also deletes the associated network
 * interface. Uncommitted writes may be lost, but breaking a mount target
 * using this operation does not corrupt the file system itself. The file
 * system you created remains. You can mount an EC2 instance in your VPC
 * using another mount target.
 * </p>
 * <p>
 * This operation requires permission for the following action on the
 * file system:
 * </p>
 * 
 * <ul>
 * <li> <code>elasticfilesystem:DeleteMountTarget</code> </li>
 * 
 * </ul>
 * <p>
 * <b>NOTE:</b>The DeleteMountTarget call returns while the mount target
 * state is still "deleting". You can check the mount target deletion by
 * calling the DescribeMountTargets API, which returns a list of mount
 * target descriptions for the given file system.
 * </p>
 * <p>
 * The operation also requires permission for the following Amazon EC2
 * action on the mount target's network interface:
 * </p>
 * 
 * <ul>
 * <li> <code>ec2:DeleteNetworkInterface</code> </li>
 * 
 * </ul>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteMountTarget(DeleteMountTargetRequest)
 */
public class DeleteMountTargetRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * String. The ID of the mount target to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     */
    private String mountTargetId;

    /**
     * String. The ID of the mount target to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @return String. The ID of the mount target to delete.
     */
    public String getMountTargetId() {
        return mountTargetId;
    }
    
    /**
     * String. The ID of the mount target to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId String. The ID of the mount target to delete.
     */
    public void setMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
    }
    
    /**
     * String. The ID of the mount target to delete.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId String. The ID of the mount target to delete.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteMountTargetRequest withMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMountTargetId() != null) sb.append("MountTargetId: " + getMountTargetId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMountTargetId() == null) ? 0 : getMountTargetId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteMountTargetRequest == false) return false;
        DeleteMountTargetRequest other = (DeleteMountTargetRequest)obj;
        
        if (other.getMountTargetId() == null ^ this.getMountTargetId() == null) return false;
        if (other.getMountTargetId() != null && other.getMountTargetId().equals(this.getMountTargetId()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteMountTargetRequest clone() {
        
            return (DeleteMountTargetRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DeleteTagsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteTags(DeleteTagsRequest) DeleteTags operation}.
 * <p>
 * Deletes the specified tags from a file system. If the
 * <code>DeleteTags</code> request includes a tag key that does not
 * exist, Amazon EFS ignores it; it is not an error. For more information
 * about tags and related restrictions, go to
 * <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html"> Tag Restrictions </a>
 * in the <i>AWS Billing and Cost Management User Guide</i> .
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:DeleteTags</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#deleteTags(DeleteTagsRequest)
 */
public class DeleteTagsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * String. The ID of the file system whose tags you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * A list of tag keys to delete.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<String> tagKeys;

    /**
     * String. The ID of the file system whose tags you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return String. The ID of the file system whose tags you want to delete.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose tags you want to delete.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose tags you want to delete.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose tags you want to delete.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose tags you want to delete.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteTagsRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * A list of tag keys to delete.
     *
     * @return A list of tag keys to delete.
     */
    public java.util.List<String> getTagKeys() {
        if (tagKeys == null) {
              tagKeys = new com.amazonaws.internal.ListWithAutoConstructFlag<String>();
              tagKeys.setAutoConstruct(true);
        }
        return tagKeys;
    }
    
    /**
     * A list of tag keys to delete.
     *
     * @param tagKeys A list of tag keys to delete.
     */
    public void setTagKeys(java.util.Collection<String> tagKeys) {
        if (tagKeys == null) {
            this.tagKeys = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<String> tagKeysCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(tagKeys.size());
        tagKeysCopy.addAll(tagKeys);
        this.tagKeys = tagKeysCopy;
    }
    
    /**
     * A list of tag keys to delete.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setTagKeys(java.util.Collection)} or {@link
     * #withTagKeys(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagKeys A list of tag keys to delete.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteTagsRequest withTagKeys(String... tagKeys) {
        if (getTagKeys() == null) setTagKeys(new java.util.ArrayList<String>(tagKeys.length));
        for (String value : tagKeys) {
            getTagKeys().add(value);
        }
        return this;
    }
    
    /**
     * A list of tag keys to delete.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagKeys A list of tag keys to delete.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteTagsRequest withTagKeys(java.util.Collection<String> tagKeys) {
        if (tagKeys == null) {
            this.tagKeys = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<String> tagKeysCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(tagKeys.size());
            tagKeysCopy.addAll(tagKeys);
            this.tagKeys = tagKeysCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getTagKeys() != null) sb.append("TagKeys: " + getTagKeys() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getTagKeys() == null) ? 0 : getTagKeys().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteTagsRequest == false) return false;
        DeleteTagsRequest other = (DeleteTagsRequest)obj;
        
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getTagKeys() == null ^ this.getTagKeys() == null) return false;
        if (other.getTagKeys() != null && other.getTagKeys().equals(this.getTagKeys()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteTagsRequest clone() {
        
            return (DeleteTagsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DependencyTimeoutException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The service timed out trying to fulfill the request, and the client
 * should try the call again.
 * </p>
 */        
public class DependencyTimeoutException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new DependencyTimeoutException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public DependencyTimeoutException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeFileSystemsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeFileSystems(DescribeFileSystemsRequest) DescribeFileSystems operation}.
 * <p>
 * Returns the description of a specific Amazon EFS file system if either
 * the file system <code>CreationToken</code> or the
 * <code>FileSystemId</code> is provided; otherwise, returns descriptions
 * of all file systems owned by the caller's AWS account in the AWS
 * region of the endpoint that you're calling.
 * </p>
 * <p>
 * When retrieving all file system descriptions, you can optionally
 * specify the <code>MaxItems</code> parameter to limit the number of
 * descriptions in a response. If more file system descriptions remain,
 * Amazon EFS returns a <code>NextMarker</code> , an opaque token, in the
 * response. In this case, you should send a subsequent request with the
 * <code>Marker</code> request parameter set to the value of
 * <code>NextMarker</code> .
 * 
 * </p>
 * <p>
 * So to retrieve a list of your file system descriptions, the expected
 * usage of this API is an iterative process of first calling
 * <code>DescribeFileSystems</code> without the <code>Marker</code> and
 * then continuing to call it with the <code>Marker</code> parameter set
 * to the value of the <code>NextMarker</code> from the previous response
 * until the response has no <code>NextMarker</code> .
 * 
 * </p>
 * <p>
 * Note that the implementation may return fewer than
 * <code>MaxItems</code> file system descriptions while still including a
 * <code>NextMarker</code> value.
 * </p>
 * <p>
 * The order of file systems returned in the response of one
 * <code>DescribeFileSystems</code> call, and the order of file systems
 * returned across the responses of a multi-call iteration, is
 * unspecified.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:DescribeFileSystems</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeFileSystems(DescribeFileSystemsRequest)
 */
public class DescribeFileSystemsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Optional integer. Specifies the maximum number of file systems to
     * return in the response. This parameter value must be greater than 0.
     * The number of items Amazon EFS returns will be the minimum of the
     * <code>MaxItems</code> parameter specified in the request and the
     * service's internal maximum number of items per page.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     */
    private Integer maxItems;

    /**
     * Optional string. Opaque pagination token returned from a previous
     * <code>DescribeFileSystems</code> operation. If present, specifies to
     * continue the list from where the returning call had left off.
     */
    private String marker;

    /**
     * Optional string. Restricts the list to the file system with this
     * creation token (you specify a creation token at the time of creating
     * an Amazon EFS file system).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     */
    private String creationToken;

    /**
     * Optional string. File system ID whose description you want to
     * retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * Optional integer. Specifies the maximum number of file systems to
     * return in the response. This parameter value must be greater than 0.
     * The number of items Amazon EFS returns will be the minimum of the
     * <code>MaxItems</code> parameter specified in the request and the
     * service's internal maximum number of items per page.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @return Optional integer. Specifies the maximum number of file systems to
     *         return in the response. This parameter value must be greater than 0.
     *         The number of items Amazon EFS returns will be the minimum of the
     *         <code>MaxItems</code> parameter specified in the request and the
     *         service's internal maximum number of items per page.
     */
    public Integer getMaxItems() {
        return maxItems;
    }
    
    /**
     * Optional integer. Specifies the maximum number of file systems to
     * return in the response. This parameter value must be greater than 0.
     * The number of items Amazon EFS returns will be the minimum of the
     * <code>MaxItems</code> parameter specified in the request and the
     * service's internal maximum number of items per page.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional integer. Specifies the maximum number of file systems to
     *         return in the response. This parameter value must be greater than 0.
     *         The number of items Amazon EFS returns will be the minimum of the
     *         <code>MaxItems</code> parameter specified in the request and the
     *         service's internal maximum number of items per page.
     */
    public void setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
    }
    
    /**
     * Optional integer. Specifies the maximum number of file systems to
     * return in the response. This parameter value must be greater than 0.
     * The number of items Amazon EFS returns will be the minimum of the
     * <code>MaxItems</code> parameter specified in the request and the
     * service's internal maximum number of items per page.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional integer. Specifies the maximum number of file systems to
     *         return in the response. This parameter value must be greater than 0.
     *         The number of items Amazon EFS returns will be the minimum of the
     *         <code>MaxItems</code> parameter specified in the request and the
     *         service's internal maximum number of items per page.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsRequest withMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    /**
     * Optional string. Opaque pagination token returned from a previous
     * <code>DescribeFileSystems</code> operation. If present, specifies to
     * continue the list from where the returning call had left off.
     *
     * @return Optional string. Opaque pagination token returned from a previous
     *         <code>DescribeFileSystems</code> operation. If present, specifies to
     *         continue the list from where the returning call had left off.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * Optional string. Opaque pagination token returned from a previous
     * <code>DescribeFileSystems</code> operation. If present, specifies to
     * continue the list from where the returning call had left off.
     *
     * @param marker Optional string. Opaque pagination token returned from a previous
     *         <code>DescribeFileSystems</code> operation. If present, specifies to
     *         continue the list from where the returning call had left off.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * Optional string. Opaque pagination token returned from a previous
     * <code>DescribeFileSystems</code> operation. If present, specifies to
     * continue the list from where the returning call had left off.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker Optional string. Opaque pagination token returned from a previous
     *         <code>DescribeFileSystems</code> operation. If present, specifies to
     *         continue the list from where the returning call had left off.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsRequest withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * Optional string. Restricts the list to the file system with this
     * creation token (you specify a creation token at the time of creating
     * an Amazon EFS file system).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @return Optional string. Restricts the list to the file system with this
     *         creation token (you specify a creation token at the time of creating
     *         an Amazon EFS file system).
     */
    public String getCreationToken() {
        return creationToken;
    }
    
    /**
     * Optional string. Restricts the list to the file system with this
     * creation token (you specify a creation token at the time of creating
     * an Amazon EFS file system).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Optional string. Restricts the list to the file system with this
     *         creation token (you specify a creation token at the time of creating
     *         an Amazon EFS file system).
     */
    public void setCreationToken(String creationToken) {
        this.creationToken = creationToken;
    }
    
    /**
     * Optional string. Restricts the list to the file system with this
     * creation token (you specify a creation token at the time of creating
     * an Amazon EFS file system).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Optional string. Restricts the list to the file system with this
     *         creation token (you specify a creation token at the time of creating
     *         an Amazon EFS file system).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsRequest withCreationToken(String creationToken) {
        this.creationToken = creationToken;
        return this;
    }

    /**
     * Optional string. File system ID whose description you want to
     * retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return Optional string. File system ID whose description you want to
     *         retrieve.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * Optional string. File system ID whose description you want to
     * retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId Optional string. File system ID whose description you want to
     *         retrieve.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * Optional string. File system ID whose description you want to
     * retrieve.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId Optional string. File system ID whose description you want to
     *         retrieve.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMaxItems() != null) sb.append("MaxItems: " + getMaxItems() + ",");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getCreationToken() != null) sb.append("CreationToken: " + getCreationToken() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMaxItems() == null) ? 0 : getMaxItems().hashCode()); 
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getCreationToken() == null) ? 0 : getCreationToken().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeFileSystemsRequest == false) return false;
        DescribeFileSystemsRequest other = (DescribeFileSystemsRequest)obj;
        
        if (other.getMaxItems() == null ^ this.getMaxItems() == null) return false;
        if (other.getMaxItems() != null && other.getMaxItems().equals(this.getMaxItems()) == false) return false; 
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getCreationToken() == null ^ this.getCreationToken() == null) return false;
        if (other.getCreationToken() != null && other.getCreationToken().equals(this.getCreationToken()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeFileSystemsRequest clone() {
        
            return (DescribeFileSystemsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeFileSystemsResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * 
 */
public class DescribeFileSystemsResult implements Serializable, Cloneable {

    /**
     * A string, present if provided by caller in the request.
     */
    private String marker;

    /**
     * An array of file system descriptions.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription> fileSystems;

    /**
     * A string, present if there are more file systems than returned in the
     * response. You can use the <code>NextMarker</code> in the subsequent
     * request to fetch the descriptions.
     */
    private String nextMarker;

    /**
     * A string, present if provided by caller in the request.
     *
     * @return A string, present if provided by caller in the request.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * A string, present if provided by caller in the request.
     *
     * @param marker A string, present if provided by caller in the request.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * A string, present if provided by caller in the request.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker A string, present if provided by caller in the request.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsResult withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * An array of file system descriptions.
     *
     * @return An array of file system descriptions.
     */
    public java.util.List<FileSystemDescription> getFileSystems() {
        if (fileSystems == null) {
              fileSystems = new com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription>();
              fileSystems.setAutoConstruct(true);
        }
        return fileSystems;
    }
    
    /**
     * An array of file system descriptions.
     *
     * @param fileSystems An array of file system descriptions.
     */
    public void setFileSystems(java.util.Collection<FileSystemDescription> fileSystems) {
        if (fileSystems == null) {
            this.fileSystems = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription> fileSystemsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription>(fileSystems.size());
        fileSystemsCopy.addAll(fileSystems);
        this.fileSystems = fileSystemsCopy;
    }
    
    /**
     * An array of file system descriptions.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setFileSystems(java.util.Collection)} or {@link
     * #withFileSystems(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param fileSystems An array of file system descriptions.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsResult withFileSystems(FileSystemDescription... fileSystems) {
        if (getFileSystems() == null) setFileSystems(new java.util.ArrayList<FileSystemDescription>(fileSystems.length));
        for (FileSystemDescription value : fileSystems) {
            getFileSystems().add(value);
        }
        return this;
    }
    
    /**
     * An array of file system descriptions.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param fileSystems An array of file system descriptions.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsResult withFileSystems(java.util.Collection<FileSystemDescription> fileSystems) {
        if (fileSystems == null) {
            this.fileSystems = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription> fileSystemsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<FileSystemDescription>(fileSystems.size());
            fileSystemsCopy.addAll(fileSystems);
            this.fileSystems = fileSystemsCopy;
        }

        return this;
    }

    /**
     * A string, present if there are more file systems than returned in the
     * response. You can use the <code>NextMarker</code> in the subsequent
     * request to fetch the descriptions.
     *
     * @return A string, present if there are more file systems than returned in the
     *         response. You can use the <code>NextMarker</code> in the subsequent
     *         request to fetch the descriptions.
     */
    public String getNextMarker() {
        return nextMarker;
    }
    
    /**
     * A string, present if there are more file systems than returned in the
     * response. You can use the <code>NextMarker</code> in the subsequent
     * request to fetch the descriptions.
     *
     * @param nextMarker A string, present if there are more file systems than returned in the
     *         response. You can use the <code>NextMarker</code> in the subsequent
     *         request to fetch the descriptions.
     */
    public void setNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
    }
    
    /**
     * A string, present if there are more file systems than returned in the
     * response. You can use the <code>NextMarker</code> in the subsequent
     * request to fetch the descriptions.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param nextMarker A string, present if there are more file systems than returned in the
     *         response. You can use the <code>NextMarker</code> in the subsequent
     *         request to fetch the descriptions.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeFileSystemsResult withNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getFileSystems() != null) sb.append("FileSystems: " + getFileSystems() + ",");
        if (getNextMarker() != null) sb.append("NextMarker: " + getNextMarker() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystems() == null) ? 0 : getFileSystems().hashCode()); 
        hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeFileSystemsResult == false) return false;
        DescribeFileSystemsResult other = (DescribeFileSystemsResult)obj;
        
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getFileSystems() == null ^ this.getFileSystems() == null) return false;
        if (other.getFileSystems() != null && other.getFileSystems().equals(this.getFileSystems()) == false) return false; 
        if (other.getNextMarker() == null ^ this.getNextMarker() == null) return false;
        if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeFileSystemsResult clone() {
        try {
            return (DescribeFileSystemsResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeMountTargetSecurityGroupsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeMountTargetSecurityGroups(DescribeMountTargetSecurityGroupsRequest) DescribeMountTargetSecurityGroups operation}.
 * <p>
 * Returns the security groups currently in effect for a mount target.
 * This operation requires that the network interface of the mount target
 * has been created and the life cycle state of the mount target is not
 * "deleted".
 * </p>
 * <p>
 * This operation requires permissions for the following actions:
 * </p>
 * 
 * <ul>
 * <li> <code>elasticfilesystem:DescribeMountTargetSecurityGroups</code>
 * action on the mount target's file system. </li>
 * <li> <code>ec2:DescribeNetworkInterfaceAttribute</code> action on the
 * mount target's network interface. </li>
 * 
 * </ul>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeMountTargetSecurityGroups(DescribeMountTargetSecurityGroupsRequest)
 */
public class DescribeMountTargetSecurityGroupsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The ID of the mount target whose security groups you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     */
    private String mountTargetId;

    /**
     * The ID of the mount target whose security groups you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @return The ID of the mount target whose security groups you want to retrieve.
     */
    public String getMountTargetId() {
        return mountTargetId;
    }
    
    /**
     * The ID of the mount target whose security groups you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The ID of the mount target whose security groups you want to retrieve.
     */
    public void setMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
    }
    
    /**
     * The ID of the mount target whose security groups you want to retrieve.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The ID of the mount target whose security groups you want to retrieve.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetSecurityGroupsRequest withMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMountTargetId() != null) sb.append("MountTargetId: " + getMountTargetId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMountTargetId() == null) ? 0 : getMountTargetId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeMountTargetSecurityGroupsRequest == false) return false;
        DescribeMountTargetSecurityGroupsRequest other = (DescribeMountTargetSecurityGroupsRequest)obj;
        
        if (other.getMountTargetId() == null ^ this.getMountTargetId() == null) return false;
        if (other.getMountTargetId() != null && other.getMountTargetId().equals(this.getMountTargetId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeMountTargetSecurityGroupsRequest clone() {
        
            return (DescribeMountTargetSecurityGroupsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeMountTargetSecurityGroupsResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * 
 */
public class DescribeMountTargetSecurityGroupsResult implements Serializable, Cloneable {

    /**
     * An array of security groups.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroups;

    /**
     * An array of security groups.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @return An array of security groups.
     */
    public java.util.List<String> getSecurityGroups() {
        if (securityGroups == null) {
              securityGroups = new com.amazonaws.internal.ListWithAutoConstructFlag<String>();
              securityGroups.setAutoConstruct(true);
        }
        return securityGroups;
    }
    
    /**
     * An array of security groups.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of security groups.
     */
    public void setSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
        securityGroupsCopy.addAll(securityGroups);
        this.securityGroups = securityGroupsCopy;
    }
    
    /**
     * An array of security groups.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setSecurityGroups(java.util.Collection)} or {@link
     * #withSecurityGroups(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of security groups.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetSecurityGroupsResult withSecurityGroups(String... securityGroups) {
        if (getSecurityGroups() == null) setSecurityGroups(new java.util.ArrayList<String>(securityGroups.length));
        for (String value : securityGroups) {
            getSecurityGroups().add(value);
        }
        return this;
    }
    
    /**
     * An array of security groups.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of security groups.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetSecurityGroupsResult withSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
            securityGroupsCopy.addAll(securityGroups);
            this.securityGroups = securityGroupsCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getSecurityGroups() != null) sb.append("SecurityGroups: " + getSecurityGroups() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getSecurityGroups() == null) ? 0 : getSecurityGroups().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeMountTargetSecurityGroupsResult == false) return false;
        DescribeMountTargetSecurityGroupsResult other = (DescribeMountTargetSecurityGroupsResult)obj;
        
        if (other.getSecurityGroups() == null ^ this.getSecurityGroups() == null) return false;
        if (other.getSecurityGroups() != null && other.getSecurityGroups().equals(this.getSecurityGroups()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeMountTargetSecurityGroupsResult clone() {
        try {
            return (DescribeMountTargetSecurityGroupsResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeMountTargetsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeMountTargets(DescribeMountTargetsRequest) DescribeMountTargets operation}.
 * <p>
 * Returns the descriptions of the current mount targets for a file
 * system. The order of mount targets returned in the response is
 * unspecified.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:DescribeMountTargets</code> action on the file
 * system <code>FileSystemId</code> .
 * 
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeMountTargets(DescribeMountTargetsRequest)
 */
public class DescribeMountTargetsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Optional. Maximum number of mount targets to return in the response.
     * It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     */
    private Integer maxItems;

    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeMountTargets</code> operation. If present, it specifies
     * to continue the list from where the previous returning call left off.
     */
    private String marker;

    /**
     * String. The ID of the file system whose mount targets you want to
     * list.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * Optional. Maximum number of mount targets to return in the response.
     * It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @return Optional. Maximum number of mount targets to return in the response.
     *         It must be an integer with a value greater than zero.
     */
    public Integer getMaxItems() {
        return maxItems;
    }
    
    /**
     * Optional. Maximum number of mount targets to return in the response.
     * It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional. Maximum number of mount targets to return in the response.
     *         It must be an integer with a value greater than zero.
     */
    public void setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
    }
    
    /**
     * Optional. Maximum number of mount targets to return in the response.
     * It must be an integer with a value greater than zero.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional. Maximum number of mount targets to return in the response.
     *         It must be an integer with a value greater than zero.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsRequest withMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeMountTargets</code> operation. If present, it specifies
     * to continue the list from where the previous returning call left off.
     *
     * @return Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeMountTargets</code> operation. If present, it specifies
     *         to continue the list from where the previous returning call left off.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeMountTargets</code> operation. If present, it specifies
     * to continue the list from where the previous returning call left off.
     *
     * @param marker Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeMountTargets</code> operation. If present, it specifies
     *         to continue the list from where the previous returning call left off.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeMountTargets</code> operation. If present, it specifies
     * to continue the list from where the previous returning call left off.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeMountTargets</code> operation. If present, it specifies
     *         to continue the list from where the previous returning call left off.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsRequest withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * String. The ID of the file system whose mount targets you want to
     * list.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return String. The ID of the file system whose mount targets you want to
     *         list.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose mount targets you want to
     * list.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose mount targets you want to
     *         list.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * String. The ID of the file system whose mount targets you want to
     * list.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId String. The ID of the file system whose mount targets you want to
     *         list.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMaxItems() != null) sb.append("MaxItems: " + getMaxItems() + ",");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMaxItems() == null) ? 0 : getMaxItems().hashCode()); 
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeMountTargetsRequest == false) return false;
        DescribeMountTargetsRequest other = (DescribeMountTargetsRequest)obj;
        
        if (other.getMaxItems() == null ^ this.getMaxItems() == null) return false;
        if (other.getMaxItems() != null && other.getMaxItems().equals(this.getMaxItems()) == false) return false; 
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeMountTargetsRequest clone() {
        
            return (DescribeMountTargetsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeMountTargetsResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * 
 */
public class DescribeMountTargetsResult implements Serializable, Cloneable {

    /**
     * If the request included the <code>Marker</code>, the response returns
     * that value in this field.
     */
    private String marker;

    /**
     * Returns the file system's mount targets as an array of
     * <code>MountTargetDescription</code> objects.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription> mountTargets;

    /**
     * If a value is present, there are more mount targets to return. In a
     * subsequent request, you can provide <code>Marker</code> in your
     * request with this value to retrieve the next set of mount targets.
     */
    private String nextMarker;

    /**
     * If the request included the <code>Marker</code>, the response returns
     * that value in this field.
     *
     * @return If the request included the <code>Marker</code>, the response returns
     *         that value in this field.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * If the request included the <code>Marker</code>, the response returns
     * that value in this field.
     *
     * @param marker If the request included the <code>Marker</code>, the response returns
     *         that value in this field.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * If the request included the <code>Marker</code>, the response returns
     * that value in this field.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker If the request included the <code>Marker</code>, the response returns
     *         that value in this field.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsResult withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * Returns the file system's mount targets as an array of
     * <code>MountTargetDescription</code> objects.
     *
     * @return Returns the file system's mount targets as an array of
     *         <code>MountTargetDescription</code> objects.
     */
    public java.util.List<MountTargetDescription> getMountTargets() {
        if (mountTargets == null) {
              mountTargets = new com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription>();
              mountTargets.setAutoConstruct(true);
        }
        return mountTargets;
    }
    
    /**
     * Returns the file system's mount targets as an array of
     * <code>MountTargetDescription</code> objects.
     *
     * @param mountTargets Returns the file system's mount targets as an array of
     *         <code>MountTargetDescription</code> objects.
     */
    public void setMountTargets(java.util.Collection<MountTargetDescription> mountTargets) {
        if (mountTargets == null) {
            this.mountTargets = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription> mountTargetsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription>(mountTargets.size());
        mountTargetsCopy.addAll(mountTargets);
        this.mountTargets = mountTargetsCopy;
    }
    
    /**
     * Returns the file system's mount targets as an array of
     * <code>MountTargetDescription</code> objects.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setMountTargets(java.util.Collection)} or {@link
     * #withMountTargets(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param mountTargets Returns the file system's mount targets as an array of
     *         <code>MountTargetDescription</code> objects.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsResult withMountTargets(MountTargetDescription... mountTargets) {
        if (getMountTargets() == null) setMountTargets(new java.util.ArrayList<MountTargetDescription>(mountTargets.length));
        for (MountTargetDescription value : mountTargets) {
            getMountTargets().add(value);
        }
        return this;
    }
    
    /**
     * Returns the file system's mount targets as an array of
     * <code>MountTargetDescription</code> objects.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param mountTargets Returns the file system's mount targets as an array of
     *         <code>MountTargetDescription</code> objects.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsResult withMountTargets(java.util.Collection<MountTargetDescription> mountTargets) {
        if (mountTargets == null) {
            this.mountTargets = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription> mountTargetsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<MountTargetDescription>(mountTargets.size());
            mountTargetsCopy.addAll(mountTargets);
            this.mountTargets = mountTargetsCopy;
        }

        return this;
    }

    /**
     * If a value is present, there are more mount targets to return. In a
     * subsequent request, you can provide <code>Marker</code> in your
     * request with this value to retrieve the next set of mount targets.
     *
     * @return If a value is present, there are more mount targets to return. In a
     *         subsequent request, you can provide <code>Marker</code> in your
     *         request with this value to retrieve the next set of mount targets.
     */
    public String getNextMarker() {
        return nextMarker;
    }
    
    /**
     * If a value is present, there are more mount targets to return. In a
     * subsequent request, you can provide <code>Marker</code> in your
     * request with this value to retrieve the next set of mount targets.
     *
     * @param nextMarker If a value is present, there are more mount targets to return. In a
     *         subsequent request, you can provide <code>Marker</code> in your
     *         request with this value to retrieve the next set of mount targets.
     */
    public void setNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
    }
    
    /**
     * If a value is present, there are more mount targets to return. In a
     * subsequent request, you can provide <code>Marker</code> in your
     * request with this value to retrieve the next set of mount targets.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param nextMarker If a value is present, there are more mount targets to return. In a
     *         subsequent request, you can provide <code>Marker</code> in your
     *         request with this value to retrieve the next set of mount targets.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeMountTargetsResult withNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getMountTargets() != null) sb.append("MountTargets: " + getMountTargets() + ",");
        if (getNextMarker() != null) sb.append("NextMarker: " + getNextMarker() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getMountTargets() == null) ? 0 : getMountTargets().hashCode()); 
        hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeMountTargetsResult == false) return false;
        DescribeMountTargetsResult other = (DescribeMountTargetsResult)obj;
        
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getMountTargets() == null ^ this.getMountTargets() == null) return false;
        if (other.getMountTargets() != null && other.getMountTargets().equals(this.getMountTargets()) == false) return false; 
        if (other.getNextMarker() == null ^ this.getNextMarker() == null) return false;
        if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeMountTargetsResult clone() {
        try {
            return (DescribeMountTargetsResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeTagsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeTags(DescribeTagsRequest) DescribeTags operation}.
 * <p>
 * Returns the tags associated with a file system. The order of tags
 * returned in the response of one <code>DescribeTags</code> call, and
 * the order of tags returned across the responses of a multi-call
 * iteration (when using pagination), is unspecified.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>elasticfilesystem:DescribeTags</code> action.
 * </p>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#describeTags(DescribeTagsRequest)
 */
public class DescribeTagsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Optional. Maximum number of file system tags to return in the
     * response. It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     */
    private Integer maxItems;

    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeTags</code> operation. If present, it specifies to
     * continue the list from where the previous call left off.
     */
    private String marker;

    /**
     * The ID of the file system whose tag set you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * Optional. Maximum number of file system tags to return in the
     * response. It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @return Optional. Maximum number of file system tags to return in the
     *         response. It must be an integer with a value greater than zero.
     */
    public Integer getMaxItems() {
        return maxItems;
    }
    
    /**
     * Optional. Maximum number of file system tags to return in the
     * response. It must be an integer with a value greater than zero.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional. Maximum number of file system tags to return in the
     *         response. It must be an integer with a value greater than zero.
     */
    public void setMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
    }
    
    /**
     * Optional. Maximum number of file system tags to return in the
     * response. It must be an integer with a value greater than zero.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - <br/>
     *
     * @param maxItems Optional. Maximum number of file system tags to return in the
     *         response. It must be an integer with a value greater than zero.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsRequest withMaxItems(Integer maxItems) {
        this.maxItems = maxItems;
        return this;
    }

    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeTags</code> operation. If present, it specifies to
     * continue the list from where the previous call left off.
     *
     * @return Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeTags</code> operation. If present, it specifies to
     *         continue the list from where the previous call left off.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeTags</code> operation. If present, it specifies to
     * continue the list from where the previous call left off.
     *
     * @param marker Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeTags</code> operation. If present, it specifies to
     *         continue the list from where the previous call left off.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * Optional. String. Opaque pagination token returned from a previous
     * <code>DescribeTags</code> operation. If present, it specifies to
     * continue the list from where the previous call left off.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker Optional. String. Opaque pagination token returned from a previous
     *         <code>DescribeTags</code> operation. If present, it specifies to
     *         continue the list from where the previous call left off.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsRequest withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * The ID of the file system whose tag set you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The ID of the file system whose tag set you want to retrieve.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The ID of the file system whose tag set you want to retrieve.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system whose tag set you want to retrieve.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The ID of the file system whose tag set you want to retrieve.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system whose tag set you want to retrieve.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsRequest withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMaxItems() != null) sb.append("MaxItems: " + getMaxItems() + ",");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMaxItems() == null) ? 0 : getMaxItems().hashCode()); 
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeTagsRequest == false) return false;
        DescribeTagsRequest other = (DescribeTagsRequest)obj;
        
        if (other.getMaxItems() == null ^ this.getMaxItems() == null) return false;
        if (other.getMaxItems() != null && other.getMaxItems().equals(this.getMaxItems()) == false) return false; 
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeTagsRequest clone() {
        
            return (DescribeTagsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/DescribeTagsResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * 
 */
public class DescribeTagsResult implements Serializable, Cloneable {

    /**
     * If the request included a <code>Marker</code>, the response returns
     * that value in this field.
     */
    private String marker;

    /**
     * Returns tags associated with the file system as an array of
     * <code>Tag</code> objects.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tags;

    /**
     * If a value is present, there are more tags to return. In a subsequent
     * request, you can provide the value of <code>NextMarker</code> as the
     * value of the <code>Marker</code> parameter in your next request to
     * retrieve the next set of tags.
     */
    private String nextMarker;

    /**
     * If the request included a <code>Marker</code>, the response returns
     * that value in this field.
     *
     * @return If the request included a <code>Marker</code>, the response returns
     *         that value in this field.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * If the request included a <code>Marker</code>, the response returns
     * that value in this field.
     *
     * @param marker If the request included a <code>Marker</code>, the response returns
     *         that value in this field.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * If the request included a <code>Marker</code>, the response returns
     * that value in this field.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker If the request included a <code>Marker</code>, the response returns
     *         that value in this field.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsResult withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * Returns tags associated with the file system as an array of
     * <code>Tag</code> objects.
     *
     * @return Returns tags associated with the file system as an array of
     *         <code>Tag</code> objects.
     */
    public java.util.List<Tag> getTags() {
        if (tags == null) {
              tags = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>();
              tags.setAutoConstruct(true);
        }
        return tags;
    }
    
    /**
     * Returns tags associated with the file system as an array of
     * <code>Tag</code> objects.
     *
     * @param tags Returns tags associated with the file system as an array of
     *         <code>Tag</code> objects.
     */
    public void setTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tagsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>(tags.size());
        tagsCopy.addAll(tags);
        this.tags = tagsCopy;
    }
    
    /**
     * Returns tags associated with the file system as an array of
     * <code>Tag</code> objects.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setTags(java.util.Collection)} or {@link
     * #withTags(java.util.Collection)} if you want to override the existing
     * values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags Returns tags associated with the file system as an array of
     *         <code>Tag</code> objects.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsResult withTags(Tag... tags) {
        if (getTags() == null) setTags(new java.util.ArrayList<Tag>(tags.length));
        for (Tag value : tags) {
            getTags().add(value);
        }
        return this;
    }
    
    /**
     * Returns tags associated with the file system as an array of
     * <code>Tag</code> objects.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags Returns tags associated with the file system as an array of
     *         <code>Tag</code> objects.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsResult withTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tagsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Tag>(tags.size());
            tagsCopy.addAll(tags);
            this.tags = tagsCopy;
        }

        return this;
    }

    /**
     * If a value is present, there are more tags to return. In a subsequent
     * request, you can provide the value of <code>NextMarker</code> as the
     * value of the <code>Marker</code> parameter in your next request to
     * retrieve the next set of tags.
     *
     * @return If a value is present, there are more tags to return. In a subsequent
     *         request, you can provide the value of <code>NextMarker</code> as the
     *         value of the <code>Marker</code> parameter in your next request to
     *         retrieve the next set of tags.
     */
    public String getNextMarker() {
        return nextMarker;
    }
    
    /**
     * If a value is present, there are more tags to return. In a subsequent
     * request, you can provide the value of <code>NextMarker</code> as the
     * value of the <code>Marker</code> parameter in your next request to
     * retrieve the next set of tags.
     *
     * @param nextMarker If a value is present, there are more tags to return. In a subsequent
     *         request, you can provide the value of <code>NextMarker</code> as the
     *         value of the <code>Marker</code> parameter in your next request to
     *         retrieve the next set of tags.
     */
    public void setNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
    }
    
    /**
     * If a value is present, there are more tags to return. In a subsequent
     * request, you can provide the value of <code>NextMarker</code> as the
     * value of the <code>Marker</code> parameter in your next request to
     * retrieve the next set of tags.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param nextMarker If a value is present, there are more tags to return. In a subsequent
     *         request, you can provide the value of <code>NextMarker</code> as the
     *         value of the <code>Marker</code> parameter in your next request to
     *         retrieve the next set of tags.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DescribeTagsResult withNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getTags() != null) sb.append("Tags: " + getTags() + ",");
        if (getNextMarker() != null) sb.append("NextMarker: " + getNextMarker() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getTags() == null) ? 0 : getTags().hashCode()); 
        hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DescribeTagsResult == false) return false;
        DescribeTagsResult other = (DescribeTagsResult)obj;
        
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getTags() == null ^ this.getTags() == null) return false;
        if (other.getTags() != null && other.getTags().equals(this.getTags()) == false) return false; 
        if (other.getNextMarker() == null ^ this.getNextMarker() == null) return false;
        if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false) return false; 
        return true;
    }
    
    @Override
    public DescribeTagsResult clone() {
        try {
            return (DescribeTagsResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemAlreadyExistsException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the file system you are trying to create already exists,
 * with the creation token you provided.
 * </p>
 */        
public class FileSystemAlreadyExistsException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    private String fileSystemId;
    
    /**
     * Constructs a new FileSystemAlreadyExistsException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public FileSystemAlreadyExistsException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
    /**
     * Returns the value of the FileSystemId property for this object.
     *
     * @return The value of the FileSystemId property for this object.         
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
        
    /**
     * Sets the value of the FileSystemId property for this object.
     *
     * @param fileSystemId The new value for this object's FileSystemId property. 
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemDescription.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * This object provides description of a file system.
 * </p>
 */
public class FileSystemDescription implements Serializable, Cloneable {

    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     */
    private String ownerId;

    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     */
    private String creationToken;

    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     */
    private java.util.Date creationTime;

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     */
    private String lifeCycleState;

    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     */
    private String name;

    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     */
    private Integer numberOfMountTargets;

    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     */
    private FileSystemSize sizeInBytes;

    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @return The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     */
    public String getOwnerId() {
        return ownerId;
    }
    
    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     */
    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }
    
    /**
     * The AWS account that created the file system. If the file system was
     * created by an IAM user, the parent account to which the user belongs
     * is the owner.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account that created the file system. If the file system was
     *         created by an IAM user, the parent account to which the user belongs
     *         is the owner.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withOwnerId(String ownerId) {
        this.ownerId = ownerId;
        return this;
    }

    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @return Opaque string specified in the request.
     */
    public String getCreationToken() {
        return creationToken;
    }
    
    /**
     * Opaque string specified in the request.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Opaque string specified in the request.
     */
    public void setCreationToken(String creationToken) {
        this.creationToken = creationToken;
    }
    
    /**
     * Opaque string specified in the request.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 64<br/>
     *
     * @param creationToken Opaque string specified in the request.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withCreationToken(String creationToken) {
        this.creationToken = creationToken;
        return this;
    }

    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The file system ID assigned by Amazon EFS.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The file system ID assigned by Amazon EFS.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The file system ID assigned by Amazon EFS.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The file system ID assigned by Amazon EFS.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     *
     * @return The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     */
    public java.util.Date getCreationTime() {
        return creationTime;
    }
    
    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     *
     * @param creationTime The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     */
    public void setCreationTime(java.util.Date creationTime) {
        this.creationTime = creationTime;
    }
    
    /**
     * The time at which the file system was created, in seconds, since
     * 1970-01-01T00:00:00Z.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param creationTime The time at which the file system was created, in seconds, since
     *         1970-01-01T00:00:00Z.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withCreationTime(java.util.Date creationTime) {
        this.creationTime = creationTime;
        return this;
    }

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @return A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public String getLifeCycleState() {
        return lifeCycleState;
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public FileSystemDescription withLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
        return this;
    }

    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
    }
    
    /**
     * A predefined string value that indicates the lifecycle phase of the
     * file system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState A predefined string value that indicates the lifecycle phase of the
     *         file system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public FileSystemDescription withLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
        return this;
    }

    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @return You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     */
    public String getName() {
        return name;
    }
    
    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param name You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * You can add tags to a file system (see <a>CreateTags</a>) including a
     * "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     * the value in this field.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param name You can add tags to a file system (see <a>CreateTags</a>) including a
     *         "Name" tag. If the file system has a "Name" tag, Amazon EFS returns
     *         the value in this field.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @return The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     */
    public Integer getNumberOfMountTargets() {
        return numberOfMountTargets;
    }
    
    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param numberOfMountTargets The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     */
    public void setNumberOfMountTargets(Integer numberOfMountTargets) {
        this.numberOfMountTargets = numberOfMountTargets;
    }
    
    /**
     * The current number of mount targets (see <a>CreateMountTarget</a>) the
     * file system has.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param numberOfMountTargets The current number of mount targets (see <a>CreateMountTarget</a>) the
     *         file system has.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withNumberOfMountTargets(Integer numberOfMountTargets) {
        this.numberOfMountTargets = numberOfMountTargets;
        return this;
    }

    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     *
     * @return This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     */
    public FileSystemSize getSizeInBytes() {
        return sizeInBytes;
    }
    
    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     *
     * @param sizeInBytes This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     */
    public void setSizeInBytes(FileSystemSize sizeInBytes) {
        this.sizeInBytes = sizeInBytes;
    }
    
    /**
     * This object provides the latest known metered size of data stored in
     * the file system, in bytes, in its <code>Value</code> field, and the
     * time at which that size was determined in its <code>Timestamp</code>
     * field. The <code>Timestamp</code> value is the integer number of
     * seconds since 1970-01-01T00:00:00Z. Note that the value does not
     * represent the size of a consistent snapshot of the file system, but it
     * is eventually consistent when there are no writes to the file system.
     * That is, the value will represent actual size only if the file system
     * is not modified for a period longer than a couple of hours. Otherwise,
     * the value is not the exact size the file system was at any instant in
     * time.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param sizeInBytes This object provides the latest known metered size of data stored in
     *         the file system, in bytes, in its <code>Value</code> field, and the
     *         time at which that size was determined in its <code>Timestamp</code>
     *         field. The <code>Timestamp</code> value is the integer number of
     *         seconds since 1970-01-01T00:00:00Z. Note that the value does not
     *         represent the size of a consistent snapshot of the file system, but it
     *         is eventually consistent when there are no writes to the file system.
     *         That is, the value will represent actual size only if the file system
     *         is not modified for a period longer than a couple of hours. Otherwise,
     *         the value is not the exact size the file system was at any instant in
     *         time.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemDescription withSizeInBytes(FileSystemSize sizeInBytes) {
        this.sizeInBytes = sizeInBytes;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getOwnerId() != null) sb.append("OwnerId: " + getOwnerId() + ",");
        if (getCreationToken() != null) sb.append("CreationToken: " + getCreationToken() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getCreationTime() != null) sb.append("CreationTime: " + getCreationTime() + ",");
        if (getLifeCycleState() != null) sb.append("LifeCycleState: " + getLifeCycleState() + ",");
        if (getName() != null) sb.append("Name: " + getName() + ",");
        if (getNumberOfMountTargets() != null) sb.append("NumberOfMountTargets: " + getNumberOfMountTargets() + ",");
        if (getSizeInBytes() != null) sb.append("SizeInBytes: " + getSizeInBytes() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getOwnerId() == null) ? 0 : getOwnerId().hashCode()); 
        hashCode = prime * hashCode + ((getCreationToken() == null) ? 0 : getCreationToken().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getCreationTime() == null) ? 0 : getCreationTime().hashCode()); 
        hashCode = prime * hashCode + ((getLifeCycleState() == null) ? 0 : getLifeCycleState().hashCode()); 
        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode()); 
        hashCode = prime * hashCode + ((getNumberOfMountTargets() == null) ? 0 : getNumberOfMountTargets().hashCode()); 
        hashCode = prime * hashCode + ((getSizeInBytes() == null) ? 0 : getSizeInBytes().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof FileSystemDescription == false) return false;
        FileSystemDescription other = (FileSystemDescription)obj;
        
        if (other.getOwnerId() == null ^ this.getOwnerId() == null) return false;
        if (other.getOwnerId() != null && other.getOwnerId().equals(this.getOwnerId()) == false) return false; 
        if (other.getCreationToken() == null ^ this.getCreationToken() == null) return false;
        if (other.getCreationToken() != null && other.getCreationToken().equals(this.getCreationToken()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getCreationTime() == null ^ this.getCreationTime() == null) return false;
        if (other.getCreationTime() != null && other.getCreationTime().equals(this.getCreationTime()) == false) return false; 
        if (other.getLifeCycleState() == null ^ this.getLifeCycleState() == null) return false;
        if (other.getLifeCycleState() != null && other.getLifeCycleState().equals(this.getLifeCycleState()) == false) return false; 
        if (other.getName() == null ^ this.getName() == null) return false;
        if (other.getName() != null && other.getName().equals(this.getName()) == false) return false; 
        if (other.getNumberOfMountTargets() == null ^ this.getNumberOfMountTargets() == null) return false;
        if (other.getNumberOfMountTargets() != null && other.getNumberOfMountTargets().equals(this.getNumberOfMountTargets()) == false) return false; 
        if (other.getSizeInBytes() == null ^ this.getSizeInBytes() == null) return false;
        if (other.getSizeInBytes() != null && other.getSizeInBytes().equals(this.getSizeInBytes()) == false) return false; 
        return true;
    }
    
    @Override
    public FileSystemDescription clone() {
        try {
            return (FileSystemDescription) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemInUseException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if a file system has mount targets.
 * </p>
 */        
public class FileSystemInUseException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new FileSystemInUseException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public FileSystemInUseException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemLimitExceededException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the AWS account has already created maximum number of file
 * systems allowed per account.
 * </p>
 */        
public class FileSystemLimitExceededException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new FileSystemLimitExceededException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public FileSystemLimitExceededException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemNotFoundException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the specified <code>FileSystemId</code> does not exist in
 * the requester's AWS account.
 * </p>
 */        
public class FileSystemNotFoundException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new FileSystemNotFoundException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public FileSystemNotFoundException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/FileSystemSize.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * This object provides the latest known metered size, in bytes, of data
 * stored in the file system, in its <code>Value</code> field, and the
 * time at which that size was determined in its <code>Timestamp</code>
 * field. Note that the value does not represent the size of a consistent
 * snapshot of the file system, but it is eventually consistent when
 * there are no writes to the file system. That is, the value will
 * represent the actual size only if the file system is not modified for
 * a period longer than a couple of hours. Otherwise, the value is not
 * necessarily the exact size the file system was at any instant in time.
 * </p>
 */
public class FileSystemSize implements Serializable, Cloneable {

    /**
     * The latest known metered size, in bytes, of data stored in the file
     * system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     */
    private Long value;

    /**
     * The time at which the size of data, returned in the <code>Value</code>
     * field, was determined. The value is the integer number of seconds
     * since 1970-01-01T00:00:00Z.
     */
    private java.util.Date timestamp;

    /**
     * The latest known metered size, in bytes, of data stored in the file
     * system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @return The latest known metered size, in bytes, of data stored in the file
     *         system.
     */
    public Long getValue() {
        return value;
    }
    
    /**
     * The latest known metered size, in bytes, of data stored in the file
     * system.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param value The latest known metered size, in bytes, of data stored in the file
     *         system.
     */
    public void setValue(Long value) {
        this.value = value;
    }
    
    /**
     * The latest known metered size, in bytes, of data stored in the file
     * system.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>0 - <br/>
     *
     * @param value The latest known metered size, in bytes, of data stored in the file
     *         system.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemSize withValue(Long value) {
        this.value = value;
        return this;
    }

    /**
     * The time at which the size of data, returned in the <code>Value</code>
     * field, was determined. The value is the integer number of seconds
     * since 1970-01-01T00:00:00Z.
     *
     * @return The time at which the size of data, returned in the <code>Value</code>
     *         field, was determined. The value is the integer number of seconds
     *         since 1970-01-01T00:00:00Z.
     */
    public java.util.Date getTimestamp() {
        return timestamp;
    }
    
    /**
     * The time at which the size of data, returned in the <code>Value</code>
     * field, was determined. The value is the integer number of seconds
     * since 1970-01-01T00:00:00Z.
     *
     * @param timestamp The time at which the size of data, returned in the <code>Value</code>
     *         field, was determined. The value is the integer number of seconds
     *         since 1970-01-01T00:00:00Z.
     */
    public void setTimestamp(java.util.Date timestamp) {
        this.timestamp = timestamp;
    }
    
    /**
     * The time at which the size of data, returned in the <code>Value</code>
     * field, was determined. The value is the integer number of seconds
     * since 1970-01-01T00:00:00Z.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param timestamp The time at which the size of data, returned in the <code>Value</code>
     *         field, was determined. The value is the integer number of seconds
     *         since 1970-01-01T00:00:00Z.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public FileSystemSize withTimestamp(java.util.Date timestamp) {
        this.timestamp = timestamp;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getValue() != null) sb.append("Value: " + getValue() + ",");
        if (getTimestamp() != null) sb.append("Timestamp: " + getTimestamp() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getValue() == null) ? 0 : getValue().hashCode()); 
        hashCode = prime * hashCode + ((getTimestamp() == null) ? 0 : getTimestamp().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof FileSystemSize == false) return false;
        FileSystemSize other = (FileSystemSize)obj;
        
        if (other.getValue() == null ^ this.getValue() == null) return false;
        if (other.getValue() != null && other.getValue().equals(this.getValue()) == false) return false; 
        if (other.getTimestamp() == null ^ this.getTimestamp() == null) return false;
        if (other.getTimestamp() != null && other.getTimestamp().equals(this.getTimestamp()) == false) return false; 
        return true;
    }
    
    @Override
    public FileSystemSize clone() {
        try {
            return (FileSystemSize) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/IncorrectFileSystemLifeCycleStateException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the file system's life cycle state is not "created".
 * </p>
 */        
public class IncorrectFileSystemLifeCycleStateException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new IncorrectFileSystemLifeCycleStateException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public IncorrectFileSystemLifeCycleStateException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/IncorrectMountTargetStateException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the mount target is not in the correct state for the
 * operation.
 * </p>
 */        
public class IncorrectMountTargetStateException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new IncorrectMountTargetStateException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public IncorrectMountTargetStateException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/InternalServerErrorException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if an error occurred on the server side.
 * </p>
 */        
public class InternalServerErrorException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new InternalServerErrorException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InternalServerErrorException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/IpAddressInUseException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the request specified an <code>IpAddress</code> that is
 * already in use in the subnet.
 * </p>
 */        
public class IpAddressInUseException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new IpAddressInUseException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public IpAddressInUseException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/LifeCycleState.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

/**
 * Life Cycle State
 */
public enum LifeCycleState {
    
    Creating("creating"),
    Available("available"),
    Deleting("deleting"),
    Deleted("deleted");

    private String value;

    private LifeCycleState(String value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return this.value;
    }

    /**
     * Use this in place of valueOf.
     *
     * @param value
     *            real value
     * @return LifeCycleState corresponding to the value
     */
    public static LifeCycleState fromValue(String value) {
        if (value == null || "".equals(value)) {
            throw new IllegalArgumentException("Value cannot be null or empty!");
        
        } else if ("creating".equals(value)) {
            return LifeCycleState.Creating;
        } else if ("available".equals(value)) {
            return LifeCycleState.Available;
        } else if ("deleting".equals(value)) {
            return LifeCycleState.Deleting;
        } else if ("deleted".equals(value)) {
            return LifeCycleState.Deleted;
        } else {
            throw new IllegalArgumentException("Cannot create enum from " + value + " value!");
        }
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/ModifyMountTargetSecurityGroupsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#modifyMountTargetSecurityGroups(ModifyMountTargetSecurityGroupsRequest) ModifyMountTargetSecurityGroups operation}.
 * <p>
 * Modifies the set of security groups in effect for a mount target.
 * </p>
 * <p>
 * When you create a mount target, Amazon EFS also creates a new network
 * interface (see CreateMountTarget). This operation replaces the
 * security groups in effect for the network interface associated with a
 * mount target, with the <code>SecurityGroups</code> provided in the
 * request. This operation requires that the network interface of the
 * mount target has been created and the life cycle state of the mount
 * target is not "deleted".
 * </p>
 * <p>
 * The operation requires permissions for the following actions:
 * </p>
 * 
 * <ul>
 * <li> <code>elasticfilesystem:ModifyMountTargetSecurityGroups</code>
 * action on the mount target's file system. </li>
 * <li> <code>ec2:ModifyNetworkInterfaceAttribute</code> action on the
 * mount target's network interface. </li>
 * 
 * </ul>
 *
 * @see com.amazonaws.services.elasticfilesystem.AmazonElasticFileSystem#modifyMountTargetSecurityGroups(ModifyMountTargetSecurityGroupsRequest)
 */
public class ModifyMountTargetSecurityGroupsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The ID of the mount target whose security groups you want to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     */
    private String mountTargetId;

    /**
     * An array of up to five VPC security group IDs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroups;

    /**
     * The ID of the mount target whose security groups you want to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @return The ID of the mount target whose security groups you want to modify.
     */
    public String getMountTargetId() {
        return mountTargetId;
    }
    
    /**
     * The ID of the mount target whose security groups you want to modify.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The ID of the mount target whose security groups you want to modify.
     */
    public void setMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
    }
    
    /**
     * The ID of the mount target whose security groups you want to modify.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The ID of the mount target whose security groups you want to modify.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ModifyMountTargetSecurityGroupsRequest withMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
        return this;
    }

    /**
     * An array of up to five VPC security group IDs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @return An array of up to five VPC security group IDs.
     */
    public java.util.List<String> getSecurityGroups() {
        if (securityGroups == null) {
              securityGroups = new com.amazonaws.internal.ListWithAutoConstructFlag<String>();
              securityGroups.setAutoConstruct(true);
        }
        return securityGroups;
    }
    
    /**
     * An array of up to five VPC security group IDs.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of up to five VPC security group IDs.
     */
    public void setSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
        securityGroupsCopy.addAll(securityGroups);
        this.securityGroups = securityGroupsCopy;
    }
    
    /**
     * An array of up to five VPC security group IDs.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setSecurityGroups(java.util.Collection)} or {@link
     * #withSecurityGroups(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of up to five VPC security group IDs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ModifyMountTargetSecurityGroupsRequest withSecurityGroups(String... securityGroups) {
        if (getSecurityGroups() == null) setSecurityGroups(new java.util.ArrayList<String>(securityGroups.length));
        for (String value : securityGroups) {
            getSecurityGroups().add(value);
        }
        return this;
    }
    
    /**
     * An array of up to five VPC security group IDs.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 5<br/>
     *
     * @param securityGroups An array of up to five VPC security group IDs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ModifyMountTargetSecurityGroupsRequest withSecurityGroups(java.util.Collection<String> securityGroups) {
        if (securityGroups == null) {
            this.securityGroups = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(securityGroups.size());
            securityGroupsCopy.addAll(securityGroups);
            this.securityGroups = securityGroupsCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMountTargetId() != null) sb.append("MountTargetId: " + getMountTargetId() + ",");
        if (getSecurityGroups() != null) sb.append("SecurityGroups: " + getSecurityGroups() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMountTargetId() == null) ? 0 : getMountTargetId().hashCode()); 
        hashCode = prime * hashCode + ((getSecurityGroups() == null) ? 0 : getSecurityGroups().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof ModifyMountTargetSecurityGroupsRequest == false) return false;
        ModifyMountTargetSecurityGroupsRequest other = (ModifyMountTargetSecurityGroupsRequest)obj;
        
        if (other.getMountTargetId() == null ^ this.getMountTargetId() == null) return false;
        if (other.getMountTargetId() != null && other.getMountTargetId().equals(this.getMountTargetId()) == false) return false; 
        if (other.getSecurityGroups() == null ^ this.getSecurityGroups() == null) return false;
        if (other.getSecurityGroups() != null && other.getSecurityGroups().equals(this.getSecurityGroups()) == false) return false; 
        return true;
    }
    
    @Override
    public ModifyMountTargetSecurityGroupsRequest clone() {
        
            return (ModifyMountTargetSecurityGroupsRequest) super.clone();
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/MountTargetConflictException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the mount target would violate one of the specified
 * restrictions based on the file system's existing mount targets.
 * </p>
 */        
public class MountTargetConflictException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new MountTargetConflictException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MountTargetConflictException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/MountTargetDescription.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * This object provides description of a mount target.
 * </p>
 */
public class MountTargetDescription implements Serializable, Cloneable {

    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     */
    private String ownerId;

    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     */
    private String mountTargetId;

    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     */
    private String fileSystemId;

    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     */
    private String subnetId;

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     */
    private String lifeCycleState;

    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     */
    private String ipAddress;

    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     */
    private String networkInterfaceId;

    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @return The AWS account ID that owns the resource.
     */
    public String getOwnerId() {
        return ownerId;
    }
    
    /**
     * The AWS account ID that owns the resource.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account ID that owns the resource.
     */
    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }
    
    /**
     * The AWS account ID that owns the resource.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{12}<br/>
     *
     * @param ownerId The AWS account ID that owns the resource.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withOwnerId(String ownerId) {
        this.ownerId = ownerId;
        return this;
    }

    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @return The system-assigned mount target ID.
     */
    public String getMountTargetId() {
        return mountTargetId;
    }
    
    /**
     * The system-assigned mount target ID.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The system-assigned mount target ID.
     */
    public void setMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
    }
    
    /**
     * The system-assigned mount target ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fsmt-[0-9a-f]{8}<br/>
     *
     * @param mountTargetId The system-assigned mount target ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withMountTargetId(String mountTargetId) {
        this.mountTargetId = mountTargetId;
        return this;
    }

    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @return The ID of the file system for which the mount target is intended.
     */
    public String getFileSystemId() {
        return fileSystemId;
    }
    
    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which the mount target is intended.
     */
    public void setFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
    }
    
    /**
     * The ID of the file system for which the mount target is intended.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>fs-[0-9a-f]{8}<br/>
     *
     * @param fileSystemId The ID of the file system for which the mount target is intended.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withFileSystemId(String fileSystemId) {
        this.fileSystemId = fileSystemId;
        return this;
    }

    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @return The ID of the subnet that the mount target is in.
     */
    public String getSubnetId() {
        return subnetId;
    }
    
    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet that the mount target is in.
     */
    public void setSubnetId(String subnetId) {
        this.subnetId = subnetId;
    }
    
    /**
     * The ID of the subnet that the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>subnet-[0-9a-f]{8}<br/>
     *
     * @param subnetId The ID of the subnet that the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withSubnetId(String subnetId) {
        this.subnetId = subnetId;
        return this;
    }

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @return The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public String getLifeCycleState() {
        return lifeCycleState;
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public MountTargetDescription withLifeCycleState(String lifeCycleState) {
        this.lifeCycleState = lifeCycleState;
        return this;
    }

    /**
     * The lifecycle state the mount target is in.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @see LifeCycleState
     */
    public void setLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
    }
    
    /**
     * The lifecycle state the mount target is in.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>creating, available, deleting, deleted
     *
     * @param lifeCycleState The lifecycle state the mount target is in.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see LifeCycleState
     */
    public MountTargetDescription withLifeCycleState(LifeCycleState lifeCycleState) {
        this.lifeCycleState = lifeCycleState.toString();
        return this;
    }

    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @return The address at which the file system may be mounted via the mount
     *         target.
     */
    public String getIpAddress() {
        return ipAddress;
    }
    
    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress The address at which the file system may be mounted via the mount
     *         target.
     */
    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }
    
    /**
     * The address at which the file system may be mounted via the mount
     * target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}<br/>
     *
     * @param ipAddress The address at which the file system may be mounted via the mount
     *         target.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
        return this;
    }

    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @return The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     */
    public String getNetworkInterfaceId() {
        return networkInterfaceId;
    }
    
    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @param networkInterfaceId The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     */
    public void setNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
    }
    
    /**
     * The ID of the network interface that Amazon EFS created when it
     * created the mount target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>eni-[0-9a-f]{8}<br/>
     *
     * @param networkInterfaceId The ID of the network interface that Amazon EFS created when it
     *         created the mount target.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public MountTargetDescription withNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getOwnerId() != null) sb.append("OwnerId: " + getOwnerId() + ",");
        if (getMountTargetId() != null) sb.append("MountTargetId: " + getMountTargetId() + ",");
        if (getFileSystemId() != null) sb.append("FileSystemId: " + getFileSystemId() + ",");
        if (getSubnetId() != null) sb.append("SubnetId: " + getSubnetId() + ",");
        if (getLifeCycleState() != null) sb.append("LifeCycleState: " + getLifeCycleState() + ",");
        if (getIpAddress() != null) sb.append("IpAddress: " + getIpAddress() + ",");
        if (getNetworkInterfaceId() != null) sb.append("NetworkInterfaceId: " + getNetworkInterfaceId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getOwnerId() == null) ? 0 : getOwnerId().hashCode()); 
        hashCode = prime * hashCode + ((getMountTargetId() == null) ? 0 : getMountTargetId().hashCode()); 
        hashCode = prime * hashCode + ((getFileSystemId() == null) ? 0 : getFileSystemId().hashCode()); 
        hashCode = prime * hashCode + ((getSubnetId() == null) ? 0 : getSubnetId().hashCode()); 
        hashCode = prime * hashCode + ((getLifeCycleState() == null) ? 0 : getLifeCycleState().hashCode()); 
        hashCode = prime * hashCode + ((getIpAddress() == null) ? 0 : getIpAddress().hashCode()); 
        hashCode = prime * hashCode + ((getNetworkInterfaceId() == null) ? 0 : getNetworkInterfaceId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof MountTargetDescription == false) return false;
        MountTargetDescription other = (MountTargetDescription)obj;
        
        if (other.getOwnerId() == null ^ this.getOwnerId() == null) return false;
        if (other.getOwnerId() != null && other.getOwnerId().equals(this.getOwnerId()) == false) return false; 
        if (other.getMountTargetId() == null ^ this.getMountTargetId() == null) return false;
        if (other.getMountTargetId() != null && other.getMountTargetId().equals(this.getMountTargetId()) == false) return false; 
        if (other.getFileSystemId() == null ^ this.getFileSystemId() == null) return false;
        if (other.getFileSystemId() != null && other.getFileSystemId().equals(this.getFileSystemId()) == false) return false; 
        if (other.getSubnetId() == null ^ this.getSubnetId() == null) return false;
        if (other.getSubnetId() != null && other.getSubnetId().equals(this.getSubnetId()) == false) return false; 
        if (other.getLifeCycleState() == null ^ this.getLifeCycleState() == null) return false;
        if (other.getLifeCycleState() != null && other.getLifeCycleState().equals(this.getLifeCycleState()) == false) return false; 
        if (other.getIpAddress() == null ^ this.getIpAddress() == null) return false;
        if (other.getIpAddress() != null && other.getIpAddress().equals(this.getIpAddress()) == false) return false; 
        if (other.getNetworkInterfaceId() == null ^ this.getNetworkInterfaceId() == null) return false;
        if (other.getNetworkInterfaceId() != null && other.getNetworkInterfaceId().equals(this.getNetworkInterfaceId()) == false) return false; 
        return true;
    }
    
    @Override
    public MountTargetDescription clone() {
        try {
            return (MountTargetDescription) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/MountTargetNotFoundException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if there is no mount target with the specified ID is found in
 * the caller's account.
 * </p>
 */        
public class MountTargetNotFoundException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new MountTargetNotFoundException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MountTargetNotFoundException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/NetworkInterfaceLimitExceededException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The calling account has reached the ENI limit for the specific AWS
 * region. Client should try to delete some ENIs or get its account limit
 * raised. For more information, go to
 * <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html"> Amazon VPC Limits </a>
 * in the Amazon Virtual Private Cloud User Guide (see the Network
 * interfaces per VPC entry in the table).
 * </p>
 */        
public class NetworkInterfaceLimitExceededException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new NetworkInterfaceLimitExceededException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public NetworkInterfaceLimitExceededException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/NoFreeAddressesInSubnetException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if <code>IpAddress</code> was not specified in the request
 * and there are no free IP addresses in the subnet.
 * </p>
 */        
public class NoFreeAddressesInSubnetException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new NoFreeAddressesInSubnetException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public NoFreeAddressesInSubnetException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/SecurityGroupLimitExceededException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if the size of <code>SecurityGroups</code> specified in the
 * request is greater than five.
 * </p>
 */        
public class SecurityGroupLimitExceededException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new SecurityGroupLimitExceededException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public SecurityGroupLimitExceededException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/SecurityGroupNotFoundException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if one of the specified security groups does not exist in the
 * subnet's VPC.
 * </p>
 */        
public class SecurityGroupNotFoundException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new SecurityGroupNotFoundException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public SecurityGroupNotFoundException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/SubnetNotFoundException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Returned if there is no subnet with ID <code>SubnetId</code> provided
 * in the request.
 * </p>
 */        
public class SubnetNotFoundException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new SubnetNotFoundException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public SubnetNotFoundException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/Tag.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import java.io.Serializable;

/**
 * <p>
 * A tag is a pair of key and value. The allowed characters in keys and
 * values are letters, whitespace, and numbers, representable in UTF-8,
 * and the characters '+', '-', '=', '.', '_', ':', and '/'.
 * </p>
 */
public class Tag implements Serializable, Cloneable {

    /**
     * Tag key, a string. The key must not start with "aws:".
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     */
    private String key;

    /**
     * Value of the tag key.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     */
    private String value;

    /**
     * Tag key, a string. The key must not start with "aws:".
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @return Tag key, a string. The key must not start with "aws:".
     */
    public String getKey() {
        return key;
    }
    
    /**
     * Tag key, a string. The key must not start with "aws:".
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param key Tag key, a string. The key must not start with "aws:".
     */
    public void setKey(String key) {
        this.key = key;
    }
    
    /**
     * Tag key, a string. The key must not start with "aws:".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 128<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param key Tag key, a string. The key must not start with "aws:".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Tag withKey(String key) {
        this.key = key;
        return this;
    }

    /**
     * Value of the tag key.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @return Value of the tag key.
     */
    public String getValue() {
        return value;
    }
    
    /**
     * Value of the tag key.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param value Value of the tag key.
     */
    public void setValue(String value) {
        this.value = value;
    }
    
    /**
     * Value of the tag key.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>0 - 256<br/>
     * <b>Pattern: </b>^([\p{L}\p{Z}\p{N}_.:/=+\-%@]*)$<br/>
     *
     * @param value Value of the tag key.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Tag withValue(String value) {
        this.value = value;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getKey() != null) sb.append("Key: " + getKey() + ",");
        if (getValue() != null) sb.append("Value: " + getValue() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getKey() == null) ? 0 : getKey().hashCode()); 
        hashCode = prime * hashCode + ((getValue() == null) ? 0 : getValue().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof Tag == false) return false;
        Tag other = (Tag)obj;
        
        if (other.getKey() == null ^ this.getKey() == null) return false;
        if (other.getKey() != null && other.getKey().equals(this.getKey()) == false) return false; 
        if (other.getValue() == null ^ this.getValue() == null) return false;
        if (other.getValue() != null && other.getValue().equals(this.getValue()) == false) return false; 
        return true;
    }
    
    @Override
    public Tag clone() {
        try {
            return (Tag) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/UnsupportedAvailabilityZoneException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model;

import com.amazonaws.AmazonServiceException;

/**
 * AmazonElasticFileSystem exception
 */        
public class UnsupportedAvailabilityZoneException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    private String errorCode;
    
    /**
     * Constructs a new UnsupportedAvailabilityZoneException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public UnsupportedAvailabilityZoneException(String message) {
        super(message);
    }
    
    /**
     * Returns the value of the ErrorCode property for this object.
     *
     * @return The value of the ErrorCode property for this object.         
     */
    public String getErrorCode() {
        return errorCode;
    }
        
    /**
     * Sets the value of the ErrorCode property for this object.
     *
     * @param errorCode The new value for this object's ErrorCode property. 
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/package-info.java

/**
 * Classes modeling the various types represented by AmazonElasticFileSystem.
 */
 package com.amazonaws.services.elasticfilesystem.model;
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/CreateFileSystemRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Create File System Request Marshaller
 */
public class CreateFileSystemRequestMarshaller implements Marshaller<Request<CreateFileSystemRequest>, CreateFileSystemRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/file-systems";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateFileSystemRequest> marshall(CreateFileSystemRequest createFileSystemRequest) {
        if (createFileSystemRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateFileSystemRequest> request = new DefaultRequest<CreateFileSystemRequest>(createFileSystemRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.CreateFileSystem";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.POST);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();
          
            if (createFileSystemRequest.getCreationToken() != null) {
                jsonWriter.key("CreationToken").value(createFileSystemRequest.getCreationToken());
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/CreateFileSystemResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Create File System Result JSON Unmarshaller
 */
public class CreateFileSystemResultJsonUnmarshaller implements Unmarshaller<CreateFileSystemResult, JsonUnmarshallerContext> {

    public CreateFileSystemResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        CreateFileSystemResult createFileSystemResult = new CreateFileSystemResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("OwnerId", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setOwnerId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CreationToken", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setCreationToken(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("FileSystemId", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setFileSystemId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CreationTime", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setCreationTime(DateJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("LifeCycleState", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setLifeCycleState(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("Name", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setName(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("NumberOfMountTargets", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setNumberOfMountTargets(IntegerJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("SizeInBytes", targetDepth)) {
                    context.nextToken();
                    createFileSystemResult.setSizeInBytes(FileSystemSizeJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return createFileSystemResult;
    }

    private static CreateFileSystemResultJsonUnmarshaller instance;
    public static CreateFileSystemResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new CreateFileSystemResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/CreateMountTargetRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Create Mount Target Request Marshaller
 */
public class CreateMountTargetRequestMarshaller implements Marshaller<Request<CreateMountTargetRequest>, CreateMountTargetRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/mount-targets";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateMountTargetRequest> marshall(CreateMountTargetRequest createMountTargetRequest) {
        if (createMountTargetRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateMountTargetRequest> request = new DefaultRequest<CreateMountTargetRequest>(createMountTargetRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.CreateMountTarget";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.POST);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();
          
            if (createMountTargetRequest.getFileSystemId() != null) {
                jsonWriter.key("FileSystemId").value(createMountTargetRequest.getFileSystemId());
            }
            if (createMountTargetRequest.getSubnetId() != null) {
                jsonWriter.key("SubnetId").value(createMountTargetRequest.getSubnetId());
            }
            if (createMountTargetRequest.getIpAddress() != null) {
                jsonWriter.key("IpAddress").value(createMountTargetRequest.getIpAddress());
            }

            com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsList = (com.amazonaws.internal.ListWithAutoConstructFlag<String>)(createMountTargetRequest.getSecurityGroups());
            if (securityGroupsList != null && !(securityGroupsList.isAutoConstruct() && securityGroupsList.isEmpty())) {

                jsonWriter.key("SecurityGroups");
                jsonWriter.array();

                for (String securityGroupsListValue : securityGroupsList) {
                    if (securityGroupsListValue != null) {
                        jsonWriter.value(securityGroupsListValue);
                    }
                }
                jsonWriter.endArray();
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/CreateMountTargetResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Create Mount Target Result JSON Unmarshaller
 */
public class CreateMountTargetResultJsonUnmarshaller implements Unmarshaller<CreateMountTargetResult, JsonUnmarshallerContext> {

    public CreateMountTargetResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        CreateMountTargetResult createMountTargetResult = new CreateMountTargetResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("OwnerId", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setOwnerId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("MountTargetId", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setMountTargetId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("FileSystemId", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setFileSystemId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("SubnetId", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setSubnetId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("LifeCycleState", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setLifeCycleState(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("IpAddress", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setIpAddress(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("NetworkInterfaceId", targetDepth)) {
                    context.nextToken();
                    createMountTargetResult.setNetworkInterfaceId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return createMountTargetResult;
    }

    private static CreateMountTargetResultJsonUnmarshaller instance;
    public static CreateMountTargetResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new CreateMountTargetResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/CreateTagsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Create Tags Request Marshaller
 */
public class CreateTagsRequestMarshaller implements Marshaller<Request<CreateTagsRequest>, CreateTagsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/create-tags/{FileSystemId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<CreateTagsRequest> marshall(CreateTagsRequest createTagsRequest) {
        if (createTagsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateTagsRequest> request = new DefaultRequest<CreateTagsRequest>(createTagsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.CreateTags";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.POST);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (createTagsRequest.getFileSystemId() == null) ? null : StringUtils.fromString(createTagsRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (createTagsRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(createTagsRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();

            com.amazonaws.internal.ListWithAutoConstructFlag<Tag> tagsList = (com.amazonaws.internal.ListWithAutoConstructFlag<Tag>)(createTagsRequest.getTags());
            if (tagsList != null && !(tagsList.isAutoConstruct() && tagsList.isEmpty())) {

                jsonWriter.key("Tags");
                jsonWriter.array();

                for (Tag tagsListValue : tagsList) {
                    if (tagsListValue != null) {
                        jsonWriter.object();
                        if (tagsListValue.getKey() != null) {
                            jsonWriter.key("Key").value(tagsListValue.getKey());
                        }
                        if (tagsListValue.getValue() != null) {
                            jsonWriter.key("Value").value(tagsListValue.getValue());
                        }
                        jsonWriter.endObject();
                    }
                }
                jsonWriter.endArray();
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DeleteFileSystemRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Delete File System Request Marshaller
 */
public class DeleteFileSystemRequestMarshaller implements Marshaller<Request<DeleteFileSystemRequest>, DeleteFileSystemRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/file-systems/{FileSystemId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteFileSystemRequest> marshall(DeleteFileSystemRequest deleteFileSystemRequest) {
        if (deleteFileSystemRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteFileSystemRequest> request = new DefaultRequest<DeleteFileSystemRequest>(deleteFileSystemRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DeleteFileSystem";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.DELETE);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (deleteFileSystemRequest.getFileSystemId() == null) ? null : StringUtils.fromString(deleteFileSystemRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (deleteFileSystemRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(deleteFileSystemRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DeleteMountTargetRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Delete Mount Target Request Marshaller
 */
public class DeleteMountTargetRequestMarshaller implements Marshaller<Request<DeleteMountTargetRequest>, DeleteMountTargetRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/mount-targets/{MountTargetId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteMountTargetRequest> marshall(DeleteMountTargetRequest deleteMountTargetRequest) {
        if (deleteMountTargetRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteMountTargetRequest> request = new DefaultRequest<DeleteMountTargetRequest>(deleteMountTargetRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DeleteMountTarget";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.DELETE);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MountTargetId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MountTargetId");

            String value = (deleteMountTargetRequest.getMountTargetId() == null) ? null : StringUtils.fromString(deleteMountTargetRequest.getMountTargetId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MountTargetId}", (deleteMountTargetRequest.getMountTargetId() == null) ? "" : StringUtils.fromString(deleteMountTargetRequest.getMountTargetId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DeleteTagsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Delete Tags Request Marshaller
 */
public class DeleteTagsRequestMarshaller implements Marshaller<Request<DeleteTagsRequest>, DeleteTagsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/delete-tags/{FileSystemId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DeleteTagsRequest> marshall(DeleteTagsRequest deleteTagsRequest) {
        if (deleteTagsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DeleteTagsRequest> request = new DefaultRequest<DeleteTagsRequest>(deleteTagsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DeleteTags";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.POST);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (deleteTagsRequest.getFileSystemId() == null) ? null : StringUtils.fromString(deleteTagsRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (deleteTagsRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(deleteTagsRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();

            com.amazonaws.internal.ListWithAutoConstructFlag<String> tagKeysList = (com.amazonaws.internal.ListWithAutoConstructFlag<String>)(deleteTagsRequest.getTagKeys());
            if (tagKeysList != null && !(tagKeysList.isAutoConstruct() && tagKeysList.isEmpty())) {

                jsonWriter.key("TagKeys");
                jsonWriter.array();

                for (String tagKeysListValue : tagKeysList) {
                    if (tagKeysListValue != null) {
                        jsonWriter.value(tagKeysListValue);
                    }
                }
                jsonWriter.endArray();
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeFileSystemsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe File Systems Request Marshaller
 */
public class DescribeFileSystemsRequestMarshaller implements Marshaller<Request<DescribeFileSystemsRequest>, DescribeFileSystemsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/file-systems?MaxItems={MaxItems}&Marker={Marker}&CreationToken={CreationToken}&FileSystemId={FileSystemId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DescribeFileSystemsRequest> marshall(DescribeFileSystemsRequest describeFileSystemsRequest) {
        if (describeFileSystemsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DescribeFileSystemsRequest> request = new DefaultRequest<DescribeFileSystemsRequest>(describeFileSystemsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DescribeFileSystems";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.GET);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");

            String value = (describeFileSystemsRequest.getMaxItems() == null) ? null : StringUtils.fromInteger(describeFileSystemsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (describeFileSystemsRequest.getMaxItems() == null) ? "" : StringUtils.fromInteger(describeFileSystemsRequest.getMaxItems())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");

            String value = (describeFileSystemsRequest.getMarker() == null) ? null : StringUtils.fromString(describeFileSystemsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (describeFileSystemsRequest.getMarker() == null) ? "" : StringUtils.fromString(describeFileSystemsRequest.getMarker())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("CreationToken")) {
            String name = DYNAMIC_QUERY_PARAMS.get("CreationToken");

            String value = (describeFileSystemsRequest.getCreationToken() == null) ? null : StringUtils.fromString(describeFileSystemsRequest.getCreationToken());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{CreationToken}", (describeFileSystemsRequest.getCreationToken() == null) ? "" : StringUtils.fromString(describeFileSystemsRequest.getCreationToken())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (describeFileSystemsRequest.getFileSystemId() == null) ? null : StringUtils.fromString(describeFileSystemsRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (describeFileSystemsRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(describeFileSystemsRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeFileSystemsResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Describe File Systems Result JSON Unmarshaller
 */
public class DescribeFileSystemsResultJsonUnmarshaller implements Unmarshaller<DescribeFileSystemsResult, JsonUnmarshallerContext> {

    public DescribeFileSystemsResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeFileSystemsResult describeFileSystemsResult = new DescribeFileSystemsResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("Marker", targetDepth)) {
                    context.nextToken();
                    describeFileSystemsResult.setMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("FileSystems", targetDepth)) {
                    context.nextToken();
                    describeFileSystemsResult.setFileSystems(new ListUnmarshaller<FileSystemDescription>(FileSystemDescriptionJsonUnmarshaller.getInstance()).unmarshall(context));
                }
                if (context.testExpression("NextMarker", targetDepth)) {
                    context.nextToken();
                    describeFileSystemsResult.setNextMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return describeFileSystemsResult;
    }

    private static DescribeFileSystemsResultJsonUnmarshaller instance;
    public static DescribeFileSystemsResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeFileSystemsResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeMountTargetSecurityGroupsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Mount Target Security Groups Request Marshaller
 */
public class DescribeMountTargetSecurityGroupsRequestMarshaller implements Marshaller<Request<DescribeMountTargetSecurityGroupsRequest>, DescribeMountTargetSecurityGroupsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/mount-targets/{MountTargetId}/security-groups";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DescribeMountTargetSecurityGroupsRequest> marshall(DescribeMountTargetSecurityGroupsRequest describeMountTargetSecurityGroupsRequest) {
        if (describeMountTargetSecurityGroupsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DescribeMountTargetSecurityGroupsRequest> request = new DefaultRequest<DescribeMountTargetSecurityGroupsRequest>(describeMountTargetSecurityGroupsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DescribeMountTargetSecurityGroups";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.GET);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MountTargetId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MountTargetId");

            String value = (describeMountTargetSecurityGroupsRequest.getMountTargetId() == null) ? null : StringUtils.fromString(describeMountTargetSecurityGroupsRequest.getMountTargetId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MountTargetId}", (describeMountTargetSecurityGroupsRequest.getMountTargetId() == null) ? "" : StringUtils.fromString(describeMountTargetSecurityGroupsRequest.getMountTargetId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeMountTargetSecurityGroupsResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Describe Mount Target Security Groups Result JSON Unmarshaller
 */
public class DescribeMountTargetSecurityGroupsResultJsonUnmarshaller implements Unmarshaller<DescribeMountTargetSecurityGroupsResult, JsonUnmarshallerContext> {

    public DescribeMountTargetSecurityGroupsResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeMountTargetSecurityGroupsResult describeMountTargetSecurityGroupsResult = new DescribeMountTargetSecurityGroupsResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("SecurityGroups", targetDepth)) {
                    context.nextToken();
                    describeMountTargetSecurityGroupsResult.setSecurityGroups(new ListUnmarshaller<String>(StringJsonUnmarshaller.getInstance()).unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return describeMountTargetSecurityGroupsResult;
    }

    private static DescribeMountTargetSecurityGroupsResultJsonUnmarshaller instance;
    public static DescribeMountTargetSecurityGroupsResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeMountTargetSecurityGroupsResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeMountTargetsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Mount Targets Request Marshaller
 */
public class DescribeMountTargetsRequestMarshaller implements Marshaller<Request<DescribeMountTargetsRequest>, DescribeMountTargetsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/mount-targets?MaxItems={MaxItems}&Marker={Marker}&FileSystemId={FileSystemId}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DescribeMountTargetsRequest> marshall(DescribeMountTargetsRequest describeMountTargetsRequest) {
        if (describeMountTargetsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DescribeMountTargetsRequest> request = new DefaultRequest<DescribeMountTargetsRequest>(describeMountTargetsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DescribeMountTargets";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.GET);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");

            String value = (describeMountTargetsRequest.getMaxItems() == null) ? null : StringUtils.fromInteger(describeMountTargetsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (describeMountTargetsRequest.getMaxItems() == null) ? "" : StringUtils.fromInteger(describeMountTargetsRequest.getMaxItems())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");

            String value = (describeMountTargetsRequest.getMarker() == null) ? null : StringUtils.fromString(describeMountTargetsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (describeMountTargetsRequest.getMarker() == null) ? "" : StringUtils.fromString(describeMountTargetsRequest.getMarker())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (describeMountTargetsRequest.getFileSystemId() == null) ? null : StringUtils.fromString(describeMountTargetsRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (describeMountTargetsRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(describeMountTargetsRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeMountTargetsResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Describe Mount Targets Result JSON Unmarshaller
 */
public class DescribeMountTargetsResultJsonUnmarshaller implements Unmarshaller<DescribeMountTargetsResult, JsonUnmarshallerContext> {

    public DescribeMountTargetsResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeMountTargetsResult describeMountTargetsResult = new DescribeMountTargetsResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("Marker", targetDepth)) {
                    context.nextToken();
                    describeMountTargetsResult.setMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("MountTargets", targetDepth)) {
                    context.nextToken();
                    describeMountTargetsResult.setMountTargets(new ListUnmarshaller<MountTargetDescription>(MountTargetDescriptionJsonUnmarshaller.getInstance()).unmarshall(context));
                }
                if (context.testExpression("NextMarker", targetDepth)) {
                    context.nextToken();
                    describeMountTargetsResult.setNextMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return describeMountTargetsResult;
    }

    private static DescribeMountTargetsResultJsonUnmarshaller instance;
    public static DescribeMountTargetsResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeMountTargetsResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeTagsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Tags Request Marshaller
 */
public class DescribeTagsRequestMarshaller implements Marshaller<Request<DescribeTagsRequest>, DescribeTagsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/tags/{FileSystemId}/?MaxItems={MaxItems}&Marker={Marker}";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<DescribeTagsRequest> marshall(DescribeTagsRequest describeTagsRequest) {
        if (describeTagsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<DescribeTagsRequest> request = new DefaultRequest<DescribeTagsRequest>(describeTagsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.DescribeTags";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.GET);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MaxItems")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MaxItems");

            String value = (describeTagsRequest.getMaxItems() == null) ? null : StringUtils.fromInteger(describeTagsRequest.getMaxItems());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MaxItems}", (describeTagsRequest.getMaxItems() == null) ? "" : StringUtils.fromInteger(describeTagsRequest.getMaxItems())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("Marker")) {
            String name = DYNAMIC_QUERY_PARAMS.get("Marker");

            String value = (describeTagsRequest.getMarker() == null) ? null : StringUtils.fromString(describeTagsRequest.getMarker());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{Marker}", (describeTagsRequest.getMarker() == null) ? "" : StringUtils.fromString(describeTagsRequest.getMarker())); 
        } 
        if (DYNAMIC_QUERY_PARAMS.containsKey("FileSystemId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("FileSystemId");

            String value = (describeTagsRequest.getFileSystemId() == null) ? null : StringUtils.fromString(describeTagsRequest.getFileSystemId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{FileSystemId}", (describeTagsRequest.getFileSystemId() == null) ? "" : StringUtils.fromString(describeTagsRequest.getFileSystemId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        request.setContent(new ByteArrayInputStream(new byte[0]));
        if (!request.getHeaders().containsKey("Content-Type")) {
            request.addHeader("Content-Type", "application/x-amz-json-1.1");
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/DescribeTagsResultJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Describe Tags Result JSON Unmarshaller
 */
public class DescribeTagsResultJsonUnmarshaller implements Unmarshaller<DescribeTagsResult, JsonUnmarshallerContext> {

    public DescribeTagsResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeTagsResult describeTagsResult = new DescribeTagsResult();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("Marker", targetDepth)) {
                    context.nextToken();
                    describeTagsResult.setMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("Tags", targetDepth)) {
                    context.nextToken();
                    describeTagsResult.setTags(new ListUnmarshaller<Tag>(TagJsonUnmarshaller.getInstance()).unmarshall(context));
                }
                if (context.testExpression("NextMarker", targetDepth)) {
                    context.nextToken();
                    describeTagsResult.setNextMarker(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return describeTagsResult;
    }

    private static DescribeTagsResultJsonUnmarshaller instance;
    public static DescribeTagsResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeTagsResultJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/FileSystemAlreadyExistsExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.FileSystemAlreadyExistsException;

public class FileSystemAlreadyExistsExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public FileSystemAlreadyExistsExceptionUnmarshaller() {
        super(FileSystemAlreadyExistsException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("FileSystemAlreadyExists"));
        } else {
            return errorTypeFromHeader.equals("FileSystemAlreadyExists");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        FileSystemAlreadyExistsException e = (FileSystemAlreadyExistsException)super.unmarshall(json);
        e.setErrorCode("FileSystemAlreadyExists");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        e.setFileSystemId(parseMember("FileSystemId", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/FileSystemDescriptionJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * File System Description JSON Unmarshaller
 */
public class FileSystemDescriptionJsonUnmarshaller implements Unmarshaller<FileSystemDescription, JsonUnmarshallerContext> {

    public FileSystemDescription unmarshall(JsonUnmarshallerContext context) throws Exception {
        FileSystemDescription fileSystemDescription = new FileSystemDescription();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("OwnerId", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setOwnerId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CreationToken", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setCreationToken(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("FileSystemId", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setFileSystemId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CreationTime", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setCreationTime(DateJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("LifeCycleState", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setLifeCycleState(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("Name", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setName(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("NumberOfMountTargets", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setNumberOfMountTargets(IntegerJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("SizeInBytes", targetDepth)) {
                    context.nextToken();
                    fileSystemDescription.setSizeInBytes(FileSystemSizeJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return fileSystemDescription;
    }

    private static FileSystemDescriptionJsonUnmarshaller instance;
    public static FileSystemDescriptionJsonUnmarshaller getInstance() {
        if (instance == null) instance = new FileSystemDescriptionJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/FileSystemLimitExceededExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.FileSystemLimitExceededException;

public class FileSystemLimitExceededExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public FileSystemLimitExceededExceptionUnmarshaller() {
        super(FileSystemLimitExceededException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("FileSystemLimitExceeded"));
        } else {
            return errorTypeFromHeader.equals("FileSystemLimitExceeded");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        FileSystemLimitExceededException e = (FileSystemLimitExceededException)super.unmarshall(json);
        e.setErrorCode("FileSystemLimitExceeded");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/FileSystemNotFoundExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.FileSystemNotFoundException;

public class FileSystemNotFoundExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public FileSystemNotFoundExceptionUnmarshaller() {
        super(FileSystemNotFoundException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("FileSystemNotFound"));
        } else {
            return errorTypeFromHeader.equals("FileSystemNotFound");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        FileSystemNotFoundException e = (FileSystemNotFoundException)super.unmarshall(json);
        e.setErrorCode("FileSystemNotFound");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/FileSystemSizeJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * File System Size JSON Unmarshaller
 */
public class FileSystemSizeJsonUnmarshaller implements Unmarshaller<FileSystemSize, JsonUnmarshallerContext> {

    public FileSystemSize unmarshall(JsonUnmarshallerContext context) throws Exception {
        FileSystemSize fileSystemSize = new FileSystemSize();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("Value", targetDepth)) {
                    context.nextToken();
                    fileSystemSize.setValue(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("Timestamp", targetDepth)) {
                    context.nextToken();
                    fileSystemSize.setTimestamp(DateJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return fileSystemSize;
    }

    private static FileSystemSizeJsonUnmarshaller instance;
    public static FileSystemSizeJsonUnmarshaller getInstance() {
        if (instance == null) instance = new FileSystemSizeJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/IncorrectFileSystemLifeCycleStateExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.IncorrectFileSystemLifeCycleStateException;

public class IncorrectFileSystemLifeCycleStateExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public IncorrectFileSystemLifeCycleStateExceptionUnmarshaller() {
        super(IncorrectFileSystemLifeCycleStateException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("IncorrectFileSystemLifeCycleState"));
        } else {
            return errorTypeFromHeader.equals("IncorrectFileSystemLifeCycleState");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        IncorrectFileSystemLifeCycleStateException e = (IncorrectFileSystemLifeCycleStateException)super.unmarshall(json);
        e.setErrorCode("IncorrectFileSystemLifeCycleState");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/IncorrectMountTargetStateExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.IncorrectMountTargetStateException;

public class IncorrectMountTargetStateExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public IncorrectMountTargetStateExceptionUnmarshaller() {
        super(IncorrectMountTargetStateException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("IncorrectMountTargetState"));
        } else {
            return errorTypeFromHeader.equals("IncorrectMountTargetState");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        IncorrectMountTargetStateException e = (IncorrectMountTargetStateException)super.unmarshall(json);
        e.setErrorCode("IncorrectMountTargetState");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/InternalServerErrorExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.InternalServerErrorException;

public class InternalServerErrorExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public InternalServerErrorExceptionUnmarshaller() {
        super(InternalServerErrorException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("InternalServerError"));
        } else {
            return errorTypeFromHeader.equals("InternalServerError");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        InternalServerErrorException e = (InternalServerErrorException)super.unmarshall(json);
        e.setErrorCode("InternalServerError");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/IpAddressInUseExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.IpAddressInUseException;

public class IpAddressInUseExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public IpAddressInUseExceptionUnmarshaller() {
        super(IpAddressInUseException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("IpAddressInUse"));
        } else {
            return errorTypeFromHeader.equals("IpAddressInUse");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        IpAddressInUseException e = (IpAddressInUseException)super.unmarshall(json);
        e.setErrorCode("IpAddressInUse");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/ModifyMountTargetSecurityGroupsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import static com.amazonaws.util.StringUtils.UTF8;
import static com.amazonaws.util.StringUtils.COMMA_SEPARATOR;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.regex.Pattern;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.BinaryUtils;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Modify Mount Target Security Groups Request Marshaller
 */
public class ModifyMountTargetSecurityGroupsRequestMarshaller implements Marshaller<Request<ModifyMountTargetSecurityGroupsRequest>, ModifyMountTargetSecurityGroupsRequest> {

    private static final String RESOURCE_PATH_TEMPLATE;
    private static final Map<String, String> STATIC_QUERY_PARAMS;
    private static final Map<String, String> DYNAMIC_QUERY_PARAMS;
    static {
        String path = "/2015-02-01/mount-targets/{MountTargetId}/security-groups";
        Map<String, String> staticMap = new HashMap<String, String>();
        Map<String, String> dynamicMap = new HashMap<String, String>();

        int index = path.indexOf("?");
        if (index != -1) {
            String queryString = path.substring(index + 1);
            path = path.substring(0, index);

            for (String s : queryString.split("[;&]")) {
                index = s.indexOf("=");
                if (index != -1) {
                    String name = s.substring(0, index);
                    String value = s.substring(index + 1);

                    if (value.startsWith("{") && value.endsWith("}")) {
                        dynamicMap.put(value.substring(1, value.length() - 1), name);
                    } else {
                        staticMap.put(name, value);
                    }
                }
            }
        }

        RESOURCE_PATH_TEMPLATE = path;
        STATIC_QUERY_PARAMS = Collections.unmodifiableMap(staticMap);
        DYNAMIC_QUERY_PARAMS = Collections.unmodifiableMap(dynamicMap);
    }

    public Request<ModifyMountTargetSecurityGroupsRequest> marshall(ModifyMountTargetSecurityGroupsRequest modifyMountTargetSecurityGroupsRequest) {
        if (modifyMountTargetSecurityGroupsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ModifyMountTargetSecurityGroupsRequest> request = new DefaultRequest<ModifyMountTargetSecurityGroupsRequest>(modifyMountTargetSecurityGroupsRequest, "AmazonElasticFileSystem");
        String target = "MagnolioAPIService_v20150201.ModifyMountTargetSecurityGroups";
        request.addHeader("X-Amz-Target", target);

        request.setHttpMethod(HttpMethodName.PUT);
        String uriResourcePath = RESOURCE_PATH_TEMPLATE;

        if (DYNAMIC_QUERY_PARAMS.containsKey("MountTargetId")) {
            String name = DYNAMIC_QUERY_PARAMS.get("MountTargetId");

            String value = (modifyMountTargetSecurityGroupsRequest.getMountTargetId() == null) ? null : StringUtils.fromString(modifyMountTargetSecurityGroupsRequest.getMountTargetId());

            if (!(value == null || value.isEmpty())) {
                request.addParameter(name, value);
            }
            
        } else {
            uriResourcePath = uriResourcePath.replace("{MountTargetId}", (modifyMountTargetSecurityGroupsRequest.getMountTargetId() == null) ? "" : StringUtils.fromString(modifyMountTargetSecurityGroupsRequest.getMountTargetId())); 
        } 

        request.setResourcePath(uriResourcePath.replaceAll("//", "/"));

        for (Map.Entry<String, String> entry : STATIC_QUERY_PARAMS.entrySet()) {
            request.addParameter(entry.getKey(), entry.getValue());
        }

        try {
          StringWriter stringWriter = new StringWriter();
          JSONWriter jsonWriter = new JSONWriter(stringWriter);

          jsonWriter.object();

            com.amazonaws.internal.ListWithAutoConstructFlag<String> securityGroupsList = (com.amazonaws.internal.ListWithAutoConstructFlag<String>)(modifyMountTargetSecurityGroupsRequest.getSecurityGroups());
            if (securityGroupsList != null && !(securityGroupsList.isAutoConstruct() && securityGroupsList.isEmpty())) {

                jsonWriter.key("SecurityGroups");
                jsonWriter.array();

                for (String securityGroupsListValue : securityGroupsList) {
                    if (securityGroupsListValue != null) {
                        jsonWriter.value(securityGroupsListValue);
                    }
                }
                jsonWriter.endArray();
            }

          jsonWriter.endObject();

          String snippet = stringWriter.toString();
          byte[] content = snippet.getBytes(UTF8);
          request.setContent(new StringInputStream(snippet));
          request.addHeader("Content-Length", Integer.toString(content.length));
          request.addHeader("Content-Type", "application/x-amz-json-1.1");
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }

        return request;
    }
}


File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/MountTargetConflictExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.MountTargetConflictException;

public class MountTargetConflictExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public MountTargetConflictExceptionUnmarshaller() {
        super(MountTargetConflictException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("MountTargetConflict"));
        } else {
            return errorTypeFromHeader.equals("MountTargetConflict");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        MountTargetConflictException e = (MountTargetConflictException)super.unmarshall(json);
        e.setErrorCode("MountTargetConflict");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/MountTargetDescriptionJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Mount Target Description JSON Unmarshaller
 */
public class MountTargetDescriptionJsonUnmarshaller implements Unmarshaller<MountTargetDescription, JsonUnmarshallerContext> {

    public MountTargetDescription unmarshall(JsonUnmarshallerContext context) throws Exception {
        MountTargetDescription mountTargetDescription = new MountTargetDescription();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("OwnerId", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setOwnerId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("MountTargetId", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setMountTargetId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("FileSystemId", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setFileSystemId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("SubnetId", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setSubnetId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("LifeCycleState", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setLifeCycleState(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("IpAddress", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setIpAddress(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("NetworkInterfaceId", targetDepth)) {
                    context.nextToken();
                    mountTargetDescription.setNetworkInterfaceId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return mountTargetDescription;
    }

    private static MountTargetDescriptionJsonUnmarshaller instance;
    public static MountTargetDescriptionJsonUnmarshaller getInstance() {
        if (instance == null) instance = new MountTargetDescriptionJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/MountTargetNotFoundExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.MountTargetNotFoundException;

public class MountTargetNotFoundExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public MountTargetNotFoundExceptionUnmarshaller() {
        super(MountTargetNotFoundException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("MountTargetNotFound"));
        } else {
            return errorTypeFromHeader.equals("MountTargetNotFound");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        MountTargetNotFoundException e = (MountTargetNotFoundException)super.unmarshall(json);
        e.setErrorCode("MountTargetNotFound");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/NetworkInterfaceLimitExceededExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.NetworkInterfaceLimitExceededException;

public class NetworkInterfaceLimitExceededExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public NetworkInterfaceLimitExceededExceptionUnmarshaller() {
        super(NetworkInterfaceLimitExceededException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("NetworkInterfaceLimitExceeded"));
        } else {
            return errorTypeFromHeader.equals("NetworkInterfaceLimitExceeded");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        NetworkInterfaceLimitExceededException e = (NetworkInterfaceLimitExceededException)super.unmarshall(json);
        e.setErrorCode("NetworkInterfaceLimitExceeded");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/NoFreeAddressesInSubnetExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.NoFreeAddressesInSubnetException;

public class NoFreeAddressesInSubnetExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public NoFreeAddressesInSubnetExceptionUnmarshaller() {
        super(NoFreeAddressesInSubnetException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("NoFreeAddressesInSubnet"));
        } else {
            return errorTypeFromHeader.equals("NoFreeAddressesInSubnet");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        NoFreeAddressesInSubnetException e = (NoFreeAddressesInSubnetException)super.unmarshall(json);
        e.setErrorCode("NoFreeAddressesInSubnet");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/SecurityGroupLimitExceededExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.SecurityGroupLimitExceededException;

public class SecurityGroupLimitExceededExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public SecurityGroupLimitExceededExceptionUnmarshaller() {
        super(SecurityGroupLimitExceededException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("SecurityGroupLimitExceeded"));
        } else {
            return errorTypeFromHeader.equals("SecurityGroupLimitExceeded");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        SecurityGroupLimitExceededException e = (SecurityGroupLimitExceededException)super.unmarshall(json);
        e.setErrorCode("SecurityGroupLimitExceeded");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/SecurityGroupNotFoundExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.SecurityGroupNotFoundException;

public class SecurityGroupNotFoundExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public SecurityGroupNotFoundExceptionUnmarshaller() {
        super(SecurityGroupNotFoundException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("SecurityGroupNotFound"));
        } else {
            return errorTypeFromHeader.equals("SecurityGroupNotFound");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        SecurityGroupNotFoundException e = (SecurityGroupNotFoundException)super.unmarshall(json);
        e.setErrorCode("SecurityGroupNotFound");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/SubnetNotFoundExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.SubnetNotFoundException;

public class SubnetNotFoundExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public SubnetNotFoundExceptionUnmarshaller() {
        super(SubnetNotFoundException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("SubnetNotFound"));
        } else {
            return errorTypeFromHeader.equals("SubnetNotFound");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        SubnetNotFoundException e = (SubnetNotFoundException)super.unmarshall(json);
        e.setErrorCode("SubnetNotFound");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/TagJsonUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.elasticfilesystem.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.elasticfilesystem.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import com.fasterxml.jackson.core.JsonToken;
import static com.fasterxml.jackson.core.JsonToken.*;

/**
 * Tag JSON Unmarshaller
 */
public class TagJsonUnmarshaller implements Unmarshaller<Tag, JsonUnmarshallerContext> {

    public Tag unmarshall(JsonUnmarshallerContext context) throws Exception {
        Tag tag = new Tag();

        int originalDepth = context.getCurrentDepth();
        String currentParentElement = context.getCurrentParentElement();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.getCurrentToken();
        if (token == null) token = context.nextToken();
        if (token == VALUE_NULL) return null;

        while (true) {
            if (token == null) break;

            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("Key", targetDepth)) {
                    context.nextToken();
                    tag.setKey(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("Value", targetDepth)) {
                    context.nextToken();
                    tag.setValue(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {
                    if (context.getCurrentDepth() <= originalDepth) break;
                }
            }

            token = context.nextToken();
        }
        
        return tag;
    }

    private static TagJsonUnmarshaller instance;
    public static TagJsonUnmarshaller getInstance() {
        if (instance == null) instance = new TagJsonUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/UnsupportedAvailabilityZoneExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticfilesystem.model.transform;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.transform.JsonErrorUnmarshaller;
import com.amazonaws.util.json.JSONObject;

import com.amazonaws.services.elasticfilesystem.model.UnsupportedAvailabilityZoneException;

public class UnsupportedAvailabilityZoneExceptionUnmarshaller extends JsonErrorUnmarshaller {

    public UnsupportedAvailabilityZoneExceptionUnmarshaller() {
        super(UnsupportedAvailabilityZoneException.class);
    }

    @Override
    public boolean match(String errorTypeFromHeader, JSONObject json) throws Exception {
        if (errorTypeFromHeader == null) {
            // Parse error type from the JSON content if it's not available in the response headers
            String errorCodeFromContent = parseErrorCode(json);
            return (errorCodeFromContent != null && errorCodeFromContent.equals("UnsupportedAvailabilityZone"));
        } else {
            return errorTypeFromHeader.equals("UnsupportedAvailabilityZone");
        }
    }

    @Override
    public AmazonServiceException unmarshall(JSONObject json) throws Exception {
        UnsupportedAvailabilityZoneException e = (UnsupportedAvailabilityZoneException)super.unmarshall(json);
        e.setErrorCode("UnsupportedAvailabilityZone");

        e.setErrorCode(parseMember("ErrorCode", json));
        
        return e;
    }
}
    

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/model/transform/package-info.java

/**
 * Marhsalling for the various types represented by AmazonElasticFileSystem.
 */
 package com.amazonaws.services.elasticfilesystem.model.transform;
        

File: aws-java-sdk-efs/src/main/java/com/amazonaws/services/elasticfilesystem/package-info.java

/**
 * Synchronous and asynchronous client classes for accessing AmazonElasticFileSystem.
 *
 * Amazon Elastic File System
 */
 package com.amazonaws.services.elasticfilesystem;
        

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/AmazonGlacier.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.glacier.model.*;

/**
 * Interface for accessing AmazonGlacier.
 * <p>
 * Amazon Glacier is a storage solution for "cold data."
 * </p>
 * <p>
 * Amazon Glacier is an extremely low-cost storage service that provides
 * secure, durable, and easy-to-use storage for data backup and archival.
 * With Amazon Glacier, customers can store their data cost effectively
 * for months, years, or decades. Amazon Glacier also enables customers
 * to offload the administrative burdens of operating and scaling storage
 * to AWS, so they don't have to worry about capacity planning, hardware
 * provisioning, data replication, hardware failure and recovery, or
 * time-consuming hardware migrations.
 * </p>
 * <p>
 * Amazon Glacier is a great storage choice when low storage cost is
 * paramount, your data is rarely retrieved, and retrieval latency of
 * several hours is acceptable. If your application requires fast or
 * frequent access to your data, consider using Amazon S3. For more
 * information, go to
 * <a href="http://aws.amazon.com/s3/"> Amazon Simple Storage Service (Amazon S3) </a>
 * .
 * </p>
 * <p>
 * You can store any kind of data in any format. There is no maximum
 * limit on the total amount of data you can store in Amazon Glacier.
 * </p>
 * <p>
 * If you are a first-time user of Amazon Glacier, we recommend that you
 * begin by reading the following sections in the <i>Amazon Glacier
 * Developer Guide</i> :
 * </p>
 * 
 * <ul>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/introduction.html"> What is Amazon Glacier </a>
 * - This section of the Developer Guide describes the underlying data
 * model, the operations it supports, and the AWS SDKs that you can use
 * to interact with the service.
 * </p>
 * </li>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/amazon-glacier-getting-started.html"> Getting Started with Amazon Glacier </a>
 * - The Getting Started section walks you through the process of
 * creating a vault, uploading archives, creating jobs to download
 * archives, retrieving the job output, and deleting archives.
 * </p>
 * </li>
 * 
 * </ul>
 */
public interface AmazonGlacier {

    /**
     * Overrides the default endpoint for this client ("https://glacier.us-east-1.amazonaws.com").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "glacier.us-east-1.amazonaws.com") or a full
     * URL, including the protocol (ex: "https://glacier.us-east-1.amazonaws.com"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "glacier.us-east-1.amazonaws.com") or a full URL,
     *            including the protocol (ex: "https://glacier.us-east-1.amazonaws.com") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonGlacier#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults service method on AmazonGlacier.
     * 
     * @return The response from the ListVaults service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListVaultsResult listVaults(ListVaultsRequest listVaultsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob service method on AmazonGlacier.
     * 
     * @return The response from the DescribeJob service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeJobResult describeJob(DescribeJobRequest describeJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts service method on AmazonGlacier.
     * 
     * @return The response from the ListParts service method, as returned by
     *         AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListPartsResult listParts(ListPartsRequest listPartsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetVaultNotifications service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetVaultNotificationsResult getVaultNotifications(GetVaultNotificationsRequest getVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs service method on AmazonGlacier.
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs(ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetVaultAccessPolicy service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetVaultAccessPolicyResult getVaultAccessPolicy(GetVaultAccessPolicyRequest getVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault service method on AmazonGlacier.
     * 
     * @return The response from the CreateVault service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     * @throws LimitExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateVaultResult createVault(CreateVaultRequest createVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * @return The response from the InitiateMultipartUpload service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public InitiateMultipartUploadResult initiateMultipartUpload(InitiateMultipartUploadRequest initiateMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive service method on AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteArchive(DeleteArchiveRequest deleteArchiveRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput service method on AmazonGlacier.
     * 
     * @return The response from the GetJobOutput service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetJobOutputResult getJobOutput(GetJobOutputRequest getJobOutputRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob service method on AmazonGlacier.
     * 
     * @return The response from the InitiateJob service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws PolicyEnforcedException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public InitiateJobResult initiateJob(InitiateJobRequest initiateJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive service method on AmazonGlacier.
     * 
     * @return The response from the UploadArchive service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws RequestTimeoutException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UploadArchiveResult uploadArchive(UploadArchiveRequest uploadArchiveRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setVaultNotifications(SetVaultNotificationsRequest setVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * @return The response from the CompleteMultipartUpload service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CompleteMultipartUploadResult completeMultipartUpload(CompleteMultipartUploadRequest completeMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVaultAccessPolicy(DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart service method on
     *           AmazonGlacier.
     * 
     * @return The response from the UploadMultipartPart service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws RequestTimeoutException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UploadMultipartPartResult uploadMultipartPart(UploadMultipartPartRequest uploadMultipartPartRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault service method on AmazonGlacier.
     * 
     * @return The response from the DescribeVault service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeVaultResult describeVault(DescribeVaultRequest describeVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVaultNotifications(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads service method on
     *           AmazonGlacier.
     * 
     * @return The response from the ListMultipartUploads service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListMultipartUploadsResult listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setDataRetrievalPolicy(SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault service method on AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVault(DeleteVaultRequest deleteVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setVaultAccessPolicy(SetVaultAccessPolicyRequest setVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetDataRetrievalPolicy service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDataRetrievalPolicyResult getDataRetrievalPolicy(GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/AmazonGlacierAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.glacier.model.*;

/**
 * Interface for accessing AmazonGlacier asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * <p>
 * Amazon Glacier is a storage solution for "cold data."
 * </p>
 * <p>
 * Amazon Glacier is an extremely low-cost storage service that provides
 * secure, durable, and easy-to-use storage for data backup and archival.
 * With Amazon Glacier, customers can store their data cost effectively
 * for months, years, or decades. Amazon Glacier also enables customers
 * to offload the administrative burdens of operating and scaling storage
 * to AWS, so they don't have to worry about capacity planning, hardware
 * provisioning, data replication, hardware failure and recovery, or
 * time-consuming hardware migrations.
 * </p>
 * <p>
 * Amazon Glacier is a great storage choice when low storage cost is
 * paramount, your data is rarely retrieved, and retrieval latency of
 * several hours is acceptable. If your application requires fast or
 * frequent access to your data, consider using Amazon S3. For more
 * information, go to
 * <a href="http://aws.amazon.com/s3/"> Amazon Simple Storage Service (Amazon S3) </a>
 * .
 * </p>
 * <p>
 * You can store any kind of data in any format. There is no maximum
 * limit on the total amount of data you can store in Amazon Glacier.
 * </p>
 * <p>
 * If you are a first-time user of Amazon Glacier, we recommend that you
 * begin by reading the following sections in the <i>Amazon Glacier
 * Developer Guide</i> :
 * </p>
 * 
 * <ul>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/introduction.html"> What is Amazon Glacier </a>
 * - This section of the Developer Guide describes the underlying data
 * model, the operations it supports, and the AWS SDKs that you can use
 * to interact with the service.
 * </p>
 * </li>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/amazon-glacier-getting-started.html"> Getting Started with Amazon Glacier </a>
 * - The Getting Started section walks you through the process of
 * creating a vault, uploading archives, creating jobs to download
 * archives, retrieving the job output, and deleting archives.
 * </p>
 * </li>
 * 
 * </ul>
 */
public interface AmazonGlacierAsync extends AmazonGlacier {
    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListVaults service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListVaultsResult> listVaultsAsync(ListVaultsRequest listVaultsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListVaults service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListVaultsResult> listVaultsAsync(ListVaultsRequest listVaultsRequest,
            AsyncHandler<ListVaultsRequest, ListVaultsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeJobResult> describeJobAsync(DescribeJobRequest describeJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeJobResult> describeJobAsync(DescribeJobRequest describeJobRequest,
            AsyncHandler<DescribeJobRequest, DescribeJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListParts service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListPartsResult> listPartsAsync(ListPartsRequest listPartsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListParts service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListPartsResult> listPartsAsync(ListPartsRequest listPartsRequest,
            AsyncHandler<ListPartsRequest, ListPartsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultNotificationsResult> getVaultNotificationsAsync(GetVaultNotificationsRequest getVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultNotificationsResult> getVaultNotificationsAsync(GetVaultNotificationsRequest getVaultNotificationsRequest,
            AsyncHandler<GetVaultNotificationsRequest, GetVaultNotificationsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(ListJobsRequest listJobsRequest,
            AsyncHandler<ListJobsRequest, ListJobsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultAccessPolicyResult> getVaultAccessPolicyAsync(GetVaultAccessPolicyRequest getVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultAccessPolicyResult> getVaultAccessPolicyAsync(GetVaultAccessPolicyRequest getVaultAccessPolicyRequest,
            AsyncHandler<GetVaultAccessPolicyRequest, GetVaultAccessPolicyResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         CreateVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateVaultResult> createVaultAsync(CreateVaultRequest createVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateVaultResult> createVaultAsync(CreateVaultRequest createVaultRequest,
            AsyncHandler<CreateVaultRequest, CreateVaultResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateMultipartUploadResult> initiateMultipartUploadAsync(InitiateMultipartUploadRequest initiateMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateMultipartUploadResult> initiateMultipartUploadAsync(InitiateMultipartUploadRequest initiateMultipartUploadRequest,
            AsyncHandler<InitiateMultipartUploadRequest, InitiateMultipartUploadResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         AbortMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> abortMultipartUploadAsync(AbortMultipartUploadRequest abortMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         AbortMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> abortMultipartUploadAsync(AbortMultipartUploadRequest abortMultipartUploadRequest,
            AsyncHandler<AbortMultipartUploadRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteArchiveAsync(DeleteArchiveRequest deleteArchiveRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteArchiveAsync(DeleteArchiveRequest deleteArchiveRequest,
            AsyncHandler<DeleteArchiveRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetJobOutput service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetJobOutputResult> getJobOutputAsync(GetJobOutputRequest getJobOutputRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetJobOutput service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetJobOutputResult> getJobOutputAsync(GetJobOutputRequest getJobOutputRequest,
            AsyncHandler<GetJobOutputRequest, GetJobOutputResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateJobResult> initiateJobAsync(InitiateJobRequest initiateJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateJobResult> initiateJobAsync(InitiateJobRequest initiateJobRequest,
            AsyncHandler<InitiateJobRequest, InitiateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         UploadArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadArchiveResult> uploadArchiveAsync(UploadArchiveRequest uploadArchiveRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UploadArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadArchiveResult> uploadArchiveAsync(UploadArchiveRequest uploadArchiveRequest,
            AsyncHandler<UploadArchiveRequest, UploadArchiveResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultNotificationsAsync(SetVaultNotificationsRequest setVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultNotificationsAsync(SetVaultNotificationsRequest setVaultNotificationsRequest,
            AsyncHandler<SetVaultNotificationsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         CompleteMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CompleteMultipartUploadResult> completeMultipartUploadAsync(CompleteMultipartUploadRequest completeMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CompleteMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CompleteMultipartUploadResult> completeMultipartUploadAsync(CompleteMultipartUploadRequest completeMultipartUploadRequest,
            AsyncHandler<CompleteMultipartUploadRequest, CompleteMultipartUploadResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAccessPolicyAsync(DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAccessPolicyAsync(DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest,
            AsyncHandler<DeleteVaultAccessPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         UploadMultipartPart service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadMultipartPartResult> uploadMultipartPartAsync(UploadMultipartPartRequest uploadMultipartPartRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UploadMultipartPart service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadMultipartPartResult> uploadMultipartPartAsync(UploadMultipartPartRequest uploadMultipartPartRequest,
            AsyncHandler<UploadMultipartPartRequest, UploadMultipartPartResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeVaultResult> describeVaultAsync(DescribeVaultRequest describeVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeVaultResult> describeVaultAsync(DescribeVaultRequest describeVaultRequest,
            AsyncHandler<DescribeVaultRequest, DescribeVaultResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultNotificationsAsync(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultNotificationsAsync(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest,
            AsyncHandler<DeleteVaultNotificationsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListMultipartUploads service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListMultipartUploadsResult> listMultipartUploadsAsync(ListMultipartUploadsRequest listMultipartUploadsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListMultipartUploads service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListMultipartUploadsResult> listMultipartUploadsAsync(ListMultipartUploadsRequest listMultipartUploadsRequest,
            AsyncHandler<ListMultipartUploadsRequest, ListMultipartUploadsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setDataRetrievalPolicyAsync(SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setDataRetrievalPolicyAsync(SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest,
            AsyncHandler<SetDataRetrievalPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAsync(DeleteVaultRequest deleteVaultRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAsync(DeleteVaultRequest deleteVaultRequest,
            AsyncHandler<DeleteVaultRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultAccessPolicyAsync(SetVaultAccessPolicyRequest setVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultAccessPolicyAsync(SetVaultAccessPolicyRequest setVaultAccessPolicyRequest,
            AsyncHandler<SetVaultAccessPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDataRetrievalPolicyResult> getDataRetrievalPolicyAsync(GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDataRetrievalPolicyResult> getDataRetrievalPolicyAsync(GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest,
            AsyncHandler<GetDataRetrievalPolicyRequest, GetDataRetrievalPolicyResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/AmazonGlacierAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.glacier.model.*;

/**
 * Asynchronous client for accessing AmazonGlacier.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * <p>
 * Amazon Glacier is a storage solution for "cold data."
 * </p>
 * <p>
 * Amazon Glacier is an extremely low-cost storage service that provides
 * secure, durable, and easy-to-use storage for data backup and archival.
 * With Amazon Glacier, customers can store their data cost effectively
 * for months, years, or decades. Amazon Glacier also enables customers
 * to offload the administrative burdens of operating and scaling storage
 * to AWS, so they don't have to worry about capacity planning, hardware
 * provisioning, data replication, hardware failure and recovery, or
 * time-consuming hardware migrations.
 * </p>
 * <p>
 * Amazon Glacier is a great storage choice when low storage cost is
 * paramount, your data is rarely retrieved, and retrieval latency of
 * several hours is acceptable. If your application requires fast or
 * frequent access to your data, consider using Amazon S3. For more
 * information, go to
 * <a href="http://aws.amazon.com/s3/"> Amazon Simple Storage Service (Amazon S3) </a>
 * .
 * </p>
 * <p>
 * You can store any kind of data in any format. There is no maximum
 * limit on the total amount of data you can store in Amazon Glacier.
 * </p>
 * <p>
 * If you are a first-time user of Amazon Glacier, we recommend that you
 * begin by reading the following sections in the <i>Amazon Glacier
 * Developer Guide</i> :
 * </p>
 * 
 * <ul>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/introduction.html"> What is Amazon Glacier </a>
 * - This section of the Developer Guide describes the underlying data
 * model, the operations it supports, and the AWS SDKs that you can use
 * to interact with the service.
 * </p>
 * </li>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/amazon-glacier-getting-started.html"> Getting Started with Amazon Glacier </a>
 * - The Getting Started section walks you through the process of
 * creating a vault, uploading archives, creating jobs to download
 * archives, retrieving the job output, and deleting archives.
 * </p>
 * </li>
 * 
 * </ul>
 */
public class AmazonGlacierAsyncClient extends AmazonGlacierClient
        implements AmazonGlacierAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonGlacierAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonGlacier
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonGlacierAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonGlacierAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonGlacierAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonGlacierAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonGlacierAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonGlacierAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonGlacierAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonGlacierAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListVaults service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListVaultsResult> listVaultsAsync(final ListVaultsRequest listVaultsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListVaultsResult>() {
            public ListVaultsResult call() throws Exception {
                return listVaults(listVaultsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListVaults service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListVaultsResult> listVaultsAsync(
            final ListVaultsRequest listVaultsRequest,
            final AsyncHandler<ListVaultsRequest, ListVaultsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListVaultsResult>() {
            public ListVaultsResult call() throws Exception {
              ListVaultsResult result;
                try {
                result = listVaults(listVaultsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listVaultsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeJobResult> describeJobAsync(final DescribeJobRequest describeJobRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeJobResult>() {
            public DescribeJobResult call() throws Exception {
                return describeJob(describeJobRequest);
        }
    });
    }

    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeJobResult> describeJobAsync(
            final DescribeJobRequest describeJobRequest,
            final AsyncHandler<DescribeJobRequest, DescribeJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeJobResult>() {
            public DescribeJobResult call() throws Exception {
              DescribeJobResult result;
                try {
                result = describeJob(describeJobRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeJobRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListParts service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListPartsResult> listPartsAsync(final ListPartsRequest listPartsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListPartsResult>() {
            public ListPartsResult call() throws Exception {
                return listParts(listPartsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListParts service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListPartsResult> listPartsAsync(
            final ListPartsRequest listPartsRequest,
            final AsyncHandler<ListPartsRequest, ListPartsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListPartsResult>() {
            public ListPartsResult call() throws Exception {
              ListPartsResult result;
                try {
                result = listParts(listPartsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listPartsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultNotificationsResult> getVaultNotificationsAsync(final GetVaultNotificationsRequest getVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetVaultNotificationsResult>() {
            public GetVaultNotificationsResult call() throws Exception {
                return getVaultNotifications(getVaultNotificationsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultNotificationsResult> getVaultNotificationsAsync(
            final GetVaultNotificationsRequest getVaultNotificationsRequest,
            final AsyncHandler<GetVaultNotificationsRequest, GetVaultNotificationsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetVaultNotificationsResult>() {
            public GetVaultNotificationsResult call() throws Exception {
              GetVaultNotificationsResult result;
                try {
                result = getVaultNotifications(getVaultNotificationsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getVaultNotificationsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(final ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListJobsResult>() {
            public ListJobsResult call() throws Exception {
                return listJobs(listJobsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(
            final ListJobsRequest listJobsRequest,
            final AsyncHandler<ListJobsRequest, ListJobsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListJobsResult>() {
            public ListJobsResult call() throws Exception {
              ListJobsResult result;
                try {
                result = listJobs(listJobsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listJobsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultAccessPolicyResult> getVaultAccessPolicyAsync(final GetVaultAccessPolicyRequest getVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetVaultAccessPolicyResult>() {
            public GetVaultAccessPolicyResult call() throws Exception {
                return getVaultAccessPolicy(getVaultAccessPolicyRequest);
        }
    });
    }

    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetVaultAccessPolicyResult> getVaultAccessPolicyAsync(
            final GetVaultAccessPolicyRequest getVaultAccessPolicyRequest,
            final AsyncHandler<GetVaultAccessPolicyRequest, GetVaultAccessPolicyResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetVaultAccessPolicyResult>() {
            public GetVaultAccessPolicyResult call() throws Exception {
              GetVaultAccessPolicyResult result;
                try {
                result = getVaultAccessPolicy(getVaultAccessPolicyRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getVaultAccessPolicyRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         CreateVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateVaultResult> createVaultAsync(final CreateVaultRequest createVaultRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateVaultResult>() {
            public CreateVaultResult call() throws Exception {
                return createVault(createVaultRequest);
        }
    });
    }

    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateVaultResult> createVaultAsync(
            final CreateVaultRequest createVaultRequest,
            final AsyncHandler<CreateVaultRequest, CreateVaultResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateVaultResult>() {
            public CreateVaultResult call() throws Exception {
              CreateVaultResult result;
                try {
                result = createVault(createVaultRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createVaultRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateMultipartUploadResult> initiateMultipartUploadAsync(final InitiateMultipartUploadRequest initiateMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<InitiateMultipartUploadResult>() {
            public InitiateMultipartUploadResult call() throws Exception {
                return initiateMultipartUpload(initiateMultipartUploadRequest);
        }
    });
    }

    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateMultipartUploadResult> initiateMultipartUploadAsync(
            final InitiateMultipartUploadRequest initiateMultipartUploadRequest,
            final AsyncHandler<InitiateMultipartUploadRequest, InitiateMultipartUploadResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<InitiateMultipartUploadResult>() {
            public InitiateMultipartUploadResult call() throws Exception {
              InitiateMultipartUploadResult result;
                try {
                result = initiateMultipartUpload(initiateMultipartUploadRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(initiateMultipartUploadRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         AbortMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> abortMultipartUploadAsync(final AbortMultipartUploadRequest abortMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                abortMultipartUpload(abortMultipartUploadRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         AbortMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> abortMultipartUploadAsync(
            final AbortMultipartUploadRequest abortMultipartUploadRequest,
            final AsyncHandler<AbortMultipartUploadRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                abortMultipartUpload(abortMultipartUploadRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(abortMultipartUploadRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteArchiveAsync(final DeleteArchiveRequest deleteArchiveRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteArchive(deleteArchiveRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteArchiveAsync(
            final DeleteArchiveRequest deleteArchiveRequest,
            final AsyncHandler<DeleteArchiveRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteArchive(deleteArchiveRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteArchiveRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetJobOutput service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetJobOutputResult> getJobOutputAsync(final GetJobOutputRequest getJobOutputRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetJobOutputResult>() {
            public GetJobOutputResult call() throws Exception {
                return getJobOutput(getJobOutputRequest);
        }
    });
    }

    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetJobOutput service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetJobOutputResult> getJobOutputAsync(
            final GetJobOutputRequest getJobOutputRequest,
            final AsyncHandler<GetJobOutputRequest, GetJobOutputResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetJobOutputResult>() {
            public GetJobOutputResult call() throws Exception {
              GetJobOutputResult result;
                try {
                result = getJobOutput(getJobOutputRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getJobOutputRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateJobResult> initiateJobAsync(final InitiateJobRequest initiateJobRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<InitiateJobResult>() {
            public InitiateJobResult call() throws Exception {
                return initiateJob(initiateJobRequest);
        }
    });
    }

    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         InitiateJob service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<InitiateJobResult> initiateJobAsync(
            final InitiateJobRequest initiateJobRequest,
            final AsyncHandler<InitiateJobRequest, InitiateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<InitiateJobResult>() {
            public InitiateJobResult call() throws Exception {
              InitiateJobResult result;
                try {
                result = initiateJob(initiateJobRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(initiateJobRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         UploadArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadArchiveResult> uploadArchiveAsync(final UploadArchiveRequest uploadArchiveRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UploadArchiveResult>() {
            public UploadArchiveResult call() throws Exception {
                return uploadArchive(uploadArchiveRequest);
        }
    });
    }

    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UploadArchive service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadArchiveResult> uploadArchiveAsync(
            final UploadArchiveRequest uploadArchiveRequest,
            final AsyncHandler<UploadArchiveRequest, UploadArchiveResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UploadArchiveResult>() {
            public UploadArchiveResult call() throws Exception {
              UploadArchiveResult result;
                try {
                result = uploadArchive(uploadArchiveRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(uploadArchiveRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultNotificationsAsync(final SetVaultNotificationsRequest setVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                setVaultNotifications(setVaultNotificationsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultNotificationsAsync(
            final SetVaultNotificationsRequest setVaultNotificationsRequest,
            final AsyncHandler<SetVaultNotificationsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                setVaultNotifications(setVaultNotificationsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(setVaultNotificationsRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         CompleteMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CompleteMultipartUploadResult> completeMultipartUploadAsync(final CompleteMultipartUploadRequest completeMultipartUploadRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CompleteMultipartUploadResult>() {
            public CompleteMultipartUploadResult call() throws Exception {
                return completeMultipartUpload(completeMultipartUploadRequest);
        }
    });
    }

    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CompleteMultipartUpload service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CompleteMultipartUploadResult> completeMultipartUploadAsync(
            final CompleteMultipartUploadRequest completeMultipartUploadRequest,
            final AsyncHandler<CompleteMultipartUploadRequest, CompleteMultipartUploadResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CompleteMultipartUploadResult>() {
            public CompleteMultipartUploadResult call() throws Exception {
              CompleteMultipartUploadResult result;
                try {
                result = completeMultipartUpload(completeMultipartUploadRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(completeMultipartUploadRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAccessPolicyAsync(final DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteVaultAccessPolicy(deleteVaultAccessPolicyRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAccessPolicyAsync(
            final DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest,
            final AsyncHandler<DeleteVaultAccessPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteVaultAccessPolicy(deleteVaultAccessPolicyRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteVaultAccessPolicyRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         UploadMultipartPart service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadMultipartPartResult> uploadMultipartPartAsync(final UploadMultipartPartRequest uploadMultipartPartRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UploadMultipartPartResult>() {
            public UploadMultipartPartResult call() throws Exception {
                return uploadMultipartPart(uploadMultipartPartRequest);
        }
    });
    }

    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UploadMultipartPart service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UploadMultipartPartResult> uploadMultipartPartAsync(
            final UploadMultipartPartRequest uploadMultipartPartRequest,
            final AsyncHandler<UploadMultipartPartRequest, UploadMultipartPartResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UploadMultipartPartResult>() {
            public UploadMultipartPartResult call() throws Exception {
              UploadMultipartPartResult result;
                try {
                result = uploadMultipartPart(uploadMultipartPartRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(uploadMultipartPartRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeVaultResult> describeVaultAsync(final DescribeVaultRequest describeVaultRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeVaultResult>() {
            public DescribeVaultResult call() throws Exception {
                return describeVault(describeVaultRequest);
        }
    });
    }

    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeVaultResult> describeVaultAsync(
            final DescribeVaultRequest describeVaultRequest,
            final AsyncHandler<DescribeVaultRequest, DescribeVaultResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<DescribeVaultResult>() {
            public DescribeVaultResult call() throws Exception {
              DescribeVaultResult result;
                try {
                result = describeVault(describeVaultRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(describeVaultRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultNotificationsAsync(final DeleteVaultNotificationsRequest deleteVaultNotificationsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteVaultNotifications(deleteVaultNotificationsRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVaultNotifications service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultNotificationsAsync(
            final DeleteVaultNotificationsRequest deleteVaultNotificationsRequest,
            final AsyncHandler<DeleteVaultNotificationsRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteVaultNotifications(deleteVaultNotificationsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteVaultNotificationsRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         ListMultipartUploads service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListMultipartUploadsResult> listMultipartUploadsAsync(final ListMultipartUploadsRequest listMultipartUploadsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListMultipartUploadsResult>() {
            public ListMultipartUploadsResult call() throws Exception {
                return listMultipartUploads(listMultipartUploadsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListMultipartUploads service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListMultipartUploadsResult> listMultipartUploadsAsync(
            final ListMultipartUploadsRequest listMultipartUploadsRequest,
            final AsyncHandler<ListMultipartUploadsRequest, ListMultipartUploadsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListMultipartUploadsResult>() {
            public ListMultipartUploadsResult call() throws Exception {
              ListMultipartUploadsResult result;
                try {
                result = listMultipartUploads(listMultipartUploadsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listMultipartUploadsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setDataRetrievalPolicyAsync(final SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                setDataRetrievalPolicy(setDataRetrievalPolicyRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setDataRetrievalPolicyAsync(
            final SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest,
            final AsyncHandler<SetDataRetrievalPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                setDataRetrievalPolicy(setDataRetrievalPolicyRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(setDataRetrievalPolicyRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault operation on AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAsync(final DeleteVaultRequest deleteVaultRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                deleteVault(deleteVaultRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault operation on AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DeleteVault service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> deleteVaultAsync(
            final DeleteVaultRequest deleteVaultRequest,
            final AsyncHandler<DeleteVaultRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                deleteVault(deleteVaultRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(deleteVaultRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultAccessPolicyAsync(final SetVaultAccessPolicyRequest setVaultAccessPolicyRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
                setVaultAccessPolicy(setVaultAccessPolicyRequest);
                return null;
        }
    });
    }

    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         SetVaultAccessPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<Void> setVaultAccessPolicyAsync(
            final SetVaultAccessPolicyRequest setVaultAccessPolicyRequest,
            final AsyncHandler<SetVaultAccessPolicyRequest, Void> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<Void>() {
            public Void call() throws Exception {
              try {
                setVaultAccessPolicy(setVaultAccessPolicyRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(setVaultAccessPolicyRequest, null);
                 return null;
        }
    });
    }
    
    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * 
     * @return A Java Future object containing the response from the
     *         GetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDataRetrievalPolicyResult> getDataRetrievalPolicyAsync(final GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDataRetrievalPolicyResult>() {
            public GetDataRetrievalPolicyResult call() throws Exception {
                return getDataRetrievalPolicy(getDataRetrievalPolicyRequest);
        }
    });
    }

    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy operation on
     *           AmazonGlacier.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetDataRetrievalPolicy service method, as returned by AmazonGlacier.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetDataRetrievalPolicyResult> getDataRetrievalPolicyAsync(
            final GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest,
            final AsyncHandler<GetDataRetrievalPolicyRequest, GetDataRetrievalPolicyResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetDataRetrievalPolicyResult>() {
            public GetDataRetrievalPolicyResult call() throws Exception {
              GetDataRetrievalPolicyResult result;
                try {
                result = getDataRetrievalPolicy(getDataRetrievalPolicyRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getDataRetrievalPolicyRequest, result);
                 return result;
        }
    });
    }
    
}
        

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/AmazonGlacierClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier;

import java.io.*;

import java.net.*;
import java.util.*;

import org.apache.commons.logging.*;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.regions.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;
import com.amazonaws.util.json.*;

import com.amazonaws.services.glacier.model.*;
import com.amazonaws.services.glacier.model.transform.*;

/**
 * Client for accessing AmazonGlacier.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * <p>
 * Amazon Glacier is a storage solution for "cold data."
 * </p>
 * <p>
 * Amazon Glacier is an extremely low-cost storage service that provides
 * secure, durable, and easy-to-use storage for data backup and archival.
 * With Amazon Glacier, customers can store their data cost effectively
 * for months, years, or decades. Amazon Glacier also enables customers
 * to offload the administrative burdens of operating and scaling storage
 * to AWS, so they don't have to worry about capacity planning, hardware
 * provisioning, data replication, hardware failure and recovery, or
 * time-consuming hardware migrations.
 * </p>
 * <p>
 * Amazon Glacier is a great storage choice when low storage cost is
 * paramount, your data is rarely retrieved, and retrieval latency of
 * several hours is acceptable. If your application requires fast or
 * frequent access to your data, consider using Amazon S3. For more
 * information, go to
 * <a href="http://aws.amazon.com/s3/"> Amazon Simple Storage Service (Amazon S3) </a>
 * .
 * </p>
 * <p>
 * You can store any kind of data in any format. There is no maximum
 * limit on the total amount of data you can store in Amazon Glacier.
 * </p>
 * <p>
 * If you are a first-time user of Amazon Glacier, we recommend that you
 * begin by reading the following sections in the <i>Amazon Glacier
 * Developer Guide</i> :
 * </p>
 * 
 * <ul>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/introduction.html"> What is Amazon Glacier </a>
 * - This section of the Developer Guide describes the underlying data
 * model, the operations it supports, and the AWS SDKs that you can use
 * to interact with the service.
 * </p>
 * </li>
 * <li> <p>
 * 
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/amazon-glacier-getting-started.html"> Getting Started with Amazon Glacier </a>
 * - The Getting Started section walks you through the process of
 * creating a vault, uploading archives, creating jobs to download
 * archives, retrieving the job output, and deleting archives.
 * </p>
 * </li>
 * 
 * </ul>
 */
public class AmazonGlacierClient extends AmazonWebServiceClient implements AmazonGlacier {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    private static final Log log = LogFactory.getLog(AmazonGlacier.class);

    /**
     * List of exception unmarshallers for all AmazonGlacier exceptions.
     */
    protected List<GlacierErrorUnmarshaller> jsonErrorUnmarshallers;

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonGlacierClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonGlacier
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonGlacierClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonGlacierClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonGlacier
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonGlacierClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(adjustClientConfiguration(clientConfiguration));
        
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials provider.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonGlacierClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * provider and client configuration options.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonGlacier
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonGlacierClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonGlacier using the specified AWS account credentials
     * provider, client configuration options and request metric collector.
     * 
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonGlacier
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonGlacierClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(adjustClientConfiguration(clientConfiguration), requestMetricCollector);
        
        this.awsCredentialsProvider = awsCredentialsProvider;
        
        init();
    }

    private void init() {
        jsonErrorUnmarshallers = new ArrayList<GlacierErrorUnmarshaller>();
        jsonErrorUnmarshallers.add(new InvalidParameterValueExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new LimitExceededExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new MissingParameterValueExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new PolicyEnforcedExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new RequestTimeoutExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ServiceUnavailableExceptionUnmarshaller());
        jsonErrorUnmarshallers.add(new ResourceNotFoundExceptionUnmarshaller());
        
        jsonErrorUnmarshallers.add(new GlacierErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("glacier.us-east-1.amazonaws.com");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/glacier/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/glacier/request.handler2s"));
    }

    private static ClientConfiguration adjustClientConfiguration(ClientConfiguration orig) {
        ClientConfiguration config = orig;
        
        return config;
    }

    /**
     * <p>
     * This operation lists all vaults owned by the calling user's account.
     * The list returned in the response is ASCII-sorted by vault name.
     * </p>
     * <p>
     * By default, this operation returns up to 1,000 items. If there are
     * more vaults to list, the response <code>marker</code> field contains
     * the vault Amazon Resource Name (ARN) at which to continue the list
     * with a new List Vaults request; otherwise, the <code>marker</code>
     * field is <code>null</code> . To return a list of vaults that begins at
     * a specific vault, set the <code>marker</code> request parameter to the
     * vault ARN you obtained from a previous List Vaults request. You can
     * also limit the number of vaults returned in the response by specifying
     * the <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html"> List Vaults </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listVaultsRequest Container for the necessary parameters to
     *           execute the ListVaults service method on AmazonGlacier.
     * 
     * @return The response from the ListVaults service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListVaultsResult listVaults(ListVaultsRequest listVaultsRequest) {
        ExecutionContext executionContext = createExecutionContext(listVaultsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListVaultsRequest> request = null;
        Response<ListVaultsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListVaultsRequestMarshaller().marshall(super.beforeMarshalling(listVaultsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListVaultsResult, JsonUnmarshallerContext> unmarshaller =
                new ListVaultsResultJsonUnmarshaller();
            JsonResponseHandler<ListVaultsResult> responseHandler =
                new JsonResponseHandler<ListVaultsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation returns information about a job you previously
     * initiated, including the job initiation date, the user who initiated
     * the job, the job status code/message and the Amazon SNS topic to
     * notify after Amazon Glacier completes the job. For more information
     * about initiating a job, see InitiateJob.
     * </p>
     * <p>
     * <b>NOTE:</b> This operation enables you to check the status of your
     * job. However, it is strongly recommended that you set up an Amazon SNS
     * topic and specify it in your initiate job request so that Amazon
     * Glacier can notify the topic after it completes the job.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For information about the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html"> Working with Archives in Amazon Glacier </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeJobRequest Container for the necessary parameters to
     *           execute the DescribeJob service method on AmazonGlacier.
     * 
     * @return The response from the DescribeJob service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeJobResult describeJob(DescribeJobRequest describeJobRequest) {
        ExecutionContext executionContext = createExecutionContext(describeJobRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeJobRequest> request = null;
        Response<DescribeJobResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeJobRequestMarshaller().marshall(super.beforeMarshalling(describeJobRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeJobResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeJobResultJsonUnmarshaller();
            JsonResponseHandler<DescribeJobResult> responseHandler =
                new JsonResponseHandler<DescribeJobResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation lists the parts of an archive that have been uploaded
     * in a specific multipart upload. You can make this request at any time
     * during an in-progress multipart upload before you complete the upload
     * (see CompleteMultipartUpload. List Parts returns an error for
     * completed uploads. The list returned in the List Parts response is
     * sorted by part range.
     * </p>
     * <p>
     * The List Parts operation supports pagination. By default, this
     * operation returns up to 1,000 uploaded parts in the response. You
     * should always check the response for a <code>marker</code> at which to
     * continue the list; if there are no more items the <code>marker</code>
     * is <code>null</code> . To return a list of parts that begins at a
     * specific part, set the <code>marker</code> request parameter to the
     * value you obtained from a previous List Parts request. You can also
     * limit the number of parts returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html"> List Parts </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listPartsRequest Container for the necessary parameters to
     *           execute the ListParts service method on AmazonGlacier.
     * 
     * @return The response from the ListParts service method, as returned by
     *         AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListPartsResult listParts(ListPartsRequest listPartsRequest) {
        ExecutionContext executionContext = createExecutionContext(listPartsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListPartsRequest> request = null;
        Response<ListPartsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListPartsRequestMarshaller().marshall(super.beforeMarshalling(listPartsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListPartsResult, JsonUnmarshallerContext> unmarshaller =
                new ListPartsResultJsonUnmarshaller();
            JsonResponseHandler<ListPartsResult> responseHandler =
                new JsonResponseHandler<ListPartsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation retrieves the <code>notification-configuration</code>
     * subresource of the specified vault.
     * </p>
     * <p>
     * For information about setting a notification configuration on a
     * vault, see SetVaultNotifications. If a notification configuration for
     * a vault is not set, the operation returns a <code>404 Not Found</code>
     * error. For more information about vault notifications, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html"> Get Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param getVaultNotificationsRequest Container for the necessary
     *           parameters to execute the GetVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetVaultNotifications service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetVaultNotificationsResult getVaultNotifications(GetVaultNotificationsRequest getVaultNotificationsRequest) {
        ExecutionContext executionContext = createExecutionContext(getVaultNotificationsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetVaultNotificationsRequest> request = null;
        Response<GetVaultNotificationsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetVaultNotificationsRequestMarshaller().marshall(super.beforeMarshalling(getVaultNotificationsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetVaultNotificationsResult, JsonUnmarshallerContext> unmarshaller =
                new GetVaultNotificationsResultJsonUnmarshaller();
            JsonResponseHandler<GetVaultNotificationsResult> responseHandler =
                new JsonResponseHandler<GetVaultNotificationsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation lists jobs for a vault, including jobs that are
     * in-progress and jobs that have recently finished.
     * </p>
     * <p>
     * <b>NOTE:</b> Amazon Glacier retains recently completed jobs for a
     * period before deleting them; however, it eventually removes completed
     * jobs. The output of completed jobs can be retrieved. Retaining
     * completed jobs for a period of time after they have completed enables
     * you to get a job output in the event you miss the job completion
     * notification or your first attempt to download it fails. For example,
     * suppose you start an archive retrieval job to download an archive.
     * After the job completes, you start to download the archive but
     * encounter a network error. In this scenario, you can retry and
     * download the archive while the job exists.
     * </p>
     * <p>
     * To retrieve an archive or retrieve a vault inventory from Amazon
     * Glacier, you first initiate a job, and after the job completes, you
     * download the data. For an archive retrieval, the output is the archive
     * data, and for an inventory retrieval, it is the inventory list. The
     * List Job operation returns a list of these jobs sorted by job
     * initiation time.
     * </p>
     * <p>
     * This List Jobs operation supports pagination. By default, this
     * operation returns up to 1,000 jobs in the response. You should always
     * check the response for a <code>marker</code> at which to continue the
     * list; if there are no more items the <code>marker</code> is
     * <code>null</code> . To return a list of jobs that begins at a specific
     * job, set the <code>marker</code> request parameter to the value you
     * obtained from a previous List Jobs request. You can also limit the
     * number of jobs returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Additionally, you can filter the jobs list returned by specifying an
     * optional <code>statuscode</code> (InProgress, Succeeded, or Failed)
     * and <code>completed</code> (true, false) parameter. The
     * <code>statuscode</code> allows you to specify that only jobs that
     * match a specified status are returned. The <code>completed</code>
     * parameter allows you to specify that only jobs in a specific
     * completion state are returned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html"> List Jobs </a>
     * 
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs service method on AmazonGlacier.
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs(ListJobsRequest listJobsRequest) {
        ExecutionContext executionContext = createExecutionContext(listJobsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListJobsRequest> request = null;
        Response<ListJobsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListJobsRequestMarshaller().marshall(super.beforeMarshalling(listJobsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListJobsResult, JsonUnmarshallerContext> unmarshaller =
                new ListJobsResultJsonUnmarshaller();
            JsonResponseHandler<ListJobsResult> responseHandler =
                new JsonResponseHandler<ListJobsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation retrieves the <code>access-policy</code> subresource
     * set on the vault???for more information on setting this subresource,
     * see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param getVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the GetVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetVaultAccessPolicy service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetVaultAccessPolicyResult getVaultAccessPolicy(GetVaultAccessPolicyRequest getVaultAccessPolicyRequest) {
        ExecutionContext executionContext = createExecutionContext(getVaultAccessPolicyRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetVaultAccessPolicyRequest> request = null;
        Response<GetVaultAccessPolicyResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetVaultAccessPolicyRequestMarshaller().marshall(super.beforeMarshalling(getVaultAccessPolicyRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetVaultAccessPolicyResult, JsonUnmarshallerContext> unmarshaller =
                new GetVaultAccessPolicyResultJsonUnmarshaller();
            JsonResponseHandler<GetVaultAccessPolicyResult> responseHandler =
                new JsonResponseHandler<GetVaultAccessPolicyResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation creates a new vault with the specified name. The name
     * of the vault must be unique within a region for an AWS account. You
     * can create up to 1,000 vaults per account. If you need to create more
     * vaults, contact Amazon Glacier.
     * </p>
     * <p>
     * You must use the following guidelines when naming a vault.
     * </p>
     * <p>
     * 
     * <ul>
     * <li> <p>
     * Names can be between 1 and 255 characters long.
     * </p>
     * </li>
     * <li> <p>
     * Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
     * and '.' (period).
     * </p>
     * </li>
     * 
     * </ul>
     * 
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html"> Creating a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html"> Create Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param createVaultRequest Container for the necessary parameters to
     *           execute the CreateVault service method on AmazonGlacier.
     * 
     * @return The response from the CreateVault service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     * @throws LimitExceededException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateVaultResult createVault(CreateVaultRequest createVaultRequest) {
        ExecutionContext executionContext = createExecutionContext(createVaultRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateVaultRequest> request = null;
        Response<CreateVaultResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateVaultRequestMarshaller().marshall(super.beforeMarshalling(createVaultRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<CreateVaultResult, JsonUnmarshallerContext> unmarshaller =
                new CreateVaultResultJsonUnmarshaller();
            JsonResponseHandler<CreateVaultResult> responseHandler =
                new JsonResponseHandler<CreateVaultResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation initiates a multipart upload. Amazon Glacier creates a
     * multipart upload resource and returns its ID in the response. The
     * multipart upload ID is used in subsequent requests to upload parts of
     * an archive (see UploadMultipartPart).
     * </p>
     * <p>
     * When you initiate a multipart upload, you specify the part size in
     * number of bytes. The part size must be a megabyte (1024 KB) multiplied
     * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
     * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
     * 1 MB, and the maximum is 4 GB.
     * </p>
     * <p>
     * Every part you upload to this resource (see UploadMultipartPart),
     * except the last one, must have the same size. The last one can be the
     * same size or smaller. For example, suppose you want to upload a 16.2
     * MB file. If you initiate the multipart upload with a part size of 4
     * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
     * </p>
     * <p>
     * <b>NOTE:</b> You don't need to know the size of the archive when you
     * start a multipart upload because Amazon Glacier does not require you
     * to specify the overall archive size.
     * </p>
     * <p>
     * After you complete the multipart upload, Amazon Glacier removes the
     * multipart upload resource referenced by the ID. Amazon Glacier also
     * removes the multipart upload resource if you cancel the multipart
     * upload or it may be removed if there is no activity for a period of 24
     * hours.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param initiateMultipartUploadRequest Container for the necessary
     *           parameters to execute the InitiateMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * @return The response from the InitiateMultipartUpload service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public InitiateMultipartUploadResult initiateMultipartUpload(InitiateMultipartUploadRequest initiateMultipartUploadRequest) {
        ExecutionContext executionContext = createExecutionContext(initiateMultipartUploadRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<InitiateMultipartUploadRequest> request = null;
        Response<InitiateMultipartUploadResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new InitiateMultipartUploadRequestMarshaller().marshall(super.beforeMarshalling(initiateMultipartUploadRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<InitiateMultipartUploadResult, JsonUnmarshallerContext> unmarshaller =
                new InitiateMultipartUploadResultJsonUnmarshaller();
            JsonResponseHandler<InitiateMultipartUploadResult> responseHandler =
                new JsonResponseHandler<InitiateMultipartUploadResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation aborts a multipart upload identified by the upload ID.
     * </p>
     * <p>
     * After the Abort Multipart Upload request succeeds, you cannot upload
     * any more parts to the multipart upload or complete the multipart
     * upload. Aborting a completed upload fails. However, aborting an
     * already-aborted upload will succeed, for a short time. For more
     * information about uploading a part and completing a multipart upload,
     * see UploadMultipartPart and CompleteMultipartUpload.
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html"> Abort Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param abortMultipartUploadRequest Container for the necessary
     *           parameters to execute the AbortMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void abortMultipartUpload(AbortMultipartUploadRequest abortMultipartUploadRequest) {
        ExecutionContext executionContext = createExecutionContext(abortMultipartUploadRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<AbortMultipartUploadRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new AbortMultipartUploadRequestMarshaller().marshall(super.beforeMarshalling(abortMultipartUploadRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation deletes an archive from a vault. Subsequent requests
     * to initiate a retrieval of this archive will fail. Archive retrievals
     * that are in progress for this archive ID may or may not succeed
     * according to the following scenarios:
     * </p>
     * 
     * <ul>
     * <li>If the archive retrieval job is actively preparing the data for
     * download when Amazon Glacier receives the delete archive request, the
     * archival retrieval operation might fail. </li>
     * <li>If the archive retrieval job has successfully prepared the
     * archive for download when Amazon Glacier receives the delete archive
     * request, you will be able to download the output. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. Attempting to delete an already-deleted
     * archive does not result in an error.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html"> Deleting an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteArchiveRequest Container for the necessary parameters to
     *           execute the DeleteArchive service method on AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteArchive(DeleteArchiveRequest deleteArchiveRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteArchiveRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteArchiveRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteArchiveRequestMarshaller().marshall(super.beforeMarshalling(deleteArchiveRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation downloads the output of the job you initiated using
     * InitiateJob. Depending on the job type you specified when you
     * initiated the job, the output will be either the content of an archive
     * or a vault inventory.
     * </p>
     * <p>
     * A job ID will not expire for at least 24 hours after Amazon Glacier
     * completes the job. That is, you can download the job output within the
     * 24 hours period after Amazon Glacier completes the job.
     * </p>
     * <p>
     * If the job output is large, then you can use the <code>Range</code>
     * request header to retrieve a portion of the output. This allows you to
     * download the entire output in smaller chunks of bytes. For example,
     * suppose you have 1 GB of job output you want to download and you
     * decide to download 128 MB chunks of data at a time, which is a total
     * of eight Get Job Output requests. You use the following process to
     * download the job output:
     * </p>
     * <ol> <li> <p>
     * Download a 128 MB chunk of output by specifying the appropriate byte
     * range using the <code>Range</code> header.
     * </p>
     * </li>
     * <li> <p>
     * Along with the data, the response includes a SHA256 tree hash of the
     * payload. You compute the checksum of the payload on the client and
     * compare it with the checksum you received in the response to ensure
     * you received all the expected data.
     * </p>
     * </li>
     * <li> <p>
     * Repeat steps 1 and 2 for all the eight 128 MB chunks of output data,
     * each time specifying the appropriate byte range.
     * </p>
     * </li>
     * <li> <p>
     * After downloading all the parts of the job output, you have a list of
     * eight checksum values. Compute the tree hash of these values to find
     * the checksum of the entire output. Using the DescribeJob API, obtain
     * job information of the job that provided you the output. The response
     * includes the checksum of the entire archive stored in Amazon Glacier.
     * You compare this value with the checksum you computed to ensure you
     * have downloaded the entire archive content with no errors.
     * </p>
     * </li>
     * </ol> <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a> , <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html"> Downloading an Archive </a> , and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html"> Get Job Output </a>
     * 
     * </p>
     *
     * @param getJobOutputRequest Container for the necessary parameters to
     *           execute the GetJobOutput service method on AmazonGlacier.
     * 
     * @return The response from the GetJobOutput service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetJobOutputResult getJobOutput(GetJobOutputRequest getJobOutputRequest) {
        ExecutionContext executionContext = createExecutionContext(getJobOutputRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetJobOutputRequest> request = null;
        Response<GetJobOutputResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetJobOutputRequestMarshaller().marshall(super.beforeMarshalling(getJobOutputRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetJobOutputResult, JsonUnmarshallerContext> unmarshaller =
                new GetJobOutputResultJsonUnmarshaller();
            JsonResponseHandler<GetJobOutputResult> responseHandler =
                new JsonResponseHandler<GetJobOutputResult>(unmarshaller);

            responseHandler.needsConnectionLeftOpen = true;

            response = invoke(request, responseHandler, executionContext);

            GetJobOutputResult awsResponse = response.getAwsResponse();
            awsResponse.setBody(new ServiceClientHolderInputStream(awsResponse.getBody(),this));
            
            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation initiates a job of the specified type. In this
     * release, you can initiate a job to retrieve either an archive or a
     * vault inventory (a list of archives in a vault).
     * </p>
     * <p>
     * Retrieving data from Amazon Glacier is a two-step process:
     * </p>
     * <ol> <li> <p>
     * Initiate a retrieval job.
     * </p>
     * <p>
     * <b>NOTE:</b> A data retrieval policy can cause your initiate
     * retrieval job request to fail with a PolicyEnforcedException
     * exception. For more information about data retrieval policies, see
     * Amazon Glacier Data Retrieval Policies. For more information about the
     * PolicyEnforcedException exception, see Error Responses.
     * </p>
     * </li>
     * <li> <p>
     * After the job completes, download the bytes.
     * </p>
     * </li>
     * </ol> <p>
     * The retrieval request is executed asynchronously. When you initiate a
     * retrieval job, Amazon Glacier creates a job and returns a job ID in
     * the response. When Amazon Glacier completes the job, you can get the
     * job output (archive or inventory data). For information about getting
     * job output, see GetJobOutput operation.
     * </p>
     * <p>
     * The job must complete before you can get its output. To determine
     * when a job is complete, you have the following options:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>Use Amazon SNS Notification</b> You can specify an Amazon Simple
     * Notification Service (Amazon SNS) topic to which Amazon Glacier can
     * post a notification after the job is completed. You can specify an SNS
     * topic per job request. The notification is sent only after Amazon
     * Glacier completes the job. In addition to specifying an SNS topic per
     * job request, you can configure vault notifications for a vault so that
     * job notifications are always sent. For more information, see
     * SetVaultNotifications.
     * </p>
     * </li>
     * <li> <p>
     * <b>Get job details</b> You can make a DescribeJob request to obtain
     * job status information while a job is in progress. However, it is more
     * efficient to use an Amazon SNS notification to determine when a job is
     * complete.
     * </p>
     * </li>
     * 
     * </ul>
     * <p>
     * <b>NOTE:</b> The information you get via notification is same that
     * you get by calling DescribeJob.
     * </p>
     * <p>
     * If for a specific event, you add both the notification configuration
     * on the vault and also specify an SNS topic in your initiate job
     * request, Amazon Glacier sends both notifications. For more
     * information, see SetVaultNotifications.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * <b>About the Vault Inventory</b>
     * </p>
     * <p>
     * Amazon Glacier prepares an inventory for each vault periodically,
     * every 24 hours. When you initiate a job for a vault inventory, Amazon
     * Glacier returns the last inventory for the vault. The inventory data
     * you get might be up to a day or two days old. Also, the initiate
     * inventory job might take some time to complete before you can download
     * the vault inventory. So you do not want to retrieve a vault inventory
     * for each vault operation. However, in some scenarios, you might find
     * the vault inventory useful. For example, when you upload an archive,
     * you can provide an archive description but not an archive name. Amazon
     * Glacier provides you a unique archive ID, an opaque string of
     * characters. So, you might maintain your own database that maps archive
     * names to their corresponding Amazon Glacier assigned archive IDs. You
     * might find the vault inventory useful in the event you need to
     * reconcile information in your database with the actual vault
     * inventory.
     * </p>
     * <p>
     * <b>Range Inventory Retrieval</b>
     * </p>
     * <p>
     * You can limit the number of inventory items retrieved by filtering on
     * the archive creation date or by setting a limit.
     * </p>
     * <p>
     * <i>Filtering by Archive Creation Date</i>
     * </p>
     * <p>
     * You can retrieve inventory items for archives created between
     * <code>StartDate</code> and <code>EndDate</code> by specifying values
     * for these parameters in the <b>InitiateJob</b> request. Archives
     * created on or after the <code>StartDate</code> and before the
     * <code>EndDate</code> will be returned. If you only provide the
     * <code>StartDate</code> without the <code>EndDate</code> , you will
     * retrieve the inventory for all archives created on or after the
     * <code>StartDate</code> . If you only provide the <code>EndDate</code>
     * without the <code>StartDate</code> , you will get back the inventory
     * for all archives created before the <code>EndDate</code> .
     * </p>
     * <p>
     * <i>Limiting Inventory Items per Retrieval</i>
     * </p>
     * <p>
     * You can limit the number of inventory items returned by setting the
     * <code>Limit</code> parameter in the <b>InitiateJob</b> request. The
     * inventory job output will contain inventory items up to the specified
     * <code>Limit</code> . If there are more inventory items available, the
     * result is paginated. After a job is complete you can use the
     * DescribeJob operation to get a marker that you use in a subsequent
     * <b>InitiateJob</b> request. The marker will indicate the starting
     * point to retrieve the next set of inventory items. You can page
     * through your entire inventory by repeatedly making <b>InitiateJob</b>
     * requests with the marker from the previous <b>DescribeJob</b> output,
     * until you get a marker from <b>DescribeJob</b> that returns null,
     * indicating that there are no more inventory items available.
     * </p>
     * <p>
     * You can use the <code>Limit</code> parameter together with the date
     * range parameters.
     * </p>
     * <p>
     * <b>About Ranged Archive Retrieval</b>
     * </p>
     * <p>
     * You can initiate an archive retrieval for the whole archive or a
     * range of the archive. In the case of ranged archive retrieval, you
     * specify a byte range to return or the whole archive. The range
     * specified must be megabyte (MB) aligned, that is the range start value
     * must be divisible by 1 MB and range end value plus 1 must be divisible
     * by 1 MB or equal the end of the archive. If the ranged archive
     * retrieval is not megabyte aligned, this operation returns a 400
     * response. Furthermore, to ensure you get checksum values for data you
     * download using Get Job Output API, the range must be tree hash
     * aligned.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory </a>
     * 
     * </p>
     *
     * @param initiateJobRequest Container for the necessary parameters to
     *           execute the InitiateJob service method on AmazonGlacier.
     * 
     * @return The response from the InitiateJob service method, as returned
     *         by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws PolicyEnforcedException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public InitiateJobResult initiateJob(InitiateJobRequest initiateJobRequest) {
        ExecutionContext executionContext = createExecutionContext(initiateJobRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<InitiateJobRequest> request = null;
        Response<InitiateJobResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new InitiateJobRequestMarshaller().marshall(super.beforeMarshalling(initiateJobRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<InitiateJobResult, JsonUnmarshallerContext> unmarshaller =
                new InitiateJobResultJsonUnmarshaller();
            JsonResponseHandler<InitiateJobResult> responseHandler =
                new JsonResponseHandler<InitiateJobResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation adds an archive to a vault. This is a synchronous
     * operation, and for a successful upload, your data is durably
     * persisted. Amazon Glacier returns the archive ID in the
     * <code>x-amz-archive-id</code> header of the response.
     * </p>
     * <p>
     * You must use the archive ID to access your data in Amazon Glacier.
     * After you upload an archive, you should save the archive ID returned
     * so that you can retrieve or delete the archive later. Besides saving
     * the archive ID, you can also index it and give it a friendly name to
     * allow for better searching. You can also use the optional archive
     * description field to specify how the archive is referred to in an
     * external index of archives, such as you might create in Amazon
     * DynamoDB. You can also get the vault inventory to obtain a list of
     * archive IDs in a vault. For more information, see InitiateJob.
     * </p>
     * <p>
     * You must provide a SHA256 tree hash of the data you are uploading.
     * For information about computing a SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * <p>
     * You can optionally specify an archive description of up to 1,024
     * printable ASCII characters. You can get the archive description when
     * you either retrieve the archive or get the vault inventory. For more
     * information, see InitiateJob. Amazon Glacier does not interpret the
     * description in any way. An archive description does not need to be
     * unique. You cannot use the description to retrieve or sort the archive
     * list.
     * </p>
     * <p>
     * Archives are immutable. After you upload an archive, you cannot edit
     * the archive or its description.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html"> Uploading an Archive in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html"> Upload Archive </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadArchiveRequest Container for the necessary parameters to
     *           execute the UploadArchive service method on AmazonGlacier.
     * 
     * @return The response from the UploadArchive service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws RequestTimeoutException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UploadArchiveResult uploadArchive(UploadArchiveRequest uploadArchiveRequest) {
        ExecutionContext executionContext = createExecutionContext(uploadArchiveRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UploadArchiveRequest> request = null;
        Response<UploadArchiveResult> response = null;
        
        final InputStream isOrig = uploadArchiveRequest.getBody();
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UploadArchiveRequestMarshaller().marshall(super.beforeMarshalling(uploadArchiveRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<UploadArchiveResult, JsonUnmarshallerContext> unmarshaller =
                new UploadArchiveResultJsonUnmarshaller();
            JsonResponseHandler<UploadArchiveResult> responseHandler =
                new JsonResponseHandler<UploadArchiveResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            // Restore the original input stream, so that the caller
            // (who is responsible) can close it
            uploadArchiveRequest.setBody(isOrig);
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation configures notifications that will be sent when
     * specific events happen to a vault. By default, you don't get any
     * notifications.
     * </p>
     * <p>
     * To configure vault notifications, send a PUT request to the
     * <code>notification-configuration</code> subresource of the vault. The
     * request should include a JSON document that provides an Amazon SNS
     * topic and specific events for which you want Amazon Glacier to send
     * notifications to the topic.
     * </p>
     * <p>
     * Amazon SNS topics must grant permission to the vault to be allowed to
     * publish notifications to the topic. You can configure a vault to
     * publish a notification for the following vault events:
     * </p>
     * 
     * <ul>
     * <li> <b>ArchiveRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an archive retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * <li> <b>InventoryRetrievalCompleted</b> This event occurs when a job
     * that was initiated for an inventory retrieval is completed
     * (InitiateJob). The status of the completed job can be "Succeeded" or
     * "Failed". The notification sent to the SNS topic is the same output as
     * returned from DescribeJob. </li>
     * 
     * </ul>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html"> Set Vault Notification Configuration </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param setVaultNotificationsRequest Container for the necessary
     *           parameters to execute the SetVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setVaultNotifications(SetVaultNotificationsRequest setVaultNotificationsRequest) {
        ExecutionContext executionContext = createExecutionContext(setVaultNotificationsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetVaultNotificationsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetVaultNotificationsRequestMarshaller().marshall(super.beforeMarshalling(setVaultNotificationsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * You call this operation to inform Amazon Glacier that all the archive
     * parts have been uploaded and that Amazon Glacier can now assemble the
     * archive from the uploaded parts. After assembling and saving the
     * archive to the vault, Amazon Glacier returns the URI path of the newly
     * created archive resource. Using the URI path, you can then access the
     * archive. After you upload an archive, you should save the archive ID
     * returned to retrieve the archive at a later point. You can also get
     * the vault inventory to obtain a list of archive IDs in a vault. For
     * more information, see InitiateJob.
     * </p>
     * <p>
     * In the request, you must include the computed SHA256 tree hash of the
     * entire archive you have uploaded. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * . On the server side, Amazon Glacier also constructs the SHA256 tree
     * hash of the assembled archive. If the values match, Amazon Glacier
     * saves the archive to the vault; otherwise, it returns an error, and
     * the operation fails. The ListParts operation returns a list of parts
     * uploaded for a specific multipart upload. It includes checksum
     * information for each uploaded part that can be used to debug a bad
     * checksum issue.
     * </p>
     * <p>
     * Additionally, Amazon Glacier also checks for any missing content
     * ranges when assembling the archive, if missing content ranges are
     * found, Amazon Glacier returns an error and the operation fails.
     * </p>
     * <p>
     * Complete Multipart Upload is an idempotent operation. After your
     * first successful complete multipart upload, if you call the operation
     * again within a short period, the operation will succeed and return the
     * same archive ID. This is useful in the event you experience a network
     * issue that causes an aborted connection or receive a 500 server error,
     * in which case you can repeat your Complete Multipart Upload request
     * and get the same archive ID without creating duplicate archives. Note,
     * however, that after the multipart upload completes, you cannot call
     * the List Parts operation and the multipart upload will not appear in
     * List Multipart Uploads response, even if idempotent complete is
     * possible.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html"> Complete Multipart Upload </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param completeMultipartUploadRequest Container for the necessary
     *           parameters to execute the CompleteMultipartUpload service method on
     *           AmazonGlacier.
     * 
     * @return The response from the CompleteMultipartUpload service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CompleteMultipartUploadResult completeMultipartUpload(CompleteMultipartUploadRequest completeMultipartUploadRequest) {
        ExecutionContext executionContext = createExecutionContext(completeMultipartUploadRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CompleteMultipartUploadRequest> request = null;
        Response<CompleteMultipartUploadResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CompleteMultipartUploadRequestMarshaller().marshall(super.beforeMarshalling(completeMultipartUploadRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<CompleteMultipartUploadResult, JsonUnmarshallerContext> unmarshaller =
                new CompleteMultipartUploadResultJsonUnmarshaller();
            JsonResponseHandler<CompleteMultipartUploadResult> responseHandler =
                new JsonResponseHandler<CompleteMultipartUploadResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation deletes the access policy associated with the
     * specified vault. The operation is eventually consistent???that is, it
     * might take some time for Amazon Glacier to completely remove the
     * access policy, and you might still see the effect of the policy for a
     * short time after you send the delete request.
     * </p>
     * <p>
     * This operation is idempotent. You can invoke delete multiple times,
     * even if there is no policy associated with the vault. For more
     * information about vault access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param deleteVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the DeleteVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVaultAccessPolicy(DeleteVaultAccessPolicyRequest deleteVaultAccessPolicyRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteVaultAccessPolicyRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteVaultAccessPolicyRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteVaultAccessPolicyRequestMarshaller().marshall(super.beforeMarshalling(deleteVaultAccessPolicyRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation uploads a part of an archive. You can upload archive
     * parts in any order. You can also upload them in parallel. You can
     * upload up to 10,000 parts for a multipart upload.
     * </p>
     * <p>
     * Amazon Glacier rejects your upload part request if any of the
     * following conditions is true:
     * </p>
     * 
     * <ul>
     * <li> <p>
     * <b>SHA256 tree hash does not match</b> To ensure that part data is
     * not corrupted in transmission, you compute a SHA256 tree hash of the
     * part and include it in your request. Upon receiving the part data,
     * Amazon Glacier also computes a SHA256 tree hash. If these hash values
     * don't match, the operation fails. For information about computing a
     * SHA256 tree hash, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html"> Computing Checksums </a>
     * .
     * </p>
     * </li>
     * <li> <p>
     * <b>Part size does not match</b> The size of each part except the last
     * must match the size specified in the corresponding
     * InitiateMultipartUpload request. The size of the last part must be the
     * same size as, or smaller than, the specified size.
     * </p>
     * <p>
     * <b>NOTE:</b> If you upload a part whose size is smaller than the part
     * size you specified in your initiate multipart upload request and that
     * part is not the last part, then the upload part request will succeed.
     * However, the subsequent Complete Multipart Upload request will fail.
     * </p>
     * </li>
     * <li> <b>Range does not align</b> The byte range value in the request
     * does not align with the part size specified in the corresponding
     * initiate request. For example, if you specify a part size of 4194304
     * bytes (4 MB), then 0 to 4194303 bytes (4 MB - 1) and 4194304 (4 MB) to
     * 8388607 (8 MB - 1) are valid part ranges. However, if you set a range
     * value of 2 MB to 6 MB, the range does not align with the part size and
     * the upload will fail. </li>
     * 
     * </ul>
     * <p>
     * This operation is idempotent. If you upload the same part multiple
     * times, the data included in the most recent request overwrites the
     * previously uploaded data.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html"> Upload Part </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param uploadMultipartPartRequest Container for the necessary
     *           parameters to execute the UploadMultipartPart service method on
     *           AmazonGlacier.
     * 
     * @return The response from the UploadMultipartPart service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws RequestTimeoutException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UploadMultipartPartResult uploadMultipartPart(UploadMultipartPartRequest uploadMultipartPartRequest) {
        ExecutionContext executionContext = createExecutionContext(uploadMultipartPartRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UploadMultipartPartRequest> request = null;
        Response<UploadMultipartPartResult> response = null;
        
        final InputStream isOrig = uploadMultipartPartRequest.getBody();
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UploadMultipartPartRequestMarshaller().marshall(super.beforeMarshalling(uploadMultipartPartRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<UploadMultipartPartResult, JsonUnmarshallerContext> unmarshaller =
                new UploadMultipartPartResultJsonUnmarshaller();
            JsonResponseHandler<UploadMultipartPartResult> responseHandler =
                new JsonResponseHandler<UploadMultipartPartResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            // Restore the original input stream, so that the caller
            // (who is responsible) can close it
            uploadMultipartPartRequest.setBody(isOrig);
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation returns information about a vault, including the
     * vault's Amazon Resource Name (ARN), the date the vault was created,
     * the number of archives it contains, and the total size of all the
     * archives in the vault. The number of archives and their total size are
     * as of the last inventory generation. This means that if you add or
     * remove an archive from a vault, and then immediately use Describe
     * Vault, the change in contents will not be immediately reflected. If
     * you want to retrieve the latest inventory of the vault, use
     * InitiateJob. Amazon Glacier generates vault inventories approximately
     * daily. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html"> Downloading a Vault Inventory in Amazon Glacier </a>
     * .
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html"> Retrieving Vault Metadata in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html"> Describe Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param describeVaultRequest Container for the necessary parameters to
     *           execute the DescribeVault service method on AmazonGlacier.
     * 
     * @return The response from the DescribeVault service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public DescribeVaultResult describeVault(DescribeVaultRequest describeVaultRequest) {
        ExecutionContext executionContext = createExecutionContext(describeVaultRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DescribeVaultRequest> request = null;
        Response<DescribeVaultResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DescribeVaultRequestMarshaller().marshall(super.beforeMarshalling(describeVaultRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<DescribeVaultResult, JsonUnmarshallerContext> unmarshaller =
                new DescribeVaultResultJsonUnmarshaller();
            JsonResponseHandler<DescribeVaultResult> responseHandler =
                new JsonResponseHandler<DescribeVaultResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation deletes the notification configuration set for a
     * vault. The operation is eventually consistent;that is, it might take
     * some time for Amazon Glacier to completely disable the notifications
     * and you might still receive some notifications for a short time after
     * you send the delete request.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
     * in the Amazon Glacier Developer Guide.
     * </p>
     *
     * @param deleteVaultNotificationsRequest Container for the necessary
     *           parameters to execute the DeleteVaultNotifications service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVaultNotifications(DeleteVaultNotificationsRequest deleteVaultNotificationsRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteVaultNotificationsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteVaultNotificationsRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteVaultNotificationsRequestMarshaller().marshall(super.beforeMarshalling(deleteVaultNotificationsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation lists in-progress multipart uploads for the specified
     * vault. An in-progress multipart upload is a multipart upload that has
     * been initiated by an InitiateMultipartUpload request, but has not yet
     * been completed or aborted. The list returned in the List Multipart
     * Upload response has no guaranteed order.
     * </p>
     * <p>
     * The List Multipart Uploads operation supports pagination. By default,
     * this operation returns up to 1,000 multipart uploads in the response.
     * You should always check the response for a <code>marker</code> at
     * which to continue the list; if there are no more items the
     * <code>marker</code> is <code>null</code> . To return a list of
     * multipart uploads that begins at a specific upload, set the
     * <code>marker</code> request parameter to the value you obtained from a
     * previous List Multipart Upload request. You can also limit the number
     * of uploads returned in the response by specifying the
     * <code>limit</code> parameter in the request.
     * </p>
     * <p>
     * Note the difference between this operation and listing parts
     * (ListParts). The List Multipart Uploads operation lists all multipart
     * uploads for a vault and does not require a multipart upload ID. The
     * List Parts operation requires a multipart upload ID since parts are
     * associated with a single upload.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and the underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html"> Working with Archives in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html"> List Multipart Uploads </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param listMultipartUploadsRequest Container for the necessary
     *           parameters to execute the ListMultipartUploads service method on
     *           AmazonGlacier.
     * 
     * @return The response from the ListMultipartUploads service method, as
     *         returned by AmazonGlacier.
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListMultipartUploadsResult listMultipartUploads(ListMultipartUploadsRequest listMultipartUploadsRequest) {
        ExecutionContext executionContext = createExecutionContext(listMultipartUploadsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListMultipartUploadsRequest> request = null;
        Response<ListMultipartUploadsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListMultipartUploadsRequestMarshaller().marshall(super.beforeMarshalling(listMultipartUploadsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<ListMultipartUploadsResult, JsonUnmarshallerContext> unmarshaller =
                new ListMultipartUploadsResultJsonUnmarshaller();
            JsonResponseHandler<ListMultipartUploadsResult> responseHandler =
                new JsonResponseHandler<ListMultipartUploadsResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    /**
     * <p>
     * This operation sets and then enacts a data retrieval policy in the
     * region specified in the PUT request. You can set one policy per region
     * for an AWS account. The policy is enacted within a few minutes of a
     * successful PUT operation.
     * </p>
     * <p>
     * The set policy operation does not affect retrieval jobs that were in
     * progress before the policy was enacted. For more information about
     * data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param setDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the SetDataRetrievalPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setDataRetrievalPolicy(SetDataRetrievalPolicyRequest setDataRetrievalPolicyRequest) {
        ExecutionContext executionContext = createExecutionContext(setDataRetrievalPolicyRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetDataRetrievalPolicyRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetDataRetrievalPolicyRequestMarshaller().marshall(super.beforeMarshalling(setDataRetrievalPolicyRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation deletes a vault. Amazon Glacier will delete a vault
     * only if there are no archives in the vault as of the last inventory
     * and there have been no writes to the vault since the last inventory.
     * If either of these conditions is not satisfied, the vault deletion
     * fails (that is, the vault is not removed) and Amazon Glacier returns
     * an error. You can use DescribeVault to return the number of archives
     * in a vault, and you can use
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html"> Initiate a Job (POST jobs) </a> to initiate a new inventory retrieval for a vault. The inventory contains the archive IDs you use to delete archives using <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html"> Delete Archive (DELETE archive) </a>
     * .
     * </p>
     * <p>
     * This operation is idempotent.
     * </p>
     * <p>
     * An AWS account has full permission to perform all operations
     * (actions). However, AWS Identity and Access Management (IAM) users
     * don't have any permissions by default. You must grant them explicit
     * permission to perform specific actions. For more information, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
     * .
     * </p>
     * <p>
     * For conceptual information and underlying REST API, go to
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html"> Deleting a Vault in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html"> Delete Vault </a>
     * in the <i>Amazon Glacier Developer Guide</i> .
     * </p>
     *
     * @param deleteVaultRequest Container for the necessary parameters to
     *           execute the DeleteVault service method on AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void deleteVault(DeleteVaultRequest deleteVaultRequest) {
        ExecutionContext executionContext = createExecutionContext(deleteVaultRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<DeleteVaultRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new DeleteVaultRequestMarshaller().marshall(super.beforeMarshalling(deleteVaultRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation configures an access policy for a vault and will
     * overwrite an existing policy. To configure a vault access policy, send
     * a PUT request to the <code>access-policy</code> subresource of the
     * vault. An access policy is specific to a vault and is also called a
     * vault subresource. You can set one access policy per vault and the
     * policy can be up to 20 KB in size. For more information about vault
     * access policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
     * .
     * </p>
     *
     * @param setVaultAccessPolicyRequest Container for the necessary
     *           parameters to execute the SetVaultAccessPolicy service method on
     *           AmazonGlacier.
     * 
     * 
     * @throws ResourceNotFoundException
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public void setVaultAccessPolicy(SetVaultAccessPolicyRequest setVaultAccessPolicyRequest) {
        ExecutionContext executionContext = createExecutionContext(setVaultAccessPolicyRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<SetVaultAccessPolicyRequest> request = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new SetVaultAccessPolicyRequestMarshaller().marshall(super.beforeMarshalling(setVaultAccessPolicyRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            JsonResponseHandler<Void> responseHandler = new JsonResponseHandler<Void>(null);
            invoke(request, responseHandler, executionContext);

        } finally {
            
            endClientExecution(awsRequestMetrics, request, null, LOGGING_AWS_REQUEST_METRIC);
        }
    }
    
    /**
     * <p>
     * This operation returns the current data retrieval policy for the
     * account and region specified in the GET request. For more information
     * about data retrieval policies, see
     * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html"> Amazon Glacier Data Retrieval Policies </a>
     * .
     * </p>
     *
     * @param getDataRetrievalPolicyRequest Container for the necessary
     *           parameters to execute the GetDataRetrievalPolicy service method on
     *           AmazonGlacier.
     * 
     * @return The response from the GetDataRetrievalPolicy service method,
     *         as returned by AmazonGlacier.
     * 
     * @throws MissingParameterValueException
     * @throws ServiceUnavailableException
     * @throws InvalidParameterValueException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonGlacier indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetDataRetrievalPolicyResult getDataRetrievalPolicy(GetDataRetrievalPolicyRequest getDataRetrievalPolicyRequest) {
        ExecutionContext executionContext = createExecutionContext(getDataRetrievalPolicyRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetDataRetrievalPolicyRequest> request = null;
        Response<GetDataRetrievalPolicyResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetDataRetrievalPolicyRequestMarshaller().marshall(super.beforeMarshalling(getDataRetrievalPolicyRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            Unmarshaller<GetDataRetrievalPolicyResult, JsonUnmarshallerContext> unmarshaller =
                new GetDataRetrievalPolicyResultJsonUnmarshaller();
            JsonResponseHandler<GetDataRetrievalPolicyResult> responseHandler =
                new JsonResponseHandler<GetDataRetrievalPolicyResult>(unmarshaller);

            response = invoke(request, responseHandler, executionContext);

            return response.getAwsResponse();
        } finally {
            
            endClientExecution(awsRequestMetrics, request, response, LOGGING_AWS_REQUEST_METRIC);
        }
    }

    @Override
    public void setEndpoint(String endpoint) {
        super.setEndpoint(endpoint);
    }

    @Override
    public void setEndpoint(String endpoint, String serviceName, String regionId) throws IllegalArgumentException {
        super.setEndpoint(endpoint, serviceName, regionId);
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            HttpResponseHandler<AmazonWebServiceResponse<X>> responseHandler,
            ExecutionContext executionContext) {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);

        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        AWSCredentials credentials;
        awsRequestMetrics.startEvent(Field.CredentialsRequestTime);
        try {
            credentials = awsCredentialsProvider.getCredentials();
        } finally {
            awsRequestMetrics.endEvent(Field.CredentialsRequestTime);
        }

        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();
        if (originalRequest != null && originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        JsonErrorResponseHandler errorResponseHandler = new JsonErrorResponseHandler(jsonErrorUnmarshallers);
        Response<X> result = client.execute(request, responseHandler,
                errorResponseHandler, executionContext);
        return result;
    }
}
        

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/model/DeleteVaultAccessPolicyRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.glacier.AmazonGlacier#deleteVaultAccessPolicy(DeleteVaultAccessPolicyRequest) DeleteVaultAccessPolicy operation}.
 * <p>
 * This operation deletes the access policy associated with the specified
 * vault. The operation is eventually consistent???that is, it might take
 * some time for Amazon Glacier to completely remove the access policy,
 * and you might still see the effect of the policy for a short time
 * after you send the delete request.
 * </p>
 * <p>
 * This operation is idempotent. You can invoke delete multiple times,
 * even if there is no policy associated with the vault. For more
 * information about vault access policies, see
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
 * .
 * </p>
 *
 * @see com.amazonaws.services.glacier.AmazonGlacier#deleteVaultAccessPolicy(DeleteVaultAccessPolicyRequest)
 */
public class DeleteVaultAccessPolicyRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     */
    private String accountId;

    /**
     * The name of the vault.
     */
    private String vaultName;

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @return The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public String getAccountId() {
        return accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteVaultAccessPolicyRequest withAccountId(String accountId) {
        this.accountId = accountId;
        return this;
    }

    /**
     * The name of the vault.
     *
     * @return The name of the vault.
     */
    public String getVaultName() {
        return vaultName;
    }
    
    /**
     * The name of the vault.
     *
     * @param vaultName The name of the vault.
     */
    public void setVaultName(String vaultName) {
        this.vaultName = vaultName;
    }
    
    /**
     * The name of the vault.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param vaultName The name of the vault.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteVaultAccessPolicyRequest withVaultName(String vaultName) {
        this.vaultName = vaultName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getAccountId() != null) sb.append("AccountId: " + getAccountId() + ",");
        if (getVaultName() != null) sb.append("VaultName: " + getVaultName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getAccountId() == null) ? 0 : getAccountId().hashCode()); 
        hashCode = prime * hashCode + ((getVaultName() == null) ? 0 : getVaultName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteVaultAccessPolicyRequest == false) return false;
        DeleteVaultAccessPolicyRequest other = (DeleteVaultAccessPolicyRequest)obj;
        
        if (other.getAccountId() == null ^ this.getAccountId() == null) return false;
        if (other.getAccountId() != null && other.getAccountId().equals(this.getAccountId()) == false) return false; 
        if (other.getVaultName() == null ^ this.getVaultName() == null) return false;
        if (other.getVaultName() != null && other.getVaultName().equals(this.getVaultName()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteVaultAccessPolicyRequest clone() {
        
            return (DeleteVaultAccessPolicyRequest) super.clone();
    }

}
    

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/model/DeleteVaultNotificationsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.glacier.AmazonGlacier#deleteVaultNotifications(DeleteVaultNotificationsRequest) DeleteVaultNotifications operation}.
 * <p>
 * This operation deletes the notification configuration set for a vault.
 * The operation is eventually consistent;that is, it might take some
 * time for Amazon Glacier to completely disable the notifications and
 * you might still receive some notifications for a short time after you
 * send the delete request.
 * </p>
 * <p>
 * An AWS account has full permission to perform all operations
 * (actions). However, AWS Identity and Access Management (IAM) users
 * don't have any permissions by default. You must grant them explicit
 * permission to perform specific actions. For more information, see
 * <a href="http://docs.aws.amazon.com/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
 * .
 * </p>
 * <p>
 * For conceptual information and underlying REST API, go to
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html"> Configuring Vault Notifications in Amazon Glacier </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html"> Delete Vault Notification Configuration </a>
 * in the Amazon Glacier Developer Guide.
 * </p>
 *
 * @see com.amazonaws.services.glacier.AmazonGlacier#deleteVaultNotifications(DeleteVaultNotificationsRequest)
 */
public class DeleteVaultNotificationsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     */
    private String accountId;

    /**
     * The name of the vault.
     */
    private String vaultName;

    /**
     * Default constructor for a new DeleteVaultNotificationsRequest object.  Callers should use the
     * setter or fluent setter (with...) methods to initialize this object after creating it.
     */
    public DeleteVaultNotificationsRequest() {}
    
    /**
     * Constructs a new DeleteVaultNotificationsRequest object.
     * Callers should use the setter or fluent setter (with...) methods to
     * initialize any additional object members.
     * 
     * @param vaultName The name of the vault.
     */
    public DeleteVaultNotificationsRequest(String vaultName) {
        setVaultName(vaultName);
    }

    /**
     * Constructs a new DeleteVaultNotificationsRequest object.
     * Callers should use the setter or fluent setter (with...) methods to
     * initialize any additional object members.
     * 
     * @param accountId The <code>AccountId</code> value is the AWS account
     * ID of the account that owns the vault. You can either specify an AWS
     * account ID or optionally a single '<code>-</code>' (hyphen), in which
     * case Amazon Glacier uses the AWS account ID associated with the
     * credentials used to sign the request. If you use an account ID, do not
     * include any hyphens ('-') in the ID.
     * @param vaultName The name of the vault.
     */
    public DeleteVaultNotificationsRequest(String accountId, String vaultName) {
        setAccountId(accountId);
        setVaultName(vaultName);
    }

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @return The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public String getAccountId() {
        return accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteVaultNotificationsRequest withAccountId(String accountId) {
        this.accountId = accountId;
        return this;
    }

    /**
     * The name of the vault.
     *
     * @return The name of the vault.
     */
    public String getVaultName() {
        return vaultName;
    }
    
    /**
     * The name of the vault.
     *
     * @param vaultName The name of the vault.
     */
    public void setVaultName(String vaultName) {
        this.vaultName = vaultName;
    }
    
    /**
     * The name of the vault.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param vaultName The name of the vault.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public DeleteVaultNotificationsRequest withVaultName(String vaultName) {
        this.vaultName = vaultName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getAccountId() != null) sb.append("AccountId: " + getAccountId() + ",");
        if (getVaultName() != null) sb.append("VaultName: " + getVaultName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getAccountId() == null) ? 0 : getAccountId().hashCode()); 
        hashCode = prime * hashCode + ((getVaultName() == null) ? 0 : getVaultName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof DeleteVaultNotificationsRequest == false) return false;
        DeleteVaultNotificationsRequest other = (DeleteVaultNotificationsRequest)obj;
        
        if (other.getAccountId() == null ^ this.getAccountId() == null) return false;
        if (other.getAccountId() != null && other.getAccountId().equals(this.getAccountId()) == false) return false; 
        if (other.getVaultName() == null ^ this.getVaultName() == null) return false;
        if (other.getVaultName() != null && other.getVaultName().equals(this.getVaultName()) == false) return false; 
        return true;
    }
    
    @Override
    public DeleteVaultNotificationsRequest clone() {
        
            return (DeleteVaultNotificationsRequest) super.clone();
    }

}
    

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/model/GetVaultAccessPolicyRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.glacier.AmazonGlacier#getVaultAccessPolicy(GetVaultAccessPolicyRequest) GetVaultAccessPolicy operation}.
 * <p>
 * This operation retrieves the <code>access-policy</code> subresource
 * set on the vault???for more information on setting this subresource,
 * see
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html"> Set Vault Access Policy (PUT access-policy) </a> . If there is no access policy set on the vault, the operation returns a <code>404 Not found</code> error. For more information about vault access policies, see <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html"> Amazon Glacier Access Control with Vault Access Policies </a>
 * .
 * </p>
 *
 * @see com.amazonaws.services.glacier.AmazonGlacier#getVaultAccessPolicy(GetVaultAccessPolicyRequest)
 */
public class GetVaultAccessPolicyRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     */
    private String accountId;

    /**
     * The name of the vault.
     */
    private String vaultName;

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @return The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public String getAccountId() {
        return accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetVaultAccessPolicyRequest withAccountId(String accountId) {
        this.accountId = accountId;
        return this;
    }

    /**
     * The name of the vault.
     *
     * @return The name of the vault.
     */
    public String getVaultName() {
        return vaultName;
    }
    
    /**
     * The name of the vault.
     *
     * @param vaultName The name of the vault.
     */
    public void setVaultName(String vaultName) {
        this.vaultName = vaultName;
    }
    
    /**
     * The name of the vault.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param vaultName The name of the vault.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetVaultAccessPolicyRequest withVaultName(String vaultName) {
        this.vaultName = vaultName;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getAccountId() != null) sb.append("AccountId: " + getAccountId() + ",");
        if (getVaultName() != null) sb.append("VaultName: " + getVaultName() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getAccountId() == null) ? 0 : getAccountId().hashCode()); 
        hashCode = prime * hashCode + ((getVaultName() == null) ? 0 : getVaultName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetVaultAccessPolicyRequest == false) return false;
        GetVaultAccessPolicyRequest other = (GetVaultAccessPolicyRequest)obj;
        
        if (other.getAccountId() == null ^ this.getAccountId() == null) return false;
        if (other.getAccountId() != null && other.getAccountId().equals(this.getAccountId()) == false) return false; 
        if (other.getVaultName() == null ^ this.getVaultName() == null) return false;
        if (other.getVaultName() != null && other.getVaultName().equals(this.getVaultName()) == false) return false; 
        return true;
    }
    
    @Override
    public GetVaultAccessPolicyRequest clone() {
        
            return (GetVaultAccessPolicyRequest) super.clone();
    }

}
    

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/model/InitiateMultipartUploadRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.glacier.AmazonGlacier#initiateMultipartUpload(InitiateMultipartUploadRequest) InitiateMultipartUpload operation}.
 * <p>
 * This operation initiates a multipart upload. Amazon Glacier creates a
 * multipart upload resource and returns its ID in the response. The
 * multipart upload ID is used in subsequent requests to upload parts of
 * an archive (see UploadMultipartPart).
 * </p>
 * <p>
 * When you initiate a multipart upload, you specify the part size in
 * number of bytes. The part size must be a megabyte (1024 KB) multiplied
 * by a power of 2-for example, 1048576 (1 MB), 2097152 (2 MB), 4194304
 * (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is
 * 1 MB, and the maximum is 4 GB.
 * </p>
 * <p>
 * Every part you upload to this resource (see UploadMultipartPart),
 * except the last one, must have the same size. The last one can be the
 * same size or smaller. For example, suppose you want to upload a 16.2
 * MB file. If you initiate the multipart upload with a part size of 4
 * MB, you will upload four parts of 4 MB each and one part of 0.2 MB.
 * </p>
 * <p>
 * <b>NOTE:</b> You don't need to know the size of the archive when you
 * start a multipart upload because Amazon Glacier does not require you
 * to specify the overall archive size.
 * </p>
 * <p>
 * After you complete the multipart upload, Amazon Glacier removes the
 * multipart upload resource referenced by the ID. Amazon Glacier also
 * removes the multipart upload resource if you cancel the multipart
 * upload or it may be removed if there is no activity for a period of 24
 * hours.
 * </p>
 * <p>
 * An AWS account has full permission to perform all operations
 * (actions). However, AWS Identity and Access Management (IAM) users
 * don't have any permissions by default. You must grant them explicit
 * permission to perform specific actions. For more information, see
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html"> Access Control Using AWS Identity and Access Management (IAM) </a>
 * .
 * </p>
 * <p>
 * For conceptual information and underlying REST API, go to
 * <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html"> Uploading Large Archives in Parts (Multipart Upload) </a> and <a href="http://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html"> Initiate Multipart Upload </a>
 * in the <i>Amazon Glacier Developer Guide</i> .
 * </p>
 *
 * @see com.amazonaws.services.glacier.AmazonGlacier#initiateMultipartUpload(InitiateMultipartUploadRequest)
 */
public class InitiateMultipartUploadRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     */
    private String accountId;

    /**
     * The name of the vault.
     */
    private String vaultName;

    /**
     * The archive description that you are uploading in parts. <p>The part
     * size must be a megabyte (1024 KB) multiplied by a power of 2???for
     * example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     * MB), and so on. The minimum allowable part size is 1 MB, and the
     * maximum is 4 GB (4096 MB).
     */
    private String archiveDescription;

    /**
     * The size of each part except the last, in bytes. The last part can be
     * smaller than this part size.
     */
    private String partSize;

    /**
     * Default constructor for a new InitiateMultipartUploadRequest object.  Callers should use the
     * setter or fluent setter (with...) methods to initialize this object after creating it.
     */
    public InitiateMultipartUploadRequest() {}
    
    /**
     * Constructs a new InitiateMultipartUploadRequest object.
     * Callers should use the setter or fluent setter (with...) methods to
     * initialize any additional object members.
     * 
     * @param vaultName The name of the vault.
     * @param archiveDescription The archive description that you are
     * uploading in parts. <p>The part size must be a megabyte (1024 KB)
     * multiplied by a power of 2???for example, 1048576 (1 MB), 2097152 (2
     * MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum allowable
     * part size is 1 MB, and the maximum is 4 GB (4096 MB).
     * @param partSize The size of each part except the last, in bytes. The
     * last part can be smaller than this part size.
     */
    public InitiateMultipartUploadRequest(String vaultName, String archiveDescription, String partSize) {
        setVaultName(vaultName);
        setArchiveDescription(archiveDescription);
        setPartSize(partSize);
    }

    /**
     * Constructs a new InitiateMultipartUploadRequest object.
     * Callers should use the setter or fluent setter (with...) methods to
     * initialize any additional object members.
     * 
     * @param accountId The <code>AccountId</code> value is the AWS account
     * ID of the account that owns the vault. You can either specify an AWS
     * account ID or optionally a single '<code>-</code>' (hyphen), in which
     * case Amazon Glacier uses the AWS account ID associated with the
     * credentials used to sign the request. If you use an account ID, do not
     * include any hyphens ('-') in the ID.
     * @param vaultName The name of the vault.
     * @param archiveDescription The archive description that you are
     * uploading in parts. <p>The part size must be a megabyte (1024 KB)
     * multiplied by a power of 2???for example, 1048576 (1 MB), 2097152 (2
     * MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum allowable
     * part size is 1 MB, and the maximum is 4 GB (4096 MB).
     * @param partSize The size of each part except the last, in bytes. The
     * last part can be smaller than this part size.
     */
    public InitiateMultipartUploadRequest(String accountId, String vaultName, String archiveDescription, String partSize) {
        setAccountId(accountId);
        setVaultName(vaultName);
        setArchiveDescription(archiveDescription);
        setPartSize(partSize);
    }

    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @return The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public String getAccountId() {
        return accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     */
    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }
    
    /**
     * The <code>AccountId</code> value is the AWS account ID of the account
     * that owns the vault. You can either specify an AWS account ID or
     * optionally a single '<code>-</code>' (hyphen), in which case Amazon
     * Glacier uses the AWS account ID associated with the credentials used
     * to sign the request. If you use an account ID, do not include any
     * hyphens ('-') in the ID.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param accountId The <code>AccountId</code> value is the AWS account ID of the account
     *         that owns the vault. You can either specify an AWS account ID or
     *         optionally a single '<code>-</code>' (hyphen), in which case Amazon
     *         Glacier uses the AWS account ID associated with the credentials used
     *         to sign the request. If you use an account ID, do not include any
     *         hyphens ('-') in the ID.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadRequest withAccountId(String accountId) {
        this.accountId = accountId;
        return this;
    }

    /**
     * The name of the vault.
     *
     * @return The name of the vault.
     */
    public String getVaultName() {
        return vaultName;
    }
    
    /**
     * The name of the vault.
     *
     * @param vaultName The name of the vault.
     */
    public void setVaultName(String vaultName) {
        this.vaultName = vaultName;
    }
    
    /**
     * The name of the vault.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param vaultName The name of the vault.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadRequest withVaultName(String vaultName) {
        this.vaultName = vaultName;
        return this;
    }

    /**
     * The archive description that you are uploading in parts. <p>The part
     * size must be a megabyte (1024 KB) multiplied by a power of 2???for
     * example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     * MB), and so on. The minimum allowable part size is 1 MB, and the
     * maximum is 4 GB (4096 MB).
     *
     * @return The archive description that you are uploading in parts. <p>The part
     *         size must be a megabyte (1024 KB) multiplied by a power of 2???for
     *         example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     *         MB), and so on. The minimum allowable part size is 1 MB, and the
     *         maximum is 4 GB (4096 MB).
     */
    public String getArchiveDescription() {
        return archiveDescription;
    }
    
    /**
     * The archive description that you are uploading in parts. <p>The part
     * size must be a megabyte (1024 KB) multiplied by a power of 2???for
     * example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     * MB), and so on. The minimum allowable part size is 1 MB, and the
     * maximum is 4 GB (4096 MB).
     *
     * @param archiveDescription The archive description that you are uploading in parts. <p>The part
     *         size must be a megabyte (1024 KB) multiplied by a power of 2???for
     *         example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     *         MB), and so on. The minimum allowable part size is 1 MB, and the
     *         maximum is 4 GB (4096 MB).
     */
    public void setArchiveDescription(String archiveDescription) {
        this.archiveDescription = archiveDescription;
    }
    
    /**
     * The archive description that you are uploading in parts. <p>The part
     * size must be a megabyte (1024 KB) multiplied by a power of 2???for
     * example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     * MB), and so on. The minimum allowable part size is 1 MB, and the
     * maximum is 4 GB (4096 MB).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param archiveDescription The archive description that you are uploading in parts. <p>The part
     *         size must be a megabyte (1024 KB) multiplied by a power of 2???for
     *         example, 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8
     *         MB), and so on. The minimum allowable part size is 1 MB, and the
     *         maximum is 4 GB (4096 MB).
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadRequest withArchiveDescription(String archiveDescription) {
        this.archiveDescription = archiveDescription;
        return this;
    }

    /**
     * The size of each part except the last, in bytes. The last part can be
     * smaller than this part size.
     *
     * @return The size of each part except the last, in bytes. The last part can be
     *         smaller than this part size.
     */
    public String getPartSize() {
        return partSize;
    }
    
    /**
     * The size of each part except the last, in bytes. The last part can be
     * smaller than this part size.
     *
     * @param partSize The size of each part except the last, in bytes. The last part can be
     *         smaller than this part size.
     */
    public void setPartSize(String partSize) {
        this.partSize = partSize;
    }
    
    /**
     * The size of each part except the last, in bytes. The last part can be
     * smaller than this part size.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param partSize The size of each part except the last, in bytes. The last part can be
     *         smaller than this part size.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadRequest withPartSize(String partSize) {
        this.partSize = partSize;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getAccountId() != null) sb.append("AccountId: " + getAccountId() + ",");
        if (getVaultName() != null) sb.append("VaultName: " + getVaultName() + ",");
        if (getArchiveDescription() != null) sb.append("ArchiveDescription: " + getArchiveDescription() + ",");
        if (getPartSize() != null) sb.append("PartSize: " + getPartSize() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getAccountId() == null) ? 0 : getAccountId().hashCode()); 
        hashCode = prime * hashCode + ((getVaultName() == null) ? 0 : getVaultName().hashCode()); 
        hashCode = prime * hashCode + ((getArchiveDescription() == null) ? 0 : getArchiveDescription().hashCode()); 
        hashCode = prime * hashCode + ((getPartSize() == null) ? 0 : getPartSize().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof InitiateMultipartUploadRequest == false) return false;
        InitiateMultipartUploadRequest other = (InitiateMultipartUploadRequest)obj;
        
        if (other.getAccountId() == null ^ this.getAccountId() == null) return false;
        if (other.getAccountId() != null && other.getAccountId().equals(this.getAccountId()) == false) return false; 
        if (other.getVaultName() == null ^ this.getVaultName() == null) return false;
        if (other.getVaultName() != null && other.getVaultName().equals(this.getVaultName()) == false) return false; 
        if (other.getArchiveDescription() == null ^ this.getArchiveDescription() == null) return false;
        if (other.getArchiveDescription() != null && other.getArchiveDescription().equals(this.getArchiveDescription()) == false) return false; 
        if (other.getPartSize() == null ^ this.getPartSize() == null) return false;
        if (other.getPartSize() != null && other.getPartSize().equals(this.getPartSize()) == false) return false; 
        return true;
    }
    
    @Override
    public InitiateMultipartUploadRequest clone() {
        
            return (InitiateMultipartUploadRequest) super.clone();
    }

}
    

File: aws-java-sdk-glacier/src/main/java/com/amazonaws/services/glacier/model/InitiateMultipartUploadResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.glacier.model;

import java.io.Serializable;

/**
 * <p>
 * Contains the Amazon Glacier response to your request.
 * </p>
 */
public class InitiateMultipartUploadResult implements Serializable, Cloneable {

    /**
     * The relative URI path of the multipart upload ID Amazon Glacier
     * created.
     */
    private String location;

    /**
     * The ID of the multipart upload. This value is also included as part of
     * the location.
     */
    private String uploadId;

    /**
     * The relative URI path of the multipart upload ID Amazon Glacier
     * created.
     *
     * @return The relative URI path of the multipart upload ID Amazon Glacier
     *         created.
     */
    public String getLocation() {
        return location;
    }
    
    /**
     * The relative URI path of the multipart upload ID Amazon Glacier
     * created.
     *
     * @param location The relative URI path of the multipart upload ID Amazon Glacier
     *         created.
     */
    public void setLocation(String location) {
        this.location = location;
    }
    
    /**
     * The relative URI path of the multipart upload ID Amazon Glacier
     * created.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param location The relative URI path of the multipart upload ID Amazon Glacier
     *         created.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadResult withLocation(String location) {
        this.location = location;
        return this;
    }

    /**
     * The ID of the multipart upload. This value is also included as part of
     * the location.
     *
     * @return The ID of the multipart upload. This value is also included as part of
     *         the location.
     */
    public String getUploadId() {
        return uploadId;
    }
    
    /**
     * The ID of the multipart upload. This value is also included as part of
     * the location.
     *
     * @param uploadId The ID of the multipart upload. This value is also included as part of
     *         the location.
     */
    public void setUploadId(String uploadId) {
        this.uploadId = uploadId;
    }
    
    /**
     * The ID of the multipart upload. This value is also included as part of
     * the location.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param uploadId The ID of the multipart upload. This value is also included as part of
     *         the location.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public InitiateMultipartUploadResult withUploadId(String uploadId) {
        this.uploadId = uploadId;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getLocation() != null) sb.append("Location: " + getLocation() + ",");
        if (getUploadId() != null) sb.append("UploadId: " + getUploadId() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getLocation() == null) ? 0 : getLocation().hashCode()); 
        hashCode = prime * hashCode + ((getUploadId() == null) ? 0 : getUploadId().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof InitiateMultipartUploadResult == false) return false;
        InitiateMultipartUploadResult other = (InitiateMultipartUploadResult)obj;
        
        if (other.getLocation() == null ^ this.getLocation() == null) return false;
        if (other.getLocation() != null && other.getLocation().equals(this.getLocation()) == false) return false; 
        if (other.getUploadId() == null ^ this.getUploadId() == null) return false;
        if (other.getUploadId() != null && other.getUploadId().equals(this.getUploadId()) == false) return false; 
        return true;
    }
    
    @Override
    public InitiateMultipartUploadResult clone() {
        try {
            return (InitiateMultipartUploadResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/AmazonImportExport.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport;

import com.amazonaws.*;
import com.amazonaws.regions.*;
import com.amazonaws.services.importexport.model.*;

/**
 * Interface for accessing AmazonImportExport.
 * AWS Import/Export Service <p>
 * AWS Import/Export accelerates transferring large amounts of data
 * between the AWS cloud and portable storage devices that you mail to
 * us. AWS Import/Export transfers data directly onto and off of your
 * storage devices using Amazon's high-speed internal network and
 * bypassing the Internet. For large data sets, AWS Import/Export is
 * often faster than Internet transfer and more cost effective than
 * upgrading your connectivity.
 * </p>
 */
public interface AmazonImportExport {

    /**
     * Overrides the default endpoint for this client ("https://importexport.amazonaws.com").
     * Callers can use this method to control which AWS region they want to work with.
     * <p>
     * Callers can pass in just the endpoint (ex: "importexport.amazonaws.com") or a full
     * URL, including the protocol (ex: "https://importexport.amazonaws.com"). If the
     * protocol is not specified here, the default protocol from this client's
     * {@link ClientConfiguration} will be used, which by default is HTTPS.
     * <p>
     * For more information on using AWS regions with the AWS SDK for Java, and
     * a complete list of all available endpoints for all AWS services, see:
     * <a href="http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912">
     * http://developer.amazonwebservices.com/connect/entry.jspa?externalID=3912</a>
     * <p>
     * <b>This method is not threadsafe. An endpoint should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param endpoint
     *            The endpoint (ex: "importexport.amazonaws.com") or a full URL,
     *            including the protocol (ex: "https://importexport.amazonaws.com") of
     *            the region specific AWS endpoint this client will communicate
     *            with.
     *
     * @throws IllegalArgumentException
     *             If any problems are detected with the specified endpoint.
     */
    public void setEndpoint(String endpoint) throws java.lang.IllegalArgumentException;

    /**
     * An alternative to {@link AmazonImportExport#setEndpoint(String)}, sets the
     * regional endpoint for this client's service calls. Callers can use this
     * method to control which AWS region they want to work with.
     * <p>
     * By default, all service endpoints in all regions use the https protocol.
     * To use http instead, specify it in the {@link ClientConfiguration}
     * supplied at construction.
     * <p>
     * <b>This method is not threadsafe. A region should be configured when the
     * client is created and before any service requests are made. Changing it
     * afterwards creates inevitable race conditions for any service requests in
     * transit or retrying.</b>
     *
     * @param region
     *            The region this client will communicate with. See
     *            {@link Region#getRegion(com.amazonaws.regions.Regions)} for
     *            accessing a given region.
     * @throws java.lang.IllegalArgumentException
     *             If the given region is null, or if this service isn't
     *             available in the given region. See
     *             {@link Region#isServiceSupported(String)}
     * @see Region#getRegion(com.amazonaws.regions.Regions)
     * @see Region#createClient(Class, com.amazonaws.auth.AWSCredentialsProvider, ClientConfiguration)
     */
    public void setRegion(Region region) throws java.lang.IllegalArgumentException;
    
    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob service method on AmazonImportExport.
     * 
     * @return The response from the CreateJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws MalformedManifestException
     * @throws InvalidAddressException
     * @throws BucketPermissionException
     * @throws InvalidParameterException
     * @throws MultipleRegionsException
     * @throws InvalidVersionException
     * @throws MissingParameterException
     * @throws InvalidFileSystemException
     * @throws MissingCustomsException
     * @throws NoSuchBucketException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidManifestFieldException
     * @throws InvalidCustomsException
     * @throws MissingManifestFieldException
     * @throws CreateJobQuotaExceededException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateJobResult createJob(CreateJobRequest createJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel service method on AmazonImportExport.
     * 
     * @return The response from the GetShippingLabel service method, as
     *         returned by AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidAddressException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetShippingLabelResult getShippingLabel(GetShippingLabelRequest getShippingLabelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob service method on AmazonImportExport.
     * 
     * @return The response from the CancelJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     * @throws UnableToCancelJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CancelJobResult cancelJob(CancelJobRequest cancelJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus service method on AmazonImportExport.
     * 
     * @return The response from the GetStatus service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStatusResult getStatus(GetStatusRequest getStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs service method on AmazonImportExport.
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs(ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob service method on AmazonImportExport.
     * 
     * @return The response from the UpdateJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws MalformedManifestException
     * @throws BucketPermissionException
     * @throws InvalidAddressException
     * @throws InvalidParameterException
     * @throws UnableToUpdateJobIdException
     * @throws MultipleRegionsException
     * @throws InvalidVersionException
     * @throws MissingParameterException
     * @throws InvalidFileSystemException
     * @throws CanceledJobIdException
     * @throws MissingCustomsException
     * @throws NoSuchBucketException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidCustomsException
     * @throws InvalidManifestFieldException
     * @throws MissingManifestFieldException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateJobResult updateJob(UpdateJobRequest updateJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs() throws AmazonServiceException, AmazonClientException;
    
    /**
     * Shuts down this client object, releasing any resources that might be held
     * open. This is an optional method, and callers are not expected to call
     * it, but can if they want to explicitly release any open resources. Once a
     * client has been shutdown, it should not be used to make any more
     * requests.
     */
    public void shutdown();
    
    /**
     * Returns additional metadata for a previously executed successful request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing a request.
     *
     * @param request
     *            The originally executed request.
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request);
}
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/AmazonImportExportAsync.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport;

import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.importexport.model.*;

/**
 * Interface for accessing AmazonImportExport asynchronously.
 * Each asynchronous method will return a Java Future object, and users are also allowed
 * to provide a callback handler.
 * AWS Import/Export Service <p>
 * AWS Import/Export accelerates transferring large amounts of data
 * between the AWS cloud and portable storage devices that you mail to
 * us. AWS Import/Export transfers data directly onto and off of your
 * storage devices using Amazon's high-speed internal network and
 * bypassing the Internet. For large data sets, AWS Import/Export is
 * often faster than Internet transfer and more cost effective than
 * upgrading your connectivity.
 * </p>
 */
public interface AmazonImportExportAsync extends AmazonImportExport {
    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         CreateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateJobResult> createJobAsync(CreateJobRequest createJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateJobResult> createJobAsync(CreateJobRequest createJobRequest,
            AsyncHandler<CreateJobRequest, CreateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         GetShippingLabel service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetShippingLabelResult> getShippingLabelAsync(GetShippingLabelRequest getShippingLabelRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetShippingLabel service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetShippingLabelResult> getShippingLabelAsync(GetShippingLabelRequest getShippingLabelRequest,
            AsyncHandler<GetShippingLabelRequest, GetShippingLabelResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         CancelJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CancelJobResult> cancelJobAsync(CancelJobRequest cancelJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CancelJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CancelJobResult> cancelJobAsync(CancelJobRequest cancelJobRequest,
            AsyncHandler<CancelJobRequest, CancelJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         GetStatus service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStatusResult> getStatusAsync(GetStatusRequest getStatusRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStatus service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStatusResult> getStatusAsync(GetStatusRequest getStatusRequest,
            AsyncHandler<GetStatusRequest, GetStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(ListJobsRequest listJobsRequest,
            AsyncHandler<ListJobsRequest, ListJobsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateJobResult> updateJobAsync(UpdateJobRequest updateJobRequest) 
            throws AmazonServiceException, AmazonClientException;

    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateJobResult> updateJobAsync(UpdateJobRequest updateJobRequest,
            AsyncHandler<UpdateJobRequest, UpdateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;
}
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/AmazonImportExportAsyncClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.DefaultAWSCredentialsProviderChain;

import com.amazonaws.services.importexport.model.*;

/**
 * Asynchronous client for accessing AmazonImportExport.
 * All asynchronous calls made using this client are non-blocking. Callers could either
 * process the result and handle the exceptions in the worker thread by providing a callback handler
 * when making the call, or use the returned Future object to check the result of the call in the calling thread.
 * AWS Import/Export Service <p>
 * AWS Import/Export accelerates transferring large amounts of data
 * between the AWS cloud and portable storage devices that you mail to
 * us. AWS Import/Export transfers data directly onto and off of your
 * storage devices using Amazon's high-speed internal network and
 * bypassing the Internet. For large data sets, AWS Import/Export is
 * often faster than Internet transfer and more cost effective than
 * upgrading your connectivity.
 * </p>
 */
public class AmazonImportExportAsyncClient extends AmazonImportExportClient
        implements AmazonImportExportAsync {

    /**
     * Executor service for executing asynchronous requests.
     */
    private ExecutorService executorService;

    private static final int DEFAULT_THREAD_POOL_SIZE = 50;

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonImportExportAsyncClient() {
        this(new DefaultAWSCredentialsProviderChain());
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonImportExport
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonImportExportAsyncClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonImportExportAsyncClient(AWSCredentials awsCredentials) {
        this(awsCredentials, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonImportExportAsyncClient(AWSCredentials awsCredentials, ExecutorService executorService) {
        super(awsCredentials);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials,
     * executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentials
     *            The AWS credentials (access key ID and secret key) to use
     *            when authenticating with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonImportExportAsyncClient(AWSCredentials awsCredentials,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentials, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials provider.
     * Default client settings will be used, and a fixed size thread pool will be
     * created for executing the asynchronous tasks.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonImportExportAsyncClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials provider
     * and executor service.  Default client settings will be used.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonImportExportAsyncClient(AWSCredentialsProvider awsCredentialsProvider, ExecutorService executorService) {
        this(awsCredentialsProvider, new ClientConfiguration(), executorService);
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     */
    public AmazonImportExportAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, Executors.newFixedThreadPool(clientConfiguration.getMaxConnections()));
    }

    /**
     * Constructs a new asynchronous client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * provider, executor service, and client configuration options.
     *
     * <p>
     * All calls made using this new client object are non-blocking, and will immediately
     * return a Java Future object that the caller can later check to see if the service
     * call has actually completed.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration
     *            Client configuration options (ex: max retry limit, proxy
     *            settings, etc).
     * @param executorService
     *            The executor service by which all asynchronous requests will
     *            be executed.
     */
    public AmazonImportExportAsyncClient(AWSCredentialsProvider awsCredentialsProvider,
                ClientConfiguration clientConfiguration, ExecutorService executorService) {
        super(awsCredentialsProvider, clientConfiguration);
        this.executorService = executorService;
    }

    /**
     * Returns the executor service used by this async client to execute
     * requests.
     *
     * @return The executor service used by this async client to execute
     *         requests.
     */
    public ExecutorService getExecutorService() {
        return executorService;
    }

    /**
     * Shuts down the client, releasing all managed resources. This includes
     * forcibly terminating all pending asynchronous service calls. Clients who
     * wish to give pending asynchronous service calls time to complete should
     * call getExecutorService().shutdown() followed by
     * getExecutorService().awaitTermination() prior to calling this method.
     */
    @Override
    public void shutdown() {
        super.shutdown();
        executorService.shutdownNow();
    }
            
    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         CreateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateJobResult> createJobAsync(final CreateJobRequest createJobRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateJobResult>() {
            public CreateJobResult call() throws Exception {
                return createJob(createJobRequest);
        }
    });
    }

    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateJobResult> createJobAsync(
            final CreateJobRequest createJobRequest,
            final AsyncHandler<CreateJobRequest, CreateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CreateJobResult>() {
            public CreateJobResult call() throws Exception {
              CreateJobResult result;
                try {
                result = createJob(createJobRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(createJobRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         GetShippingLabel service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetShippingLabelResult> getShippingLabelAsync(final GetShippingLabelRequest getShippingLabelRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetShippingLabelResult>() {
            public GetShippingLabelResult call() throws Exception {
                return getShippingLabel(getShippingLabelRequest);
        }
    });
    }

    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetShippingLabel service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetShippingLabelResult> getShippingLabelAsync(
            final GetShippingLabelRequest getShippingLabelRequest,
            final AsyncHandler<GetShippingLabelRequest, GetShippingLabelResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetShippingLabelResult>() {
            public GetShippingLabelResult call() throws Exception {
              GetShippingLabelResult result;
                try {
                result = getShippingLabel(getShippingLabelRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getShippingLabelRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         CancelJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CancelJobResult> cancelJobAsync(final CancelJobRequest cancelJobRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CancelJobResult>() {
            public CancelJobResult call() throws Exception {
                return cancelJob(cancelJobRequest);
        }
    });
    }

    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CancelJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CancelJobResult> cancelJobAsync(
            final CancelJobRequest cancelJobRequest,
            final AsyncHandler<CancelJobRequest, CancelJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<CancelJobResult>() {
            public CancelJobResult call() throws Exception {
              CancelJobResult result;
                try {
                result = cancelJob(cancelJobRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(cancelJobRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         GetStatus service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStatusResult> getStatusAsync(final GetStatusRequest getStatusRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStatusResult>() {
            public GetStatusResult call() throws Exception {
                return getStatus(getStatusRequest);
        }
    });
    }

    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         GetStatus service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<GetStatusResult> getStatusAsync(
            final GetStatusRequest getStatusRequest,
            final AsyncHandler<GetStatusRequest, GetStatusResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<GetStatusResult>() {
            public GetStatusResult call() throws Exception {
              GetStatusResult result;
                try {
                result = getStatus(getStatusRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(getStatusRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(final ListJobsRequest listJobsRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListJobsResult>() {
            public ListJobsResult call() throws Exception {
                return listJobs(listJobsRequest);
        }
    });
    }

    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the ListJobs
     *         service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListJobsResult> listJobsAsync(
            final ListJobsRequest listJobsRequest,
            final AsyncHandler<ListJobsRequest, ListJobsResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListJobsResult>() {
            public ListJobsResult call() throws Exception {
              ListJobsResult result;
                try {
                result = listJobs(listJobsRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(listJobsRequest, result);
                 return result;
        }
    });
    }
    
    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob operation on AmazonImportExport.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateJobResult> updateJobAsync(final UpdateJobRequest updateJobRequest) 
            throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateJobResult>() {
            public UpdateJobResult call() throws Exception {
                return updateJob(updateJobRequest);
        }
    });
    }

    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob operation on AmazonImportExport.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         UpdateJob service method, as returned by AmazonImportExport.
     * 
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<UpdateJobResult> updateJobAsync(
            final UpdateJobRequest updateJobRequest,
            final AsyncHandler<UpdateJobRequest, UpdateJobResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<UpdateJobResult>() {
            public UpdateJobResult call() throws Exception {
              UpdateJobResult result;
                try {
                result = updateJob(updateJobRequest);
              } catch (Exception ex) {
                  asyncHandler.onError(ex);
            throw ex;
              }
              asyncHandler.onSuccess(updateJobRequest, result);
                 return result;
        }
    });
    }
    
}
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/AmazonImportExportClient.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport;

import org.w3c.dom.*;

import java.net.*;
import java.util.*;
import java.util.Map.Entry;

import com.amazonaws.*;
import com.amazonaws.auth.*;
import com.amazonaws.handlers.*;
import com.amazonaws.http.*;
import com.amazonaws.internal.*;
import com.amazonaws.metrics.*;
import com.amazonaws.regions.*;
import com.amazonaws.transform.*;
import com.amazonaws.util.*;
import com.amazonaws.util.AWSRequestMetrics.Field;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.services.importexport.model.transform.*;

/**
 * Client for accessing AmazonImportExport.  All service calls made
 * using this client are blocking, and will not return until the service call
 * completes.
 * <p>
 * AWS Import/Export Service <p>
 * AWS Import/Export accelerates transferring large amounts of data
 * between the AWS cloud and portable storage devices that you mail to
 * us. AWS Import/Export transfers data directly onto and off of your
 * storage devices using Amazon's high-speed internal network and
 * bypassing the Internet. For large data sets, AWS Import/Export is
 * often faster than Internet transfer and more cost effective than
 * upgrading your connectivity.
 * </p>
 */
public class AmazonImportExportClient extends AmazonWebServiceClient implements AmazonImportExport {

    /** Provider for AWS credentials. */
    private AWSCredentialsProvider awsCredentialsProvider;

    /**
     * List of exception unmarshallers for all AmazonImportExport exceptions.
     */
    protected final List<Unmarshaller<AmazonServiceException, Node>> exceptionUnmarshallers
            = new ArrayList<Unmarshaller<AmazonServiceException, Node>>();

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonImportExportClient() {
        this(new DefaultAWSCredentialsProviderChain(), new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport.  A credentials provider chain will be used
     * that searches for credentials in this order:
     * <ul>
     *  <li> Environment Variables - AWS_ACCESS_KEY_ID and AWS_SECRET_KEY </li>
     *  <li> Java System Properties - aws.accessKeyId and aws.secretKey </li>
     *  <li> Instance profile credentials delivered through the Amazon EC2 metadata service </li>
     * </ul>
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonImportExport
     *                       (ex: proxy settings, retry counts, etc.).
     *
     * @see DefaultAWSCredentialsProviderChain
     */
    public AmazonImportExportClient(ClientConfiguration clientConfiguration) {
        this(new DefaultAWSCredentialsProviderChain(), clientConfiguration);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     */
    public AmazonImportExportClient(AWSCredentials awsCredentials) {
        this(awsCredentials, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * and client configuration options.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentials The AWS credentials (access key ID and secret key) to use
     *                       when authenticating with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonImportExport
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonImportExportClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration) {
        super(clientConfiguration);
        this.awsCredentialsProvider = new StaticCredentialsProvider(awsCredentials);
        init();
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials provider.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     */
    public AmazonImportExportClient(AWSCredentialsProvider awsCredentialsProvider) {
        this(awsCredentialsProvider, new ClientConfiguration());
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * provider and client configuration options.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonImportExport
     *                       (ex: proxy settings, retry counts, etc.).
     */
    public AmazonImportExportClient(AWSCredentialsProvider awsCredentialsProvider, ClientConfiguration clientConfiguration) {
        this(awsCredentialsProvider, clientConfiguration, null);
    }

    /**
     * Constructs a new client to invoke service methods on
     * AmazonImportExport using the specified AWS account credentials
     * provider, client configuration options, and request metric collector.
     *
     * <p>
     * All service calls made using this new client object are blocking, and will not
     * return until the service call completes.
     *
     * @param awsCredentialsProvider
     *            The AWS credentials provider which will provide credentials
     *            to authenticate requests with AWS services.
     * @param clientConfiguration The client configuration options controlling how this
     *                       client connects to AmazonImportExport
     *                       (ex: proxy settings, retry counts, etc.).
     * @param requestMetricCollector optional request metric collector
     */
    public AmazonImportExportClient(AWSCredentialsProvider awsCredentialsProvider,
            ClientConfiguration clientConfiguration,
            RequestMetricCollector requestMetricCollector) {
        super(clientConfiguration, requestMetricCollector);
        this.awsCredentialsProvider = awsCredentialsProvider;
        init();
    }

    private void init() {
        exceptionUnmarshallers.add(new BucketPermissionExceptionUnmarshaller());
        exceptionUnmarshallers.add(new UnableToUpdateJobIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidFileSystemExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MissingCustomsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new ExpiredJobIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidManifestFieldExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MissingManifestFieldExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MalformedManifestExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidAddressExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidParameterExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MultipleRegionsExceptionUnmarshaller());
        exceptionUnmarshallers.add(new UnableToCancelJobIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new CanceledJobIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidJobIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidVersionExceptionUnmarshaller());
        exceptionUnmarshallers.add(new NoSuchBucketExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidAccessKeyIdExceptionUnmarshaller());
        exceptionUnmarshallers.add(new CreateJobQuotaExceededExceptionUnmarshaller());
        exceptionUnmarshallers.add(new MissingParameterExceptionUnmarshaller());
        exceptionUnmarshallers.add(new InvalidCustomsExceptionUnmarshaller());
        
        exceptionUnmarshallers.add(new StandardErrorUnmarshaller());
        
        // calling this.setEndPoint(...) will also modify the signer accordingly
        this.setEndpoint("importexport.amazonaws.com");
        
        HandlerChainFactory chainFactory = new HandlerChainFactory();
        requestHandler2s.addAll(chainFactory.newRequestHandlerChain(
                "/com/amazonaws/services/importexport/request.handlers"));
        requestHandler2s.addAll(chainFactory.newRequestHandler2Chain(
                "/com/amazonaws/services/importexport/request.handler2s"));
    }

    /**
     * <p>
     * This operation initiates the process of scheduling an upload or
     * download of your data. You include in the request a manifest that
     * describes the data transfer specifics. The response to the request
     * includes a job ID, which you can use in other operations, a signature
     * that you use to identify your storage device, and the address where
     * you should ship your storage device.
     * </p>
     *
     * @param createJobRequest Container for the necessary parameters to
     *           execute the CreateJob service method on AmazonImportExport.
     * 
     * @return The response from the CreateJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws MalformedManifestException
     * @throws InvalidAddressException
     * @throws BucketPermissionException
     * @throws InvalidParameterException
     * @throws MultipleRegionsException
     * @throws InvalidVersionException
     * @throws MissingParameterException
     * @throws InvalidFileSystemException
     * @throws MissingCustomsException
     * @throws NoSuchBucketException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidManifestFieldException
     * @throws InvalidCustomsException
     * @throws MissingManifestFieldException
     * @throws CreateJobQuotaExceededException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CreateJobResult createJob(CreateJobRequest createJobRequest) {
        ExecutionContext executionContext = createExecutionContext(createJobRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CreateJobRequest> request = null;
        Response<CreateJobResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CreateJobRequestMarshaller().marshall(super.beforeMarshalling(createJobRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CreateJobResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * This operation generates a pre-paid UPS shipping label that you will
     * use to ship your device to AWS for processing.
     * </p>
     *
     * @param getShippingLabelRequest Container for the necessary parameters
     *           to execute the GetShippingLabel service method on AmazonImportExport.
     * 
     * @return The response from the GetShippingLabel service method, as
     *         returned by AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidAddressException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetShippingLabelResult getShippingLabel(GetShippingLabelRequest getShippingLabelRequest) {
        ExecutionContext executionContext = createExecutionContext(getShippingLabelRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetShippingLabelRequest> request = null;
        Response<GetShippingLabelResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetShippingLabelRequestMarshaller().marshall(super.beforeMarshalling(getShippingLabelRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetShippingLabelResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * This operation cancels a specified job. Only the job owner can cancel
     * it. The operation fails if the job has already started or is complete.
     * </p>
     *
     * @param cancelJobRequest Container for the necessary parameters to
     *           execute the CancelJob service method on AmazonImportExport.
     * 
     * @return The response from the CancelJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     * @throws UnableToCancelJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public CancelJobResult cancelJob(CancelJobRequest cancelJobRequest) {
        ExecutionContext executionContext = createExecutionContext(cancelJobRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<CancelJobRequest> request = null;
        Response<CancelJobResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new CancelJobRequestMarshaller().marshall(super.beforeMarshalling(cancelJobRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new CancelJobResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * This operation returns information about a job, including where the
     * job is in the processing pipeline, the status of the results, and the
     * signature value associated with the job. You can only return
     * information about jobs you own.
     * </p>
     *
     * @param getStatusRequest Container for the necessary parameters to
     *           execute the GetStatus service method on AmazonImportExport.
     * 
     * @return The response from the GetStatus service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws CanceledJobIdException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public GetStatusResult getStatus(GetStatusRequest getStatusRequest) {
        ExecutionContext executionContext = createExecutionContext(getStatusRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<GetStatusRequest> request = null;
        Response<GetStatusResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new GetStatusRequestMarshaller().marshall(super.beforeMarshalling(getStatusRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new GetStatusResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     *
     * @param listJobsRequest Container for the necessary parameters to
     *           execute the ListJobs service method on AmazonImportExport.
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs(ListJobsRequest listJobsRequest) {
        ExecutionContext executionContext = createExecutionContext(listJobsRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<ListJobsRequest> request = null;
        Response<ListJobsResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new ListJobsRequestMarshaller().marshall(super.beforeMarshalling(listJobsRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new ListJobsResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * You use this operation to change the parameters specified in the
     * original manifest file by supplying a new manifest file. The manifest
     * file attached to this request replaces the original manifest file. You
     * can only use the operation after a CreateJob request but before the
     * data transfer starts and you can only use it on jobs you own.
     * </p>
     *
     * @param updateJobRequest Container for the necessary parameters to
     *           execute the UpdateJob service method on AmazonImportExport.
     * 
     * @return The response from the UpdateJob service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws MalformedManifestException
     * @throws BucketPermissionException
     * @throws InvalidAddressException
     * @throws InvalidParameterException
     * @throws UnableToUpdateJobIdException
     * @throws MultipleRegionsException
     * @throws InvalidVersionException
     * @throws MissingParameterException
     * @throws InvalidFileSystemException
     * @throws CanceledJobIdException
     * @throws MissingCustomsException
     * @throws NoSuchBucketException
     * @throws ExpiredJobIdException
     * @throws InvalidAccessKeyIdException
     * @throws InvalidCustomsException
     * @throws InvalidManifestFieldException
     * @throws MissingManifestFieldException
     * @throws InvalidJobIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public UpdateJobResult updateJob(UpdateJobRequest updateJobRequest) {
        ExecutionContext executionContext = createExecutionContext(updateJobRequest);
        AWSRequestMetrics awsRequestMetrics = executionContext.getAwsRequestMetrics();
        awsRequestMetrics.startEvent(Field.ClientExecuteTime);
        Request<UpdateJobRequest> request = null;
        Response<UpdateJobResult> response = null;
        
        try {
            awsRequestMetrics.startEvent(Field.RequestMarshallTime);
            try {
                request = new UpdateJobRequestMarshaller().marshall(super.beforeMarshalling(updateJobRequest));
                // Binds the request metrics to the current request.
                request.setAWSRequestMetrics(awsRequestMetrics);
            } finally {
                awsRequestMetrics.endEvent(Field.RequestMarshallTime);
            }

            response = invoke(request, new UpdateJobResultStaxUnmarshaller(), executionContext);
            return response.getAwsResponse();

        } finally {
            
            endClientExecution(awsRequestMetrics, request, response);
        }
    }
    
    /**
     * <p>
     * This operation returns the jobs associated with the requester. AWS
     * Import/Export lists the jobs in reverse chronological order based on
     * the date of creation. For example if Job Test1 was created 2009Dec30
     * and Test2 was created 2010Feb05, the ListJobs operation would return
     * Test2 followed by Test1.
     * </p>
     * 
     * @return The response from the ListJobs service method, as returned by
     *         AmazonImportExport.
     * 
     * @throws InvalidVersionException
     * @throws InvalidParameterException
     * @throws InvalidAccessKeyIdException
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonImportExport indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public ListJobsResult listJobs() throws AmazonServiceException, AmazonClientException {
        return listJobs(new ListJobsRequest());
    }

    /**
     * Returns additional metadata for a previously executed successful, request, typically used for
     * debugging issues where a service isn't acting as expected.  This data isn't considered part
     * of the result data returned by an operation, so it's available through this separate,
     * diagnostic interface.
     * <p>
     * Response metadata is only cached for a limited period of time, so if you need to access
     * this extra diagnostic information for an executed request, you should use this method
     * to retrieve it as soon as possible after executing the request.
     *
     * @param request
     *            The originally executed request
     *
     * @return The response metadata for the specified request, or null if none
     *         is available.
     */
    public ResponseMetadata getCachedResponseMetadata(AmazonWebServiceRequest request) {
        return client.getResponseMetadataForRequest(request);
    }

    private <X, Y extends AmazonWebServiceRequest> Response<X> invoke(Request<Y> request,
            Unmarshaller<X, StaxUnmarshallerContext> unmarshaller,
            ExecutionContext executionContext)
    {
        request.setEndpoint(endpoint);
        request.setTimeOffset(timeOffset);
        AmazonWebServiceRequest originalRequest = request.getOriginalRequest();

        AWSCredentials credentials = awsCredentialsProvider.getCredentials();
        if (originalRequest.getRequestCredentials() != null) {
            credentials = originalRequest.getRequestCredentials();
        }

        executionContext.setCredentials(credentials);
        
        StaxResponseHandler<X> responseHandler = new StaxResponseHandler<X>(unmarshaller);
        DefaultErrorResponseHandler errorResponseHandler = new DefaultErrorResponseHandler(exceptionUnmarshallers);
        return client.execute(request, responseHandler, errorResponseHandler, executionContext);
    }
}
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/Artifact.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * A discrete item that contains the description and URL of an artifact
 * (such as a PDF).
 * </p>
 */
public class Artifact implements Serializable, Cloneable {

    /**
     * The associated description for this object.
     */
    private String description;

    /**
     * The URL for a given Artifact.
     */
    private String uRL;

    /**
     * The associated description for this object.
     *
     * @return The associated description for this object.
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * The associated description for this object.
     *
     * @param description The associated description for this object.
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    /**
     * The associated description for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param description The associated description for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Artifact withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * The URL for a given Artifact.
     *
     * @return The URL for a given Artifact.
     */
    public String getURL() {
        return uRL;
    }
    
    /**
     * The URL for a given Artifact.
     *
     * @param uRL The URL for a given Artifact.
     */
    public void setURL(String uRL) {
        this.uRL = uRL;
    }
    
    /**
     * The URL for a given Artifact.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param uRL The URL for a given Artifact.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Artifact withURL(String uRL) {
        this.uRL = uRL;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getDescription() != null) sb.append("Description: " + getDescription() + ",");
        if (getURL() != null) sb.append("URL: " + getURL() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getDescription() == null) ? 0 : getDescription().hashCode()); 
        hashCode = prime * hashCode + ((getURL() == null) ? 0 : getURL().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof Artifact == false) return false;
        Artifact other = (Artifact)obj;
        
        if (other.getDescription() == null ^ this.getDescription() == null) return false;
        if (other.getDescription() != null && other.getDescription().equals(this.getDescription()) == false) return false; 
        if (other.getURL() == null ^ this.getURL() == null) return false;
        if (other.getURL() != null && other.getURL().equals(this.getURL()) == false) return false; 
        return true;
    }
    
    @Override
    public Artifact clone() {
        try {
            return (Artifact) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/BucketPermissionException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The account specified does not have the appropriate bucket
 * permissions.
 * </p>
 */        
public class BucketPermissionException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new BucketPermissionException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public BucketPermissionException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CancelJobRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#cancelJob(CancelJobRequest) CancelJob operation}.
 * <p>
 * This operation cancels a specified job. Only the job owner can cancel
 * it. The operation fails if the job has already started or is complete.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#cancelJob(CancelJobRequest)
 */
public class CancelJobRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * Specifies the version of the client tool.
     */
    private String aPIVersion;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CancelJobRequest withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * Specifies the version of the client tool.
     *
     * @return Specifies the version of the client tool.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     *
     * @param aPIVersion Specifies the version of the client tool.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion Specifies the version of the client tool.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CancelJobRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CancelJobRequest == false) return false;
        CancelJobRequest other = (CancelJobRequest)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public CancelJobRequest clone() {
        
            return (CancelJobRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CancelJobResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Output structure for the CancelJob operation.
 * </p>
 */
public class CancelJobResult implements Serializable, Cloneable {

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     */
    private Boolean success;

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @return Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public Boolean isSuccess() {
        return success;
    }
    
    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @param success Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public void setSuccess(Boolean success) {
        this.success = success;
    }
    
    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param success Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CancelJobResult withSuccess(Boolean success) {
        this.success = success;
        return this;
    }

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @return Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public Boolean getSuccess() {
        return success;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (isSuccess() != null) sb.append("Success: " + isSuccess() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((isSuccess() == null) ? 0 : isSuccess().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CancelJobResult == false) return false;
        CancelJobResult other = (CancelJobResult)obj;
        
        if (other.isSuccess() == null ^ this.isSuccess() == null) return false;
        if (other.isSuccess() != null && other.isSuccess().equals(this.isSuccess()) == false) return false; 
        return true;
    }
    
    @Override
    public CancelJobResult clone() {
        try {
            return (CancelJobResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CanceledJobIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The specified job ID has been canceled and is no longer valid.
 * </p>
 */        
public class CanceledJobIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new CanceledJobIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public CanceledJobIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CreateJobQuotaExceededException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Each account can create only a certain number of jobs per day. If
 * you need to create more than this, please contact
 * awsimportexport@amazon.com to explain your particular use case.
 * </p>
 */        
public class CreateJobQuotaExceededException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new CreateJobQuotaExceededException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public CreateJobQuotaExceededException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CreateJobRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#createJob(CreateJobRequest) CreateJob operation}.
 * <p>
 * This operation initiates the process of scheduling an upload or
 * download of your data. You include in the request a manifest that
 * describes the data transfer specifics. The response to the request
 * includes a job ID, which you can use in other operations, a signature
 * that you use to identify your storage device, and the address where
 * you should ship your storage device.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#createJob(CreateJobRequest)
 */
public class CreateJobRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     */
    private String jobType;

    /**
     * The UTF-8 encoded text of the manifest file.
     */
    private String manifest;

    /**
     * For internal use only.
     */
    private String manifestAddendum;

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     */
    private Boolean validateOnly;

    /**
     * Specifies the version of the client tool.
     */
    private String aPIVersion;

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @return Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public String getJobType() {
        return jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(String jobType) {
        this.jobType = jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public CreateJobRequest withJobType(String jobType) {
        this.jobType = jobType;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(JobType jobType) {
        this.jobType = jobType.toString();
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public CreateJobRequest withJobType(JobType jobType) {
        this.jobType = jobType.toString();
        return this;
    }

    /**
     * The UTF-8 encoded text of the manifest file.
     *
     * @return The UTF-8 encoded text of the manifest file.
     */
    public String getManifest() {
        return manifest;
    }
    
    /**
     * The UTF-8 encoded text of the manifest file.
     *
     * @param manifest The UTF-8 encoded text of the manifest file.
     */
    public void setManifest(String manifest) {
        this.manifest = manifest;
    }
    
    /**
     * The UTF-8 encoded text of the manifest file.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param manifest The UTF-8 encoded text of the manifest file.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobRequest withManifest(String manifest) {
        this.manifest = manifest;
        return this;
    }

    /**
     * For internal use only.
     *
     * @return For internal use only.
     */
    public String getManifestAddendum() {
        return manifestAddendum;
    }
    
    /**
     * For internal use only.
     *
     * @param manifestAddendum For internal use only.
     */
    public void setManifestAddendum(String manifestAddendum) {
        this.manifestAddendum = manifestAddendum;
    }
    
    /**
     * For internal use only.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param manifestAddendum For internal use only.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobRequest withManifestAddendum(String manifestAddendum) {
        this.manifestAddendum = manifestAddendum;
        return this;
    }

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @return Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public Boolean isValidateOnly() {
        return validateOnly;
    }
    
    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @param validateOnly Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public void setValidateOnly(Boolean validateOnly) {
        this.validateOnly = validateOnly;
    }
    
    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param validateOnly Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobRequest withValidateOnly(Boolean validateOnly) {
        this.validateOnly = validateOnly;
        return this;
    }

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @return Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public Boolean getValidateOnly() {
        return validateOnly;
    }

    /**
     * Specifies the version of the client tool.
     *
     * @return Specifies the version of the client tool.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     *
     * @param aPIVersion Specifies the version of the client tool.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion Specifies the version of the client tool.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobType() != null) sb.append("JobType: " + getJobType() + ",");
        if (getManifest() != null) sb.append("Manifest: " + getManifest() + ",");
        if (getManifestAddendum() != null) sb.append("ManifestAddendum: " + getManifestAddendum() + ",");
        if (isValidateOnly() != null) sb.append("ValidateOnly: " + isValidateOnly() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobType() == null) ? 0 : getJobType().hashCode()); 
        hashCode = prime * hashCode + ((getManifest() == null) ? 0 : getManifest().hashCode()); 
        hashCode = prime * hashCode + ((getManifestAddendum() == null) ? 0 : getManifestAddendum().hashCode()); 
        hashCode = prime * hashCode + ((isValidateOnly() == null) ? 0 : isValidateOnly().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateJobRequest == false) return false;
        CreateJobRequest other = (CreateJobRequest)obj;
        
        if (other.getJobType() == null ^ this.getJobType() == null) return false;
        if (other.getJobType() != null && other.getJobType().equals(this.getJobType()) == false) return false; 
        if (other.getManifest() == null ^ this.getManifest() == null) return false;
        if (other.getManifest() != null && other.getManifest().equals(this.getManifest()) == false) return false; 
        if (other.getManifestAddendum() == null ^ this.getManifestAddendum() == null) return false;
        if (other.getManifestAddendum() != null && other.getManifestAddendum().equals(this.getManifestAddendum()) == false) return false; 
        if (other.isValidateOnly() == null ^ this.isValidateOnly() == null) return false;
        if (other.isValidateOnly() != null && other.isValidateOnly().equals(this.isValidateOnly()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateJobRequest clone() {
        
            return (CreateJobRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/CreateJobResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Output structure for the CreateJob operation.
 * </p>
 */
public class CreateJobResult implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     */
    private String jobType;

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     */
    private String signature;

    /**
     * The actual text of the SIGNATURE file to be written to disk.
     */
    private String signatureFileContents;

    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     */
    private String warningMessage;

    /**
     * A collection of artifacts.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactList;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @return Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public String getJobType() {
        return jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(String jobType) {
        this.jobType = jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public CreateJobResult withJobType(String jobType) {
        this.jobType = jobType;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(JobType jobType) {
        this.jobType = jobType.toString();
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public CreateJobResult withJobType(JobType jobType) {
        this.jobType = jobType.toString();
        return this;
    }

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @return An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public String getSignature() {
        return signature;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @param signature An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public void setSignature(String signature) {
        this.signature = signature;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param signature An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withSignature(String signature) {
        this.signature = signature;
        return this;
    }

    /**
     * The actual text of the SIGNATURE file to be written to disk.
     *
     * @return The actual text of the SIGNATURE file to be written to disk.
     */
    public String getSignatureFileContents() {
        return signatureFileContents;
    }
    
    /**
     * The actual text of the SIGNATURE file to be written to disk.
     *
     * @param signatureFileContents The actual text of the SIGNATURE file to be written to disk.
     */
    public void setSignatureFileContents(String signatureFileContents) {
        this.signatureFileContents = signatureFileContents;
    }
    
    /**
     * The actual text of the SIGNATURE file to be written to disk.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param signatureFileContents The actual text of the SIGNATURE file to be written to disk.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withSignatureFileContents(String signatureFileContents) {
        this.signatureFileContents = signatureFileContents;
        return this;
    }

    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     *
     * @return An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     */
    public String getWarningMessage() {
        return warningMessage;
    }
    
    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     *
     * @param warningMessage An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     */
    public void setWarningMessage(String warningMessage) {
        this.warningMessage = warningMessage;
    }
    
    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param warningMessage An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withWarningMessage(String warningMessage) {
        this.warningMessage = warningMessage;
        return this;
    }

    /**
     * A collection of artifacts.
     *
     * @return A collection of artifacts.
     */
    public java.util.List<Artifact> getArtifactList() {
        if (artifactList == null) {
              artifactList = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>();
              artifactList.setAutoConstruct(true);
        }
        return artifactList;
    }
    
    /**
     * A collection of artifacts.
     *
     * @param artifactList A collection of artifacts.
     */
    public void setArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
        artifactListCopy.addAll(artifactList);
        this.artifactList = artifactListCopy;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setArtifactList(java.util.Collection)} or {@link
     * #withArtifactList(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withArtifactList(Artifact... artifactList) {
        if (getArtifactList() == null) setArtifactList(new java.util.ArrayList<Artifact>(artifactList.length));
        for (Artifact value : artifactList) {
            getArtifactList().add(value);
        }
        return this;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateJobResult withArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
            artifactListCopy.addAll(artifactList);
            this.artifactList = artifactListCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getJobType() != null) sb.append("JobType: " + getJobType() + ",");
        if (getSignature() != null) sb.append("Signature: " + getSignature() + ",");
        if (getSignatureFileContents() != null) sb.append("SignatureFileContents: " + getSignatureFileContents() + ",");
        if (getWarningMessage() != null) sb.append("WarningMessage: " + getWarningMessage() + ",");
        if (getArtifactList() != null) sb.append("ArtifactList: " + getArtifactList() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getJobType() == null) ? 0 : getJobType().hashCode()); 
        hashCode = prime * hashCode + ((getSignature() == null) ? 0 : getSignature().hashCode()); 
        hashCode = prime * hashCode + ((getSignatureFileContents() == null) ? 0 : getSignatureFileContents().hashCode()); 
        hashCode = prime * hashCode + ((getWarningMessage() == null) ? 0 : getWarningMessage().hashCode()); 
        hashCode = prime * hashCode + ((getArtifactList() == null) ? 0 : getArtifactList().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateJobResult == false) return false;
        CreateJobResult other = (CreateJobResult)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getJobType() == null ^ this.getJobType() == null) return false;
        if (other.getJobType() != null && other.getJobType().equals(this.getJobType()) == false) return false; 
        if (other.getSignature() == null ^ this.getSignature() == null) return false;
        if (other.getSignature() != null && other.getSignature().equals(this.getSignature()) == false) return false; 
        if (other.getSignatureFileContents() == null ^ this.getSignatureFileContents() == null) return false;
        if (other.getSignatureFileContents() != null && other.getSignatureFileContents().equals(this.getSignatureFileContents()) == false) return false; 
        if (other.getWarningMessage() == null ^ this.getWarningMessage() == null) return false;
        if (other.getWarningMessage() != null && other.getWarningMessage().equals(this.getWarningMessage()) == false) return false; 
        if (other.getArtifactList() == null ^ this.getArtifactList() == null) return false;
        if (other.getArtifactList() != null && other.getArtifactList().equals(this.getArtifactList()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateJobResult clone() {
        try {
            return (CreateJobResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/ExpiredJobIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Indicates that the specified job has expired out of the system.
 * </p>
 */        
public class ExpiredJobIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new ExpiredJobIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public ExpiredJobIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/GetShippingLabelRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#getShippingLabel(GetShippingLabelRequest) GetShippingLabel operation}.
 * <p>
 * This operation generates a pre-paid UPS shipping label that you will
 * use to ship your device to AWS for processing.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#getShippingLabel(GetShippingLabelRequest)
 */
public class GetShippingLabelRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    private com.amazonaws.internal.ListWithAutoConstructFlag<String> jobIds;

    private String name;

    private String company;

    private String phoneNumber;

    private String country;

    private String stateOrProvince;

    private String city;

    private String postalCode;

    private String street1;

    private String street2;

    private String street3;

    private String aPIVersion;

    /**
     * Returns the value of the JobIds property for this object.
     *
     * @return The value of the JobIds property for this object.
     */
    public java.util.List<String> getJobIds() {
        if (jobIds == null) {
              jobIds = new com.amazonaws.internal.ListWithAutoConstructFlag<String>();
              jobIds.setAutoConstruct(true);
        }
        return jobIds;
    }
    
    /**
     * Sets the value of the JobIds property for this object.
     *
     * @param jobIds The new value for the JobIds property for this object.
     */
    public void setJobIds(java.util.Collection<String> jobIds) {
        if (jobIds == null) {
            this.jobIds = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<String> jobIdsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(jobIds.size());
        jobIdsCopy.addAll(jobIds);
        this.jobIds = jobIdsCopy;
    }
    
    /**
     * Sets the value of the JobIds property for this object.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setJobIds(java.util.Collection)} or {@link
     * #withJobIds(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobIds The new value for the JobIds property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withJobIds(String... jobIds) {
        if (getJobIds() == null) setJobIds(new java.util.ArrayList<String>(jobIds.length));
        for (String value : jobIds) {
            getJobIds().add(value);
        }
        return this;
    }
    
    /**
     * Sets the value of the JobIds property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobIds The new value for the JobIds property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withJobIds(java.util.Collection<String> jobIds) {
        if (jobIds == null) {
            this.jobIds = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<String> jobIdsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<String>(jobIds.size());
            jobIdsCopy.addAll(jobIds);
            this.jobIds = jobIdsCopy;
        }

        return this;
    }

    /**
     * Returns the value of the Name property for this object.
     *
     * @return The value of the Name property for this object.
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the value of the Name property for this object.
     *
     * @param name The new value for the Name property for this object.
     */
    public void setName(String name) {
        this.name = name;
    }
    
    /**
     * Sets the value of the Name property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param name The new value for the Name property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Returns the value of the Company property for this object.
     *
     * @return The value of the Company property for this object.
     */
    public String getCompany() {
        return company;
    }
    
    /**
     * Sets the value of the Company property for this object.
     *
     * @param company The new value for the Company property for this object.
     */
    public void setCompany(String company) {
        this.company = company;
    }
    
    /**
     * Sets the value of the Company property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param company The new value for the Company property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withCompany(String company) {
        this.company = company;
        return this;
    }

    /**
     * Returns the value of the PhoneNumber property for this object.
     *
     * @return The value of the PhoneNumber property for this object.
     */
    public String getPhoneNumber() {
        return phoneNumber;
    }
    
    /**
     * Sets the value of the PhoneNumber property for this object.
     *
     * @param phoneNumber The new value for the PhoneNumber property for this object.
     */
    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }
    
    /**
     * Sets the value of the PhoneNumber property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param phoneNumber The new value for the PhoneNumber property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
        return this;
    }

    /**
     * Returns the value of the Country property for this object.
     *
     * @return The value of the Country property for this object.
     */
    public String getCountry() {
        return country;
    }
    
    /**
     * Sets the value of the Country property for this object.
     *
     * @param country The new value for the Country property for this object.
     */
    public void setCountry(String country) {
        this.country = country;
    }
    
    /**
     * Sets the value of the Country property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param country The new value for the Country property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withCountry(String country) {
        this.country = country;
        return this;
    }

    /**
     * Returns the value of the StateOrProvince property for this object.
     *
     * @return The value of the StateOrProvince property for this object.
     */
    public String getStateOrProvince() {
        return stateOrProvince;
    }
    
    /**
     * Sets the value of the StateOrProvince property for this object.
     *
     * @param stateOrProvince The new value for the StateOrProvince property for this object.
     */
    public void setStateOrProvince(String stateOrProvince) {
        this.stateOrProvince = stateOrProvince;
    }
    
    /**
     * Sets the value of the StateOrProvince property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param stateOrProvince The new value for the StateOrProvince property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withStateOrProvince(String stateOrProvince) {
        this.stateOrProvince = stateOrProvince;
        return this;
    }

    /**
     * Returns the value of the City property for this object.
     *
     * @return The value of the City property for this object.
     */
    public String getCity() {
        return city;
    }
    
    /**
     * Sets the value of the City property for this object.
     *
     * @param city The new value for the City property for this object.
     */
    public void setCity(String city) {
        this.city = city;
    }
    
    /**
     * Sets the value of the City property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param city The new value for the City property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withCity(String city) {
        this.city = city;
        return this;
    }

    /**
     * Returns the value of the PostalCode property for this object.
     *
     * @return The value of the PostalCode property for this object.
     */
    public String getPostalCode() {
        return postalCode;
    }
    
    /**
     * Sets the value of the PostalCode property for this object.
     *
     * @param postalCode The new value for the PostalCode property for this object.
     */
    public void setPostalCode(String postalCode) {
        this.postalCode = postalCode;
    }
    
    /**
     * Sets the value of the PostalCode property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param postalCode The new value for the PostalCode property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withPostalCode(String postalCode) {
        this.postalCode = postalCode;
        return this;
    }

    /**
     * Returns the value of the Street1 property for this object.
     *
     * @return The value of the Street1 property for this object.
     */
    public String getStreet1() {
        return street1;
    }
    
    /**
     * Sets the value of the Street1 property for this object.
     *
     * @param street1 The new value for the Street1 property for this object.
     */
    public void setStreet1(String street1) {
        this.street1 = street1;
    }
    
    /**
     * Sets the value of the Street1 property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param street1 The new value for the Street1 property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withStreet1(String street1) {
        this.street1 = street1;
        return this;
    }

    /**
     * Returns the value of the Street2 property for this object.
     *
     * @return The value of the Street2 property for this object.
     */
    public String getStreet2() {
        return street2;
    }
    
    /**
     * Sets the value of the Street2 property for this object.
     *
     * @param street2 The new value for the Street2 property for this object.
     */
    public void setStreet2(String street2) {
        this.street2 = street2;
    }
    
    /**
     * Sets the value of the Street2 property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param street2 The new value for the Street2 property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withStreet2(String street2) {
        this.street2 = street2;
        return this;
    }

    /**
     * Returns the value of the Street3 property for this object.
     *
     * @return The value of the Street3 property for this object.
     */
    public String getStreet3() {
        return street3;
    }
    
    /**
     * Sets the value of the Street3 property for this object.
     *
     * @param street3 The new value for the Street3 property for this object.
     */
    public void setStreet3(String street3) {
        this.street3 = street3;
    }
    
    /**
     * Sets the value of the Street3 property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param street3 The new value for the Street3 property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withStreet3(String street3) {
        this.street3 = street3;
        return this;
    }

    /**
     * Returns the value of the APIVersion property for this object.
     *
     * @return The value of the APIVersion property for this object.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Sets the value of the APIVersion property for this object.
     *
     * @param aPIVersion The new value for the APIVersion property for this object.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Sets the value of the APIVersion property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion The new value for the APIVersion property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobIds() != null) sb.append("JobIds: " + getJobIds() + ",");
        if (getName() != null) sb.append("Name: " + getName() + ",");
        if (getCompany() != null) sb.append("Company: " + getCompany() + ",");
        if (getPhoneNumber() != null) sb.append("PhoneNumber: " + getPhoneNumber() + ",");
        if (getCountry() != null) sb.append("Country: " + getCountry() + ",");
        if (getStateOrProvince() != null) sb.append("StateOrProvince: " + getStateOrProvince() + ",");
        if (getCity() != null) sb.append("City: " + getCity() + ",");
        if (getPostalCode() != null) sb.append("PostalCode: " + getPostalCode() + ",");
        if (getStreet1() != null) sb.append("Street1: " + getStreet1() + ",");
        if (getStreet2() != null) sb.append("Street2: " + getStreet2() + ",");
        if (getStreet3() != null) sb.append("Street3: " + getStreet3() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobIds() == null) ? 0 : getJobIds().hashCode()); 
        hashCode = prime * hashCode + ((getName() == null) ? 0 : getName().hashCode()); 
        hashCode = prime * hashCode + ((getCompany() == null) ? 0 : getCompany().hashCode()); 
        hashCode = prime * hashCode + ((getPhoneNumber() == null) ? 0 : getPhoneNumber().hashCode()); 
        hashCode = prime * hashCode + ((getCountry() == null) ? 0 : getCountry().hashCode()); 
        hashCode = prime * hashCode + ((getStateOrProvince() == null) ? 0 : getStateOrProvince().hashCode()); 
        hashCode = prime * hashCode + ((getCity() == null) ? 0 : getCity().hashCode()); 
        hashCode = prime * hashCode + ((getPostalCode() == null) ? 0 : getPostalCode().hashCode()); 
        hashCode = prime * hashCode + ((getStreet1() == null) ? 0 : getStreet1().hashCode()); 
        hashCode = prime * hashCode + ((getStreet2() == null) ? 0 : getStreet2().hashCode()); 
        hashCode = prime * hashCode + ((getStreet3() == null) ? 0 : getStreet3().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetShippingLabelRequest == false) return false;
        GetShippingLabelRequest other = (GetShippingLabelRequest)obj;
        
        if (other.getJobIds() == null ^ this.getJobIds() == null) return false;
        if (other.getJobIds() != null && other.getJobIds().equals(this.getJobIds()) == false) return false; 
        if (other.getName() == null ^ this.getName() == null) return false;
        if (other.getName() != null && other.getName().equals(this.getName()) == false) return false; 
        if (other.getCompany() == null ^ this.getCompany() == null) return false;
        if (other.getCompany() != null && other.getCompany().equals(this.getCompany()) == false) return false; 
        if (other.getPhoneNumber() == null ^ this.getPhoneNumber() == null) return false;
        if (other.getPhoneNumber() != null && other.getPhoneNumber().equals(this.getPhoneNumber()) == false) return false; 
        if (other.getCountry() == null ^ this.getCountry() == null) return false;
        if (other.getCountry() != null && other.getCountry().equals(this.getCountry()) == false) return false; 
        if (other.getStateOrProvince() == null ^ this.getStateOrProvince() == null) return false;
        if (other.getStateOrProvince() != null && other.getStateOrProvince().equals(this.getStateOrProvince()) == false) return false; 
        if (other.getCity() == null ^ this.getCity() == null) return false;
        if (other.getCity() != null && other.getCity().equals(this.getCity()) == false) return false; 
        if (other.getPostalCode() == null ^ this.getPostalCode() == null) return false;
        if (other.getPostalCode() != null && other.getPostalCode().equals(this.getPostalCode()) == false) return false; 
        if (other.getStreet1() == null ^ this.getStreet1() == null) return false;
        if (other.getStreet1() != null && other.getStreet1().equals(this.getStreet1()) == false) return false; 
        if (other.getStreet2() == null ^ this.getStreet2() == null) return false;
        if (other.getStreet2() != null && other.getStreet2().equals(this.getStreet2()) == false) return false; 
        if (other.getStreet3() == null ^ this.getStreet3() == null) return false;
        if (other.getStreet3() != null && other.getStreet3().equals(this.getStreet3()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public GetShippingLabelRequest clone() {
        
            return (GetShippingLabelRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/GetShippingLabelResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * Get Shipping Label Result
 */
public class GetShippingLabelResult implements Serializable, Cloneable {

    private String shippingLabelURL;

    private String warning;

    /**
     * Returns the value of the ShippingLabelURL property for this object.
     *
     * @return The value of the ShippingLabelURL property for this object.
     */
    public String getShippingLabelURL() {
        return shippingLabelURL;
    }
    
    /**
     * Sets the value of the ShippingLabelURL property for this object.
     *
     * @param shippingLabelURL The new value for the ShippingLabelURL property for this object.
     */
    public void setShippingLabelURL(String shippingLabelURL) {
        this.shippingLabelURL = shippingLabelURL;
    }
    
    /**
     * Sets the value of the ShippingLabelURL property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param shippingLabelURL The new value for the ShippingLabelURL property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelResult withShippingLabelURL(String shippingLabelURL) {
        this.shippingLabelURL = shippingLabelURL;
        return this;
    }

    /**
     * Returns the value of the Warning property for this object.
     *
     * @return The value of the Warning property for this object.
     */
    public String getWarning() {
        return warning;
    }
    
    /**
     * Sets the value of the Warning property for this object.
     *
     * @param warning The new value for the Warning property for this object.
     */
    public void setWarning(String warning) {
        this.warning = warning;
    }
    
    /**
     * Sets the value of the Warning property for this object.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param warning The new value for the Warning property for this object.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetShippingLabelResult withWarning(String warning) {
        this.warning = warning;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getShippingLabelURL() != null) sb.append("ShippingLabelURL: " + getShippingLabelURL() + ",");
        if (getWarning() != null) sb.append("Warning: " + getWarning() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getShippingLabelURL() == null) ? 0 : getShippingLabelURL().hashCode()); 
        hashCode = prime * hashCode + ((getWarning() == null) ? 0 : getWarning().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetShippingLabelResult == false) return false;
        GetShippingLabelResult other = (GetShippingLabelResult)obj;
        
        if (other.getShippingLabelURL() == null ^ this.getShippingLabelURL() == null) return false;
        if (other.getShippingLabelURL() != null && other.getShippingLabelURL().equals(this.getShippingLabelURL()) == false) return false; 
        if (other.getWarning() == null ^ this.getWarning() == null) return false;
        if (other.getWarning() != null && other.getWarning().equals(this.getWarning()) == false) return false; 
        return true;
    }
    
    @Override
    public GetShippingLabelResult clone() {
        try {
            return (GetShippingLabelResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/GetStatusRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#getStatus(GetStatusRequest) GetStatus operation}.
 * <p>
 * This operation returns information about a job, including where the
 * job is in the processing pipeline, the status of the results, and the
 * signature value associated with the job. You can only return
 * information about jobs you own.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#getStatus(GetStatusRequest)
 */
public class GetStatusRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * Specifies the version of the client tool.
     */
    private String aPIVersion;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusRequest withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * Specifies the version of the client tool.
     *
     * @return Specifies the version of the client tool.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     *
     * @param aPIVersion Specifies the version of the client tool.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion Specifies the version of the client tool.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetStatusRequest == false) return false;
        GetStatusRequest other = (GetStatusRequest)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public GetStatusRequest clone() {
        
            return (GetStatusRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/GetStatusResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Output structure for the GetStatus operation.
 * </p>
 */
public class GetStatusResult implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     */
    private String jobType;

    /**
     * A token representing the location of the storage device, such as
     * "AtAWS".
     */
    private String locationCode;

    /**
     * A more human readable form of the physical location of the storage
     * device.
     */
    private String locationMessage;

    /**
     * A token representing the state of the job, such as "Started".
     */
    private String progressCode;

    /**
     * A more human readable form of the job status.
     */
    private String progressMessage;

    /**
     * Name of the shipping company. This value is included when the
     * LocationCode is "Returned".
     */
    private String carrier;

    /**
     * The shipping tracking number assigned by AWS Import/Export to the
     * storage device when it's returned to you. We return this value when
     * the LocationCode is "Returned".
     */
    private String trackingNumber;

    /**
     * Amazon S3 bucket for user logs.
     */
    private String logBucket;

    /**
     * The key where the user logs were stored.
     */
    private String logKey;

    /**
     * Number of errors. We return this value when the ProgressCode is
     * Success or SuccessWithErrors.
     */
    private Integer errorCount;

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     */
    private String signature;

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     */
    private String signatureFileContents;

    /**
     * The last manifest submitted, which will be used to process the job.
     */
    private String currentManifest;

    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     */
    private java.util.Date creationDate;

    /**
     * A collection of artifacts.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactList;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @return Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public String getJobType() {
        return jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(String jobType) {
        this.jobType = jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public GetStatusResult withJobType(String jobType) {
        this.jobType = jobType;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(JobType jobType) {
        this.jobType = jobType.toString();
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public GetStatusResult withJobType(JobType jobType) {
        this.jobType = jobType.toString();
        return this;
    }

    /**
     * A token representing the location of the storage device, such as
     * "AtAWS".
     *
     * @return A token representing the location of the storage device, such as
     *         "AtAWS".
     */
    public String getLocationCode() {
        return locationCode;
    }
    
    /**
     * A token representing the location of the storage device, such as
     * "AtAWS".
     *
     * @param locationCode A token representing the location of the storage device, such as
     *         "AtAWS".
     */
    public void setLocationCode(String locationCode) {
        this.locationCode = locationCode;
    }
    
    /**
     * A token representing the location of the storage device, such as
     * "AtAWS".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param locationCode A token representing the location of the storage device, such as
     *         "AtAWS".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withLocationCode(String locationCode) {
        this.locationCode = locationCode;
        return this;
    }

    /**
     * A more human readable form of the physical location of the storage
     * device.
     *
     * @return A more human readable form of the physical location of the storage
     *         device.
     */
    public String getLocationMessage() {
        return locationMessage;
    }
    
    /**
     * A more human readable form of the physical location of the storage
     * device.
     *
     * @param locationMessage A more human readable form of the physical location of the storage
     *         device.
     */
    public void setLocationMessage(String locationMessage) {
        this.locationMessage = locationMessage;
    }
    
    /**
     * A more human readable form of the physical location of the storage
     * device.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param locationMessage A more human readable form of the physical location of the storage
     *         device.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withLocationMessage(String locationMessage) {
        this.locationMessage = locationMessage;
        return this;
    }

    /**
     * A token representing the state of the job, such as "Started".
     *
     * @return A token representing the state of the job, such as "Started".
     */
    public String getProgressCode() {
        return progressCode;
    }
    
    /**
     * A token representing the state of the job, such as "Started".
     *
     * @param progressCode A token representing the state of the job, such as "Started".
     */
    public void setProgressCode(String progressCode) {
        this.progressCode = progressCode;
    }
    
    /**
     * A token representing the state of the job, such as "Started".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param progressCode A token representing the state of the job, such as "Started".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withProgressCode(String progressCode) {
        this.progressCode = progressCode;
        return this;
    }

    /**
     * A more human readable form of the job status.
     *
     * @return A more human readable form of the job status.
     */
    public String getProgressMessage() {
        return progressMessage;
    }
    
    /**
     * A more human readable form of the job status.
     *
     * @param progressMessage A more human readable form of the job status.
     */
    public void setProgressMessage(String progressMessage) {
        this.progressMessage = progressMessage;
    }
    
    /**
     * A more human readable form of the job status.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param progressMessage A more human readable form of the job status.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withProgressMessage(String progressMessage) {
        this.progressMessage = progressMessage;
        return this;
    }

    /**
     * Name of the shipping company. This value is included when the
     * LocationCode is "Returned".
     *
     * @return Name of the shipping company. This value is included when the
     *         LocationCode is "Returned".
     */
    public String getCarrier() {
        return carrier;
    }
    
    /**
     * Name of the shipping company. This value is included when the
     * LocationCode is "Returned".
     *
     * @param carrier Name of the shipping company. This value is included when the
     *         LocationCode is "Returned".
     */
    public void setCarrier(String carrier) {
        this.carrier = carrier;
    }
    
    /**
     * Name of the shipping company. This value is included when the
     * LocationCode is "Returned".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param carrier Name of the shipping company. This value is included when the
     *         LocationCode is "Returned".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withCarrier(String carrier) {
        this.carrier = carrier;
        return this;
    }

    /**
     * The shipping tracking number assigned by AWS Import/Export to the
     * storage device when it's returned to you. We return this value when
     * the LocationCode is "Returned".
     *
     * @return The shipping tracking number assigned by AWS Import/Export to the
     *         storage device when it's returned to you. We return this value when
     *         the LocationCode is "Returned".
     */
    public String getTrackingNumber() {
        return trackingNumber;
    }
    
    /**
     * The shipping tracking number assigned by AWS Import/Export to the
     * storage device when it's returned to you. We return this value when
     * the LocationCode is "Returned".
     *
     * @param trackingNumber The shipping tracking number assigned by AWS Import/Export to the
     *         storage device when it's returned to you. We return this value when
     *         the LocationCode is "Returned".
     */
    public void setTrackingNumber(String trackingNumber) {
        this.trackingNumber = trackingNumber;
    }
    
    /**
     * The shipping tracking number assigned by AWS Import/Export to the
     * storage device when it's returned to you. We return this value when
     * the LocationCode is "Returned".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param trackingNumber The shipping tracking number assigned by AWS Import/Export to the
     *         storage device when it's returned to you. We return this value when
     *         the LocationCode is "Returned".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withTrackingNumber(String trackingNumber) {
        this.trackingNumber = trackingNumber;
        return this;
    }

    /**
     * Amazon S3 bucket for user logs.
     *
     * @return Amazon S3 bucket for user logs.
     */
    public String getLogBucket() {
        return logBucket;
    }
    
    /**
     * Amazon S3 bucket for user logs.
     *
     * @param logBucket Amazon S3 bucket for user logs.
     */
    public void setLogBucket(String logBucket) {
        this.logBucket = logBucket;
    }
    
    /**
     * Amazon S3 bucket for user logs.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param logBucket Amazon S3 bucket for user logs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withLogBucket(String logBucket) {
        this.logBucket = logBucket;
        return this;
    }

    /**
     * The key where the user logs were stored.
     *
     * @return The key where the user logs were stored.
     */
    public String getLogKey() {
        return logKey;
    }
    
    /**
     * The key where the user logs were stored.
     *
     * @param logKey The key where the user logs were stored.
     */
    public void setLogKey(String logKey) {
        this.logKey = logKey;
    }
    
    /**
     * The key where the user logs were stored.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param logKey The key where the user logs were stored.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withLogKey(String logKey) {
        this.logKey = logKey;
        return this;
    }

    /**
     * Number of errors. We return this value when the ProgressCode is
     * Success or SuccessWithErrors.
     *
     * @return Number of errors. We return this value when the ProgressCode is
     *         Success or SuccessWithErrors.
     */
    public Integer getErrorCount() {
        return errorCount;
    }
    
    /**
     * Number of errors. We return this value when the ProgressCode is
     * Success or SuccessWithErrors.
     *
     * @param errorCount Number of errors. We return this value when the ProgressCode is
     *         Success or SuccessWithErrors.
     */
    public void setErrorCount(Integer errorCount) {
        this.errorCount = errorCount;
    }
    
    /**
     * Number of errors. We return this value when the ProgressCode is
     * Success or SuccessWithErrors.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param errorCount Number of errors. We return this value when the ProgressCode is
     *         Success or SuccessWithErrors.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withErrorCount(Integer errorCount) {
        this.errorCount = errorCount;
        return this;
    }

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @return An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public String getSignature() {
        return signature;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @param signature An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public void setSignature(String signature) {
        this.signature = signature;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param signature An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withSignature(String signature) {
        this.signature = signature;
        return this;
    }

    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @return An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public String getSignatureFileContents() {
        return signatureFileContents;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     *
     * @param signatureFileContents An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     */
    public void setSignatureFileContents(String signatureFileContents) {
        this.signatureFileContents = signatureFileContents;
    }
    
    /**
     * An encrypted code used to authenticate the request and response, for
     * example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     * want to create the signature file yourself. Generally you should use
     * the SignatureFileContents value.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param signatureFileContents An encrypted code used to authenticate the request and response, for
     *         example, "DV+TpDfx1/TdSE9ktyK9k/bDTVI=". Only use this value is you
     *         want to create the signature file yourself. Generally you should use
     *         the SignatureFileContents value.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withSignatureFileContents(String signatureFileContents) {
        this.signatureFileContents = signatureFileContents;
        return this;
    }

    /**
     * The last manifest submitted, which will be used to process the job.
     *
     * @return The last manifest submitted, which will be used to process the job.
     */
    public String getCurrentManifest() {
        return currentManifest;
    }
    
    /**
     * The last manifest submitted, which will be used to process the job.
     *
     * @param currentManifest The last manifest submitted, which will be used to process the job.
     */
    public void setCurrentManifest(String currentManifest) {
        this.currentManifest = currentManifest;
    }
    
    /**
     * The last manifest submitted, which will be used to process the job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param currentManifest The last manifest submitted, which will be used to process the job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withCurrentManifest(String currentManifest) {
        this.currentManifest = currentManifest;
        return this;
    }

    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     *
     * @return Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     */
    public java.util.Date getCreationDate() {
        return creationDate;
    }
    
    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     *
     * @param creationDate Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     */
    public void setCreationDate(java.util.Date creationDate) {
        this.creationDate = creationDate;
    }
    
    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param creationDate Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withCreationDate(java.util.Date creationDate) {
        this.creationDate = creationDate;
        return this;
    }

    /**
     * A collection of artifacts.
     *
     * @return A collection of artifacts.
     */
    public java.util.List<Artifact> getArtifactList() {
        if (artifactList == null) {
              artifactList = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>();
              artifactList.setAutoConstruct(true);
        }
        return artifactList;
    }
    
    /**
     * A collection of artifacts.
     *
     * @param artifactList A collection of artifacts.
     */
    public void setArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
        artifactListCopy.addAll(artifactList);
        this.artifactList = artifactListCopy;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setArtifactList(java.util.Collection)} or {@link
     * #withArtifactList(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withArtifactList(Artifact... artifactList) {
        if (getArtifactList() == null) setArtifactList(new java.util.ArrayList<Artifact>(artifactList.length));
        for (Artifact value : artifactList) {
            getArtifactList().add(value);
        }
        return this;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public GetStatusResult withArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
            artifactListCopy.addAll(artifactList);
            this.artifactList = artifactListCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getJobType() != null) sb.append("JobType: " + getJobType() + ",");
        if (getLocationCode() != null) sb.append("LocationCode: " + getLocationCode() + ",");
        if (getLocationMessage() != null) sb.append("LocationMessage: " + getLocationMessage() + ",");
        if (getProgressCode() != null) sb.append("ProgressCode: " + getProgressCode() + ",");
        if (getProgressMessage() != null) sb.append("ProgressMessage: " + getProgressMessage() + ",");
        if (getCarrier() != null) sb.append("Carrier: " + getCarrier() + ",");
        if (getTrackingNumber() != null) sb.append("TrackingNumber: " + getTrackingNumber() + ",");
        if (getLogBucket() != null) sb.append("LogBucket: " + getLogBucket() + ",");
        if (getLogKey() != null) sb.append("LogKey: " + getLogKey() + ",");
        if (getErrorCount() != null) sb.append("ErrorCount: " + getErrorCount() + ",");
        if (getSignature() != null) sb.append("Signature: " + getSignature() + ",");
        if (getSignatureFileContents() != null) sb.append("SignatureFileContents: " + getSignatureFileContents() + ",");
        if (getCurrentManifest() != null) sb.append("CurrentManifest: " + getCurrentManifest() + ",");
        if (getCreationDate() != null) sb.append("CreationDate: " + getCreationDate() + ",");
        if (getArtifactList() != null) sb.append("ArtifactList: " + getArtifactList() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getJobType() == null) ? 0 : getJobType().hashCode()); 
        hashCode = prime * hashCode + ((getLocationCode() == null) ? 0 : getLocationCode().hashCode()); 
        hashCode = prime * hashCode + ((getLocationMessage() == null) ? 0 : getLocationMessage().hashCode()); 
        hashCode = prime * hashCode + ((getProgressCode() == null) ? 0 : getProgressCode().hashCode()); 
        hashCode = prime * hashCode + ((getProgressMessage() == null) ? 0 : getProgressMessage().hashCode()); 
        hashCode = prime * hashCode + ((getCarrier() == null) ? 0 : getCarrier().hashCode()); 
        hashCode = prime * hashCode + ((getTrackingNumber() == null) ? 0 : getTrackingNumber().hashCode()); 
        hashCode = prime * hashCode + ((getLogBucket() == null) ? 0 : getLogBucket().hashCode()); 
        hashCode = prime * hashCode + ((getLogKey() == null) ? 0 : getLogKey().hashCode()); 
        hashCode = prime * hashCode + ((getErrorCount() == null) ? 0 : getErrorCount().hashCode()); 
        hashCode = prime * hashCode + ((getSignature() == null) ? 0 : getSignature().hashCode()); 
        hashCode = prime * hashCode + ((getSignatureFileContents() == null) ? 0 : getSignatureFileContents().hashCode()); 
        hashCode = prime * hashCode + ((getCurrentManifest() == null) ? 0 : getCurrentManifest().hashCode()); 
        hashCode = prime * hashCode + ((getCreationDate() == null) ? 0 : getCreationDate().hashCode()); 
        hashCode = prime * hashCode + ((getArtifactList() == null) ? 0 : getArtifactList().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof GetStatusResult == false) return false;
        GetStatusResult other = (GetStatusResult)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getJobType() == null ^ this.getJobType() == null) return false;
        if (other.getJobType() != null && other.getJobType().equals(this.getJobType()) == false) return false; 
        if (other.getLocationCode() == null ^ this.getLocationCode() == null) return false;
        if (other.getLocationCode() != null && other.getLocationCode().equals(this.getLocationCode()) == false) return false; 
        if (other.getLocationMessage() == null ^ this.getLocationMessage() == null) return false;
        if (other.getLocationMessage() != null && other.getLocationMessage().equals(this.getLocationMessage()) == false) return false; 
        if (other.getProgressCode() == null ^ this.getProgressCode() == null) return false;
        if (other.getProgressCode() != null && other.getProgressCode().equals(this.getProgressCode()) == false) return false; 
        if (other.getProgressMessage() == null ^ this.getProgressMessage() == null) return false;
        if (other.getProgressMessage() != null && other.getProgressMessage().equals(this.getProgressMessage()) == false) return false; 
        if (other.getCarrier() == null ^ this.getCarrier() == null) return false;
        if (other.getCarrier() != null && other.getCarrier().equals(this.getCarrier()) == false) return false; 
        if (other.getTrackingNumber() == null ^ this.getTrackingNumber() == null) return false;
        if (other.getTrackingNumber() != null && other.getTrackingNumber().equals(this.getTrackingNumber()) == false) return false; 
        if (other.getLogBucket() == null ^ this.getLogBucket() == null) return false;
        if (other.getLogBucket() != null && other.getLogBucket().equals(this.getLogBucket()) == false) return false; 
        if (other.getLogKey() == null ^ this.getLogKey() == null) return false;
        if (other.getLogKey() != null && other.getLogKey().equals(this.getLogKey()) == false) return false; 
        if (other.getErrorCount() == null ^ this.getErrorCount() == null) return false;
        if (other.getErrorCount() != null && other.getErrorCount().equals(this.getErrorCount()) == false) return false; 
        if (other.getSignature() == null ^ this.getSignature() == null) return false;
        if (other.getSignature() != null && other.getSignature().equals(this.getSignature()) == false) return false; 
        if (other.getSignatureFileContents() == null ^ this.getSignatureFileContents() == null) return false;
        if (other.getSignatureFileContents() != null && other.getSignatureFileContents().equals(this.getSignatureFileContents()) == false) return false; 
        if (other.getCurrentManifest() == null ^ this.getCurrentManifest() == null) return false;
        if (other.getCurrentManifest() != null && other.getCurrentManifest().equals(this.getCurrentManifest()) == false) return false; 
        if (other.getCreationDate() == null ^ this.getCreationDate() == null) return false;
        if (other.getCreationDate() != null && other.getCreationDate().equals(this.getCreationDate()) == false) return false; 
        if (other.getArtifactList() == null ^ this.getArtifactList() == null) return false;
        if (other.getArtifactList() != null && other.getArtifactList().equals(this.getArtifactList()) == false) return false; 
        return true;
    }
    
    @Override
    public GetStatusResult clone() {
        try {
            return (GetStatusResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidAccessKeyIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The AWS Access Key ID specified in the request did not match the
 * manifest's accessKeyId value. The manifest and the request
 * authentication must use the same AWS Access Key ID.
 * </p>
 */        
public class InvalidAccessKeyIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidAccessKeyIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidAccessKeyIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidAddressException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The address specified in the manifest is invalid.
 * </p>
 */        
public class InvalidAddressException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidAddressException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidAddressException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidCustomsException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more customs parameters was invalid. Please correct and
 * resubmit.
 * </p>
 */        
public class InvalidCustomsException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidCustomsException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidCustomsException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidFileSystemException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * File system specified in export manifest is invalid.
 * </p>
 */        
public class InvalidFileSystemException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidFileSystemException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidFileSystemException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidJobIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The JOBID was missing, not found, or not associated with the AWS
 * account.
 * </p>
 */        
public class InvalidJobIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidJobIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidJobIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidManifestFieldException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more manifest fields was invalid. Please correct and resubmit.
 * </p>
 */        
public class InvalidManifestFieldException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidManifestFieldException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidManifestFieldException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidParameterException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more parameters had an invalid value.
 * </p>
 */        
public class InvalidParameterException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidParameterException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidParameterException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/InvalidVersionException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The client tool version is invalid.
 * </p>
 */        
public class InvalidVersionException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new InvalidVersionException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public InvalidVersionException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/Job.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Representation of a job returned by the ListJobs operation.
 * </p>
 */
public class Job implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     */
    private java.util.Date creationDate;

    /**
     * Indicates whether the job was canceled.
     */
    private Boolean isCanceled;

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     */
    private String jobType;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Job withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     *
     * @return Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     */
    public java.util.Date getCreationDate() {
        return creationDate;
    }
    
    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     *
     * @param creationDate Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     */
    public void setCreationDate(java.util.Date creationDate) {
        this.creationDate = creationDate;
    }
    
    /**
     * Timestamp of the CreateJob request in ISO8601 date format. For example
     * "2010-03-28T20:27:35Z".
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param creationDate Timestamp of the CreateJob request in ISO8601 date format. For example
     *         "2010-03-28T20:27:35Z".
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Job withCreationDate(java.util.Date creationDate) {
        this.creationDate = creationDate;
        return this;
    }

    /**
     * Indicates whether the job was canceled.
     *
     * @return Indicates whether the job was canceled.
     */
    public Boolean isCanceled() {
        return isCanceled;
    }
    
    /**
     * Indicates whether the job was canceled.
     *
     * @param isCanceled Indicates whether the job was canceled.
     */
    public void setIsCanceled(Boolean isCanceled) {
        this.isCanceled = isCanceled;
    }
    
    /**
     * Indicates whether the job was canceled.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param isCanceled Indicates whether the job was canceled.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public Job withIsCanceled(Boolean isCanceled) {
        this.isCanceled = isCanceled;
        return this;
    }

    /**
     * Indicates whether the job was canceled.
     *
     * @return Indicates whether the job was canceled.
     */
    public Boolean getIsCanceled() {
        return isCanceled;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @return Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public String getJobType() {
        return jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(String jobType) {
        this.jobType = jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public Job withJobType(String jobType) {
        this.jobType = jobType;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(JobType jobType) {
        this.jobType = jobType.toString();
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public Job withJobType(JobType jobType) {
        this.jobType = jobType.toString();
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getCreationDate() != null) sb.append("CreationDate: " + getCreationDate() + ",");
        if (isCanceled() != null) sb.append("IsCanceled: " + isCanceled() + ",");
        if (getJobType() != null) sb.append("JobType: " + getJobType() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getCreationDate() == null) ? 0 : getCreationDate().hashCode()); 
        hashCode = prime * hashCode + ((isCanceled() == null) ? 0 : isCanceled().hashCode()); 
        hashCode = prime * hashCode + ((getJobType() == null) ? 0 : getJobType().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof Job == false) return false;
        Job other = (Job)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getCreationDate() == null ^ this.getCreationDate() == null) return false;
        if (other.getCreationDate() != null && other.getCreationDate().equals(this.getCreationDate()) == false) return false; 
        if (other.isCanceled() == null ^ this.isCanceled() == null) return false;
        if (other.isCanceled() != null && other.isCanceled().equals(this.isCanceled()) == false) return false; 
        if (other.getJobType() == null ^ this.getJobType() == null) return false;
        if (other.getJobType() != null && other.getJobType().equals(this.getJobType()) == false) return false; 
        return true;
    }
    
    @Override
    public Job clone() {
        try {
            return (Job) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/JobType.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

/**
 * Job Type
 */
public enum JobType {
    
    Import("Import"),
    Export("Export");

    private String value;

    private JobType(String value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return this.value;
    }

    /**
     * Use this in place of valueOf.
     *
     * @param value
     *            real value
     * @return JobType corresponding to the value
     */
    public static JobType fromValue(String value) {
        if (value == null || "".equals(value)) {
            throw new IllegalArgumentException("Value cannot be null or empty!");
        
        } else if ("Import".equals(value)) {
            return JobType.Import;
        } else if ("Export".equals(value)) {
            return JobType.Export;
        } else {
            throw new IllegalArgumentException("Cannot create enum from " + value + " value!");
        }
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/ListJobsRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#listJobs(ListJobsRequest) ListJobs operation}.
 * <p>
 * This operation returns the jobs associated with the requester. AWS
 * Import/Export lists the jobs in reverse chronological order based on
 * the date of creation. For example if Job Test1 was created 2009Dec30
 * and Test2 was created 2010Feb05, the ListJobs operation would return
 * Test2 followed by Test1.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#listJobs(ListJobsRequest)
 */
public class ListJobsRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Sets the maximum number of jobs returned in the response. If there are
     * additional jobs that were not returned because MaxJobs was exceeded,
     * the response contains <IsTruncated>true</IsTruncated>. To return the
     * additional jobs, see Marker.
     */
    private Integer maxJobs;

    /**
     * Specifies the JOBID to start after when listing the jobs created with
     * your account. AWS Import/Export lists your jobs in reverse
     * chronological order. See MaxJobs.
     */
    private String marker;

    /**
     * Specifies the version of the client tool.
     */
    private String aPIVersion;

    /**
     * Sets the maximum number of jobs returned in the response. If there are
     * additional jobs that were not returned because MaxJobs was exceeded,
     * the response contains <IsTruncated>true</IsTruncated>. To return the
     * additional jobs, see Marker.
     *
     * @return Sets the maximum number of jobs returned in the response. If there are
     *         additional jobs that were not returned because MaxJobs was exceeded,
     *         the response contains <IsTruncated>true</IsTruncated>. To return the
     *         additional jobs, see Marker.
     */
    public Integer getMaxJobs() {
        return maxJobs;
    }
    
    /**
     * Sets the maximum number of jobs returned in the response. If there are
     * additional jobs that were not returned because MaxJobs was exceeded,
     * the response contains <IsTruncated>true</IsTruncated>. To return the
     * additional jobs, see Marker.
     *
     * @param maxJobs Sets the maximum number of jobs returned in the response. If there are
     *         additional jobs that were not returned because MaxJobs was exceeded,
     *         the response contains <IsTruncated>true</IsTruncated>. To return the
     *         additional jobs, see Marker.
     */
    public void setMaxJobs(Integer maxJobs) {
        this.maxJobs = maxJobs;
    }
    
    /**
     * Sets the maximum number of jobs returned in the response. If there are
     * additional jobs that were not returned because MaxJobs was exceeded,
     * the response contains <IsTruncated>true</IsTruncated>. To return the
     * additional jobs, see Marker.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param maxJobs Sets the maximum number of jobs returned in the response. If there are
     *         additional jobs that were not returned because MaxJobs was exceeded,
     *         the response contains <IsTruncated>true</IsTruncated>. To return the
     *         additional jobs, see Marker.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsRequest withMaxJobs(Integer maxJobs) {
        this.maxJobs = maxJobs;
        return this;
    }

    /**
     * Specifies the JOBID to start after when listing the jobs created with
     * your account. AWS Import/Export lists your jobs in reverse
     * chronological order. See MaxJobs.
     *
     * @return Specifies the JOBID to start after when listing the jobs created with
     *         your account. AWS Import/Export lists your jobs in reverse
     *         chronological order. See MaxJobs.
     */
    public String getMarker() {
        return marker;
    }
    
    /**
     * Specifies the JOBID to start after when listing the jobs created with
     * your account. AWS Import/Export lists your jobs in reverse
     * chronological order. See MaxJobs.
     *
     * @param marker Specifies the JOBID to start after when listing the jobs created with
     *         your account. AWS Import/Export lists your jobs in reverse
     *         chronological order. See MaxJobs.
     */
    public void setMarker(String marker) {
        this.marker = marker;
    }
    
    /**
     * Specifies the JOBID to start after when listing the jobs created with
     * your account. AWS Import/Export lists your jobs in reverse
     * chronological order. See MaxJobs.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param marker Specifies the JOBID to start after when listing the jobs created with
     *         your account. AWS Import/Export lists your jobs in reverse
     *         chronological order. See MaxJobs.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsRequest withMarker(String marker) {
        this.marker = marker;
        return this;
    }

    /**
     * Specifies the version of the client tool.
     *
     * @return Specifies the version of the client tool.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     *
     * @param aPIVersion Specifies the version of the client tool.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion Specifies the version of the client tool.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getMaxJobs() != null) sb.append("MaxJobs: " + getMaxJobs() + ",");
        if (getMarker() != null) sb.append("Marker: " + getMarker() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getMaxJobs() == null) ? 0 : getMaxJobs().hashCode()); 
        hashCode = prime * hashCode + ((getMarker() == null) ? 0 : getMarker().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof ListJobsRequest == false) return false;
        ListJobsRequest other = (ListJobsRequest)obj;
        
        if (other.getMaxJobs() == null ^ this.getMaxJobs() == null) return false;
        if (other.getMaxJobs() != null && other.getMaxJobs().equals(this.getMaxJobs()) == false) return false; 
        if (other.getMarker() == null ^ this.getMarker() == null) return false;
        if (other.getMarker() != null && other.getMarker().equals(this.getMarker()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public ListJobsRequest clone() {
        
            return (ListJobsRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/ListJobsResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Output structure for the ListJobs operation.
 * </p>
 */
public class ListJobsResult implements Serializable, Cloneable {

    /**
     * A list container for Jobs returned by the ListJobs operation.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Job> jobs;

    /**
     * Indicates whether the list of jobs was truncated. If true, then call
     * ListJobs again using the last JobId element as the marker.
     */
    private Boolean isTruncated;

    /**
     * A list container for Jobs returned by the ListJobs operation.
     *
     * @return A list container for Jobs returned by the ListJobs operation.
     */
    public java.util.List<Job> getJobs() {
        if (jobs == null) {
              jobs = new com.amazonaws.internal.ListWithAutoConstructFlag<Job>();
              jobs.setAutoConstruct(true);
        }
        return jobs;
    }
    
    /**
     * A list container for Jobs returned by the ListJobs operation.
     *
     * @param jobs A list container for Jobs returned by the ListJobs operation.
     */
    public void setJobs(java.util.Collection<Job> jobs) {
        if (jobs == null) {
            this.jobs = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Job> jobsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Job>(jobs.size());
        jobsCopy.addAll(jobs);
        this.jobs = jobsCopy;
    }
    
    /**
     * A list container for Jobs returned by the ListJobs operation.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setJobs(java.util.Collection)} or {@link
     * #withJobs(java.util.Collection)} if you want to override the existing
     * values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobs A list container for Jobs returned by the ListJobs operation.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsResult withJobs(Job... jobs) {
        if (getJobs() == null) setJobs(new java.util.ArrayList<Job>(jobs.length));
        for (Job value : jobs) {
            getJobs().add(value);
        }
        return this;
    }
    
    /**
     * A list container for Jobs returned by the ListJobs operation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobs A list container for Jobs returned by the ListJobs operation.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsResult withJobs(java.util.Collection<Job> jobs) {
        if (jobs == null) {
            this.jobs = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Job> jobsCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Job>(jobs.size());
            jobsCopy.addAll(jobs);
            this.jobs = jobsCopy;
        }

        return this;
    }

    /**
     * Indicates whether the list of jobs was truncated. If true, then call
     * ListJobs again using the last JobId element as the marker.
     *
     * @return Indicates whether the list of jobs was truncated. If true, then call
     *         ListJobs again using the last JobId element as the marker.
     */
    public Boolean isTruncated() {
        return isTruncated;
    }
    
    /**
     * Indicates whether the list of jobs was truncated. If true, then call
     * ListJobs again using the last JobId element as the marker.
     *
     * @param isTruncated Indicates whether the list of jobs was truncated. If true, then call
     *         ListJobs again using the last JobId element as the marker.
     */
    public void setIsTruncated(Boolean isTruncated) {
        this.isTruncated = isTruncated;
    }
    
    /**
     * Indicates whether the list of jobs was truncated. If true, then call
     * ListJobs again using the last JobId element as the marker.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param isTruncated Indicates whether the list of jobs was truncated. If true, then call
     *         ListJobs again using the last JobId element as the marker.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public ListJobsResult withIsTruncated(Boolean isTruncated) {
        this.isTruncated = isTruncated;
        return this;
    }

    /**
     * Indicates whether the list of jobs was truncated. If true, then call
     * ListJobs again using the last JobId element as the marker.
     *
     * @return Indicates whether the list of jobs was truncated. If true, then call
     *         ListJobs again using the last JobId element as the marker.
     */
    public Boolean getIsTruncated() {
        return isTruncated;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobs() != null) sb.append("Jobs: " + getJobs() + ",");
        if (isTruncated() != null) sb.append("IsTruncated: " + isTruncated() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobs() == null) ? 0 : getJobs().hashCode()); 
        hashCode = prime * hashCode + ((isTruncated() == null) ? 0 : isTruncated().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof ListJobsResult == false) return false;
        ListJobsResult other = (ListJobsResult)obj;
        
        if (other.getJobs() == null ^ this.getJobs() == null) return false;
        if (other.getJobs() != null && other.getJobs().equals(this.getJobs()) == false) return false; 
        if (other.isTruncated() == null ^ this.isTruncated() == null) return false;
        if (other.isTruncated() != null && other.isTruncated().equals(this.isTruncated()) == false) return false; 
        return true;
    }
    
    @Override
    public ListJobsResult clone() {
        try {
            return (ListJobsResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/MalformedManifestException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Your manifest is not well-formed.
 * </p>
 */        
public class MalformedManifestException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new MalformedManifestException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MalformedManifestException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/MissingCustomsException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more required customs parameters was missing from the
 * manifest.
 * </p>
 */        
public class MissingCustomsException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new MissingCustomsException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MissingCustomsException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/MissingManifestFieldException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more required fields were missing from the manifest file.
 * Please correct and resubmit.
 * </p>
 */        
public class MissingManifestFieldException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new MissingManifestFieldException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MissingManifestFieldException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/MissingParameterException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * One or more required parameters was missing from the request.
 * </p>
 */        
public class MissingParameterException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new MissingParameterException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MissingParameterException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/MultipleRegionsException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Your manifest file contained buckets from multiple regions. A job is
 * restricted to buckets from one region. Please correct and resubmit.
 * </p>
 */        
public class MultipleRegionsException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new MultipleRegionsException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public MultipleRegionsException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/NoSuchBucketException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * The specified bucket does not exist. Create the specified bucket or
 * change the manifest's bucket, exportBucket, or logBucket field to a
 * bucket that the account, as specified by the manifest's Access Key ID,
 * has write permissions to.
 * </p>
 */        
public class NoSuchBucketException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new NoSuchBucketException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public NoSuchBucketException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/UnableToCancelJobIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * AWS Import/Export cannot cancel the job
 * </p>
 */        
public class UnableToCancelJobIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new UnableToCancelJobIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public UnableToCancelJobIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/UnableToUpdateJobIdException.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * AWS Import/Export cannot update the job
 * </p>
 */        
public class UnableToUpdateJobIdException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new UnableToUpdateJobIdException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public UnableToUpdateJobIdException(String message) {
        super(message);
    }
    
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/UpdateJobRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.importexport.AmazonImportExport#updateJob(UpdateJobRequest) UpdateJob operation}.
 * <p>
 * You use this operation to change the parameters specified in the
 * original manifest file by supplying a new manifest file. The manifest
 * file attached to this request replaces the original manifest file. You
 * can only use the operation after a CreateJob request but before the
 * data transfer starts and you can only use it on jobs you own.
 * </p>
 *
 * @see com.amazonaws.services.importexport.AmazonImportExport#updateJob(UpdateJobRequest)
 */
public class UpdateJobRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * A unique identifier which refers to a particular job.
     */
    private String jobId;

    /**
     * The UTF-8 encoded text of the manifest file.
     */
    private String manifest;

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     */
    private String jobType;

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     */
    private Boolean validateOnly;

    /**
     * Specifies the version of the client tool.
     */
    private String aPIVersion;

    /**
     * A unique identifier which refers to a particular job.
     *
     * @return A unique identifier which refers to a particular job.
     */
    public String getJobId() {
        return jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     *
     * @param jobId A unique identifier which refers to a particular job.
     */
    public void setJobId(String jobId) {
        this.jobId = jobId;
    }
    
    /**
     * A unique identifier which refers to a particular job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobId A unique identifier which refers to a particular job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobRequest withJobId(String jobId) {
        this.jobId = jobId;
        return this;
    }

    /**
     * The UTF-8 encoded text of the manifest file.
     *
     * @return The UTF-8 encoded text of the manifest file.
     */
    public String getManifest() {
        return manifest;
    }
    
    /**
     * The UTF-8 encoded text of the manifest file.
     *
     * @param manifest The UTF-8 encoded text of the manifest file.
     */
    public void setManifest(String manifest) {
        this.manifest = manifest;
    }
    
    /**
     * The UTF-8 encoded text of the manifest file.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param manifest The UTF-8 encoded text of the manifest file.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobRequest withManifest(String manifest) {
        this.manifest = manifest;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @return Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public String getJobType() {
        return jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(String jobType) {
        this.jobType = jobType;
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public UpdateJobRequest withJobType(String jobType) {
        this.jobType = jobType;
        return this;
    }

    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @see JobType
     */
    public void setJobType(JobType jobType) {
        this.jobType = jobType.toString();
    }
    
    /**
     * Specifies whether the job to initiate is an import or export job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>Import, Export
     *
     * @param jobType Specifies whether the job to initiate is an import or export job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see JobType
     */
    public UpdateJobRequest withJobType(JobType jobType) {
        this.jobType = jobType.toString();
        return this;
    }

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @return Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public Boolean isValidateOnly() {
        return validateOnly;
    }
    
    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @param validateOnly Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public void setValidateOnly(Boolean validateOnly) {
        this.validateOnly = validateOnly;
    }
    
    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param validateOnly Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobRequest withValidateOnly(Boolean validateOnly) {
        this.validateOnly = validateOnly;
        return this;
    }

    /**
     * Validate the manifest and parameter values in the request but do not
     * actually create a job.
     *
     * @return Validate the manifest and parameter values in the request but do not
     *         actually create a job.
     */
    public Boolean getValidateOnly() {
        return validateOnly;
    }

    /**
     * Specifies the version of the client tool.
     *
     * @return Specifies the version of the client tool.
     */
    public String getAPIVersion() {
        return aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     *
     * @param aPIVersion Specifies the version of the client tool.
     */
    public void setAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
    }
    
    /**
     * Specifies the version of the client tool.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param aPIVersion Specifies the version of the client tool.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobRequest withAPIVersion(String aPIVersion) {
        this.aPIVersion = aPIVersion;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getJobId() != null) sb.append("JobId: " + getJobId() + ",");
        if (getManifest() != null) sb.append("Manifest: " + getManifest() + ",");
        if (getJobType() != null) sb.append("JobType: " + getJobType() + ",");
        if (isValidateOnly() != null) sb.append("ValidateOnly: " + isValidateOnly() + ",");
        if (getAPIVersion() != null) sb.append("APIVersion: " + getAPIVersion() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobId() == null) ? 0 : getJobId().hashCode()); 
        hashCode = prime * hashCode + ((getManifest() == null) ? 0 : getManifest().hashCode()); 
        hashCode = prime * hashCode + ((getJobType() == null) ? 0 : getJobType().hashCode()); 
        hashCode = prime * hashCode + ((isValidateOnly() == null) ? 0 : isValidateOnly().hashCode()); 
        hashCode = prime * hashCode + ((getAPIVersion() == null) ? 0 : getAPIVersion().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof UpdateJobRequest == false) return false;
        UpdateJobRequest other = (UpdateJobRequest)obj;
        
        if (other.getJobId() == null ^ this.getJobId() == null) return false;
        if (other.getJobId() != null && other.getJobId().equals(this.getJobId()) == false) return false; 
        if (other.getManifest() == null ^ this.getManifest() == null) return false;
        if (other.getManifest() != null && other.getManifest().equals(this.getManifest()) == false) return false; 
        if (other.getJobType() == null ^ this.getJobType() == null) return false;
        if (other.getJobType() != null && other.getJobType().equals(this.getJobType()) == false) return false; 
        if (other.isValidateOnly() == null ^ this.isValidateOnly() == null) return false;
        if (other.isValidateOnly() != null && other.isValidateOnly().equals(this.isValidateOnly()) == false) return false; 
        if (other.getAPIVersion() == null ^ this.getAPIVersion() == null) return false;
        if (other.getAPIVersion() != null && other.getAPIVersion().equals(this.getAPIVersion()) == false) return false; 
        return true;
    }
    
    @Override
    public UpdateJobRequest clone() {
        
            return (UpdateJobRequest) super.clone();
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/UpdateJobResult.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model;

import java.io.Serializable;

/**
 * <p>
 * Output structure for the UpateJob operation.
 * </p>
 */
public class UpdateJobResult implements Serializable, Cloneable {

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     */
    private Boolean success;

    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     */
    private String warningMessage;

    /**
     * A collection of artifacts.
     */
    private com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactList;

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @return Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public Boolean isSuccess() {
        return success;
    }
    
    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @param success Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public void setSuccess(Boolean success) {
        this.success = success;
    }
    
    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param success Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobResult withSuccess(Boolean success) {
        this.success = success;
        return this;
    }

    /**
     * Specifies whether (true) or not (false) AWS Import/Export updated your
     * job.
     *
     * @return Specifies whether (true) or not (false) AWS Import/Export updated your
     *         job.
     */
    public Boolean getSuccess() {
        return success;
    }

    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     *
     * @return An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     */
    public String getWarningMessage() {
        return warningMessage;
    }
    
    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     *
     * @param warningMessage An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     */
    public void setWarningMessage(String warningMessage) {
        this.warningMessage = warningMessage;
    }
    
    /**
     * An optional message notifying you of non-fatal issues with the job,
     * such as use of an incompatible Amazon S3 bucket name.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param warningMessage An optional message notifying you of non-fatal issues with the job,
     *         such as use of an incompatible Amazon S3 bucket name.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobResult withWarningMessage(String warningMessage) {
        this.warningMessage = warningMessage;
        return this;
    }

    /**
     * A collection of artifacts.
     *
     * @return A collection of artifacts.
     */
    public java.util.List<Artifact> getArtifactList() {
        if (artifactList == null) {
              artifactList = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>();
              artifactList.setAutoConstruct(true);
        }
        return artifactList;
    }
    
    /**
     * A collection of artifacts.
     *
     * @param artifactList A collection of artifacts.
     */
    public void setArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
            return;
        }
        com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
        artifactListCopy.addAll(artifactList);
        this.artifactList = artifactListCopy;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if
     * any). Use {@link #setArtifactList(java.util.Collection)} or {@link
     * #withArtifactList(java.util.Collection)} if you want to override the
     * existing values.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobResult withArtifactList(Artifact... artifactList) {
        if (getArtifactList() == null) setArtifactList(new java.util.ArrayList<Artifact>(artifactList.length));
        for (Artifact value : artifactList) {
            getArtifactList().add(value);
        }
        return this;
    }
    
    /**
     * A collection of artifacts.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param artifactList A collection of artifacts.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public UpdateJobResult withArtifactList(java.util.Collection<Artifact> artifactList) {
        if (artifactList == null) {
            this.artifactList = null;
        } else {
            com.amazonaws.internal.ListWithAutoConstructFlag<Artifact> artifactListCopy = new com.amazonaws.internal.ListWithAutoConstructFlag<Artifact>(artifactList.size());
            artifactListCopy.addAll(artifactList);
            this.artifactList = artifactListCopy;
        }

        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (isSuccess() != null) sb.append("Success: " + isSuccess() + ",");
        if (getWarningMessage() != null) sb.append("WarningMessage: " + getWarningMessage() + ",");
        if (getArtifactList() != null) sb.append("ArtifactList: " + getArtifactList() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((isSuccess() == null) ? 0 : isSuccess().hashCode()); 
        hashCode = prime * hashCode + ((getWarningMessage() == null) ? 0 : getWarningMessage().hashCode()); 
        hashCode = prime * hashCode + ((getArtifactList() == null) ? 0 : getArtifactList().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof UpdateJobResult == false) return false;
        UpdateJobResult other = (UpdateJobResult)obj;
        
        if (other.isSuccess() == null ^ this.isSuccess() == null) return false;
        if (other.isSuccess() != null && other.isSuccess().equals(this.isSuccess()) == false) return false; 
        if (other.getWarningMessage() == null ^ this.getWarningMessage() == null) return false;
        if (other.getWarningMessage() != null && other.getWarningMessage().equals(this.getWarningMessage()) == false) return false; 
        if (other.getArtifactList() == null ^ this.getArtifactList() == null) return false;
        if (other.getArtifactList() != null && other.getArtifactList().equals(this.getArtifactList()) == false) return false; 
        return true;
    }
    
    @Override
    public UpdateJobResult clone() {
        try {
            return (UpdateJobResult) super.clone();
        
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(
                    "Got a CloneNotSupportedException from Object.clone() "
                    + "even though we're Cloneable!",
                    e);
        }
        
    }

}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/package-info.java

/**
 * Classes modeling the various types represented by AmazonImportExport.
 */
 package com.amazonaws.services.importexport.model;
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/ArtifactStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Artifact StAX Unmarshaller
 */
public class ArtifactStaxUnmarshaller implements Unmarshaller<Artifact, StaxUnmarshallerContext> {

    public Artifact unmarshall(StaxUnmarshallerContext context) throws Exception {
        Artifact artifact = new Artifact();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return artifact;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("Description", targetDepth)) {
                    artifact.setDescription(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("URL", targetDepth)) {
                    artifact.setURL(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return artifact;
                }
            }
        }
    }

    private static ArtifactStaxUnmarshaller instance;
    public static ArtifactStaxUnmarshaller getInstance() {
        if (instance == null) instance = new ArtifactStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/BucketPermissionExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.BucketPermissionException;

public class BucketPermissionExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public BucketPermissionExceptionUnmarshaller() {
        super(BucketPermissionException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("BucketPermissionException"))
            return null;

        BucketPermissionException e = (BucketPermissionException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CancelJobRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Cancel Job Request Marshaller
 */
public class CancelJobRequestMarshaller implements Marshaller<Request<CancelJobRequest>, CancelJobRequest> {

    public Request<CancelJobRequest> marshall(CancelJobRequest cancelJobRequest) {

        if (cancelJobRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CancelJobRequest> request = new DefaultRequest<CancelJobRequest>(cancelJobRequest, "AmazonImportExport");
        request.addParameter("Action", "CancelJob");
        request.addParameter("Version", "2010-06-01");

        if (cancelJobRequest.getJobId() != null) {
            request.addParameter("JobId", StringUtils.fromString(cancelJobRequest.getJobId()));
        }
        if (cancelJobRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(cancelJobRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CancelJobResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Cancel Job Result StAX Unmarshaller
 */
public class CancelJobResultStaxUnmarshaller implements Unmarshaller<CancelJobResult, StaxUnmarshallerContext> {

    public CancelJobResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        CancelJobResult cancelJobResult = new CancelJobResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return cancelJobResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("Success", targetDepth)) {
                    cancelJobResult.setSuccess(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return cancelJobResult;
                }
            }
        }
    }

    private static CancelJobResultStaxUnmarshaller instance;
    public static CancelJobResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new CancelJobResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CanceledJobIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.CanceledJobIdException;

public class CanceledJobIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public CanceledJobIdExceptionUnmarshaller() {
        super(CanceledJobIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("CanceledJobIdException"))
            return null;

        CanceledJobIdException e = (CanceledJobIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CreateJobQuotaExceededExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.CreateJobQuotaExceededException;

public class CreateJobQuotaExceededExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public CreateJobQuotaExceededExceptionUnmarshaller() {
        super(CreateJobQuotaExceededException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("CreateJobQuotaExceededException"))
            return null;

        CreateJobQuotaExceededException e = (CreateJobQuotaExceededException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CreateJobRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Create Job Request Marshaller
 */
public class CreateJobRequestMarshaller implements Marshaller<Request<CreateJobRequest>, CreateJobRequest> {

    public Request<CreateJobRequest> marshall(CreateJobRequest createJobRequest) {

        if (createJobRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<CreateJobRequest> request = new DefaultRequest<CreateJobRequest>(createJobRequest, "AmazonImportExport");
        request.addParameter("Action", "CreateJob");
        request.addParameter("Version", "2010-06-01");

        if (createJobRequest.getJobType() != null) {
            request.addParameter("JobType", StringUtils.fromString(createJobRequest.getJobType()));
        }
        if (createJobRequest.getManifest() != null) {
            request.addParameter("Manifest", StringUtils.fromString(createJobRequest.getManifest()));
        }
        if (createJobRequest.getManifestAddendum() != null) {
            request.addParameter("ManifestAddendum", StringUtils.fromString(createJobRequest.getManifestAddendum()));
        }
        if (createJobRequest.isValidateOnly() != null) {
            request.addParameter("ValidateOnly", StringUtils.fromBoolean(createJobRequest.isValidateOnly()));
        }
        if (createJobRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(createJobRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/CreateJobResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Create Job Result StAX Unmarshaller
 */
public class CreateJobResultStaxUnmarshaller implements Unmarshaller<CreateJobResult, StaxUnmarshallerContext> {

    public CreateJobResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        CreateJobResult createJobResult = new CreateJobResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return createJobResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("JobId", targetDepth)) {
                    createJobResult.setJobId(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("JobType", targetDepth)) {
                    createJobResult.setJobType(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("Signature", targetDepth)) {
                    createJobResult.setSignature(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("SignatureFileContents", targetDepth)) {
                    createJobResult.setSignatureFileContents(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("WarningMessage", targetDepth)) {
                    createJobResult.setWarningMessage(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ArtifactList/member", targetDepth)) {
                    createJobResult.getArtifactList().add(ArtifactStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return createJobResult;
                }
            }
        }
    }

    private static CreateJobResultStaxUnmarshaller instance;
    public static CreateJobResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new CreateJobResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/ExpiredJobIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.ExpiredJobIdException;

public class ExpiredJobIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public ExpiredJobIdExceptionUnmarshaller() {
        super(ExpiredJobIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("ExpiredJobIdException"))
            return null;

        ExpiredJobIdException e = (ExpiredJobIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/GetShippingLabelRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Get Shipping Label Request Marshaller
 */
public class GetShippingLabelRequestMarshaller implements Marshaller<Request<GetShippingLabelRequest>, GetShippingLabelRequest> {

    public Request<GetShippingLabelRequest> marshall(GetShippingLabelRequest getShippingLabelRequest) {

        if (getShippingLabelRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetShippingLabelRequest> request = new DefaultRequest<GetShippingLabelRequest>(getShippingLabelRequest, "AmazonImportExport");
        request.addParameter("Action", "GetShippingLabel");
        request.addParameter("Version", "2010-06-01");

        java.util.List<String> jobIdsList = getShippingLabelRequest.getJobIds();
        int jobIdsListIndex = 1;

        for (String jobIdsListValue : jobIdsList) {
            if (jobIdsListValue != null) {
                request.addParameter("jobIds.member." + jobIdsListIndex, StringUtils.fromString(jobIdsListValue));
            }

            jobIdsListIndex++;
        }
        if (getShippingLabelRequest.getName() != null) {
            request.addParameter("name", StringUtils.fromString(getShippingLabelRequest.getName()));
        }
        if (getShippingLabelRequest.getCompany() != null) {
            request.addParameter("company", StringUtils.fromString(getShippingLabelRequest.getCompany()));
        }
        if (getShippingLabelRequest.getPhoneNumber() != null) {
            request.addParameter("phoneNumber", StringUtils.fromString(getShippingLabelRequest.getPhoneNumber()));
        }
        if (getShippingLabelRequest.getCountry() != null) {
            request.addParameter("country", StringUtils.fromString(getShippingLabelRequest.getCountry()));
        }
        if (getShippingLabelRequest.getStateOrProvince() != null) {
            request.addParameter("stateOrProvince", StringUtils.fromString(getShippingLabelRequest.getStateOrProvince()));
        }
        if (getShippingLabelRequest.getCity() != null) {
            request.addParameter("city", StringUtils.fromString(getShippingLabelRequest.getCity()));
        }
        if (getShippingLabelRequest.getPostalCode() != null) {
            request.addParameter("postalCode", StringUtils.fromString(getShippingLabelRequest.getPostalCode()));
        }
        if (getShippingLabelRequest.getStreet1() != null) {
            request.addParameter("street1", StringUtils.fromString(getShippingLabelRequest.getStreet1()));
        }
        if (getShippingLabelRequest.getStreet2() != null) {
            request.addParameter("street2", StringUtils.fromString(getShippingLabelRequest.getStreet2()));
        }
        if (getShippingLabelRequest.getStreet3() != null) {
            request.addParameter("street3", StringUtils.fromString(getShippingLabelRequest.getStreet3()));
        }
        if (getShippingLabelRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(getShippingLabelRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/GetShippingLabelResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Get Shipping Label Result StAX Unmarshaller
 */
public class GetShippingLabelResultStaxUnmarshaller implements Unmarshaller<GetShippingLabelResult, StaxUnmarshallerContext> {

    public GetShippingLabelResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        GetShippingLabelResult getShippingLabelResult = new GetShippingLabelResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return getShippingLabelResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("ShippingLabelURL", targetDepth)) {
                    getShippingLabelResult.setShippingLabelURL(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("Warning", targetDepth)) {
                    getShippingLabelResult.setWarning(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return getShippingLabelResult;
                }
            }
        }
    }

    private static GetShippingLabelResultStaxUnmarshaller instance;
    public static GetShippingLabelResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new GetShippingLabelResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/GetStatusRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Get Status Request Marshaller
 */
public class GetStatusRequestMarshaller implements Marshaller<Request<GetStatusRequest>, GetStatusRequest> {

    public Request<GetStatusRequest> marshall(GetStatusRequest getStatusRequest) {

        if (getStatusRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<GetStatusRequest> request = new DefaultRequest<GetStatusRequest>(getStatusRequest, "AmazonImportExport");
        request.addParameter("Action", "GetStatus");
        request.addParameter("Version", "2010-06-01");

        if (getStatusRequest.getJobId() != null) {
            request.addParameter("JobId", StringUtils.fromString(getStatusRequest.getJobId()));
        }
        if (getStatusRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(getStatusRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/GetStatusResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Get Status Result StAX Unmarshaller
 */
public class GetStatusResultStaxUnmarshaller implements Unmarshaller<GetStatusResult, StaxUnmarshallerContext> {

    public GetStatusResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        GetStatusResult getStatusResult = new GetStatusResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return getStatusResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("JobId", targetDepth)) {
                    getStatusResult.setJobId(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("JobType", targetDepth)) {
                    getStatusResult.setJobType(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("LocationCode", targetDepth)) {
                    getStatusResult.setLocationCode(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("LocationMessage", targetDepth)) {
                    getStatusResult.setLocationMessage(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ProgressCode", targetDepth)) {
                    getStatusResult.setProgressCode(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ProgressMessage", targetDepth)) {
                    getStatusResult.setProgressMessage(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("Carrier", targetDepth)) {
                    getStatusResult.setCarrier(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("TrackingNumber", targetDepth)) {
                    getStatusResult.setTrackingNumber(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("LogBucket", targetDepth)) {
                    getStatusResult.setLogBucket(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("LogKey", targetDepth)) {
                    getStatusResult.setLogKey(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ErrorCount", targetDepth)) {
                    getStatusResult.setErrorCount(IntegerStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("Signature", targetDepth)) {
                    getStatusResult.setSignature(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("SignatureFileContents", targetDepth)) {
                    getStatusResult.setSignatureFileContents(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("CurrentManifest", targetDepth)) {
                    getStatusResult.setCurrentManifest(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("CreationDate", targetDepth)) {
                    getStatusResult.setCreationDate(DateStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ArtifactList/member", targetDepth)) {
                    getStatusResult.getArtifactList().add(ArtifactStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return getStatusResult;
                }
            }
        }
    }

    private static GetStatusResultStaxUnmarshaller instance;
    public static GetStatusResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new GetStatusResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidAccessKeyIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidAccessKeyIdException;

public class InvalidAccessKeyIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidAccessKeyIdExceptionUnmarshaller() {
        super(InvalidAccessKeyIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidAccessKeyIdException"))
            return null;

        InvalidAccessKeyIdException e = (InvalidAccessKeyIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidAddressExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidAddressException;

public class InvalidAddressExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidAddressExceptionUnmarshaller() {
        super(InvalidAddressException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidAddressException"))
            return null;

        InvalidAddressException e = (InvalidAddressException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidCustomsExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidCustomsException;

public class InvalidCustomsExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidCustomsExceptionUnmarshaller() {
        super(InvalidCustomsException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidCustomsException"))
            return null;

        InvalidCustomsException e = (InvalidCustomsException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidFileSystemExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidFileSystemException;

public class InvalidFileSystemExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidFileSystemExceptionUnmarshaller() {
        super(InvalidFileSystemException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidFileSystemException"))
            return null;

        InvalidFileSystemException e = (InvalidFileSystemException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidJobIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidJobIdException;

public class InvalidJobIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidJobIdExceptionUnmarshaller() {
        super(InvalidJobIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidJobIdException"))
            return null;

        InvalidJobIdException e = (InvalidJobIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidManifestFieldExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidManifestFieldException;

public class InvalidManifestFieldExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidManifestFieldExceptionUnmarshaller() {
        super(InvalidManifestFieldException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidManifestFieldException"))
            return null;

        InvalidManifestFieldException e = (InvalidManifestFieldException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidParameterExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidParameterException;

public class InvalidParameterExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidParameterExceptionUnmarshaller() {
        super(InvalidParameterException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidParameterException"))
            return null;

        InvalidParameterException e = (InvalidParameterException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/InvalidVersionExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.InvalidVersionException;

public class InvalidVersionExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public InvalidVersionExceptionUnmarshaller() {
        super(InvalidVersionException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("InvalidVersionException"))
            return null;

        InvalidVersionException e = (InvalidVersionException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/JobStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Job StAX Unmarshaller
 */
public class JobStaxUnmarshaller implements Unmarshaller<Job, StaxUnmarshallerContext> {

    public Job unmarshall(StaxUnmarshallerContext context) throws Exception {
        Job job = new Job();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return job;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("JobId", targetDepth)) {
                    job.setJobId(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("CreationDate", targetDepth)) {
                    job.setCreationDate(DateStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("IsCanceled", targetDepth)) {
                    job.setIsCanceled(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("JobType", targetDepth)) {
                    job.setJobType(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return job;
                }
            }
        }
    }

    private static JobStaxUnmarshaller instance;
    public static JobStaxUnmarshaller getInstance() {
        if (instance == null) instance = new JobStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/ListJobsRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * List Jobs Request Marshaller
 */
public class ListJobsRequestMarshaller implements Marshaller<Request<ListJobsRequest>, ListJobsRequest> {

    public Request<ListJobsRequest> marshall(ListJobsRequest listJobsRequest) {

        if (listJobsRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<ListJobsRequest> request = new DefaultRequest<ListJobsRequest>(listJobsRequest, "AmazonImportExport");
        request.addParameter("Action", "ListJobs");
        request.addParameter("Version", "2010-06-01");

        if (listJobsRequest.getMaxJobs() != null) {
            request.addParameter("MaxJobs", StringUtils.fromInteger(listJobsRequest.getMaxJobs()));
        }
        if (listJobsRequest.getMarker() != null) {
            request.addParameter("Marker", StringUtils.fromString(listJobsRequest.getMarker()));
        }
        if (listJobsRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(listJobsRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/ListJobsResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * List Jobs Result StAX Unmarshaller
 */
public class ListJobsResultStaxUnmarshaller implements Unmarshaller<ListJobsResult, StaxUnmarshallerContext> {

    public ListJobsResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        ListJobsResult listJobsResult = new ListJobsResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return listJobsResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("Jobs/member", targetDepth)) {
                    listJobsResult.getJobs().add(JobStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("IsTruncated", targetDepth)) {
                    listJobsResult.setIsTruncated(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return listJobsResult;
                }
            }
        }
    }

    private static ListJobsResultStaxUnmarshaller instance;
    public static ListJobsResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new ListJobsResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/MalformedManifestExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.MalformedManifestException;

public class MalformedManifestExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public MalformedManifestExceptionUnmarshaller() {
        super(MalformedManifestException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("MalformedManifestException"))
            return null;

        MalformedManifestException e = (MalformedManifestException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/MissingCustomsExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.MissingCustomsException;

public class MissingCustomsExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public MissingCustomsExceptionUnmarshaller() {
        super(MissingCustomsException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("MissingCustomsException"))
            return null;

        MissingCustomsException e = (MissingCustomsException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/MissingManifestFieldExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.MissingManifestFieldException;

public class MissingManifestFieldExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public MissingManifestFieldExceptionUnmarshaller() {
        super(MissingManifestFieldException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("MissingManifestFieldException"))
            return null;

        MissingManifestFieldException e = (MissingManifestFieldException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/MissingParameterExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.MissingParameterException;

public class MissingParameterExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public MissingParameterExceptionUnmarshaller() {
        super(MissingParameterException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("MissingParameterException"))
            return null;

        MissingParameterException e = (MissingParameterException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/MultipleRegionsExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.MultipleRegionsException;

public class MultipleRegionsExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public MultipleRegionsExceptionUnmarshaller() {
        super(MultipleRegionsException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("MultipleRegionsException"))
            return null;

        MultipleRegionsException e = (MultipleRegionsException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/NoSuchBucketExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.NoSuchBucketException;

public class NoSuchBucketExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public NoSuchBucketExceptionUnmarshaller() {
        super(NoSuchBucketException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("NoSuchBucketException"))
            return null;

        NoSuchBucketException e = (NoSuchBucketException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/UnableToCancelJobIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.UnableToCancelJobIdException;

public class UnableToCancelJobIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public UnableToCancelJobIdExceptionUnmarshaller() {
        super(UnableToCancelJobIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("UnableToCancelJobIdException"))
            return null;

        UnableToCancelJobIdException e = (UnableToCancelJobIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/UnableToUpdateJobIdExceptionUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.importexport.model.UnableToUpdateJobIdException;

public class UnableToUpdateJobIdExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public UnableToUpdateJobIdExceptionUnmarshaller() {
        super(UnableToUpdateJobIdException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("UnableToUpdateJobIdException"))
            return null;

        UnableToUpdateJobIdException e = (UnableToUpdateJobIdException)super.unmarshall(node);
        
        return e;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/UpdateJobRequestMarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.importexport.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.internal.ListWithAutoConstructFlag;
import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Update Job Request Marshaller
 */
public class UpdateJobRequestMarshaller implements Marshaller<Request<UpdateJobRequest>, UpdateJobRequest> {

    public Request<UpdateJobRequest> marshall(UpdateJobRequest updateJobRequest) {

        if (updateJobRequest == null) {
            throw new AmazonClientException("Invalid argument passed to marshall(...)");
        }

        Request<UpdateJobRequest> request = new DefaultRequest<UpdateJobRequest>(updateJobRequest, "AmazonImportExport");
        request.addParameter("Action", "UpdateJob");
        request.addParameter("Version", "2010-06-01");

        if (updateJobRequest.getJobId() != null) {
            request.addParameter("JobId", StringUtils.fromString(updateJobRequest.getJobId()));
        }
        if (updateJobRequest.getManifest() != null) {
            request.addParameter("Manifest", StringUtils.fromString(updateJobRequest.getManifest()));
        }
        if (updateJobRequest.getJobType() != null) {
            request.addParameter("JobType", StringUtils.fromString(updateJobRequest.getJobType()));
        }
        if (updateJobRequest.isValidateOnly() != null) {
            request.addParameter("ValidateOnly", StringUtils.fromBoolean(updateJobRequest.isValidateOnly()));
        }
        if (updateJobRequest.getAPIVersion() != null) {
            request.addParameter("APIVersion", StringUtils.fromString(updateJobRequest.getAPIVersion()));
        }

        return request;
    }
}


File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/UpdateJobResultStaxUnmarshaller.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.importexport.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.importexport.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;

/**
 * Update Job Result StAX Unmarshaller
 */
public class UpdateJobResultStaxUnmarshaller implements Unmarshaller<UpdateJobResult, StaxUnmarshallerContext> {

    public UpdateJobResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        UpdateJobResult updateJobResult = new UpdateJobResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        if (context.isStartOfDocument()) targetDepth += 2;

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return updateJobResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("Success", targetDepth)) {
                    updateJobResult.setSuccess(BooleanStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("WarningMessage", targetDepth)) {
                    updateJobResult.setWarningMessage(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("ArtifactList/member", targetDepth)) {
                    updateJobResult.getArtifactList().add(ArtifactStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return updateJobResult;
                }
            }
        }
    }

    private static UpdateJobResultStaxUnmarshaller instance;
    public static UpdateJobResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new UpdateJobResultStaxUnmarshaller();
        return instance;
    }
}
    

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/model/transform/package-info.java

/**
 * Marhsalling for the various types represented by AmazonImportExport.
 */
 package com.amazonaws.services.importexport.model.transform;
        

File: aws-java-sdk-importexport/src/main/java/com/amazonaws/services/importexport/package-info.java

/**
 * Synchronous and asynchronous client classes for accessing AmazonImportExport.
 *
 * AWS Import/Export Service <p>
 * AWS Import/Export accelerates transferring large amounts of data
 * between the AWS cloud and portable storage devices that you mail to
 * us. AWS Import/Export transfers data directly onto and off of your
 * storage devices using Amazon's high-speed internal network and
 * bypassing the Internet. For large data sets, AWS Import/Export is
 * often faster than Internet transfer and more cost effective than
 * upgrading your connectivity.
 * </p>
 */
 package com.amazonaws.services.importexport;
        

File: aws-java-sdk-lambda/src/main/java/com/amazonaws/services/lambda/model/AddPermissionRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.lambda.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.lambda.AWSLambda#addPermission(AddPermissionRequest) AddPermission operation}.
 * <p>
 * Adds a permission to the access policy associated with the specified
 * AWS Lambda function. In a "push event" model, the access policy
 * attached to the Lambda function grants Amazon S3 or a user application
 * permission for the Lambda <code>lambda:Invoke</code> action. For
 * information about the push model, see
 * <a href="http://docs.aws.amazon.com/lambda/latest/dg/lambda-introduction.html"> AWS Lambda: How it Works </a>
 * . Each Lambda function has one access policy associated with it. You
 * can use the <code>AddPermission</code> API to add a permission to the
 * policy. You have one access policy but it can have multiple permission
 * statements.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>lambda:AddPermission</code> action.
 * </p>
 *
 * @see com.amazonaws.services.lambda.AWSLambda#addPermission(AddPermissionRequest)
 */
public class AddPermissionRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * Name of the Lambda function whose access policy you are updating by
     * adding a new permission. <p> You can specify an unqualified function
     * name (for example, "Thumbnail") or you can specify Amazon Resource
     * Name (ARN) of the function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     */
    private String functionName;

    /**
     * A unique statement identifier.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 100<br/>
     * <b>Pattern: </b>([a-zA-Z0-9-_]+)<br/>
     */
    private String statementId;

    /**
     * The AWS Lambda action you want to allow in this statement. Each Lambda
     * action is a string starting with "lambda:" followed by the API name
     * (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     * use wildcard ("lambda:*") to grant permission for all AWS Lambda
     * actions.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>(lambda:[*]|lambda:[a-zA-Z]+|[*])<br/>
     */
    private String action;

    /**
     * The principal who is getting this permission. It can be Amazon S3
     * service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     * the function, an AWS account ID if you are granting cross-account
     * permission, or any valid AWS service principal such as
     * "sns.amazonaws.com". For example, you might want to allow a custom
     * application in another AWS account to push events to AWS Lambda by
     * invoking your function.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>.*<br/>
     */
    private String principal;

    /**
     * This is optional; however, when granting Amazon S3 permission to
     * invoke your function, you should specify this field with the bucket
     * Amazon Resource Name (ARN) as its value. This ensures that only events
     * generated from the specified bucket can invoke the function.
     * <important>If you add a permission for the Amazon S3 principal without
     * providing the source ARN, any AWS account that creates a mapping to
     * your function ARN can send events to invoke your Lambda function from
     * Amazon S3.</important>
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     */
    private String sourceArn;

    /**
     * The AWS account ID (without a hyphen) of the source owner. If the
     * <code>SourceArn</code> identifies a bucket, then this is the bucket
     * owner's account ID. You can use this additional condition to ensure
     * the bucket you specify is owned by a specific account (it is possible
     * the bucket owner deleted the bucket and some other AWS account created
     * the bucket). You can also use this condition to specify all sources
     * (that is, you don't specify the <code>SourceArn</code>) owned by a
     * specific account.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\d{12}<br/>
     */
    private String sourceAccount;

    /**
     * Name of the Lambda function whose access policy you are updating by
     * adding a new permission. <p> You can specify an unqualified function
     * name (for example, "Thumbnail") or you can specify Amazon Resource
     * Name (ARN) of the function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @return Name of the Lambda function whose access policy you are updating by
     *         adding a new permission. <p> You can specify an unqualified function
     *         name (for example, "Thumbnail") or you can specify Amazon Resource
     *         Name (ARN) of the function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     */
    public String getFunctionName() {
        return functionName;
    }
    
    /**
     * Name of the Lambda function whose access policy you are updating by
     * adding a new permission. <p> You can specify an unqualified function
     * name (for example, "Thumbnail") or you can specify Amazon Resource
     * Name (ARN) of the function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @param functionName Name of the Lambda function whose access policy you are updating by
     *         adding a new permission. <p> You can specify an unqualified function
     *         name (for example, "Thumbnail") or you can specify Amazon Resource
     *         Name (ARN) of the function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     */
    public void setFunctionName(String functionName) {
        this.functionName = functionName;
    }
    
    /**
     * Name of the Lambda function whose access policy you are updating by
     * adding a new permission. <p> You can specify an unqualified function
     * name (for example, "Thumbnail") or you can specify Amazon Resource
     * Name (ARN) of the function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @param functionName Name of the Lambda function whose access policy you are updating by
     *         adding a new permission. <p> You can specify an unqualified function
     *         name (for example, "Thumbnail") or you can specify Amazon Resource
     *         Name (ARN) of the function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withFunctionName(String functionName) {
        this.functionName = functionName;
        return this;
    }

    /**
     * A unique statement identifier.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 100<br/>
     * <b>Pattern: </b>([a-zA-Z0-9-_]+)<br/>
     *
     * @return A unique statement identifier.
     */
    public String getStatementId() {
        return statementId;
    }
    
    /**
     * A unique statement identifier.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 100<br/>
     * <b>Pattern: </b>([a-zA-Z0-9-_]+)<br/>
     *
     * @param statementId A unique statement identifier.
     */
    public void setStatementId(String statementId) {
        this.statementId = statementId;
    }
    
    /**
     * A unique statement identifier.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 100<br/>
     * <b>Pattern: </b>([a-zA-Z0-9-_]+)<br/>
     *
     * @param statementId A unique statement identifier.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withStatementId(String statementId) {
        this.statementId = statementId;
        return this;
    }

    /**
     * The AWS Lambda action you want to allow in this statement. Each Lambda
     * action is a string starting with "lambda:" followed by the API name
     * (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     * use wildcard ("lambda:*") to grant permission for all AWS Lambda
     * actions.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>(lambda:[*]|lambda:[a-zA-Z]+|[*])<br/>
     *
     * @return The AWS Lambda action you want to allow in this statement. Each Lambda
     *         action is a string starting with "lambda:" followed by the API name
     *         (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     *         use wildcard ("lambda:*") to grant permission for all AWS Lambda
     *         actions.
     */
    public String getAction() {
        return action;
    }
    
    /**
     * The AWS Lambda action you want to allow in this statement. Each Lambda
     * action is a string starting with "lambda:" followed by the API name
     * (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     * use wildcard ("lambda:*") to grant permission for all AWS Lambda
     * actions.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>(lambda:[*]|lambda:[a-zA-Z]+|[*])<br/>
     *
     * @param action The AWS Lambda action you want to allow in this statement. Each Lambda
     *         action is a string starting with "lambda:" followed by the API name
     *         (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     *         use wildcard ("lambda:*") to grant permission for all AWS Lambda
     *         actions.
     */
    public void setAction(String action) {
        this.action = action;
    }
    
    /**
     * The AWS Lambda action you want to allow in this statement. Each Lambda
     * action is a string starting with "lambda:" followed by the API name
     * (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     * use wildcard ("lambda:*") to grant permission for all AWS Lambda
     * actions.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>(lambda:[*]|lambda:[a-zA-Z]+|[*])<br/>
     *
     * @param action The AWS Lambda action you want to allow in this statement. Each Lambda
     *         action is a string starting with "lambda:" followed by the API name
     *         (see <a>Operations</a>). For example, "lambda:CreateFunction". You can
     *         use wildcard ("lambda:*") to grant permission for all AWS Lambda
     *         actions.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withAction(String action) {
        this.action = action;
        return this;
    }

    /**
     * The principal who is getting this permission. It can be Amazon S3
     * service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     * the function, an AWS account ID if you are granting cross-account
     * permission, or any valid AWS service principal such as
     * "sns.amazonaws.com". For example, you might want to allow a custom
     * application in another AWS account to push events to AWS Lambda by
     * invoking your function.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>.*<br/>
     *
     * @return The principal who is getting this permission. It can be Amazon S3
     *         service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     *         the function, an AWS account ID if you are granting cross-account
     *         permission, or any valid AWS service principal such as
     *         "sns.amazonaws.com". For example, you might want to allow a custom
     *         application in another AWS account to push events to AWS Lambda by
     *         invoking your function.
     */
    public String getPrincipal() {
        return principal;
    }
    
    /**
     * The principal who is getting this permission. It can be Amazon S3
     * service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     * the function, an AWS account ID if you are granting cross-account
     * permission, or any valid AWS service principal such as
     * "sns.amazonaws.com". For example, you might want to allow a custom
     * application in another AWS account to push events to AWS Lambda by
     * invoking your function.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>.*<br/>
     *
     * @param principal The principal who is getting this permission. It can be Amazon S3
     *         service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     *         the function, an AWS account ID if you are granting cross-account
     *         permission, or any valid AWS service principal such as
     *         "sns.amazonaws.com". For example, you might want to allow a custom
     *         application in another AWS account to push events to AWS Lambda by
     *         invoking your function.
     */
    public void setPrincipal(String principal) {
        this.principal = principal;
    }
    
    /**
     * The principal who is getting this permission. It can be Amazon S3
     * service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     * the function, an AWS account ID if you are granting cross-account
     * permission, or any valid AWS service principal such as
     * "sns.amazonaws.com". For example, you might want to allow a custom
     * application in another AWS account to push events to AWS Lambda by
     * invoking your function.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>.*<br/>
     *
     * @param principal The principal who is getting this permission. It can be Amazon S3
     *         service Principal ("s3.amazonaws.com") if you want Amazon S3 to invoke
     *         the function, an AWS account ID if you are granting cross-account
     *         permission, or any valid AWS service principal such as
     *         "sns.amazonaws.com". For example, you might want to allow a custom
     *         application in another AWS account to push events to AWS Lambda by
     *         invoking your function.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withPrincipal(String principal) {
        this.principal = principal;
        return this;
    }

    /**
     * This is optional; however, when granting Amazon S3 permission to
     * invoke your function, you should specify this field with the bucket
     * Amazon Resource Name (ARN) as its value. This ensures that only events
     * generated from the specified bucket can invoke the function.
     * <important>If you add a permission for the Amazon S3 principal without
     * providing the source ARN, any AWS account that creates a mapping to
     * your function ARN can send events to invoke your Lambda function from
     * Amazon S3.</important>
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @return This is optional; however, when granting Amazon S3 permission to
     *         invoke your function, you should specify this field with the bucket
     *         Amazon Resource Name (ARN) as its value. This ensures that only events
     *         generated from the specified bucket can invoke the function.
     *         <important>If you add a permission for the Amazon S3 principal without
     *         providing the source ARN, any AWS account that creates a mapping to
     *         your function ARN can send events to invoke your Lambda function from
     *         Amazon S3.</important>
     */
    public String getSourceArn() {
        return sourceArn;
    }
    
    /**
     * This is optional; however, when granting Amazon S3 permission to
     * invoke your function, you should specify this field with the bucket
     * Amazon Resource Name (ARN) as its value. This ensures that only events
     * generated from the specified bucket can invoke the function.
     * <important>If you add a permission for the Amazon S3 principal without
     * providing the source ARN, any AWS account that creates a mapping to
     * your function ARN can send events to invoke your Lambda function from
     * Amazon S3.</important>
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @param sourceArn This is optional; however, when granting Amazon S3 permission to
     *         invoke your function, you should specify this field with the bucket
     *         Amazon Resource Name (ARN) as its value. This ensures that only events
     *         generated from the specified bucket can invoke the function.
     *         <important>If you add a permission for the Amazon S3 principal without
     *         providing the source ARN, any AWS account that creates a mapping to
     *         your function ARN can send events to invoke your Lambda function from
     *         Amazon S3.</important>
     */
    public void setSourceArn(String sourceArn) {
        this.sourceArn = sourceArn;
    }
    
    /**
     * This is optional; however, when granting Amazon S3 permission to
     * invoke your function, you should specify this field with the bucket
     * Amazon Resource Name (ARN) as its value. This ensures that only events
     * generated from the specified bucket can invoke the function.
     * <important>If you add a permission for the Amazon S3 principal without
     * providing the source ARN, any AWS account that creates a mapping to
     * your function ARN can send events to invoke your Lambda function from
     * Amazon S3.</important>
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @param sourceArn This is optional; however, when granting Amazon S3 permission to
     *         invoke your function, you should specify this field with the bucket
     *         Amazon Resource Name (ARN) as its value. This ensures that only events
     *         generated from the specified bucket can invoke the function.
     *         <important>If you add a permission for the Amazon S3 principal without
     *         providing the source ARN, any AWS account that creates a mapping to
     *         your function ARN can send events to invoke your Lambda function from
     *         Amazon S3.</important>
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withSourceArn(String sourceArn) {
        this.sourceArn = sourceArn;
        return this;
    }

    /**
     * The AWS account ID (without a hyphen) of the source owner. If the
     * <code>SourceArn</code> identifies a bucket, then this is the bucket
     * owner's account ID. You can use this additional condition to ensure
     * the bucket you specify is owned by a specific account (it is possible
     * the bucket owner deleted the bucket and some other AWS account created
     * the bucket). You can also use this condition to specify all sources
     * (that is, you don't specify the <code>SourceArn</code>) owned by a
     * specific account.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\d{12}<br/>
     *
     * @return The AWS account ID (without a hyphen) of the source owner. If the
     *         <code>SourceArn</code> identifies a bucket, then this is the bucket
     *         owner's account ID. You can use this additional condition to ensure
     *         the bucket you specify is owned by a specific account (it is possible
     *         the bucket owner deleted the bucket and some other AWS account created
     *         the bucket). You can also use this condition to specify all sources
     *         (that is, you don't specify the <code>SourceArn</code>) owned by a
     *         specific account.
     */
    public String getSourceAccount() {
        return sourceAccount;
    }
    
    /**
     * The AWS account ID (without a hyphen) of the source owner. If the
     * <code>SourceArn</code> identifies a bucket, then this is the bucket
     * owner's account ID. You can use this additional condition to ensure
     * the bucket you specify is owned by a specific account (it is possible
     * the bucket owner deleted the bucket and some other AWS account created
     * the bucket). You can also use this condition to specify all sources
     * (that is, you don't specify the <code>SourceArn</code>) owned by a
     * specific account.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\d{12}<br/>
     *
     * @param sourceAccount The AWS account ID (without a hyphen) of the source owner. If the
     *         <code>SourceArn</code> identifies a bucket, then this is the bucket
     *         owner's account ID. You can use this additional condition to ensure
     *         the bucket you specify is owned by a specific account (it is possible
     *         the bucket owner deleted the bucket and some other AWS account created
     *         the bucket). You can also use this condition to specify all sources
     *         (that is, you don't specify the <code>SourceArn</code>) owned by a
     *         specific account.
     */
    public void setSourceAccount(String sourceAccount) {
        this.sourceAccount = sourceAccount;
    }
    
    /**
     * The AWS account ID (without a hyphen) of the source owner. If the
     * <code>SourceArn</code> identifies a bucket, then this is the bucket
     * owner's account ID. You can use this additional condition to ensure
     * the bucket you specify is owned by a specific account (it is possible
     * the bucket owner deleted the bucket and some other AWS account created
     * the bucket). You can also use this condition to specify all sources
     * (that is, you don't specify the <code>SourceArn</code>) owned by a
     * specific account.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\d{12}<br/>
     *
     * @param sourceAccount The AWS account ID (without a hyphen) of the source owner. If the
     *         <code>SourceArn</code> identifies a bucket, then this is the bucket
     *         owner's account ID. You can use this additional condition to ensure
     *         the bucket you specify is owned by a specific account (it is possible
     *         the bucket owner deleted the bucket and some other AWS account created
     *         the bucket). You can also use this condition to specify all sources
     *         (that is, you don't specify the <code>SourceArn</code>) owned by a
     *         specific account.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public AddPermissionRequest withSourceAccount(String sourceAccount) {
        this.sourceAccount = sourceAccount;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getFunctionName() != null) sb.append("FunctionName: " + getFunctionName() + ",");
        if (getStatementId() != null) sb.append("StatementId: " + getStatementId() + ",");
        if (getAction() != null) sb.append("Action: " + getAction() + ",");
        if (getPrincipal() != null) sb.append("Principal: " + getPrincipal() + ",");
        if (getSourceArn() != null) sb.append("SourceArn: " + getSourceArn() + ",");
        if (getSourceAccount() != null) sb.append("SourceAccount: " + getSourceAccount() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getFunctionName() == null) ? 0 : getFunctionName().hashCode()); 
        hashCode = prime * hashCode + ((getStatementId() == null) ? 0 : getStatementId().hashCode()); 
        hashCode = prime * hashCode + ((getAction() == null) ? 0 : getAction().hashCode()); 
        hashCode = prime * hashCode + ((getPrincipal() == null) ? 0 : getPrincipal().hashCode()); 
        hashCode = prime * hashCode + ((getSourceArn() == null) ? 0 : getSourceArn().hashCode()); 
        hashCode = prime * hashCode + ((getSourceAccount() == null) ? 0 : getSourceAccount().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof AddPermissionRequest == false) return false;
        AddPermissionRequest other = (AddPermissionRequest)obj;
        
        if (other.getFunctionName() == null ^ this.getFunctionName() == null) return false;
        if (other.getFunctionName() != null && other.getFunctionName().equals(this.getFunctionName()) == false) return false; 
        if (other.getStatementId() == null ^ this.getStatementId() == null) return false;
        if (other.getStatementId() != null && other.getStatementId().equals(this.getStatementId()) == false) return false; 
        if (other.getAction() == null ^ this.getAction() == null) return false;
        if (other.getAction() != null && other.getAction().equals(this.getAction()) == false) return false; 
        if (other.getPrincipal() == null ^ this.getPrincipal() == null) return false;
        if (other.getPrincipal() != null && other.getPrincipal().equals(this.getPrincipal()) == false) return false; 
        if (other.getSourceArn() == null ^ this.getSourceArn() == null) return false;
        if (other.getSourceArn() != null && other.getSourceArn().equals(this.getSourceArn()) == false) return false; 
        if (other.getSourceAccount() == null ^ this.getSourceAccount() == null) return false;
        if (other.getSourceAccount() != null && other.getSourceAccount().equals(this.getSourceAccount()) == false) return false; 
        return true;
    }
    
    @Override
    public AddPermissionRequest clone() {
        
            return (AddPermissionRequest) super.clone();
    }

}
    

File: aws-java-sdk-lambda/src/main/java/com/amazonaws/services/lambda/model/CreateEventSourceMappingRequest.java
/*
 * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.lambda.model;

import java.io.Serializable;

import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.lambda.AWSLambda#createEventSourceMapping(CreateEventSourceMappingRequest) CreateEventSourceMapping operation}.
 * <p>
 * Identifies a stream as an event source for a Lambda function. It can
 * be either an Amazon Kinesis stream or an Amazon DynamoDB stream. AWS
 * Lambda invokes the specified function when records are posted to the
 * stream.
 * </p>
 * <p>
 * This is the pull model, where AWS Lambda invokes the function. For
 * more information, go to
 * <a href="http://docs.aws.amazon.com/lambda/latest/dg/lambda-introduction.html"> AWS Lambda: How it Works </a>
 * in the <i>AWS Lambda Developer Guide</i> .
 * </p>
 * <p>
 * This association between an Amazon Kinesis stream and a Lambda
 * function is called the event source mapping. You provide the
 * configuration information (for example, which stream to read from and
 * which Lambda function to invoke) for the event source mapping in the
 * request body.
 * </p>
 * <p>
 * Each event source, such as an Amazon Kinesis or a DynamoDB stream,
 * can be associated with multiple AWS Lambda function. A given Lambda
 * function can be associated with multiple AWS event sources.
 * </p>
 * <p>
 * This operation requires permission for the
 * <code>lambda:CreateEventSourceMapping</code> action.
 * </p>
 *
 * @see com.amazonaws.services.lambda.AWSLambda#createEventSourceMapping(CreateEventSourceMappingRequest)
 */
public class CreateEventSourceMappingRequest extends AmazonWebServiceRequest implements Serializable, Cloneable {

    /**
     * The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     * DynamoDB stream that is the event source. Any record added to this
     * stream could cause AWS Lambda to invoke your Lambda function, it
     * depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     * Kinesis event, containing records, to your Lambda function as JSON.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     */
    private String eventSourceArn;

    /**
     * The Lambda function to invoke when AWS Lambda detects an event on the
     * stream. <p> You can specify an unqualified function name (for example,
     * "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     * function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     */
    private String functionName;

    /**
     * Indicates whether AWS Lambda should begin polling the event source.
     */
    private Boolean enabled;

    /**
     * The largest number of records that AWS Lambda will retrieve from your
     * event source at the time of invoking your function. Your function
     * receives an event with all the retrieved records. The default is 100
     * records.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - 10000<br/>
     */
    private Integer batchSize;

    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     */
    private String startingPosition;

    /**
     * The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     * DynamoDB stream that is the event source. Any record added to this
     * stream could cause AWS Lambda to invoke your Lambda function, it
     * depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     * Kinesis event, containing records, to your Lambda function as JSON.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @return The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     *         DynamoDB stream that is the event source. Any record added to this
     *         stream could cause AWS Lambda to invoke your Lambda function, it
     *         depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     *         Kinesis event, containing records, to your Lambda function as JSON.
     */
    public String getEventSourceArn() {
        return eventSourceArn;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     * DynamoDB stream that is the event source. Any record added to this
     * stream could cause AWS Lambda to invoke your Lambda function, it
     * depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     * Kinesis event, containing records, to your Lambda function as JSON.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @param eventSourceArn The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     *         DynamoDB stream that is the event source. Any record added to this
     *         stream could cause AWS Lambda to invoke your Lambda function, it
     *         depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     *         Kinesis event, containing records, to your Lambda function as JSON.
     */
    public void setEventSourceArn(String eventSourceArn) {
        this.eventSourceArn = eventSourceArn;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     * DynamoDB stream that is the event source. Any record added to this
     * stream could cause AWS Lambda to invoke your Lambda function, it
     * depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     * Kinesis event, containing records, to your Lambda function as JSON.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>arn:aws:([a-zA-Z0-9\-])+:([a-z]{2}-[a-z]+-\d{1})?:(\d{12})?:(.*)<br/>
     *
     * @param eventSourceArn The Amazon Resource Name (ARN) of the Amazon Kinesis or the Amazon
     *         DynamoDB stream that is the event source. Any record added to this
     *         stream could cause AWS Lambda to invoke your Lambda function, it
     *         depends on the <code>BatchSize</code>. AWS Lambda POSTs the Amazon
     *         Kinesis event, containing records, to your Lambda function as JSON.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateEventSourceMappingRequest withEventSourceArn(String eventSourceArn) {
        this.eventSourceArn = eventSourceArn;
        return this;
    }

    /**
     * The Lambda function to invoke when AWS Lambda detects an event on the
     * stream. <p> You can specify an unqualified function name (for example,
     * "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     * function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @return The Lambda function to invoke when AWS Lambda detects an event on the
     *         stream. <p> You can specify an unqualified function name (for example,
     *         "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     *         function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     */
    public String getFunctionName() {
        return functionName;
    }
    
    /**
     * The Lambda function to invoke when AWS Lambda detects an event on the
     * stream. <p> You can specify an unqualified function name (for example,
     * "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     * function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @param functionName The Lambda function to invoke when AWS Lambda detects an event on the
     *         stream. <p> You can specify an unqualified function name (for example,
     *         "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     *         function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     */
    public void setFunctionName(String functionName) {
        this.functionName = functionName;
    }
    
    /**
     * The Lambda function to invoke when AWS Lambda detects an event on the
     * stream. <p> You can specify an unqualified function name (for example,
     * "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     * function (for example,
     * "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     * also allows you to specify only the account ID qualifier (for example,
     * "account-id:Thumbnail"). Note that the length constraint applies only
     * to the ARN. If you specify only the function name, it is limited to 64
     * character in length.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 111<br/>
     * <b>Pattern: </b>(arn:aws:lambda:)?([a-z]{2}-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)<br/>
     *
     * @param functionName The Lambda function to invoke when AWS Lambda detects an event on the
     *         stream. <p> You can specify an unqualified function name (for example,
     *         "Thumbnail") or you can specify Amazon Resource Name (ARN) of the
     *         function (for example,
     *         "arn:aws:lambda:us-west-2:account-id:function:ThumbNail"). AWS Lambda
     *         also allows you to specify only the account ID qualifier (for example,
     *         "account-id:Thumbnail"). Note that the length constraint applies only
     *         to the ARN. If you specify only the function name, it is limited to 64
     *         character in length.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateEventSourceMappingRequest withFunctionName(String functionName) {
        this.functionName = functionName;
        return this;
    }

    /**
     * Indicates whether AWS Lambda should begin polling the event source.
     *
     * @return Indicates whether AWS Lambda should begin polling the event source.
     */
    public Boolean isEnabled() {
        return enabled;
    }
    
    /**
     * Indicates whether AWS Lambda should begin polling the event source.
     *
     * @param enabled Indicates whether AWS Lambda should begin polling the event source.
     */
    public void setEnabled(Boolean enabled) {
        this.enabled = enabled;
    }
    
    /**
     * Indicates whether AWS Lambda should begin polling the event source.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param enabled Indicates whether AWS Lambda should begin polling the event source.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateEventSourceMappingRequest withEnabled(Boolean enabled) {
        this.enabled = enabled;
        return this;
    }

    /**
     * Indicates whether AWS Lambda should begin polling the event source.
     *
     * @return Indicates whether AWS Lambda should begin polling the event source.
     */
    public Boolean getEnabled() {
        return enabled;
    }

    /**
     * The largest number of records that AWS Lambda will retrieve from your
     * event source at the time of invoking your function. Your function
     * receives an event with all the retrieved records. The default is 100
     * records.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - 10000<br/>
     *
     * @return The largest number of records that AWS Lambda will retrieve from your
     *         event source at the time of invoking your function. Your function
     *         receives an event with all the retrieved records. The default is 100
     *         records.
     */
    public Integer getBatchSize() {
        return batchSize;
    }
    
    /**
     * The largest number of records that AWS Lambda will retrieve from your
     * event source at the time of invoking your function. Your function
     * receives an event with all the retrieved records. The default is 100
     * records.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - 10000<br/>
     *
     * @param batchSize The largest number of records that AWS Lambda will retrieve from your
     *         event source at the time of invoking your function. Your function
     *         receives an event with all the retrieved records. The default is 100
     *         records.
     */
    public void setBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
    }
    
    /**
     * The largest number of records that AWS Lambda will retrieve from your
     * event source at the time of invoking your function. Your function
     * receives an event with all the retrieved records. The default is 100
     * records.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Range: </b>1 - 10000<br/>
     *
     * @param batchSize The largest number of records that AWS Lambda will retrieve from your
     *         event source at the time of invoking your function. Your function
     *         receives an event with all the retrieved records. The default is 100
     *         records.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     */
    public CreateEventSourceMappingRequest withBatchSize(Integer batchSize) {
        this.batchSize = batchSize;
        return this;
    }

    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     *
     * @return The position in the stream where AWS Lambda should start reading. For
     *         more information, go to <a
     *         href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     *         in the <i>Amazon Kinesis API Reference</i>.
     *
     * @see EventSourcePosition
     */
    public String getStartingPosition() {
        return startingPosition;
    }
    
    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     *
     * @param startingPosition The position in the stream where AWS Lambda should start reading. For
     *         more information, go to <a
     *         href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     *         in the <i>Amazon Kinesis API Reference</i>.
     *
     * @see EventSourcePosition
     */
    public void setStartingPosition(String startingPosition) {
        this.startingPosition = startingPosition;
    }
    
    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     *
     * @param startingPosition The position in the stream where AWS Lambda should start reading. For
     *         more information, go to <a
     *         href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     *         in the <i>Amazon Kinesis API Reference</i>.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see EventSourcePosition
     */
    public CreateEventSourceMappingRequest withStartingPosition(String startingPosition) {
        this.startingPosition = startingPosition;
        return this;
    }

    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     *
     * @param startingPosition The position in the stream where AWS Lambda should start reading. For
     *         more information, go to <a
     *         href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     *         in the <i>Amazon Kinesis API Reference</i>.
     *
     * @see EventSourcePosition
     */
    public void setStartingPosition(EventSourcePosition startingPosition) {
        this.startingPosition = startingPosition.toString();
    }
    
    /**
     * The position in the stream where AWS Lambda should start reading. For
     * more information, go to <a
     * href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     * in the <i>Amazon Kinesis API Reference</i>.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>TRIM_HORIZON, LATEST
     *
     * @param startingPosition The position in the stream where AWS Lambda should start reading. For
     *         more information, go to <a
     *         href="http://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType">ShardIteratorType</a>
     *         in the <i>Amazon Kinesis API Reference</i>.
     *
     * @return A reference to this updated object so that method calls can be chained
     *         together.
     *
     * @see EventSourcePosition
     */
    public CreateEventSourceMappingRequest withStartingPosition(EventSourcePosition startingPosition) {
        this.startingPosition = startingPosition.toString();
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (getEventSourceArn() != null) sb.append("EventSourceArn: " + getEventSourceArn() + ",");
        if (getFunctionName() != null) sb.append("FunctionName: " + getFunctionName() + ",");
        if (isEnabled() != null) sb.append("Enabled: " + isEnabled() + ",");
        if (getBatchSize() != null) sb.append("BatchSize: " + getBatchSize() + ",");
        if (getStartingPosition() != null) sb.append("StartingPosition: " + getStartingPosition() );
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getEventSourceArn() == null) ? 0 : getEventSourceArn().hashCode()); 
        hashCode = prime * hashCode + ((getFunctionName() == null) ? 0 : getFunctionName().hashCode()); 
        hashCode = prime * hashCode + ((isEnabled() == null) ? 0 : isEnabled().hashCode()); 
        hashCode = prime * hashCode + ((getBatchSize() == null) ? 0 : getBatchSize().hashCode()); 
        hashCode = prime * hashCode + ((getStartingPosition() == null) ? 0 : getStartingPosition().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;

        if (obj instanceof CreateEventSourceMappingRequest == false) return false;
        CreateEventSourceMappingRequest other = (CreateEventSourceMappingRequest)obj;
        
        if (other.getEventSourceArn() == null ^ this.getEventSourceArn() == null) return false;
        if (other.getEventSourceArn() != null && other.getEventSourceArn().equals(this.getEventSourceArn()) == false) return false; 
        if (other.getFunctionName() == null ^ this.getFunctionName() == null) return false;
        if (other.getFunctionName() != null && other.getFunctionName().equals(this.getFunctionName()) == false) return false; 
        if (other.isEnabled() == null ^ this.isEnabled() == null) return false;
        if (other.isEnabled() != null && other.isEnabled().equals(this.isEnabled()) == false) return false; 
        if (other.getBatchSize() == null ^ this.getBatchSize() == null) return false;
        if (other.getBatchSize() != null && other.getBatchSize().equals(this.getBatchSize()) == false) return false; 
        if (other.getStartingPosition() == null ^ this.getStartingPosition() == null) return false;
        if (other.getStartingPosition() != null && other.getStartingPosition().equals(this.getStartingPosition()) == false) return false; 
        return true;
    }
    
    @Override
    public CreateEventSourceMappingRequest clone() {
        
            return (CreateEventSourceMappingRequest) super.clone();
    }

}
    