Refactoring Types: ['Extract Method']
/org/neo4j/helpers/NamedThreadFactory.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.helpers;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class NamedThreadFactory implements ThreadFactory
{
    public interface Monitor
    {
        void threadCreated( String threadNamePrefix );

        void threadFinished( String threadNamePrefix );
    }

    private static final Monitor NO_OP_MONITOR = new Monitor()
    {
        @Override
        public void threadCreated( String threadNamePrefix )
        {
        }

        @Override
        public void threadFinished( String threadNamePrefix )
        {
        }
    };

    private static final int DEFAULT_THREAD_PRIORITY = Thread.NORM_PRIORITY;

    private final ThreadGroup group;
    private final AtomicInteger threadCounter = new AtomicInteger( 1 );
    private String threadNamePrefix;
    private final int priority;
    private final boolean daemon;
    private final Monitor monitor;

    public NamedThreadFactory( String threadNamePrefix )
    {
        this( threadNamePrefix, DEFAULT_THREAD_PRIORITY );
    }

    public NamedThreadFactory( String threadNamePrefix, int priority )
    {
        this( threadNamePrefix, priority, NO_OP_MONITOR );
    }

    public NamedThreadFactory( String threadNamePrefix, Monitor monitor )
    {
        this( threadNamePrefix, DEFAULT_THREAD_PRIORITY, monitor );
    }

    public NamedThreadFactory( String threadNamePrefix, int priority, Monitor monitor )
    {
        this( threadNamePrefix, priority, monitor, false );
    }

    public NamedThreadFactory( String threadNamePrefix, int priority, Monitor monitor, boolean daemon )
    {
        this.threadNamePrefix = threadNamePrefix;
        SecurityManager securityManager = System.getSecurityManager();
        group = (securityManager != null) ?
                securityManager.getThreadGroup() :
                Thread.currentThread().getThreadGroup();
        this.priority = priority;
        this.daemon = daemon;
        this.monitor = monitor;
    }

    public Thread newThread( Runnable runnable )
    {
        int id = threadCounter.getAndIncrement();

        Thread result = new Thread( group, runnable, threadNamePrefix + "-" + id )
        {
            @Override
            public void run()
            {
                try
                {
                    super.run();
                }
                finally
                {
                    monitor.threadFinished( threadNamePrefix );
                }
            }
        };

        result.setDaemon( daemon );
        result.setPriority( priority );
        monitor.threadCreated( threadNamePrefix );
        return result;
    }

    public static NamedThreadFactory named( String threadNamePrefix )
    {
        return new NamedThreadFactory( threadNamePrefix );
    }

    public static NamedThreadFactory named( String threadNamePrefix, int priority )
    {
        return new NamedThreadFactory( threadNamePrefix, priority );
    }

    public static NamedThreadFactory daemon( String threadNamePrefix )
    {
        return daemon( threadNamePrefix, NO_OP_MONITOR );
    }

    public static NamedThreadFactory daemon( String threadNamePrefix, Monitor monitor )
    {
        return new NamedThreadFactory( threadNamePrefix, DEFAULT_THREAD_PRIORITY, monitor, true );
    }
}


File: community/kernel/src/main/java/org/neo4j/kernel/impl/cache/MonitorGc.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.cache;

import org.neo4j.graphdb.config.Setting;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.lifecycle.Lifecycle;
import org.neo4j.logging.Log;

import static org.neo4j.helpers.Settings.DURATION;
import static org.neo4j.helpers.Settings.setting;

public class MonitorGc implements Lifecycle
{
    public static class Configuration
    {
        public static final Setting<Long> gc_monitor_wait_time = setting( "gc_monitor_wait_time", DURATION, "100ms" );
        public static final Setting<Long> gc_monitor_threshold = setting("gc_monitor_threshold", DURATION, "200ms" );
    }

    private final Config config;
    private final Log log;
    private volatile MeasureDoNothing monitorGc;

    public MonitorGc( Config config, Log log )
    {
        this.config = config;
        this.log = log;
    }

    @Override
    public void init() throws Throwable
    {
    }

    @Override
    public void start() throws Throwable
    {
        monitorGc = new MeasureDoNothing( "GC-Monitor", log, config.get( Configuration.gc_monitor_wait_time ),
                config.get( Configuration.gc_monitor_threshold ) );
        monitorGc.start();
    }

    @Override
    public void stop() throws Throwable
    {
        monitorGc.stopMeasuring();
        monitorGc = null;
    }

    @Override
    public void shutdown() throws Throwable
    {
    }

}


File: community/kernel/src/main/java/org/neo4j/kernel/impl/factory/PlatformModule.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.factory;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.neo4j.function.Consumer;
import org.neo4j.function.Supplier;
import org.neo4j.graphdb.DependencyResolver;
import org.neo4j.graphdb.factory.GraphDatabaseSettings;
import org.neo4j.helpers.Clock;
import org.neo4j.helpers.collection.Iterables;
import org.neo4j.io.fs.FileSystemAbstraction;
import org.neo4j.io.pagecache.PageCache;
import org.neo4j.kernel.AvailabilityGuard;
import org.neo4j.kernel.DefaultFileSystemAbstraction;
import org.neo4j.kernel.StoreLocker;
import org.neo4j.kernel.StoreLockerLifecycleAdapter;
import org.neo4j.kernel.Version;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.extension.KernelExtensionFactory;
import org.neo4j.kernel.extension.KernelExtensions;
import org.neo4j.kernel.extension.UnsatisfiedDependencyStrategies;
import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.kernel.impl.logging.StoreLogService;
import org.neo4j.kernel.impl.pagecache.ConfiguringPageCacheFactory;
import org.neo4j.kernel.impl.pagecache.PageCacheLifecycle;
import org.neo4j.kernel.impl.spi.KernelContext;
import org.neo4j.kernel.impl.transaction.TransactionCounters;
import org.neo4j.kernel.impl.transaction.state.DataSourceManager;
import org.neo4j.kernel.impl.util.JobScheduler;
import org.neo4j.kernel.impl.util.Neo4jJobScheduler;
import org.neo4j.kernel.info.DiagnosticsManager;
import org.neo4j.kernel.info.JvmChecker;
import org.neo4j.kernel.info.JvmMetadataRepository;
import org.neo4j.kernel.lifecycle.LifeSupport;
import org.neo4j.kernel.monitoring.Monitors;
import org.neo4j.kernel.monitoring.tracing.Tracers;
import org.neo4j.logging.Log;
import org.neo4j.logging.LogProvider;
import org.neo4j.udc.UsageData;
import org.neo4j.udc.UsageDataKeys;

/**
 * Platform module for {@link org.neo4j.kernel.impl.factory.GraphDatabaseFacadeFactory}. This creates
 * all the services needed by {@link org.neo4j.kernel.impl.factory.EditionModule} implementations.
 */
public class PlatformModule
{
    public final PageCache pageCache;

    public final Monitors monitors;

    public final GraphDatabaseFacade graphDatabaseFacade;

    public final org.neo4j.kernel.impl.util.Dependencies dependencies;

    public final LogService logging;

    public final LifeSupport life;

    public final File storeDir;

    public final DiagnosticsManager diagnosticsManager;

    public final Tracers tracers;

    public final Config config;

    public final FileSystemAbstraction fileSystem;

    public final DataSourceManager dataSourceManager;

    public final KernelExtensions kernelExtensions;

    public final JobScheduler jobScheduler;

    public final AvailabilityGuard availabilityGuard;

    public final TransactionCounters transactionMonitor;

    public PlatformModule( File storeDir, Map<String, String> params, final GraphDatabaseFacadeFactory.Dependencies externalDependencies,
                                                  final GraphDatabaseFacade graphDatabaseFacade)
    {
        dependencies = new org.neo4j.kernel.impl.util.Dependencies( new Supplier<DependencyResolver>()
        {
            @Override
            public DependencyResolver get()
            {
                return dataSourceManager.getDataSource().getDependencyResolver();
            }
        } );
        life = dependencies.satisfyDependency( createLife() );
        this.graphDatabaseFacade = dependencies.satisfyDependency( graphDatabaseFacade );

        // SPI - provided services
        config = dependencies.satisfyDependency( new Config( params, getSettingsClasses(
                externalDependencies.settingsClasses(), externalDependencies.kernelExtensions() ) ) );

        this.storeDir = storeDir.getAbsoluteFile();

        // Database system information, used by UDC
        dependencies.satisfyDependency( new UsageData() );

        fileSystem = life.add( dependencies.satisfyDependency( createFileSystemAbstraction() ) );

        // Component monitoring
        monitors = externalDependencies.monitors() == null ? new Monitors() : externalDependencies.monitors();
        dependencies.satisfyDependency( monitors );

        jobScheduler = life.add( dependencies.satisfyDependency( createJobScheduler() ) );

        // If no logging was passed in from the outside then create logging and register
        // with this life
        logging = life.add( dependencies.satisfyDependency( createLogService( externalDependencies.userLogProvider() ) ) );

        config.setLogger( logging.getInternalLog( Config.class ) );

        life.add( dependencies.satisfyDependency( new StoreLockerLifecycleAdapter( new StoreLocker( fileSystem ), storeDir ) ));

        new JvmChecker( logging.getInternalLog( JvmChecker.class ),
                new JvmMetadataRepository() ).checkJvmCompatibilityAndIssueWarning();

        String desiredImplementationName = config.get( GraphDatabaseFacadeFactory.Configuration.tracer );
        tracers = dependencies.satisfyDependency(
                new Tracers( desiredImplementationName, logging.getInternalLog( Tracers.class ) ) );
        dependencies.satisfyDependency( tracers.pageCacheTracer );

        pageCache = dependencies.satisfyDependency( createPageCache( fileSystem, config, logging, tracers ) );
        life.add( new PageCacheLifecycle( pageCache ) );

        diagnosticsManager = life.add( dependencies.satisfyDependency( new DiagnosticsManager( logging.getInternalLog(
                DiagnosticsManager.class ) ) ) );

        // TODO please fix the bad dependencies instead of doing this. Before the removal of JTA
        // this was the place of the XaDataSourceManager. NeoStoreXaDataSource is create further down than
        // (specifically) KernelExtensions, which creates an interesting out-of-order issue with #doAfterRecovery().
        // Anyways please fix this.
        dataSourceManager = life.add( dependencies.satisfyDependency( new DataSourceManager() ) );

        availabilityGuard = new AvailabilityGuard( Clock.SYSTEM_CLOCK );

        transactionMonitor = dependencies.satisfyDependency( createTransactionCounters() );

        KernelContext kernelContext = new KernelContext()
        {
            @Override
            public FileSystemAbstraction fileSystem()
            {
                return PlatformModule.this.fileSystem;
            }

            @Override
            public File storeDir()
            {
                return PlatformModule.this.storeDir;
            }
        };

        kernelExtensions = dependencies.satisfyDependency( new KernelExtensions(
                kernelContext,
                externalDependencies.kernelExtensions(),
                dependencies,
                UnsatisfiedDependencyStrategies.fail() ) );

        publishPlatformInfo( dependencies.resolveDependency( UsageData.class ) );
    }

    private void publishPlatformInfo( UsageData sysInfo )
    {
        sysInfo.set( UsageDataKeys.version, Version.getKernel().getReleaseVersion() );
        sysInfo.set( UsageDataKeys.revision, Version.getKernel().getVersion() );
        sysInfo.set( UsageDataKeys.operationalMode, UsageDataKeys.OperationalMode.ha );
    }

    public LifeSupport createLife()
    {
        return new LifeSupport();
    }

    protected FileSystemAbstraction createFileSystemAbstraction()
    {
        return new DefaultFileSystemAbstraction();
    }

    protected LogService createLogService( LogProvider userLogProvider )
    {
        long internalLogRotationThreshold = config.get( GraphDatabaseSettings.store_internal_log_rotation_threshold );
        int internalLogRotationDelay = config.get( GraphDatabaseSettings.store_internal_log_rotation_delay );
        int internalLogMaxArchives = config.get( GraphDatabaseSettings.store_internal_log_max_archives );

        final StoreLogService.Builder builder =
                StoreLogService.withRotation( internalLogRotationThreshold, internalLogRotationDelay,
                        internalLogMaxArchives, jobScheduler );

        if ( userLogProvider != null )
        {
            builder.withUserLogProvider( userLogProvider );
        }

        builder.withRotationListener( new Consumer<LogProvider>()
        {
            @Override
            public void accept( LogProvider logProvider )
            {
                diagnosticsManager.dumpAll( logProvider.getLog( DiagnosticsManager.class ) );
            }
        } );

        File internalLog = config.get( GraphDatabaseSettings.store_internal_log_location );
        LogService logService;
        try
        {
            if ( internalLog == null )
            {
                logService = builder.inStoreDirectory( fileSystem, storeDir );
            }
            else
            {
                logService = builder.toFile( fileSystem, internalLog );
            }
        }
        catch ( IOException ex )
        {
            throw new RuntimeException( ex );
        }
        return life.add( logService );
    }

    protected Neo4jJobScheduler createJobScheduler()
    {
        return new Neo4jJobScheduler( config.get( GraphDatabaseFacadeFactory.Configuration.editionName ) );
    }

    protected PageCache createPageCache( FileSystemAbstraction fileSystem,
            Config config,
            LogService logging,
            Tracers tracers )
    {
        Log pageCacheLog = logging.getInternalLog( PageCache.class );
        ConfiguringPageCacheFactory pageCacheFactory = new ConfiguringPageCacheFactory(
                fileSystem, config, tracers.pageCacheTracer, pageCacheLog );
        PageCache pageCache = pageCacheFactory.getOrCreatePageCache();

        if ( config.get( GraphDatabaseSettings.dump_configuration ) )
        {
            pageCacheFactory.dumpConfiguration();
        }
        return pageCache;
    }

    protected TransactionCounters createTransactionCounters()
    {
        return new TransactionCounters();
    }

    private Iterable<Class<?>> getSettingsClasses( Iterable<Class<?>> settingsClasses,
            Iterable<KernelExtensionFactory<?>> kernelExtensions )
    {
        List<Class<?>> totalSettingsClasses = Iterables.toList( settingsClasses );

        // Get the list of settings classes for extensions
        for ( KernelExtensionFactory<?> kernelExtension : kernelExtensions )
        {
            if ( kernelExtension.getSettingsClass() != null )
            {
                totalSettingsClasses.add( kernelExtension.getSettingsClass() );
            }
        }

        return totalSettingsClasses;
    }
}


File: community/kernel/src/main/java/org/neo4j/kernel/impl/util/JobScheduler.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.util;

import java.util.Collections;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.neo4j.kernel.lifecycle.Lifecycle;

import static org.neo4j.kernel.impl.util.JobScheduler.SchedulingStrategy.NEW_THREAD;
import static org.neo4j.kernel.impl.util.JobScheduler.SchedulingStrategy.POOLED;

/**
 * To be expanded, the idea here is to have a database-global service for running jobs, handling jobs crashing and so on.
 */
public interface JobScheduler extends Lifecycle
{
    enum SchedulingStrategy
    {
        /** Create a new thread each time a job is scheduled */
        NEW_THREAD,
        /** Run the job from a pool of threads, shared among all groups with this strategy */
        POOLED
    }

    /**
     * Represents a common group of jobs, defining how they should be scheduled.
     */
    class Group
    {
        public static final String THREAD_ID = "thread-id";
        public static final Map<String, String> NO_METADATA = Collections.EMPTY_MAP;

        private final String name;
        private final SchedulingStrategy strategy;
        private final AtomicInteger threadCounter = new AtomicInteger( 0 );

        public Group( String name, SchedulingStrategy strategy )
        {
            this.name = name;
            this.strategy = strategy;
        }

        public String name()
        {
            return name;
        }

        public SchedulingStrategy strategy()
        {
            return strategy;
        }

        /**
         * Name a new thread. This method may or may not be used, it is up to the scheduling strategy to decide
         * to honor this.
         * @param metadata comes from {@link #schedule(Group, Runnable, Map)}
         */
        public String threadName( Map<String, String> metadata )
        {
            if ( metadata.containsKey( THREAD_ID ) )
            {
                return "neo4j." + name() + "/" + metadata.get( THREAD_ID );
            }
            return "neo4j." + name() + "/" + threadCounter.incrementAndGet();
        }

    }

    /**
     * This is an exhaustive list of job types that run in the database. It should be expanded as needed for new groups
     * of jobs.
     *
     * For now, this does naming only, but it will allow us to define per-group configuration, such as how to handle
     * failures, shared threads and (later on) affinity strategies.
     */
    class Groups
    {
        /** Session workers, these perform the work of actually executing client queries.  */
        public static final Group sessionWorker = new Group( "Session", NEW_THREAD );

        /** Background index population */
        public static final Group indexPopulation = new Group( "IndexPopulation", POOLED );

        /** Push transactions from master to slaves */
        public static final Group masterTransactionPushing = new Group( "TransactionPushing", POOLED );

        /**
         * Rolls back idle transactions on the server.
         */
        public static final Group serverTransactionTimeout = new Group( "ServerTransactionTimeout", POOLED );

        /**
         * Aborts idle slave lock sessions on the master.
         */
        public static final Group slaveLocksTimeout = new Group( "SlaveLocksTimeout", POOLED );

        /**
         * Pulls updates from the master.
         */
        public static final Group pullUpdates = new Group( "PullUpdates", POOLED );

        /**
         * Gathers approximated data about the underlying data store.
         */
        public static final Group indexSamplingController = new Group( "IndexSamplingController", POOLED );
        public static final Group indexSampling = new Group( "IndexSampling", POOLED );
        public static final Group pageCacheEviction = new Group( "PageCacheEviction", POOLED );

        /**
         * Rotates internal diagnostic logs
         */
        public static final Group internalLogRotation = new Group( "InternalLogRotation", POOLED );

        /**
         * Checkpoint and store flush
         */
        public static final Group checkPoint = new Group( "CheckPoint", POOLED );
    }

    interface JobHandle
    {
        void cancel( boolean mayInterruptIfRunning );
    }

    /** Expose a group scheduler as an {@link Executor} */
    Executor executor( Group group );

    /** Schedule a new job in the specified group. */
    JobHandle schedule( Group group, Runnable job );

    /** Schedule a new job in the specified group, passing in metadata for the scheduling strategy to use. */
    JobHandle schedule( Group group, Runnable job, Map<String, String> metadata );

    /** Schedule a new job in the specified group with the given delay */
    JobHandle schedule( Group group, Runnable runnable, long initialDelay, TimeUnit timeUnit );

    /** Schedule a recurring job */
    JobHandle scheduleRecurring( Group group, Runnable runnable, long period, TimeUnit timeUnit );

    /** Schedule a recurring job where the first invocation is delayed the specified time */
    JobHandle scheduleRecurring( Group group, Runnable runnable, long initialDelay, long period, TimeUnit timeUnit );
}


File: community/kernel/src/main/java/org/neo4j/kernel/impl/util/Neo4jJobScheduler.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.util;

import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.neo4j.kernel.lifecycle.LifecycleAdapter;

import static java.util.concurrent.Executors.newCachedThreadPool;
import static org.neo4j.helpers.NamedThreadFactory.daemon;
import static org.neo4j.kernel.impl.util.DebugUtil.trackTest;
import static org.neo4j.kernel.impl.util.JobScheduler.Group.NO_METADATA;

public class Neo4jJobScheduler extends LifecycleAdapter implements JobScheduler
{
    private final String id;

    private ExecutorService globalPool;
    private ScheduledThreadPoolExecutor scheduledExecutor;

    public Neo4jJobScheduler()
    {
        this.id = getClass().getSimpleName();
    }

    public Neo4jJobScheduler( String id )
    {
        this.id = id;
    }

    @Override
    public void init()
    {
        this.globalPool = newCachedThreadPool( daemon( "neo4j.pooled/" + id + trackTest() ) );
        this.scheduledExecutor = new ScheduledThreadPoolExecutor( 2, daemon( "neo4j.scheduled/" + id + trackTest() ) );
    }

    @Override
    public Executor executor( final Group group )
    {
        return new Executor()
        {
            @Override
            public void execute( Runnable command )
            {
                schedule( group, command );
            }
        };
    }

    @Override
    public JobHandle schedule( Group group, Runnable job )
    {
        return schedule( group, job, NO_METADATA );
    }

    @Override
    public JobHandle schedule( Group group, Runnable job, Map<String,String> metadata )
    {
        if (globalPool == null)
            throw new RejectedExecutionException( "Scheduler is not started" );

        switch( group.strategy() )
        {
        case POOLED:
            return new PooledJobHandle( this.globalPool.submit( job ) );
        case NEW_THREAD:
            Thread thread = new Thread( null, job, group.threadName( metadata ) );
            thread.setDaemon( true );
            thread.start();
            return new SingleThreadHandle( thread );
        default:
            throw new IllegalArgumentException( "Unsupported strategy for scheduling job: " + group.strategy() );
        }
    }

    @Override
    public JobHandle scheduleRecurring( Group group, final Runnable runnable, long period, TimeUnit timeUnit )
    {
        return scheduleRecurring( group, runnable, 0, period, timeUnit );
    }

    @Override
    public JobHandle scheduleRecurring( Group group, final Runnable runnable, long initialDelay, long period,
                                        TimeUnit timeUnit )
    {
        switch ( group.strategy() )
        {
        case POOLED:
            return new PooledJobHandle( scheduledExecutor.scheduleAtFixedRate( runnable, initialDelay, period, timeUnit ) );
        default:
            throw new IllegalArgumentException( "Unsupported strategy to use for recurring jobs: " + group.strategy() );
        }
    }

    @Override
    public JobHandle schedule( Group group, final Runnable runnable, long initialDelay, TimeUnit timeUnit )
    {
        switch ( group.strategy() )
        {
        case POOLED:
            return new PooledJobHandle( scheduledExecutor.schedule( runnable, initialDelay, timeUnit ) );
        default:
            throw new IllegalArgumentException( "Unsupported strategy to use for delayed jobs: " + group.strategy() );
        }
    }

    @Override
    public void shutdown()
    {
        RuntimeException exception = null;
        try
        {
            if( globalPool != null)
            {
                globalPool.shutdownNow();
                globalPool.awaitTermination( 5, TimeUnit.SECONDS );
                globalPool = null;
            }
        } catch(RuntimeException e)
        {
            exception = e;
        }
        catch ( InterruptedException e )
        {
            exception = new RuntimeException(e);
        }

        try
        {
            if(scheduledExecutor != null)
            {
                scheduledExecutor.shutdown();
                scheduledExecutor.awaitTermination( 5, TimeUnit.SECONDS );
                scheduledExecutor = null;
            }
        } catch(RuntimeException e)
        {
            exception = e;
        }
        catch ( InterruptedException e )
        {
            exception = new RuntimeException(e);
        }

        if(exception != null)
        {
            throw new RuntimeException( "Unable to shut down job scheduler properly.", exception);
        }
    }

    private static class PooledJobHandle implements JobHandle
    {
        private final Future<?> job;

        public PooledJobHandle( Future<?> job )
        {
            this.job = job;
        }

        @Override
        public void cancel( boolean mayInterruptIfRunning )
        {
            job.cancel( mayInterruptIfRunning );
        }
    }

    private static class SingleThreadHandle implements JobHandle
    {
        private final Thread thread;

        public SingleThreadHandle( Thread thread )
        {
            this.thread = thread;
        }

        @Override
        public void cancel( boolean mayInterruptIfRunning )
        {
            if ( mayInterruptIfRunning )
            {
                thread.interrupt();
            }
        }
    }
}


File: community/kernel/src/test/java/org/neo4j/kernel/impl/util/Neo4jJobSchedulerTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.kernel.impl.util;

import org.junit.After;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import org.neo4j.kernel.lifecycle.LifeSupport;

import static java.lang.Thread.sleep;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static junit.framework.TestCase.fail;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.neo4j.helpers.Exceptions.launderedException;
import static org.neo4j.helpers.collection.MapUtil.stringMap;
import static org.neo4j.kernel.impl.util.JobScheduler.Group.THREAD_ID;
import static org.neo4j.kernel.impl.util.JobScheduler.Groups.indexPopulation;
import static org.neo4j.kernel.impl.util.JobScheduler.SchedulingStrategy.NEW_THREAD;
import static org.neo4j.kernel.impl.util.JobScheduler.SchedulingStrategy.POOLED;

public class Neo4jJobSchedulerTest
{
    private final AtomicInteger invocations = new AtomicInteger();
    private final LifeSupport life = new LifeSupport();
    private Neo4jJobScheduler scheduler = life.add( new Neo4jJobScheduler() );

    private Runnable countInvocationsJob = new Runnable()
    {
        @Override
        public void run()
        {
            try
            {
                invocations.incrementAndGet();
            }
            catch ( Throwable e )
            {
                e.printStackTrace();
                throw launderedException( e );
            }
        }
    };

    @After
    public void stopScheduler() throws Throwable
    {
        scheduler.shutdown();
    }

    @Test
    public void shouldRunRecurringJob() throws Throwable
    {
        // Given
        long period = 1_000;
        int count = 2;
        life.start();

        // When
        scheduler.scheduleRecurring( indexPopulation, countInvocationsJob, period, MILLISECONDS );
        awaitFirstInvocation();
        sleep( period * count - period / 2 );
        scheduler.shutdown();

        // Then
        int actualInvocations = invocations.get();
        assertEquals( count, actualInvocations );

        sleep( period );
        assertThat( invocations.get(), equalTo( actualInvocations ) );
    }

    @Test
    public void shouldCancelRecurringJob() throws Exception
    {
        // Given
        long period = 2;
        life.start();
        JobScheduler.JobHandle jobHandle = scheduler.scheduleRecurring(
                indexPopulation,
                countInvocationsJob,
                period,
                MILLISECONDS );
        awaitFirstInvocation();

        // When
        jobHandle.cancel( false );

        // Then
        int recorded = invocations.get();
        sleep( period * 100 );
        assertThat( invocations.get(), equalTo( recorded ) );
    }

    @Test
    public void shouldRunJobInNewThread() throws Throwable
    {
        // Given
        life.start();

        // We start a thread that will signal when it's running, and remain running until we tell it to stop.
        // This way we can check and make sure a thread with the name we expect is live and well
        final CountDownLatch threadStarted = new CountDownLatch( 1 );
        final CountDownLatch unblockThread = new CountDownLatch( 1 );

        // When
        scheduler.schedule( new JobScheduler.Group( "MyGroup", NEW_THREAD ),
                waitForLatch( threadStarted, unblockThread ),
                stringMap( THREAD_ID, "MyTestThread" ) );
        threadStarted.await();

        // Then
        try
        {
            String threadName = "neo4j.MyGroup/MyTestThread";
            for ( String name : threadNames() )
            {
                if ( name.equals( threadName ) )
                {
                    return;
                }
            }
            fail( "Expected a thread named '" + threadName + "' in " + threadNames() );

        }
        finally
        {
            unblockThread.countDown();
        }
    }

    @Test
    public void shouldRunWithDelay() throws Throwable
    {
        // Given
        life.start();

        final AtomicLong runTime = new AtomicLong();
        final CountDownLatch latch = new CountDownLatch( 1 );

        long time = System.currentTimeMillis();

        scheduler.schedule( new JobScheduler.Group( "group", POOLED ), new Runnable()
        {
            @Override
            public void run()
            {
                runTime.set( System.currentTimeMillis() );
                latch.countDown();
            }
        }, 100, TimeUnit.MILLISECONDS );

        latch.await();

        assertTrue( time + 100 <= runTime.get() );
    }

    private List<String> threadNames()
    {
        List<String> names = new ArrayList<>();
        for ( Thread thread : Thread.getAllStackTraces().keySet() )
        {
            names.add( thread.getName() );
        }
        return names;
    }

    private Runnable waitForLatch( final CountDownLatch threadStarted, final CountDownLatch runUntil )
    {
        return new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    threadStarted.countDown();
                    runUntil.await();
                }
                catch ( InterruptedException e )
                {
                    throw new RuntimeException( e );
                }
            }
        };
    }

    private void awaitFirstInvocation()
    {
        while ( invocations.get() == 0 )
        {   // Wait for the job to start running
            Thread.yield();
        }
    }
}


File: community/kernel/src/test/java/org/neo4j/test/OnDemandJobScheduler.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.test;

import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

import org.neo4j.kernel.impl.util.JobScheduler;
import org.neo4j.kernel.lifecycle.LifecycleAdapter;

import static org.neo4j.kernel.impl.util.JobScheduler.Group.*;

public class OnDemandJobScheduler extends LifecycleAdapter implements JobScheduler
{
    private Runnable job;

    @Override
    public Executor executor( Group group )
    {
        return new Executor()
        {
            @Override
            public void execute( Runnable command )
            {
                job = command;
            }
        };
    }

    @Override
    public JobHandle schedule( Group group, Runnable job )
    {
        return this.schedule( group, job, NO_METADATA );
    }

    @Override
    public JobHandle schedule( Group group, Runnable job, Map<String,String> metadata )
    {
        this.job = job;
        return new OnDemandJobHandle();
    }

    @Override
    public JobHandle schedule( Group group, Runnable job, long initialDelay, TimeUnit timeUnit )
    {
        this.job = job;
        return new OnDemandJobHandle();
    }

    @Override
    public JobHandle scheduleRecurring( Group group, Runnable runnable, long period, TimeUnit timeUnit )
    {
        this.job = runnable;
        return new OnDemandJobHandle();
    }

    @Override
    public JobHandle scheduleRecurring( Group group, Runnable runnable, long initialDelay,
            long period, TimeUnit timeUnit )
    {
        this.job = runnable;
        return new OnDemandJobHandle();
    }

    public Runnable getJob()
    {
        return job;
    }

    public void runJob()
    {
        job.run();
    }

    private class OnDemandJobHandle implements JobHandle
    {
        @Override
        public void cancel( boolean mayInterruptIfRunning )
        {
            job = null;
        }
    }
}


File: community/lucene-index/src/test/java/org/neo4j/index/impl/lucene/NonUniqueIndexTests.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.index.impl.lucene;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.LockSupport;

import org.junit.Rule;
import org.junit.Test;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Transaction;
import org.neo4j.graphdb.factory.GraphDatabaseFactoryState;
import org.neo4j.helpers.collection.IteratorUtil;
import org.neo4j.kernel.api.impl.index.DirectoryFactory;
import org.neo4j.kernel.api.impl.index.LuceneSchemaIndexProvider;
import org.neo4j.kernel.api.index.IndexAccessor;
import org.neo4j.kernel.api.index.IndexConfiguration;
import org.neo4j.kernel.api.index.IndexReader;
import org.neo4j.kernel.api.index.SchemaIndexProvider;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.impl.api.index.sampling.IndexSamplingConfig;
import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.kernel.impl.factory.CommunityFacadeFactory;
import org.neo4j.kernel.impl.factory.GraphDatabaseFacade;
import org.neo4j.kernel.impl.factory.PlatformModule;
import org.neo4j.kernel.impl.util.Neo4jJobScheduler;
import org.neo4j.kernel.impl.logging.NullLogService;
import org.neo4j.logging.LogProvider;
import org.neo4j.test.TargetDirectory;
import org.neo4j.test.TargetDirectory.TestDirectory;

import static java.util.Collections.singletonList;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;

import static org.neo4j.graphdb.DynamicLabel.label;
import static org.neo4j.helpers.collection.MapUtil.stringMap;

public class NonUniqueIndexTests
{
    @Rule
    public final TestDirectory directory = TargetDirectory.forTest( getClass() ).testDirectory();

    @Test
    public void concurrentIndexPopulationAndInsertsShouldNotProduceDuplicates() throws IOException
    {
        // Given
        GraphDatabaseService db = newEmbeddedGraphDatabaseWithSlowJobScheduler();

        // When
        try ( Transaction tx = db.beginTx() )
        {
            db.schema().indexFor( label( "SomeLabel" ) ).on( "key" ).create();
            tx.success();
        }
        Node node;
        try ( Transaction tx = db.beginTx() )
        {
            node = db.createNode( label( "SomeLabel" ) );
            node.setProperty( "key", "value" );
            tx.success();
        }
        db.shutdown();

        // Then
        assertThat( nodeIdsInIndex( 1, "value" ), equalTo( singletonList( node.getId() ) ) );
    }

    private GraphDatabaseService newEmbeddedGraphDatabaseWithSlowJobScheduler()
    {
        GraphDatabaseFactoryState graphDatabaseFactoryState = new GraphDatabaseFactoryState();
        graphDatabaseFactoryState.setUserLogProvider( NullLogService.getInstance().getUserLogProvider() );
        return new CommunityFacadeFactory()
        {
            @Override
            protected PlatformModule createPlatform( File storeDir, Map<String, String> params, Dependencies dependencies, GraphDatabaseFacade graphDatabaseFacade )
            {
                return new PlatformModule( storeDir, params, dependencies, graphDatabaseFacade )
                {
                    @Override
                    protected Neo4jJobScheduler createJobScheduler()
                    {
                        return newSlowJobScheduler();
                    }

                    @Override
                    protected LogService createLogService( LogProvider userLogProvider )
                    {
                        return NullLogService.getInstance();
                    }
                };
            }
        }.newFacade( directory.graphDbDir(), stringMap(),
                graphDatabaseFactoryState.databaseDependencies() );
    }

    private static Neo4jJobScheduler newSlowJobScheduler()
    {
        return new Neo4jJobScheduler()
        {
            @Override
            public JobHandle schedule( Group group, Runnable job )
            {
                return super.schedule( group, slowRunnable( job ) );
            }
        };
    }

    private static Runnable slowRunnable( final Runnable target )
    {
        return new Runnable()
        {
            @Override
            public void run()
            {
                LockSupport.parkNanos( 100_000_000 );
                target.run();
            }
        };
    }

    private List<Long> nodeIdsInIndex( int indexId, String value ) throws IOException
    {
        Config config = new Config();
        SchemaIndexProvider indexProvider = new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, directory.graphDbDir() );
        IndexConfiguration indexConfig = new IndexConfiguration( false );
        IndexSamplingConfig samplingConfig = new IndexSamplingConfig( config );
        try ( IndexAccessor accessor = indexProvider.getOnlineAccessor( indexId, indexConfig, samplingConfig );
              IndexReader reader = accessor.newReader() )
        {
            return IteratorUtil.asList( reader.lookup( value ) );
        }
    }
}


File: community/ndp/kernelextension/src/main/java/org/neo4j/ext/NDPKernelExtension.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ext;

import io.netty.channel.Channel;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.Function;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.config.Setting;
import org.neo4j.graphdb.factory.Description;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.helpers.Service;
import org.neo4j.kernel.GraphDatabaseAPI;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.extension.KernelExtensionFactory;
import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.kernel.impl.util.JobScheduler;
import org.neo4j.kernel.lifecycle.LifeSupport;
import org.neo4j.kernel.lifecycle.Lifecycle;
import org.neo4j.logging.Log;
import org.neo4j.ndp.runtime.Sessions;
import org.neo4j.ndp.runtime.internal.StandardSessions;
import org.neo4j.ndp.runtime.internal.concurrent.ThreadedSessions;
import org.neo4j.ndp.transport.socket.NettyServer;
import org.neo4j.ndp.transport.socket.SocketProtocol;
import org.neo4j.ndp.transport.socket.SocketProtocolV1;
import org.neo4j.ndp.transport.socket.SocketTransport;
import org.neo4j.ndp.transport.socket.WebSocketTransport;
import org.neo4j.udc.UsageData;

import static java.util.Arrays.asList;
import static org.neo4j.collection.primitive.Primitive.longObjectMap;
import static org.neo4j.helpers.Settings.BOOLEAN;
import static org.neo4j.helpers.Settings.HOSTNAME_PORT;
import static org.neo4j.helpers.Settings.setting;

/**
 * Wraps NDP and exposes it as a Kernel Extension.
 */
@Service.Implementation(KernelExtensionFactory.class)
public class NDPKernelExtension extends KernelExtensionFactory<NDPKernelExtension.Dependencies>
{
    public static class Settings
    {
        @Description("Enable Neo4j Data Protocol")
        public static final Setting<Boolean> ndp_enabled = setting( "experimental.ndp.enabled", BOOLEAN,
                "false" );

        @Description("Host and port for the Neo4j Data Protocol")
        public static final Setting<HostnamePort> ndp_socket_address =
                setting( "dbms.ndp.address", HOSTNAME_PORT, "localhost:7687" );

        @Description("Host and port for the Neo4j Data Protocol Websocket")
        public static final Setting<HostnamePort> ndp_ws_address =
                setting( "dbms.ndp.ws.address", HOSTNAME_PORT, "localhost:7688" );
    }

    public interface Dependencies
    {
        LogService logService();

        Config config();

        GraphDatabaseService db();

        JobScheduler scheduler();

        UsageData usageData();
    }

    public NDPKernelExtension()
    {
        super( "neo4j-data-protocol-server" );
    }

    @Override
    public Lifecycle newKernelExtension( Dependencies dependencies ) throws Throwable
    {
        final Config config = dependencies.config();
        final GraphDatabaseService gdb = dependencies.db();
        final GraphDatabaseAPI api = (GraphDatabaseAPI) gdb;
        final LogService logging = dependencies.logService();
        final Log log = logging.getInternalLog( Sessions.class );

        final HostnamePort socketAddress = config.get( Settings.ndp_socket_address );
        final HostnamePort webSocketAddress = config.get( Settings.ndp_ws_address );

        final LifeSupport life = new LifeSupport();

        if ( config.get( Settings.ndp_enabled ) )
        {
            final Sessions sessions = life.add( new ThreadedSessions(
                    life.add( new StandardSessions( api, dependencies.usageData(), logging ) ),
                    dependencies.scheduler(),
                    logging ) );

            PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions = longObjectMap();
            availableVersions.put( SocketProtocolV1.VERSION, new Function<Channel, SocketProtocol>()
            {
                @Override
                public SocketProtocol apply( Channel channel )
                {
                    return new SocketProtocolV1( logging, sessions.newSession(), channel );
                }
            } );

            // Start services
            life.add( new NettyServer( asList(
                    new SocketTransport( socketAddress, availableVersions ),
                    new WebSocketTransport( webSocketAddress, availableVersions ) ) ) );
            log.info( "NDP Server extension loaded." );
        }

        return life;
    }
}


File: community/ndp/kernelextension/src/test/java/org/neo4j/ext/NDPExtensionIT.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ext;

import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Arrays;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.test.TestGraphDatabaseFactory;

public class NDPExtensionIT
{
    @Rule
    public TemporaryFolder tmpDir = new TemporaryFolder();
    private GraphDatabaseService db;

    @Test
    public void shouldLaunchNDP() throws Throwable
    {
        // When I run Neo4j with the ndp extension on the class path, and experimental ndp config on
        db = new TestGraphDatabaseFactory()
                .newEmbeddedDatabaseBuilder( tmpDir.getRoot().getAbsolutePath() )
                .setConfig( NDPKernelExtension.Settings.ndp_enabled, "true" )
                .newGraphDatabase();

        // Then
        assertEventuallyServerResponds( "localhost", 7687 );
    }

    @Test
    public void shouldBeAbleToSpecifyHostAndPort() throws Throwable
    {
        // When I run Neo4j with the ndp extension on the class path
        db = new TestGraphDatabaseFactory()
                .newEmbeddedDatabaseBuilder( tmpDir.getRoot().getAbsolutePath() )
                .setConfig( NDPKernelExtension.Settings.ndp_enabled, "true" )
                .setConfig( NDPKernelExtension.Settings.ndp_socket_address, "localhost:8776" )
                .newGraphDatabase();

        // Then
        assertEventuallyServerResponds( "localhost", 8776 );
    }

    private void assertEventuallyServerResponds( String host, int port ) throws IOException, InterruptedException
    {
        long timeout = System.currentTimeMillis() + 1000 * 30;
        for (; ; )
        {
            if ( serverResponds( host, port ) )
            {
                return;
            }
            else
            {
                Thread.sleep( 100 );
            }

            // Make sure process still is alive
            if ( System.currentTimeMillis() > timeout )
            {
                throw new RuntimeException( "Waited for 30 seconds for server to respond to HTTP calls, " +
                                            "but no response, timing out to avoid blocking forever." );
            }
        }
    }

    private boolean serverResponds( String host, int port ) throws IOException, InterruptedException
    {
        try
        {
            try ( Socket socket = new Socket() )
            {
                // Ok, we can connect - can we perform the version handshake?
                socket.connect( new InetSocketAddress( host, port ) );
                OutputStream out = socket.getOutputStream();
                InputStream in = socket.getInputStream();

                // Hard-coded handshake, a general "test client" would be useful further on.
                out.write( new byte[]{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} );

                byte[] accepted = new byte[4];
                in.read( accepted );

                return Arrays.equals( accepted, new byte[]{0, 0, 0, 1} );
            }
        }
        catch ( ConnectException e )
        {
            return false;
        }
    }

    @After
    public void cleanup()
    {
        if ( db != null )
        {
            db.shutdown();
        }
    }
}


File: community/ndp/transport-socket/src/main/java/org/neo4j/ndp/transport/socket/NettyServer.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;

import java.util.Collection;

import org.neo4j.function.BiConsumer;
import org.neo4j.kernel.lifecycle.LifecycleAdapter;

/**
 * Simple wrapper around Netty boss and selector threads, which allows multiple ports and protocols to be handled
 * by the same set of common worker threads.
 */
public class NettyServer extends LifecycleAdapter
{
    private final Collection<BiConsumer<EventLoopGroup,EventLoopGroup>> bootstrappers;
    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;

    /**
     * @param bootstrappers functions that bootstrap protocols we should support
     */
    public NettyServer( Collection<BiConsumer<EventLoopGroup, EventLoopGroup>> bootstrappers )
    {
        this.bootstrappers = bootstrappers;
    }

    @Override
    public void start() throws Throwable
    {
        // TODO: This should circle back to Neo4j thread scheduler, which needs to provide some sort of thread
        // factory for us to use here.
        bossGroup = new NioEventLoopGroup( 1 );
        workerGroup = new NioEventLoopGroup();

        for ( BiConsumer<EventLoopGroup,EventLoopGroup> bootstrapper : bootstrappers )
        {
            bootstrapper.accept( bossGroup, workerGroup );
        }
    }

    @Override
    public void stop() throws Throwable
    {
        bossGroup.shutdownGracefully();
        workerGroup.shutdownGracefully();
    }
}


File: community/ndp/transport-socket/src/main/java/org/neo4j/ndp/transport/socket/SocketTransport.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.BiConsumer;
import org.neo4j.function.Factory;
import org.neo4j.function.Function;
import org.neo4j.helpers.HostnamePort;

/**
 * Implements a transport for the Neo4j Messaging Protocol that uses good old regular sockets.
 */
public class SocketTransport implements BiConsumer<EventLoopGroup, EventLoopGroup>
{
    private final HostnamePort address;
    private final PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> protocolVersions;

    public SocketTransport( HostnamePort address, PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> protocolVersions)
    {
        this.address = address;
        this.protocolVersions = protocolVersions;
    }

    public HostnamePort address()
    {
        return address;
    }

    @Override
    public void accept( EventLoopGroup bossGroup, EventLoopGroup workerGroup )
    {
        ServerBootstrap b = new ServerBootstrap();
        b.option( ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT )
         .group( bossGroup, workerGroup )
         .channel( NioServerSocketChannel.class )
         .childHandler( new ChannelInitializer<SocketChannel>()
                {
                    @Override
                    public void initChannel( SocketChannel ch ) throws Exception
                    {
                        ch.pipeline().addLast( new SocketTransportHandler(
                                new SocketTransportHandler.ProtocolChooser( protocolVersions ) ) );
                    }
                } );

        // Bind and start to accept incoming connections.
        try
        {
            b.bind( address.getHost(), address.getPort() ).sync();
        }
        catch ( InterruptedException e )
        {
            throw new RuntimeException( e );
        }
    }
}


File: community/ndp/transport-socket/src/main/java/org/neo4j/ndp/transport/socket/SocketTransportHandler.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.Factory;
import org.neo4j.function.Function;

import static io.netty.buffer.Unpooled.wrappedBuffer;
import static org.neo4j.collection.primitive.Primitive.longObjectMap;

/**
 * Handles incoming chunks of data for a given client channel. This initially will negotiate a protocol version to use,
 * and then delegate future messages to the chosen protocol.
 * <p/>
 * This class is stateful, one instance is expected per channel.
 */
public class SocketTransportHandler extends ChannelInboundHandlerAdapter
{
    private final ProtocolChooser protocolChooser;
    private SocketProtocol protocol;

    public SocketTransportHandler( ProtocolChooser protocolChooser )
    {
        this.protocolChooser = protocolChooser;
    }

    @Override
    public void channelRead( ChannelHandlerContext ctx, Object msg ) throws Exception
    {
        if ( msg instanceof ByteBuf )
        {
            ByteBuf buffer = (ByteBuf) msg;
            if ( protocol == null )
            {
                chooseProtocolVersion( ctx, buffer );
            }
            else
            {
                protocol.handle( ctx, buffer );
            }
        }
        else
        {
            ctx.fireChannelRead( msg );
        }
    }

    @Override
    public void channelInactive( ChannelHandlerContext ctx ) throws Exception
    {
        close();
    }

    @Override
    public void handlerRemoved( ChannelHandlerContext ctx ) throws Exception
    {
        close();
    }

    private void close()
    {
        if(protocol != null)
        {
            protocol.close();
            protocol = null;
        }
    }

    private void chooseProtocolVersion( ChannelHandlerContext ctx, ByteBuf buffer ) throws Exception
    {
        switch ( protocolChooser.handleVersionHandshakeChunk( buffer, ctx.channel() ) )
        {
        case PROTOCOL_CHOSEN:
            protocol = protocolChooser.chosenProtocol();
            ctx.writeAndFlush( ctx.alloc().buffer( 4 ).writeInt( protocol.version() ) );

            // If there is more data pending, the client optimistically sent this in its initial payload. It really
            // shouldn't be doing that since it can't know which versions we support, but here we are anyway.
            // Emulate a second call to channelRead, the remaining data in the buffer will be forwarded to the newly
            // selected protocol.
            if ( buffer.readableBytes() > 0 )
            {
                channelRead( ctx, buffer );
            }
            else
            {
                buffer.release();
            }
            return;
        case NO_APPLICABLE_PROTOCOL:
            ctx.writeAndFlush( wrappedBuffer( new byte[]{0, 0, 0, 0} ) )
                    .sync()
                    .channel()
                    .close();
            return;
        case PARTIAL_HANDSHAKE:
        }
    }

    public enum HandshakeOutcome
    {
        /** Yay! */
        PROTOCOL_CHOSEN,
        /** Pending more bytes before handshake can complete */
        PARTIAL_HANDSHAKE,
        /** None of the clients suggested protocol versions are available :( */
        NO_APPLICABLE_PROTOCOL
    }

    /**
     * Manages the state for choosing the protocol version to use.
     * The protocol opens with the client sending four suggested protocol versions, in preference order and big endian,
     * each a 4-byte unsigned integer. Since that message could get split up along the way, we first gather the
     * 16 bytes of data we need, and then choose a protocol to use.
     */
    public static class ProtocolChooser
    {
        private final PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions;
        private final ByteBuffer suggestedVersions = ByteBuffer.allocateDirect( 4 * 4 ).order( ByteOrder.BIG_ENDIAN );

        private SocketProtocol protocol;

        /**
         * @param availableVersions version -> protocol mapping
         */
        public ProtocolChooser( PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions )
        {
            this.availableVersions = availableVersions;
        }

        public HandshakeOutcome handleVersionHandshakeChunk( ByteBuf buffer, Channel ch )
        {
            if ( suggestedVersions.remaining() > buffer.readableBytes() )
            {
                suggestedVersions.limit( suggestedVersions.position() + buffer.readableBytes() );
                buffer.readBytes( suggestedVersions );
                suggestedVersions.limit( suggestedVersions.capacity() );
            }
            else
            {
                buffer.readBytes( suggestedVersions );
            }

            if ( suggestedVersions.remaining() == 0 )
            {
                suggestedVersions.flip();
                for ( int i = 0; i < 4; i++ )
                {
                    long suggestion = suggestedVersions.getInt() & 0xFFFFFFFFL;
                    if ( availableVersions.containsKey( suggestion ) )
                    {
                        protocol = availableVersions.get( suggestion ).apply( ch );
                        return HandshakeOutcome.PROTOCOL_CHOSEN;
                    }
                }

                // None of the suggested protocol versions are available.
                return HandshakeOutcome.NO_APPLICABLE_PROTOCOL;
            }
            return HandshakeOutcome.PARTIAL_HANDSHAKE;
        }

        public SocketProtocol chosenProtocol()
        {
            return protocol;
        }
    }
}


File: community/ndp/transport-socket/src/main/java/org/neo4j/ndp/transport/socket/WebSocketTransport.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.HttpServerCodec;
import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.BiConsumer;
import org.neo4j.function.Factory;
import org.neo4j.function.Function;
import org.neo4j.helpers.HostnamePort;

/**
 * Carries the Neo4j protocol over websockets. Apart from the initial websocket handshake, this works with the exact
 * same protocol as {@link org.neo4j.ndp.transport.socket.SocketTransport}.
 */
public class WebSocketTransport implements BiConsumer<EventLoopGroup,EventLoopGroup>
{
    private static final int MAX_WEBSOCKET_HANDSHAKE_SIZE = 65536;

    private final HostnamePort address;
    private final PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions;

    public WebSocketTransport( HostnamePort address, PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> protocolVersions )
    {
        this.address = address;
        this.availableVersions = protocolVersions;
    }

    @Override
    public void accept( EventLoopGroup bossGroup, EventLoopGroup workerGroup )
    {
        ServerBootstrap b = new ServerBootstrap();
        b.option( ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT )
         .group( bossGroup, workerGroup )
         .channel( NioServerSocketChannel.class )
         .childHandler( new ChannelInitializer<SocketChannel>()
                {
                    @Override
                    public void initChannel( SocketChannel ch ) throws Exception
                    {
                        ch.pipeline().addLast(
                                new HttpServerCodec(),
                                new HttpObjectAggregator( MAX_WEBSOCKET_HANDSHAKE_SIZE ),
                                new WebSocketServerProtocolHandler( "" ),
                                new WebSocketFrameTranslator(),
                                new SocketTransportHandler(
                                        new SocketTransportHandler.ProtocolChooser( availableVersions ) ) );
                    }
                } );

        // Bind and start to accept incoming connections.
        try
        {
            b.bind( address.getHost(), address.getPort() ).sync();
        }
        catch ( InterruptedException e )
        {
            throw new RuntimeException( e );
        }
    }
}


File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/FragmentedMessageDeliveryTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.Map;

import org.neo4j.kernel.impl.logging.NullLogService;
import org.neo4j.kernel.impl.util.HexPrinter;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.messaging.v1.message.Message;
import org.neo4j.ndp.runtime.Session;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;

import static io.netty.buffer.Unpooled.wrappedBuffer;
import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1.Writer.NO_OP;
import static org.neo4j.ndp.messaging.v1.message.Messages.run;
import static org.neo4j.ndp.transport.socket.SocketProtocolV1.State.AWAITING_CHUNK;

/**
 * This tests network fragmentation of messages. Given a set of messages, it will serialize and chunk the message up
 * to a specified chunk size. Then it will split that data into a specified number of fragments, trying every possible
 * permutation of fragment sizes for the specified number. For instance, assuming an unfragmented message size of 15,
 * and a fragment count of 3, it will create fragment size permutations like:
 * <p/>
 * [1,1,13]
 * [1,2,12]
 * [1,3,11]
 * ..
 * [12,1,1]
 * <p/>
 * For each permutation, it delivers the fragments to the protocol implementation, and asserts the protocol handled
 * them properly.
 */
public class FragmentedMessageDeliveryTest
{
    // Only test one chunk size for now, this can be parameterized to test lots of different ones
    private int chunkSize = 16;

    // Only test messages broken into three fragments for now, this can be parameterized later
    private int numFragments = 3;

    // Only test one message for now. This can be parameterized later to test lots of different ones
    private Message[] messages = new Message[]{run( "Mjölnir" )};

    @Test
    public void testFragmentedMessageDelivery() throws Throwable
    {
        // Given
        byte[] unfragmented = serialize( chunkSize, messages );

        // When & Then
        int n = unfragmented.length;
        for ( int i = 1; i < n - 1; i++ )
        {
            for ( int j = 1; j < n - i; j++ )
            {
                testPermutation( unfragmented, i, j, n - i - j );
            }
        }
    }

    private void testPermutation( byte[] unfragmented, int... sizes )
    {
        int pos = 0;
        ByteBuf[] fragments = new ByteBuf[sizes.length];
        for ( int i = 0; i < sizes.length; i++ )
        {
            fragments[i] = wrappedBuffer( unfragmented, pos, sizes[i] );
            pos += sizes[i];
        }
        testPermutation( unfragmented, fragments );
    }

    private void testPermutation( byte[] unfragmented, ByteBuf[] fragments )
    {
        // Given
        // System.out.println( "Testing fragmentation:" + describeFragments( fragments ) );
        Session sess = mock( Session.class );

        Channel ch = mock( Channel.class );
        when(ch.alloc()).thenReturn( UnpooledByteBufAllocator.DEFAULT );

        ChannelHandlerContext ctx = mock( ChannelHandlerContext.class );
        when(ctx.channel()).thenReturn( ch );

        SocketProtocolV1 protocol = new SocketProtocolV1( NullLogService.getInstance(), sess, ch );

        // When data arrives split up according to the current permutation
        for ( ByteBuf fragment : fragments )
        {
            fragment.readerIndex( 0 ).retain();
            protocol.handle( ctx, fragment );
        }

        // Then the session should've received the specified messages, and the protocol should be in a nice clean state
        try
        {
            assertEquals( AWAITING_CHUNK, protocol.state() );
            verify( sess ).run( eq( "Mjölnir" ), any( Map.class ), any(), any( Session.Callback.class ) );
        }
        catch ( AssertionError e )
        {
            throw new AssertionError( "Failed to handle fragmented delivery.\n" +
                                      "Messages: " + Arrays.toString( messages ) + "\n" +
                                      "Chunk size: " + chunkSize + "\n" +
                                      "Serialized data delivered in fragments: " + describeFragments( fragments ) +
                                      "\n" +
                                      "Unfragmented data: " + HexPrinter.hex( unfragmented ) + "\n", e );
        }
    }

    private String describeFragments( ByteBuf[] fragments )
    {
        StringBuilder sb = new StringBuilder();
        for ( int i = 0; i < fragments.length; i++ )
        {
            if ( i > 0 ) { sb.append( "," ); }
            sb.append( fragments[i].capacity() );
        }
        return sb.toString();
    }

    private byte[] serialize( int chunkSize, Message... msgs ) throws IOException
    {
        byte[][] serialized = new byte[msgs.length][];
        for ( int i = 0; i < msgs.length; i++ )
        {
            RecordingByteChannel channel = new RecordingByteChannel();

            PackStreamMessageFormatV1.Writer format = new PackStreamMessageFormatV1.Writer(
                    new PackStream.Packer( new BufferedChannelOutput( channel ) ), NO_OP );
            format.write( msgs[i] ).flush();
            serialized[i] = channel.getBytes();
        }
        return Chunker.chunk( chunkSize, serialized );
    }
}

File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/SocketTransportHandlerTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import org.junit.Test;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.Function;
import org.neo4j.kernel.impl.logging.NullLogService;
import org.neo4j.ndp.runtime.Session;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.neo4j.collection.primitive.Primitive.longObjectMap;

public class SocketTransportHandlerTest
{

    @Test
    public void shouldCloseSessionOnChannelClose() throws Throwable
    {
        // Given
        Session session = mock(Session.class);
        Channel ch = mock( Channel.class );
        ChannelHandlerContext ctx = mock( ChannelHandlerContext.class );
        when(ctx.channel()).thenReturn( ch );

        when( ch.alloc() ).thenReturn( UnpooledByteBufAllocator.DEFAULT );
        when( ctx.alloc() ).thenReturn( UnpooledByteBufAllocator.DEFAULT );

        SocketTransportHandler handler = new SocketTransportHandler( protocolChooser( session ) );

        // And Given a session has been established
        handler.channelRead( ctx, handshake() );

        // When
        handler.channelInactive( ctx );

        // Then
        verify(session).close();
    }

    private SocketTransportHandler.ProtocolChooser protocolChooser( final Session session )
    {
        PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions = longObjectMap();
        availableVersions.put( SocketProtocolV1.VERSION, new Function<Channel, SocketProtocol>()
        {
            @Override
            public SocketProtocol apply( Channel channel )
            {
                return new SocketProtocolV1( NullLogService.getInstance(), session, channel );
            }
        } );

        return new SocketTransportHandler.ProtocolChooser( availableVersions );
    }

    private ByteBuf handshake()
    {
        ByteBuf buf = UnpooledByteBufAllocator.DEFAULT.buffer();
        buf.writeInt( 1 );
        buf.writeInt( 0 );
        buf.writeInt( 0 );
        buf.writeInt( 0 );
        return buf;
    }

}

File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/client/SocketConnection.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket.client;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;

import org.neo4j.helpers.HostnamePort;
import org.neo4j.kernel.impl.util.HexPrinter;

public class SocketConnection implements Connection
{
    private Socket socket;
    private InputStream in;
    private OutputStream out;

    @Override
    public Connection connect( HostnamePort address ) throws IOException
    {
        socket = new Socket();
        socket.connect( new InetSocketAddress( address.getHost(), address.getPort() ) );
        in = socket.getInputStream();
        out = socket.getOutputStream();
        return this;
    }

    @Override
    public Connection send( byte[] rawBytes ) throws IOException
    {
        out.write( rawBytes );
        return this;
    }

    @Override
    public byte[] recv( int length ) throws IOException, InterruptedException
    {
        long timeout = System.currentTimeMillis() + 1000 * 30;
        byte[] bytes = new byte[length];
        int left = length, read;

        waitUntilAvailable( bytes, timeout, left );

        while ( (read = in.read( bytes, length - left, left )) != -1 && left > 0 )
        {
            left -= read;
            if ( left > 0 )
            {
                waitUntilAvailable( bytes, timeout, left );
            }
        }
        return bytes;
    }

    @Override
    public void discard( int length ) throws IOException
    {
        for ( int i = 0; i < length; i++ )
        {
            in.read();
        }
    }

    private void waitUntilAvailable( byte[] recieved, long timeout, int left ) throws IOException
    {
        while ( in.available() == 0 )
        {
            if ( System.currentTimeMillis() > timeout )
            {
                throw new IOException( "Waited 30 seconds for " + left + " bytes, " +
                                       "recieved " + (recieved.length - left) + ":\n" +
                                       HexPrinter.hex(
                                               ByteBuffer.wrap( recieved ), 0, recieved.length - left ) );
            }
        }
    }

    @Override
    public void disconnect() throws IOException
    {
        if ( socket != null && socket.isConnected() )
        {
            socket.close();
        }
    }

    @Override
    public void close() throws Exception
    {
        disconnect();
    }
}


File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/integration/Neo4jWithSocket.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket.integration;

import io.netty.channel.Channel;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.Function;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.kernel.GraphDatabaseAPI;
import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.kernel.lifecycle.LifeSupport;
import org.neo4j.ndp.runtime.Sessions;
import org.neo4j.ndp.runtime.internal.StandardSessions;
import org.neo4j.ndp.transport.socket.NettyServer;
import org.neo4j.ndp.transport.socket.SocketProtocol;
import org.neo4j.ndp.transport.socket.SocketProtocolV1;
import org.neo4j.ndp.transport.socket.SocketTransport;
import org.neo4j.ndp.transport.socket.WebSocketTransport;
import org.neo4j.test.TestGraphDatabaseFactory;
import org.neo4j.udc.UsageData;

import static java.util.Arrays.asList;
import static org.neo4j.collection.primitive.Primitive.longObjectMap;

public class Neo4jWithSocket implements TestRule
{
    private final LifeSupport life = new LifeSupport();
    private SocketTransport socketTransport;
    private WebSocketTransport wsTransport;

    public HostnamePort address()
    {
        return socketTransport.address();
    }

    @Override
    public Statement apply( final Statement statement, Description description )
    {
        return new Statement()
        {
            @Override
            public void evaluate() throws Throwable
            {
                final GraphDatabaseService gdb = new TestGraphDatabaseFactory().newImpermanentDatabase();
                final GraphDatabaseAPI api = ((GraphDatabaseAPI) gdb);
                final LogService logging = api.getDependencyResolver().resolveDependency( LogService.class );
                final UsageData usageData = api.getDependencyResolver().resolveDependency( UsageData.class );

                final Sessions sessions = life.add( new StandardSessions( api, usageData, logging ) );

                PrimitiveLongObjectMap<Function<Channel, SocketProtocol>> availableVersions = longObjectMap();
                availableVersions.put( SocketProtocolV1.VERSION, new Function<Channel, SocketProtocol>()
                {
                    @Override
                    public SocketProtocol apply( Channel channel )
                    {
                        return new SocketProtocolV1( logging, sessions.newSession(), channel );
                    }
                } );

                // Start services
                socketTransport = new SocketTransport( new HostnamePort( "localhost:7687" ), availableVersions );
                wsTransport = new WebSocketTransport( new HostnamePort( "localhost:7688" ), availableVersions );
                life.add( new NettyServer( asList(
                        socketTransport,
                        wsTransport )) );

                life.start();
                try
                {
                    statement.evaluate();
                }
                finally
                {
                    life.shutdown();
                    gdb.shutdown();
                }
            }
        };
    }
}


File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/integration/TransportErrorIT.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket.integration;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Arrays;
import java.util.Collection;

import org.neo4j.function.Factory;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.kernel.api.exceptions.Status;
import org.neo4j.ndp.messaging.v1.PackStreamMessageFormatV1;
import org.neo4j.ndp.messaging.v1.RecordingByteChannel;
import org.neo4j.ndp.runtime.internal.Neo4jError;
import org.neo4j.ndp.transport.socket.client.Connection;
import org.neo4j.ndp.transport.socket.client.SocketConnection;
import org.neo4j.ndp.transport.socket.client.WebSocketConnection;
import org.neo4j.packstream.BufferedChannelOutput;
import org.neo4j.packstream.PackStream;

import static java.util.Arrays.asList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.neo4j.ndp.messaging.v1.message.Messages.run;
import static org.neo4j.ndp.messaging.v1.util.MessageMatchers.msgFailure;
import static org.neo4j.ndp.messaging.v1.util.MessageMatchers.serialize;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.acceptedVersions;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.chunk;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.eventuallyRecieves;

@RunWith( Parameterized.class )
public class TransportErrorIT
{
    @Rule
    public Neo4jWithSocket server = new Neo4jWithSocket();

    @Parameterized.Parameter(0)
    public Factory<Connection> cf;

    @Parameterized.Parameter(1)
    public HostnamePort address;

    private Connection client;

    @Parameterized.Parameters
    public static Collection<Object[]> transports()
    {
        return asList(
                new Object[]{
                        new Factory<Connection>()
                        {
                            @Override
                            public Connection newInstance()
                            {
                                return new SocketConnection();
                            }
                        },
                        new HostnamePort( "localhost:7687" )
                },
                new Object[]{
                        new Factory<Connection>()
                        {
                            @Override
                            public Connection newInstance()
                            {
                                return new WebSocketConnection();
                            }
                        },
                        new HostnamePort( "localhost:7688" )
                } );
    }

    @Test
    public void shouldHandleIncorrectFraming() throws Throwable
    {
        // Given I have a message that gets truncated in the chunking, so part of it is missing
        byte[] truncated = serialize( run( "UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared" ) );
        truncated = Arrays.copyOf(truncated, truncated.length - 12);

        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) )
                .send( chunk( 32, truncated ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
        assertThat( client, eventuallyRecieves(
                msgFailure( new Neo4jError( Status.Request.InvalidFormat,
                        "Unable to deserialize request, message boundary found before message ended. This indicates " +
                        "a serialization or framing problem with your client driver." ) ) ) );
    }

    @Test
    public void shouldHandleMessagesWithIncorrectFields() throws Throwable
    {
        // Given I send a message with the wrong types in its fields
        final RecordingByteChannel rawData = new RecordingByteChannel();
        final PackStream.Packer packer = new PackStream.Packer( new BufferedChannelOutput( rawData ) );

        packer.packStructHeader( 2, PackStreamMessageFormatV1.MessageTypes.MSG_RUN );
        packer.pack( "RETURN 1" );
        packer.pack( 1234 ); // Should've been a map
        packer.flush();

        byte[] invalidMessage = rawData.getBytes();

        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) )
                .send( chunk( 32, invalidMessage ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
        assertThat( client, eventuallyRecieves(
                msgFailure( new Neo4jError( Status.Request.InvalidFormat,
                        "Unable to read MSG_RUN message. Error was: Wrong type received. Expected MAP, received: " +
                        "INTEGER (0xff)." ) ) ) );
    }

    @Test
    public void shouldHandleUnknownMessages() throws Throwable
    {
        // Given I send a message with an invalid type
        final RecordingByteChannel rawData = new RecordingByteChannel();
        final PackStream.Packer packer = new PackStream.Packer( new BufferedChannelOutput( rawData ) );

        packer.packStructHeader( 1, (byte)0x66 ); // Invalid message type
        packer.pack( 1234 );
        packer.flush();

        byte[] invalidMessage = rawData.getBytes();

        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) )
                .send( chunk( 32, invalidMessage ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
        assertThat( client, eventuallyRecieves(
                msgFailure( new Neo4jError( Status.Request.Invalid, "0x66 is not a valid message type." ) ) ) );
    }

    @Test
    public void shouldHandleUnknownMarkerBytes() throws Throwable
    {
        // Given I send a message with an invalid type
        final RecordingByteChannel rawData = new RecordingByteChannel();
        final BufferedChannelOutput out = new BufferedChannelOutput( rawData );
        final PackStream.Packer packer = new PackStream.Packer( out );

        packer.packStructHeader( 2, PackStreamMessageFormatV1.MessageTypes.MSG_RUN );
        out.writeByte( PackStream.RESERVED_C4 ); // Invalid marker byte
        out.flush();

        byte[] invalidMessage = rawData.getBytes();

        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) )
                .send( chunk( 32, invalidMessage ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
        assertThat( client, eventuallyRecieves(
                msgFailure( new Neo4jError( Status.Request.InvalidFormat,
                        "Unable to read MSG_RUN message. Error was: Wrong type received. Expected TEXT, received: " +
                        "RESERVED (0xff)." ) ) ) );
    }

    @Before
    public void setup()
    {
        this.client = cf.newInstance();
    }

    @After
    public void teardown() throws Exception
    {
        if(client != null) client.disconnect();
    }
}


File: community/ndp/transport-socket/src/test/java/org/neo4j/ndp/transport/socket/integration/TransportSessionIT.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.transport.socket.integration;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Collection;

import org.neo4j.function.Factory;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.ndp.transport.socket.client.Connection;
import org.neo4j.ndp.transport.socket.client.SocketConnection;
import org.neo4j.ndp.transport.socket.client.WebSocketConnection;

import static java.util.Arrays.asList;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.neo4j.helpers.collection.MapUtil.map;
import static org.neo4j.ndp.messaging.v1.message.Messages.initialize;
import static org.neo4j.ndp.messaging.v1.message.Messages.pullAll;
import static org.neo4j.ndp.messaging.v1.message.Messages.run;
import static org.neo4j.ndp.messaging.v1.util.MessageMatchers.msgRecord;
import static org.neo4j.ndp.messaging.v1.util.MessageMatchers.msgSuccess;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.acceptedVersions;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.chunk;
import static org.neo4j.ndp.transport.socket.integration.TransportTestUtil.eventuallyRecieves;
import static org.neo4j.runtime.internal.runner.StreamMatchers.eqRecord;

@RunWith(Parameterized.class)
public class TransportSessionIT
{
    @Rule
    public Neo4jWithSocket server = new Neo4jWithSocket();

    @Parameterized.Parameter(0)
    public Factory<Connection> cf;

    @Parameterized.Parameter(1)
    public HostnamePort address;

    private Connection client;

    @Parameterized.Parameters
    public static Collection<Object[]> transports()
    {
        return asList(
                new Object[]{
                        new Factory<Connection>()
                        {
                            @Override
                            public Connection newInstance()
                            {
                                return new SocketConnection();
                            }
                        },
                        new HostnamePort( "localhost:7687" )
                },
                new Object[]{
                        new Factory<Connection>()
                        {
                            @Override
                            public Connection newInstance()
                            {
                                return new WebSocketConnection();
                            }
                        },
                        new HostnamePort( "localhost:7688" )
                } );
    }

    @Test
    public void shouldNegotiateProtocolVersion() throws Throwable
    {
        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
    }

    @Test
    public void shouldReturnNilOnNoApplicableVersion() throws Throwable
    {
        // When
        client.connect( address )
                .send( acceptedVersions( 1337, 0, 0, 0 ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 0} ) );
    }

    @Test
    public void shouldRunSimpleStatement() throws Throwable
    {
        // When
        client.connect( address )
                .send( acceptedVersions( 1, 0, 0, 0 ) )
                .send( chunk(
                        initialize("TestClient/1.1"),
                        run( "UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared" ),
                        pullAll() ) );

        // Then
        assertThat( client, eventuallyRecieves( new byte[]{0, 0, 0, 1} ) );
        assertThat( client, eventuallyRecieves(
                msgSuccess(),
                msgSuccess( map( "fields", asList( "a", "a_squared" ) ) ),
                msgRecord( eqRecord( equalTo( 1l ), equalTo( 1l ) ) ),
                msgRecord( eqRecord( equalTo( 2l ), equalTo( 4l ) ) ),
                msgRecord( eqRecord( equalTo( 3l ), equalTo( 9l ) ) ),
                msgSuccess() ) );
    }

    @Before
    public void setup()
    {
        this.client = cf.newInstance();
    }

    @After
    public void teardown() throws Exception
    {
        if(client != null) client.disconnect();
    }

}


File: community/ndp/v1-docs/src/test/java/org/neo4j/ndp/docs/v1/NDPFullExchangesDocTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.ndp.docs.v1;

import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.ArrayList;
import java.util.Collection;

import org.neo4j.helpers.HostnamePort;
import org.neo4j.ndp.transport.socket.client.Connection;
import org.neo4j.ndp.transport.socket.client.SocketConnection;
import org.neo4j.ndp.transport.socket.client.WebSocketConnection;
import org.neo4j.ndp.transport.socket.integration.Neo4jWithSocket;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.neo4j.kernel.impl.util.HexPrinter.hex;
import static org.neo4j.ndp.docs.v1.DocExchangeExample.exchange_example;
import static org.neo4j.ndp.docs.v1.DocSerialization.packAndChunk;
import static org.neo4j.ndp.docs.v1.DocsRepository.docs;

@RunWith( Parameterized.class )
public class NDPFullExchangesDocTest
{
    @Rule
    public Neo4jWithSocket neo4j = new Neo4jWithSocket();

    @Parameterized.Parameter( 0 )
    public String testName;

    @Parameterized.Parameter( 1 )
    public DocExchangeExample example;

    @Parameterized.Parameter( 2 )
    public Connection client;

    @Parameterized.Parameter( 3 )
    public HostnamePort address;

    @Parameterized.Parameters( name = "{0}" )
    public static Collection<Object[]> documentedFullProtocolExamples()
    {
        Collection<Object[]> mappings = new ArrayList<>();

        // Load the documented mappings
        HostnamePort socketAddress = new HostnamePort( "localhost:7687" );
        HostnamePort wsAddress = new HostnamePort( "localhost:7688" );
        for ( DocExchangeExample ex : docs().read(
                "dev/transport.asciidoc",
                "code[data-lang=\"ndp_exchange\"]",
                exchange_example ) )
        {
            mappings.add( new Object[]{"Socket    - "+ex.name(), ex, new SocketConnection(), socketAddress} );
            mappings.add( new Object[]{"WebSocket - "+ex.name(), ex, new WebSocketConnection(), wsAddress} );
        }

        for ( DocExchangeExample ex : docs().read(
                "dev/examples.asciidoc",
                "code[data-lang=\"ndp_exchange\"]",
                exchange_example ) )
        {
            mappings.add( new Object[]{"Socket    - "+ex.name(), ex, new SocketConnection(), socketAddress} );
            mappings.add( new Object[]{"WebSocket - "+ex.name(), ex, new WebSocketConnection(), wsAddress} );
        }

        return mappings;
    }

    @After
    public void shutdown() throws Exception
    {
        client.close();
    }

    @Test
    public void serverShouldBehaveAsDocumented() throws Throwable
    {
        for ( DocExchangeExample.Event event : example )
        {
            if ( event.from().equalsIgnoreCase( "client" ) )
            {
                // Play out a client action
                switch ( event.type() )
                {
                case CONNECT:
                    client.connect( address );
                    break;
                case DISCONNECT:
                    client.disconnect();
                    break;
                case SEND:
                    // Ensure the documented binary representation matches the human-readable version in the docs
                    if ( event.hasHumanReadableValue() )
                    {
                        assertThat( "'" + event.humanReadableMessage() + "' should serialize to the documented " +
                                    "binary data.",
                                hex( event.payload() ),
                                equalTo( hex( packAndChunk( event.humanReadableMessage(), 64 ) ) ) );
                    }
                    client.send( event.payload() );
                    break;
                default:
                    throw new RuntimeException( "Unknown client event: " + event.type() );
                }
            }
            else if ( event.from().equalsIgnoreCase( "server" ) )
            {
                // Assert that the server does what the docs say
                // Play out a client action
                switch ( event.type() )
                {
                case DISCONNECT:
                    // There's not really a good way to verify that the remote connection is closed, we can read and
                    // time out, or write perhaps, but that's buggy and racy.. not sure how to test this on this
                    // level.
                    break;
                case SEND:
                    if ( event.hasHumanReadableValue() )
                    {
                        assertThat( "'" + event.humanReadableMessage() + "' should serialize to the documented " +
                                    "binary data.",
                                hex( event.payload() ),
                                equalTo( hex( packAndChunk( event.humanReadableMessage(), 512 ) ) ) );
                    }

                    byte[] recieved = client.recv( event.payload().length );

                    assertThat(
                            hex( recieved ),
                            equalTo( hex( event.payload() ) ) );
                    break;
                default:
                    throw new RuntimeException( "Unknown server event: " + event.type() );
                }
            }
        }
    }
}


File: community/neo4j-harness/src/test/java/org/neo4j/harness/InProcessBuilderTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.harness;

import org.apache.commons.io.FileUtils;
import org.codehaus.jackson.JsonNode;
import org.junit.Rule;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.NoSuchElementException;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.ResourceIterable;
import org.neo4j.graphdb.Transaction;
import org.neo4j.graphdb.factory.GraphDatabaseSettings;
import org.neo4j.harness.extensionpackage.MyUnmanagedExtension;
import org.neo4j.helpers.collection.IteratorUtil;
import org.neo4j.server.configuration.Configurator;
import org.neo4j.server.rest.domain.JsonParseException;
import org.neo4j.test.Mute;
import org.neo4j.test.TargetDirectory;
import org.neo4j.test.TestGraphDatabaseFactory;
import org.neo4j.test.server.HTTP;
import org.neo4j.tooling.GlobalGraphOperations;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.neo4j.harness.TestServerBuilders.newInProcessBuilder;

public class InProcessBuilderTest
{
    @Rule
    public TargetDirectory.TestDirectory testDir = TargetDirectory.testDirForTest( InProcessBuilderTest.class );

    @Rule public Mute mute = Mute.muteAll();

    @Test
    public void shouldLaunchAServerInSpecifiedDirectory() throws Exception
    {
        // Given
        File workDir = new File(testDir.directory(), "specific");
        workDir.mkdir();

        // When
        try(ServerControls server = newInProcessBuilder( workDir ).newServer())
        {
            // Then
            assertThat( HTTP.GET( server.httpURI().toString() ).status(), equalTo( 200 ) );
            assertThat( workDir.list().length, equalTo(1));
        }

        // And after it's been closed, it should've cleaned up after itself.
        assertThat( Arrays.toString( workDir.list() ), workDir.list().length, equalTo( 0 ) );
    }

    @Test
    public void shouldAllowCustomServerAndDbConfig() throws Exception
    {
        // Given
        trustAllSSLCerts();

        // When
        try ( ServerControls server = newInProcessBuilder( testDir.directory() )
                .withConfig( Configurator.WEBSERVER_HTTPS_ENABLED_PROPERTY_KEY, "true")
                .withConfig( Configurator.WEBSERVER_HTTPS_CERT_PATH_PROPERTY_KEY, testDir.file( "cert" ).getAbsolutePath() )
                .withConfig( Configurator.WEBSERVER_KEYSTORE_PATH_PROPERTY_KEY, testDir.file( "keystore" ).getAbsolutePath() )
                .withConfig( Configurator.WEBSERVER_HTTPS_KEY_PATH_PROPERTY_KEY, testDir.file( "key" ).getAbsolutePath() )
                .withConfig( GraphDatabaseSettings.dense_node_threshold, "20" )
                .newServer() )
        {
            // Then
            assertThat( HTTP.GET( server.httpsURI().toString() ).status(), equalTo( 200 ) );
            assertDBConfig( server, "20", GraphDatabaseSettings.dense_node_threshold.name() );
        }
    }

    @Test
    public void shouldMountUnmanagedExtensionsByClass() throws Exception
    {
        // When
        try(ServerControls server = newInProcessBuilder( testDir.directory() )
                .withExtension( "/path/to/my/extension", MyUnmanagedExtension.class )
                .newServer())
        {
            // Then
            assertThat( HTTP.GET( server.httpURI().toString() + "path/to/my/extension/myExtension" ).status(),
                    equalTo( 234 ) );
        }
    }

    @Test
    public void shouldMountUnmanagedExtensionsByPackage() throws Exception
    {
        // When
        try(ServerControls server = newInProcessBuilder( testDir.directory() )
                .withExtension( "/path/to/my/extension", "org.neo4j.harness.extensionpackage" )
                .newServer())
        {
            // Then
            assertThat( HTTP.GET( server.httpURI().toString() + "path/to/my/extension/myExtension" ).status(),
                    equalTo( 234 ) );
        }
    }

    @Test
    public void shouldFindFreePort() throws Exception
    {
        // Given one server is running
        try(ServerControls firstServer = newInProcessBuilder( testDir.directory() ).newServer())
        {
            // When I start a second server
            try(ServerControls secondServer = newInProcessBuilder( testDir.directory() ).newServer())
            {
                // Then
                assertThat( secondServer.httpURI().getPort(), not( firstServer.httpURI().getPort() ) );
            }
        }
    }

    @Test
    public void shouldRunBuilderOnExistingStoreDir() throws Exception
    {
        // When
        // create graph db with one node upfront
        Path dir = Files.createTempDirectory( getClass().getSimpleName() +
                "_shouldRunBuilderOnExistingStorageDir" );
        try
        {

            GraphDatabaseService db = new TestGraphDatabaseFactory().newEmbeddedDatabase( dir.toString() );
            try
            {
                db.execute( "create ()" );
            }
            finally
            {
                db.shutdown();
            }

            try ( ServerControls server = newInProcessBuilder( testDir.directory() ).copyFrom( dir.toFile() )
                    .newServer() )
            {
                // Then
                try ( Transaction tx = server.graph().beginTx() )
                {
                    ResourceIterable<Node> allNodes = GlobalGraphOperations.at(
                            server.graph() ).getAllNodes();

                    assertTrue( IteratorUtil.count( allNodes ) > 0 );

                    // When: create another node
                    server.graph().createNode();
                    tx.success();
                }
            }

            // Then: we still only have one node since the server is supposed to work on a copy
            db = new TestGraphDatabaseFactory().newEmbeddedDatabase( dir.toString() );
            try
            {
                try ( Transaction tx = db.beginTx() )
                {
                    assertEquals( 1, IteratorUtil.count( GlobalGraphOperations.at( db ).getAllNodes() ) );
                    tx.success();
                }
            }
            finally
            {
                db.shutdown();
            }
        }
        finally
        {
            FileUtils.forceDelete( dir.toFile() );
        }
    }

    @Test
    public void shouldFailWhenProvidingANonDirectoryAsSource() throws IOException
    {

        File notADirectory = File.createTempFile( "prefix", "suffix" );
        assertFalse( notADirectory.isDirectory() );

        try ( ServerControls server = newInProcessBuilder( ).copyFrom( notADirectory )
                .newServer() )
        {
            fail("server should not start");
        } catch (RuntimeException rte) {
            Throwable cause = rte.getCause();
            assertTrue( cause instanceof IOException);
            assertTrue( cause.getMessage().contains( "exists but is not a directory" ));
        }

    }

    private void assertDBConfig( ServerControls server, String expected, String key ) throws JsonParseException
    {
        JsonNode beans = HTTP.GET(
                server.httpURI().toString() + "db/manage/server/jmx/domain/org.neo4j/" ).get( "beans" );
        JsonNode configurationBean = findNamedBean( beans, "Configuration" ).get( "attributes" );
        boolean foundKey = false;
        for ( JsonNode attribute : configurationBean )
        {
            if(attribute.get("name").asText().equals( key ))
            {
                assertThat(attribute.get("value").asText(), equalTo( expected ));
                foundKey = true;
                break;
            }
        }
        if(!foundKey)
        {
            fail("No config key '" + key + "'.");
        }
    }

    private JsonNode findNamedBean( JsonNode beans, String beanName )
    {
        for ( JsonNode bean : beans )
        {
            JsonNode name = bean.get( "name" );
            if ( name != null && name.asText().endsWith( ",name=" + beanName ) )
            {
                return bean;
            }
        }
        throw new NoSuchElementException();
    }

    private void trustAllSSLCerts() throws NoSuchAlgorithmException, KeyManagementException
    {
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager()
        {
            @Override
            public void checkClientTrusted( X509Certificate[] arg0, String arg1 )
                    throws CertificateException
            {
            }

            @Override
            public void checkServerTrusted( X509Certificate[] arg0, String arg1 )
                    throws CertificateException
            {
            }

            @Override
            public X509Certificate[] getAcceptedIssuers()
            {
                return null;
            }
        }};

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance( "TLS" );
        sc.init( null, trustAllCerts, new SecureRandom() );
        HttpsURLConnection.setDefaultSSLSocketFactory( sc.getSocketFactory() );
    }
}


File: community/server/src/main/java/org/neo4j/server/AbstractNeoServer.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server;

import org.apache.commons.configuration.Configuration;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.servlet.Filter;

import org.neo4j.function.Function;
import org.neo4j.function.Supplier;
import org.neo4j.graphdb.DependencyResolver;
import org.neo4j.graphdb.factory.GraphDatabaseSettings;
import org.neo4j.helpers.Clock;
import org.neo4j.helpers.RunCarefully;
import org.neo4j.helpers.Settings;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.guard.Guard;
import org.neo4j.kernel.impl.factory.GraphDatabaseFacadeFactory;
import org.neo4j.kernel.impl.query.QueryExecutionEngine;
import org.neo4j.kernel.impl.util.Dependencies;
import org.neo4j.kernel.impl.util.JobScheduler;
import org.neo4j.kernel.info.DiagnosticsManager;
import org.neo4j.kernel.lifecycle.LifeSupport;
import org.neo4j.logging.Log;
import org.neo4j.logging.LogProvider;
import org.neo4j.server.configuration.ConfigWrappingConfiguration;
import org.neo4j.server.configuration.ConfigurationBuilder;
import org.neo4j.server.configuration.Configurator;
import org.neo4j.server.configuration.ServerSettings;
import org.neo4j.server.database.CypherExecutor;
import org.neo4j.server.database.CypherExecutorProvider;
import org.neo4j.server.database.Database;
import org.neo4j.server.database.DatabaseProvider;
import org.neo4j.server.database.ExecutionEngineProvider;
import org.neo4j.server.database.GraphDatabaseServiceProvider;
import org.neo4j.server.database.InjectableProvider;
import org.neo4j.server.database.RrdDbWrapper;
import org.neo4j.server.guard.GuardingRequestFilter;
import org.neo4j.server.modules.RESTApiModule;
import org.neo4j.server.modules.ServerModule;
import org.neo4j.server.plugins.PluginInvocatorProvider;
import org.neo4j.server.plugins.PluginManager;
import org.neo4j.server.preflight.PreFlightTasks;
import org.neo4j.server.preflight.PreflightFailedException;
import org.neo4j.server.rest.paging.LeaseManager;
import org.neo4j.server.rest.repr.InputFormatProvider;
import org.neo4j.server.rest.repr.OutputFormatProvider;
import org.neo4j.server.rest.repr.RepresentationFormatRepository;
import org.neo4j.server.rest.transactional.TransactionFacade;
import org.neo4j.server.rest.transactional.TransactionFilter;
import org.neo4j.server.rest.transactional.TransactionHandleRegistry;
import org.neo4j.server.rest.transactional.TransactionRegistry;
import org.neo4j.server.rest.transactional.TransitionalPeriodTransactionMessContainer;
import org.neo4j.server.rest.web.DatabaseActions;
import org.neo4j.server.rrd.RrdDbProvider;
import org.neo4j.server.rrd.RrdFactory;
import org.neo4j.server.security.auth.AuthManager;
import org.neo4j.server.security.auth.FileUserRepository;
import org.neo4j.server.security.ssl.KeyStoreFactory;
import org.neo4j.server.security.ssl.KeyStoreInformation;
import org.neo4j.server.security.ssl.SslCertificateFactory;
import org.neo4j.server.web.ServerInternalSettings;
import org.neo4j.server.web.SimpleUriBuilder;
import org.neo4j.server.web.WebServer;
import org.neo4j.server.web.WebServerProvider;
import org.neo4j.shell.ShellSettings;

import static java.lang.Math.round;
import static java.lang.String.format;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.neo4j.helpers.Clock.SYSTEM_CLOCK;
import static org.neo4j.helpers.collection.Iterables.map;
import static org.neo4j.kernel.impl.util.JobScheduler.Groups.serverTransactionTimeout;
import static org.neo4j.server.database.InjectableProvider.providerForSingleton;

/**
 * @deprecated This class is for internal use only and will be moved to an internal package in a future release.
 * Please use Neo4j Server and plugins or un-managed extensions for bespoke solutions.
 */
@Deprecated
public abstract class AbstractNeoServer implements NeoServer
{
    private static final long MINIMUM_TIMEOUT = 1000L;
    /**
     * We add a second to the timeout if the user configures a 1-second timeout.
     *
     * This ensures the expiry time displayed to the user is always at least 1 second, even after it is rounded down.
     */
    private static final long ROUNDING_SECOND = 1000L;

    protected final ConfigurationBuilder configurator;
    protected final LogProvider logProvider;
    protected final Log log;

    private final PreFlightTasks preFlight;

    private final List<ServerModule> serverModules = new ArrayList<>();
    private final SimpleUriBuilder uriBuilder = new SimpleUriBuilder();
    private final Config dbConfig;
    private final LifeSupport life = new LifeSupport();

    protected Database database;
    protected CypherExecutor cypherExecutor;
    protected WebServer webServer;

    protected AuthManager authManager;

    private DatabaseActions databaseActions;

    private RoundRobinJobScheduler rrdDbScheduler;
    private RrdDbWrapper rrdDbWrapper;

    private TransactionFacade transactionFacade;
    private TransactionHandleRegistry transactionRegistry;

    protected abstract PreFlightTasks createPreflightTasks();

    protected abstract Iterable<ServerModule> createServerModules();

    protected abstract WebServer createWebServer();

    public AbstractNeoServer( ConfigurationBuilder configurator, Database.Factory dbFactory, GraphDatabaseFacadeFactory.Dependencies dependencies, LogProvider logProvider )
    {
        this.configurator = configurator;
        this.logProvider = logProvider;
        this.log = logProvider.getLog( getClass() );

        this.dbConfig = new Config();
        this.database = life.add( dependencyResolver.satisfyDependency(dbFactory.newDatabase( dbConfig, dependencies)) );

        FileUserRepository users = life.add( new FileUserRepository( configurator.configuration().get( ServerInternalSettings.auth_store ).toPath(), logProvider ) );

        this.authManager = life.add(new AuthManager( users, Clock.SYSTEM_CLOCK, configurator.configuration().get( ServerSettings.auth_enabled ) ));
        this.preFlight = dependencyResolver.satisfyDependency(createPreflightTasks());
        this.webServer = createWebServer();

        for ( ServerModule moduleClass : createServerModules() )
        {
            registerModule( moduleClass );
        }
    }

    @Override
    public void init()
    {

    }

    @Override
    public void start() throws ServerStartupException
    {
        InterruptThreadTimer interruptStartupTimer =
                dependencyResolver.satisfyDependency( createInterruptStartupTimer() );

        try
        {
            // Pre-flight tasks run outside the boot timeout limit
            runPreflightTasks();

            interruptStartupTimer.startCountdown();

            try
            {
                this.dbConfig.applyChanges( reloadConfigFromDisk() );

                life.start();

                DiagnosticsManager diagnosticsManager = resolveDependency(DiagnosticsManager.class);

                Log diagnosticsLog = diagnosticsManager.getTargetLog();
                diagnosticsLog.info( "--- SERVER STARTED START ---" );

                databaseActions = createDatabaseActions();

                if(getConfig().get( ServerInternalSettings.webadmin_enabled ))
                {
                    // TODO: RrdDb is not needed once we remove the old webadmin
                    rrdDbScheduler = new RoundRobinJobScheduler( logProvider );
                    rrdDbWrapper = new RrdFactory( configurator.configuration(), logProvider )
                            .createRrdDbAndSampler( database, rrdDbScheduler );
                }

                transactionFacade = createTransactionalActions();

                cypherExecutor = new CypherExecutor( database );

                configureWebServer();

                cypherExecutor.start();

                startModules();

                startWebServer();

                diagnosticsLog.info( "--- SERVER STARTED END ---" );
            }
            finally
            {
                interruptStartupTimer.stopCountdown();
            }
        }
        catch ( Throwable t )
        {
            // Make sure we don't leak rrd db files
            stopRrdDb();

            // If the database has been started, attempt to cleanly shut it down to avoid unclean shutdowns.
            life.shutdown();

            // Guard against poor operating systems that don't clear interrupt flags
            // after having handled interrupts (looking at you, Bill).
            Thread.interrupted();
            if ( interruptStartupTimer.wasTriggered() )
            {
                throw new ServerStartupException(
                        "Startup took longer than " + interruptStartupTimer.getTimeoutMillis() + "ms, " +
                                "and was stopped. You can disable this behavior by setting '" + ServerInternalSettings.startup_timeout.name() + "' to 0.",
                        1 );
            }

            throw new ServerStartupException( format( "Starting Neo4j Server failed: %s", t.getMessage() ), t );
        }
    }

    private Map<String, String> reloadConfigFromDisk()
    {
        Map<String, String> result = new HashMap<>( configurator.getDatabaseTuningProperties() );
        result.put( ServerInternalSettings.legacy_db_location.name(),
                configurator.configuration().get( ServerInternalSettings.legacy_db_location ).getAbsolutePath() );

        // make sure that the default in server for db_query_log_filename is "data/log/queries.log" instead of null
        if ( dbConfig.get( GraphDatabaseSettings.log_queries_filename ) == null )
        {
            result.put( GraphDatabaseSettings.log_queries_filename.name(), "data/log/queries.log" );
        }

        putIfAbsent( result, ShellSettings.remote_shell_enabled.name(), Settings.TRUE );
        result.putAll( configurator.configuration().getParams() );
        return result;
    }

    private void putIfAbsent( Map<String, String> databaseProperties, String configKey, String configValue )
    {
        if ( databaseProperties.get( configKey ) == null )
        {
            databaseProperties.put( configKey, configValue );
        }
    }

    public DependencyResolver getDependencyResolver()
    {
        return dependencyResolver;
    }

    protected DatabaseActions createDatabaseActions()
    {
        return new DatabaseActions(
                new LeaseManager( SYSTEM_CLOCK ),
                configurator.configuration().get(
                        ServerInternalSettings.script_sandboxing_enabled ), database.getGraph() );
    }

    private TransactionFacade createTransactionalActions()
    {
        final long timeoutMillis = getTransactionTimeoutMillis();
        final Clock clock = SYSTEM_CLOCK;

        transactionRegistry =
            new TransactionHandleRegistry( clock, timeoutMillis, logProvider );

        // ensure that this is > 0
        long runEvery = round( timeoutMillis / 2.0 );

        resolveDependency( JobScheduler.class ).scheduleRecurring( serverTransactionTimeout, new
                Runnable()
        {
            @Override
            public void run()
            {
                long maxAge = clock.currentTimeMillis() - timeoutMillis;
                transactionRegistry.rollbackSuspendedTransactionsIdleSince( maxAge );
            }
        }, runEvery, MILLISECONDS );

        return new TransactionFacade(
                new TransitionalPeriodTransactionMessContainer( database.getGraph() ),
                database.getGraph().getDependencyResolver().resolveDependency( QueryExecutionEngine.class ),
                transactionRegistry, logProvider
        );
    }

    /**
     * We are going to ensure the minimum timeout is 2 seconds. The timeout value is communicated to the user in
     * seconds rounded down, meaning if a user set a 1 second timeout, he would be told there was less than 1 second
     * remaining before he would need to renew the timeout.
     */
    private long getTransactionTimeoutMillis()
    {
        final long timeout = configurator.configuration().get( ServerSettings.transaction_timeout );
        return Math.max( timeout, MINIMUM_TIMEOUT + ROUNDING_SECOND );
    }

    protected InterruptThreadTimer createInterruptStartupTimer()
    {
        long startupTimeout = configurator.configuration().get( ServerInternalSettings.startup_timeout );
        InterruptThreadTimer stopStartupTimer;
        if ( startupTimeout > 0 )
        {
            log.info( "Setting startup timeout to %dms", startupTimeout );
            stopStartupTimer = InterruptThreadTimer.createTimer(
                    startupTimeout,
                    Thread.currentThread() );
        }
        else
        {
            stopStartupTimer = InterruptThreadTimer.createNoOpTimer();
        }
        return stopStartupTimer;
    }

    /**
     * Use this method to register server modules from subclasses
     */
    protected final void registerModule( ServerModule module )
    {
        serverModules.add( module );
    }

    private void startModules()
    {
        for ( ServerModule module : serverModules )
        {
            module.start();
        }
    }

    private void stopModules()
    {
        new RunCarefully( map( new Function<ServerModule, Runnable>()
        {
            @Override
            public Runnable apply( final ServerModule module )
            {
                return new Runnable()
                {
                    @Override
                    public void run()
                    {
                        module.stop();
                    }
                };
            }
        }, serverModules ) )
                .run();
    }

    private void runPreflightTasks()
    {
        if ( !preFlight.run() )
        {
            throw new PreflightFailedException( preFlight.failedTask() );
        }
    }

    @Override
    public Config getConfig()
    {
        return configurator.configuration();
    }

    @Override
    public Configuration getConfiguration()
    {
        return new ConfigWrappingConfiguration( this.configurator.configuration() );
    }

    // TODO: Once WebServer is fully implementing LifeCycle,
    // it should manage all but static (eg. unchangeable during runtime)
    // configuration itself.
    private void configureWebServer()
    {
        int webServerPort = getWebServerPort();
        String webServerAddr = getWebServerAddress();

        int maxThreads = getMaxThreads();

        int sslPort = getHttpsPort();
        boolean sslEnabled = getHttpsEnabled();

        log.info( "Starting HTTP on port %s (%d threads available)", webServerPort, maxThreads );
        webServer.setPort( webServerPort );
        webServer.setAddress( webServerAddr );
        webServer.setMaxThreads( maxThreads );

        webServer.setEnableHttps( sslEnabled );
        webServer.setHttpsPort( sslPort );

        webServer.setWadlEnabled( configurator.configuration().get( ServerInternalSettings.wadl_enabled ) );
        webServer.setDefaultInjectables( createDefaultInjectables() );

        if ( sslEnabled )
        {
            log.info( "Enabling HTTPS on port %s", sslPort );
            webServer.setHttpsCertificateInformation( initHttpsKeyStore() );
        }
    }

    private int getMaxThreads()
    {
        return configurator.configuration().get( ServerSettings.webserver_max_threads ) != null ?
               configurator.configuration().get( ServerSettings.webserver_max_threads ) :
                defaultMaxWebServerThreads();
    }

    private int defaultMaxWebServerThreads()
    {
        return Math.min(Runtime.getRuntime()
                .availableProcessors(),500);
    }

    private void startWebServer()
    {
        try
        {
            setUpHttpLogging();

            setUpTimeoutFilter();

            webServer.start();

            log.info( "Remote interface ready and available at %s", baseUri() );
        }
        catch ( RuntimeException e )
        {
            //noinspection deprecation
            log.error( "Failed to start Neo Server on port %d: %s",
                    getWebServerPort(), e.getMessage() );
            throw e;
        }
    }

    private void setUpHttpLogging()
    {
        if ( !httpLoggingProperlyConfigured() )
        {
            return;
        }
        boolean contentLoggingEnabled = configurator.configuration().get( ServerSettings.http_logging_enabled );

        File logFile = configurator.configuration().get( ServerSettings.http_log_config_File );
        webServer.setHttpLoggingConfiguration( logFile, contentLoggingEnabled );
    }

    private void setUpTimeoutFilter()
    {
        if ( getConfig().get( ServerSettings.webserver_limit_execution_time ) == null )
        {
            return;
        }
        //noinspection deprecation
        Guard guard = resolveDependency( Guard.class );
        if ( guard == null )
        {
            throw new RuntimeException( format("Inconsistent configuration. In order to use %s, you must set %s.",
                    ServerSettings.webserver_limit_execution_time.name(),
                    GraphDatabaseSettings.execution_guard_enabled.name()) );
        }

        Filter filter = new GuardingRequestFilter( guard, getConfig().get( ServerSettings.webserver_limit_execution_time ) );
        webServer.addFilter( filter, "/*" );
    }

    private boolean httpLoggingProperlyConfigured()
    {
        return loggingEnabled() && configLocated();
    }

    private boolean configLocated()
    {
        final File logFile = getConfig().get( ServerSettings.http_log_config_File );
        return logFile != null && logFile.exists();
    }

    private boolean loggingEnabled()
    {
        return getConfig().get( ServerSettings.http_logging_enabled );
    }

    protected int getWebServerPort()
    {
        return configurator.configuration().get( ServerSettings.webserver_port );
    }

    protected boolean getHttpsEnabled()
    {
        return configurator.configuration().get( ServerSettings.webserver_https_enabled );
    }

    protected int getHttpsPort()
    {
        return configurator.configuration().get( ServerSettings.webserver_https_port );
    }

    protected String getWebServerAddress()
    {
        return configurator.configuration().get( ServerSettings.webserver_address );
    }

    // TODO: This is jetty-specific, move to Jetty9WebServer

    /**
     * Jetty wants certificates stored in a key store, which is nice, but
     * to make it easier for non-java savvy users, we let them put
     * their certificates directly on the file system (advising appropriate
     * permissions etc), like you do with Apache Web Server. On each startup
     * we set up a key store for them with their certificate in it.
     */
    protected KeyStoreInformation initHttpsKeyStore()
    {
        File keystorePath = configurator.configuration().get( ServerSettings.webserver_keystore_path );

        File privateKeyPath = configurator.configuration().get( ServerSettings.webserver_https_key_path );

        File certificatePath = configurator.configuration().get( ServerSettings.webserver_https_cert_path );

        if ( !certificatePath.exists() )
        {
            //noinspection deprecation
            log.info( "No SSL certificate found, generating a self-signed certificate.." );
            SslCertificateFactory certFactory = new SslCertificateFactory();
            certFactory.createSelfSignedCertificate( certificatePath, privateKeyPath, getWebServerAddress() );
        }

        KeyStoreFactory keyStoreFactory = new KeyStoreFactory();
        return keyStoreFactory.createKeyStore( keystorePath, privateKeyPath, certificatePath );
    }

    @Override
    public void stop()
    {
        // TODO: All components should be moved over to the LifeSupport instance, life, in here.
        new RunCarefully(
            new Runnable() {
                @Override
                public void run()
                {
                    stopWebServer();
                }
            },
            new Runnable() {
                @Override
                public void run()
                {
                    stopModules();
                }
            },
            new Runnable() {
                @Override
                public void run()
                {
                    stopRrdDb();
                }
            },
            new Runnable() {
                @Override
                public void run()
                {
                    life.stop();
                }
            }
        ).run();

        //noinspection deprecation
        log.info( "Successfully shutdown database" );
    }

    private void stopRrdDb()
    {
        try
        {
            if( rrdDbScheduler != null)
            {
                rrdDbScheduler.stopJobs();
            }
            if( rrdDbWrapper != null )
            {
                rrdDbWrapper.close();
            }
            log.info( "Successfully shutdown Neo4j Server" );
        } catch(IOException e)
        {
            // If we fail on shutdown, we can't really recover from it. Log the issue and carry on.
            log.error( "Unable to cleanly shut down statistics database", e );
        }
    }

    private void stopWebServer()
    {
        if ( webServer != null )
        {
            webServer.stop();
        }
    }

    @Override
    public Database getDatabase()
    {
        return database;
    }

    @Override
    public TransactionRegistry getTransactionRegistry()
    {
        return transactionRegistry;
    }

    @Override
    public URI baseUri()
    {
        return uriBuilder.buildURI( getWebServerAddress(), getWebServerPort(), false );
    }

    public URI httpsUri()
    {
        return uriBuilder.buildURI( getWebServerAddress(), getHttpsPort(), true );
    }

    public WebServer getWebServer()
    {
        return webServer;
    }

    @Override
    public ConfigurationBuilder getConfigurationBuilder()
    {
        return configurator;
    }

    @Override
    public Configurator getConfigurator()
    {
        return new ConfigurationBuilder.ConfigurationBuilderWrappingConfigurator( getConfigurationBuilder() );
    }

    @Override
    public PluginManager getExtensionManager()
    {
        if ( hasModule( RESTApiModule.class ) )
        {
            return getModule( RESTApiModule.class ).getPlugins();
        }
        else
        {
            return null;
        }
    }

    protected Collection<InjectableProvider<?>> createDefaultInjectables()
    {
        Collection<InjectableProvider<?>> singletons = new ArrayList<>();

        Database database = getDatabase();

        singletons.add( new DatabaseProvider( database ) );
        singletons.add( new DatabaseActions.Provider( databaseActions ) );
        singletons.add( new GraphDatabaseServiceProvider( database ) );
        singletons.add( new NeoServerProvider( this ) );
        singletons.add( providerForSingleton( new ConfigWrappingConfiguration( getConfig() ), Configuration.class ) );
        singletons.add( providerForSingleton( getConfig(), Config.class ) );

        if(getConfig().get( ServerInternalSettings.webadmin_enabled ))
        {
            singletons.add( new RrdDbProvider( rrdDbWrapper ) );
        }

        singletons.add( new WebServerProvider( getWebServer() ) );

        PluginInvocatorProvider pluginInvocatorProvider = new PluginInvocatorProvider( this );
        singletons.add( pluginInvocatorProvider );
        RepresentationFormatRepository repository = new RepresentationFormatRepository( this );

        singletons.add( new InputFormatProvider( repository ) );
        singletons.add( new OutputFormatProvider( repository ) );
        singletons.add( new CypherExecutorProvider( cypherExecutor ) );
        singletons.add( new ExecutionEngineProvider( cypherExecutor ) );

        singletons.add( providerForSingleton( transactionFacade, TransactionFacade.class ) );
        singletons.add( providerForSingleton( authManager, AuthManager.class ) );
        singletons.add( new TransactionFilter( database ) );
        singletons.add( new LoggingProvider( logProvider ) );
        singletons.add( providerForSingleton( logProvider.getLog( NeoServer.class ), Log.class ) );

        return singletons;
    }

    private boolean hasModule( Class<? extends ServerModule> clazz )
    {
        for ( ServerModule sm : serverModules )
        {
            if ( sm.getClass() == clazz )
            {
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    private <T extends ServerModule> T getModule( Class<T> clazz )
    {
        for ( ServerModule sm : serverModules )
        {
            if ( sm.getClass() == clazz )
            {
                return (T) sm;
            }
        }

        return null;
    }

    protected <T> T resolveDependency( Class<T> type )
    {
        return dependencyResolver.resolveDependency( type );
    }

    private final Dependencies dependencyResolver = new Dependencies(new Supplier<DependencyResolver>()
    {
        @Override
        public DependencyResolver get()
        {
            Database db = dependencyResolver.resolveDependency( Database.class );
            return db.getGraph().getDependencyResolver();
        }
    });
}


File: community/server/src/main/java/org/neo4j/server/configuration/Configurator.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.configuration;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.MapConfiguration;

import org.neo4j.helpers.TimeUtil;
import org.neo4j.kernel.info.DiagnosticsExtractor;
import org.neo4j.kernel.info.DiagnosticsPhase;
import org.neo4j.logging.Logger;
import org.neo4j.server.web.ServerInternalSettings;
import static java.util.Collections.emptyList;
import static java.util.Collections.emptyMap;

/**
 * Using the server settings from {@link ServerSettings} with {@link Configuration a configuration}.
 */
@Deprecated
public interface Configurator
{
    String SECURITY_RULES_KEY = ServerSettings.security_rules.name();

    String AUTH_STORE_FILE_KEY = ServerInternalSettings.auth_store.name();
    String DB_TUNING_PROPERTY_FILE_KEY = ServerInternalSettings.legacy_db_config.name();
    String DEFAULT_CONFIG_DIR = File.separator + "etc" + File.separator + "neo";
    String DATABASE_LOCATION_PROPERTY_KEY = ServerInternalSettings.legacy_db_location.name();
    String DEFAULT_DATABASE_LOCATION_PROPERTY_KEY = ServerInternalSettings.legacy_db_location.getDefaultValue();

    String NEO_SERVER_CONFIG_FILE_KEY = ServerInternalSettings.SERVER_CONFIG_FILE_KEY;
    String DB_MODE_KEY = "org.neo4j.server.database.mode";

    int DEFAULT_WEBSERVER_PORT = Integer.valueOf( ServerSettings.webserver_port.getDefaultValue() );
    String WEBSERVER_PORT_PROPERTY_KEY = ServerSettings.webserver_port.name();
    String DEFAULT_WEBSERVER_ADDRESS = ServerSettings.webserver_address.getDefaultValue();
    String WEBSERVER_ADDRESS_PROPERTY_KEY = ServerSettings.webserver_address.name();
    String WEBSERVER_MAX_THREADS_PROPERTY_KEY = ServerSettings.webserver_max_threads.name();
    String WEBSERVER_LIMIT_EXECUTION_TIME_PROPERTY_KEY = ServerSettings.webserver_limit_execution_time.name();
    String WEBSERVER_ENABLE_STATISTICS_COLLECTION = ServerInternalSettings.webserver_statistics_collection_enabled.name();

    String REST_API_PACKAGE = "org.neo4j.server.rest.web";
    String REST_API_PATH_PROPERTY_KEY = ServerInternalSettings.rest_api_path.name();
    String DEFAULT_DATA_API_PATH = ServerInternalSettings.rest_api_path.getDefaultValue();

    String DISCOVERY_API_PACKAGE = "org.neo4j.server.rest.discovery";

    String MANAGEMENT_API_PACKAGE = "org.neo4j.server.webadmin.rest";
    String MANAGEMENT_PATH_PROPERTY_KEY = ServerInternalSettings.management_api_path.name();
    String DEFAULT_MANAGEMENT_API_PATH = ServerInternalSettings.management_api_path.getDefaultValue();

    String BROWSER_PATH = ServerInternalSettings.browser_path.getDefaultValue();

    String RRDB_LOCATION_PROPERTY_KEY = ServerSettings.rrdb_location.name();

    String MANAGEMENT_CONSOLE_ENGINES = ServerSettings.management_console_engines.name();
    List<String> DEFAULT_MANAGEMENT_CONSOLE_ENGINES = new ArrayList<String>(){
        private static final long serialVersionUID = 6621747998288594121L;
    {
        add( ServerSettings.management_console_engines.getDefaultValue() );
    }};

    String THIRD_PARTY_PACKAGES_KEY = ServerSettings.third_party_packages.name();

    String SCRIPT_SANDBOXING_ENABLED_KEY = ServerInternalSettings.script_sandboxing_enabled.name();
    Boolean DEFAULT_SCRIPT_SANDBOXING_ENABLED = Boolean.valueOf( ServerInternalSettings.script_sandboxing_enabled.getDefaultValue() );

    String WEBSERVER_HTTPS_ENABLED_PROPERTY_KEY = ServerSettings.webserver_https_enabled.name();
    Boolean DEFAULT_WEBSERVER_HTTPS_ENABLED = Boolean.valueOf( ServerSettings.webserver_https_enabled.getDefaultValue() );

    String WEBSERVER_HTTPS_PORT_PROPERTY_KEY = ServerSettings.webserver_https_port.name();
    int DEFAULT_WEBSERVER_HTTPS_PORT = Integer.valueOf( ServerSettings.webserver_https_port.getDefaultValue() );

    String WEBSERVER_KEYSTORE_PATH_PROPERTY_KEY = ServerSettings.webserver_keystore_path.name();
    String DEFAULT_WEBSERVER_KEYSTORE_PATH = ServerSettings.webserver_keystore_path.getDefaultValue();

    String WEBSERVER_HTTPS_CERT_PATH_PROPERTY_KEY = ServerSettings.webserver_https_cert_path.name();
    String DEFAULT_WEBSERVER_HTTPS_CERT_PATH = ServerSettings.webserver_https_cert_path.getDefaultValue();

    String WEBSERVER_HTTPS_KEY_PATH_PROPERTY_KEY = ServerSettings.webserver_https_key_path.name();
    String DEFAULT_WEBSERVER_HTTPS_KEY_PATH = ServerSettings.webserver_https_key_path.getDefaultValue();

    String HTTP_LOGGING = ServerSettings.http_logging_enabled.name();
    boolean DEFAULT_HTTP_LOGGING = Boolean.valueOf( ServerSettings.http_logging_enabled.getDefaultValue() );
    String HTTP_LOG_CONFIG_LOCATION = ServerSettings.http_log_config_File.name();

    String HTTP_CONTENT_LOGGING = ServerSettings.http_content_logging_enabled.name();
    boolean DEFAULT_HTTP_CONTENT_LOGGING = Boolean.valueOf( ServerSettings.http_content_logging_enabled.getDefaultValue() );

    String WADL_ENABLED = ServerInternalSettings.wadl_enabled.name();

    String STARTUP_TIMEOUT = ServerInternalSettings.startup_timeout.name();
    int DEFAULT_STARTUP_TIMEOUT = ( int ) ( TimeUtil.parseTimeMillis.apply( ServerInternalSettings.startup_timeout
            .getDefaultValue() ) / 1000 );
    String TRANSACTION_TIMEOUT = ServerSettings.transaction_timeout.name();
    int DEFAULT_TRANSACTION_TIMEOUT = ( int ) ( TimeUtil.parseTimeMillis.apply( ServerSettings.transaction_timeout
            .getDefaultValue() ) / 1000 );/*seconds*/;

    Configuration configuration();

    Map<String,String> getDatabaseTuningProperties();

    @Deprecated
    List<ThirdPartyJaxRsPackage> getThirdpartyJaxRsClasses();

    List<ThirdPartyJaxRsPackage> getThirdpartyJaxRsPackages();

    DiagnosticsExtractor<Configurator> DIAGNOSTICS = new DiagnosticsExtractor<Configurator>()
    {
        @Override
        public void dumpDiagnostics( final Configurator source, DiagnosticsPhase phase, Logger logger )
        {
            if ( phase.isInitialization() || phase.isExplicitlyRequested() )
            {
                final Configuration config = source.configuration();
                logger.log( "Server configuration:" );
                Iterator<String> keys = config.getKeys();
                while ( keys.hasNext() )
                {
                    String key = keys.next();
                    logger.log( "%s=%s", key, config.getProperty( key ) );
                }
            }
        }

        @Override
        public String toString()
        {
            return Configurator.class.getName();
        }
    };

    public static abstract class Adapter implements Configurator
    {
        @Override
        public List<ThirdPartyJaxRsPackage> getThirdpartyJaxRsClasses()
        {
            return getThirdpartyJaxRsPackages();
        }

        @Override
        public List<ThirdPartyJaxRsPackage> getThirdpartyJaxRsPackages()
        {
            return emptyList();
        }

        @Override
        public Map<String,String> getDatabaseTuningProperties()
        {
            return emptyMap();
        }

        @Override
        public Configuration configuration()
        {
            return new MapConfiguration( Collections.<String, String> emptyMap() );
        }
    }

    public static final Configurator EMPTY = new Configurator.Adapter()
    {
    };
}


File: community/server/src/main/java/org/neo4j/server/configuration/ServerSettings.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.configuration;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import org.neo4j.graphdb.config.Setting;
import org.neo4j.graphdb.factory.Description;
import org.neo4j.helpers.Function;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.helpers.Settings;
import org.neo4j.kernel.configuration.Internal;

import static org.neo4j.helpers.Settings.ANY;
import static org.neo4j.helpers.Settings.BOOLEAN;
import static org.neo4j.helpers.Settings.DURATION;
import static org.neo4j.helpers.Settings.EMPTY;
import static org.neo4j.helpers.Settings.FALSE;
import static org.neo4j.helpers.Settings.HOSTNAME_PORT;
import static org.neo4j.helpers.Settings.INTEGER;
import static org.neo4j.helpers.Settings.NO_DEFAULT;
import static org.neo4j.helpers.Settings.PATH;
import static org.neo4j.helpers.Settings.STRING;
import static org.neo4j.helpers.Settings.STRING_LIST;
import static org.neo4j.helpers.Settings.TRUE;
import static org.neo4j.helpers.Settings.illegalValueMessage;
import static org.neo4j.helpers.Settings.matches;
import static org.neo4j.helpers.Settings.min;
import static org.neo4j.helpers.Settings.port;
import static org.neo4j.helpers.Settings.setting;

@Description("Settings used by the server configuration")
public interface ServerSettings
{

    @Description( "Maximum request header size" )
    Setting<Integer> maximum_request_header_size =
            setting( "org.neo4j.server.webserver.max.request.header", INTEGER, "20480" );

    @Description( "Maximum response header size" )
    Setting<Integer> maximum_response_header_size =
            setting( "org.neo4j.server.webserver.max.response.header", INTEGER, "20480" );

    @Description( "Comma-seperated list of custom security rules for Neo4j to use." )
    Setting<List<String>> security_rules = setting( "org.neo4j.server.rest.security_rules",
            STRING_LIST, EMPTY );

    // webserver configuration
    @Description( "Http port for the Neo4j REST API." )
    Setting<Integer> webserver_port = setting( "org.neo4j.server.webserver.port", INTEGER, "7474",
            port );

    @Description( "Hostname for the Neo4j REST API" )
    Setting<String> webserver_address = setting( "org.neo4j.server.webserver.address", STRING,
            "localhost", illegalValueMessage( "Must be a valid hostname", matches( ANY ) ) );

    @Description( "Number of Neo4j worker threads." )
    Setting<Integer> webserver_max_threads = setting( "org.neo4j.server.webserver.maxthreads",
            INTEGER, NO_DEFAULT, min( 1 ) );

    @Description( "If execution time limiting is enabled in the database, this configures the maximum request execution time." )
    Setting<Long> webserver_limit_execution_time = setting(
            "org.neo4j.server.webserver.limit.executiontime", DURATION, NO_DEFAULT );

    @Description( "Path to the statistics database file." )
    Setting<File> rrdb_location = setting( "org.neo4j.server.webadmin.rrdb.location", PATH, NO_DEFAULT );

    @Description( "Console engines for the legacy webadmin administration" )
    Setting<List<String>> management_console_engines = setting(
            "org.neo4j.server.manage.console_engines", STRING_LIST, "SHELL" );

    @Description( "Comma-separated list of <classname>=<mount point> for unmanaged extensions." )
    Setting<List<ThirdPartyJaxRsPackage>> third_party_packages = setting( "org.neo4j.server.thirdparty_jaxrs_classes",
            new Function<String, List<ThirdPartyJaxRsPackage>>()
            {
                @Override
                public List<ThirdPartyJaxRsPackage> apply( String value )
                {
                    String[] list = value.split( Settings.SEPARATOR );
                    List<ThirdPartyJaxRsPackage> result = new ArrayList<>();
                    for ( String item : list )
                    {
                        item = item.trim();
                        if ( !item.equals( "" ) )
                        {
                            result.add( createThirdPartyJaxRsPackage( item ) );
                        }
                    }
                    return result;
                }

                @Override
                public String toString()
                {
                    return "a comma-seperated list of <classname>=<mount point> strings";
                }

                private ThirdPartyJaxRsPackage createThirdPartyJaxRsPackage( String packageAndMoutpoint )
                {
                    String[] parts = packageAndMoutpoint.split( "=" );
                    if ( parts.length != 2 )
                    {
                        throw new IllegalArgumentException( "config for " + ServerSettings.third_party_packages.name()
                                + " is wrong: " + packageAndMoutpoint );
                    }
                    String pkg = parts[0];
                    String mountPoint = parts[1];
                    return new ThirdPartyJaxRsPackage( pkg, mountPoint );
                }
            },
            EMPTY );

    @Description( "Enable HTTPS for the REST API." )
    Setting<Boolean> webserver_https_enabled = setting( "org.neo4j.server.webserver.https.enabled", BOOLEAN, FALSE );

    @Description( "HTTPS port for the REST API." )
    Setting<Integer> webserver_https_port = setting( "org.neo4j.server.webserver.https.port", INTEGER, "7473", port );

    @Description( "Path to the keystore used to store SSL certificates and keys while the server is running." )
    Setting<File> webserver_keystore_path = setting(
            "org.neo4j.server.webserver.https.keystore.location", PATH, "neo4j-home/ssl/keystore" );

    @Description( "Path to the SSL certificate used for HTTPS connections." )
    Setting<File> webserver_https_cert_path = setting(
            "org.neo4j.server.webserver.https.cert.location", PATH, "neo4j-home/ssl/snakeoil.cert" );

    @Description( "Path to the SSL key used for HTTPS connections." )
    Setting<File> webserver_https_key_path = setting(
            "org.neo4j.server.webserver.https.key.location", PATH, "neo4j-home/ssl/snakeoil.key" );

    @Description( "Enable HTTP request logging." )
    Setting<Boolean> http_logging_enabled = setting( "org.neo4j.server.http.log.enabled", BOOLEAN, FALSE );

    @Description( "Enable HTTP content logging." )
    Setting<Boolean> http_content_logging_enabled = setting( "org.neo4j.server.http.unsafe.content_log.enabled",
            BOOLEAN, FALSE );

    @Description( "Path to a logback configuration file for HTTP request logging." )
    Setting<File> http_log_config_File = setting( "org.neo4j.server.http.log.config", PATH, NO_DEFAULT );

    @Description( "Timeout for idle transactions." )
    Setting<Long> transaction_timeout = setting( "org.neo4j.server.transaction.timeout", DURATION, "60s" );

    @Description( "Enable auth requirement to access Neo4j." )
    Setting<Boolean> auth_enabled = setting("dbms.security.auth_enabled", BOOLEAN, TRUE);

    @Internal
    @Description("Enable Neo4j Data Protocol")
    Setting<Boolean> ndp_enabled = setting( "xx.ndp.enabled", BOOLEAN, "false" );

    @Internal
    @Description("Host and port for the Neo4j Data Protocol")
    Setting<HostnamePort> ndp_socket_address = setting( "dbms.ndp.address", HOSTNAME_PORT, "localhost:7687" );

    @Internal
    @Description("Host and port for the Neo4j Data Protocol Websocket")
    Setting<HostnamePort> ndp_ws_address = setting( "dbms.ndp.ws.address", HOSTNAME_PORT, "localhost:7688" );
}


File: community/server/src/main/java/org/neo4j/server/modules/NDPModule.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.modules;

import io.netty.channel.Channel;
import io.netty.util.internal.logging.InternalLoggerFactory;

import org.neo4j.collection.primitive.PrimitiveLongObjectMap;
import org.neo4j.function.Function;
import org.neo4j.graphdb.DependencyResolver;
import org.neo4j.helpers.HostnamePort;
import org.neo4j.kernel.GraphDatabaseAPI;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.kernel.impl.logging.LogService;
import org.neo4j.kernel.impl.util.JobScheduler;
import org.neo4j.kernel.lifecycle.LifeSupport;
import org.neo4j.logging.Log;
import org.neo4j.ndp.runtime.Sessions;
import org.neo4j.ndp.runtime.internal.StandardSessions;
import org.neo4j.ndp.runtime.internal.concurrent.ThreadedSessions;
import org.neo4j.ndp.transport.socket.NettyServer;
import org.neo4j.ndp.transport.socket.SocketProtocol;
import org.neo4j.ndp.transport.socket.SocketProtocolV1;
import org.neo4j.ndp.transport.socket.SocketTransport;
import org.neo4j.ndp.transport.socket.WebSocketTransport;
import org.neo4j.server.configuration.ServerSettings;
import org.neo4j.server.logging.Netty4LoggerFactory;
import org.neo4j.udc.UsageData;

import static java.util.Arrays.asList;
import static org.neo4j.collection.primitive.Primitive.longObjectMap;

/**
 * Experimental feature support for Neo4j Data Protocol, must be explicitly enabled to start up.
 */
public class NDPModule implements ServerModule
{
    private final Config config;
    private final DependencyResolver dependencyResolver;
    private final LifeSupport life = new LifeSupport();

    public NDPModule( Config config, DependencyResolver dependencyResolver )
    {
        this.config = config;
        this.dependencyResolver = dependencyResolver;
    }

    @Override
    public void start()
    {
        // These three pulled out dynamically due to initialization ordering issue where this module is
        // created before the below services are created. A bigger piece of work is pending to
        // organize this module life cycle better.
        final GraphDatabaseAPI api = dependencyResolver.resolveDependency( GraphDatabaseAPI.class );
        final LogService logging = dependencyResolver.resolveDependency( LogService.class );
        final UsageData usageData = dependencyResolver.resolveDependency( UsageData.class );
        final JobScheduler scheduler = dependencyResolver.resolveDependency( JobScheduler.class );

        final Log internalLog = logging.getInternalLog( Sessions.class );
        final Log userLog = logging.getUserLog( Sessions.class );

        final HostnamePort socketAddress = config.get( ServerSettings.ndp_socket_address );
        final HostnamePort webSocketAddress = config.get( ServerSettings.ndp_ws_address );

        if ( config.get( ServerSettings.ndp_enabled ) )
        {
            final Sessions sessions = life.add( new ThreadedSessions(
                    life.add( new StandardSessions( api, usageData, logging ) ),
                    scheduler,
                    logging ) );

            PrimitiveLongObjectMap<Function<Channel,SocketProtocol>> availableVersions = longObjectMap();
            availableVersions.put( SocketProtocolV1.VERSION, new Function<Channel,SocketProtocol>()
            {
                @Override
                public SocketProtocol apply( Channel channel )
                {
                    return new SocketProtocolV1( logging, sessions.newSession(), channel );
                }
            } );

            InternalLoggerFactory.setDefaultFactory( new Netty4LoggerFactory( logging.getInternalLogProvider() ) );
            life.add( new NettyServer( asList(
                    new SocketTransport( socketAddress, availableVersions ),
                    new WebSocketTransport( webSocketAddress, availableVersions ) ) ) );
            internalLog.info( "NDP Server extension loaded." );
            userLog.info( "Experimental NDP support enabled! Listening for socket connections on " + socketAddress +
                          " and for websocket connections on " + webSocketAddress + ".");
        }

        life.start();
    }

    @Override
    public void stop()
    {
        life.stop();
    }
}


File: community/server/src/main/java/org/neo4j/server/security/ssl/KeyStoreFactory.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.spec.InvalidKeySpecException;
import javax.crypto.NoSuchPaddingException;

public class KeyStoreFactory
{
    private SslCertificateFactory sslCertificateFactory;

    public KeyStoreFactory()
    {
        this.sslCertificateFactory = new SslCertificateFactory();
    }

    public KeyStoreInformation createKeyStore( File keyStorePath, File privateKeyPath, File certificatePath )
    {
        try
        {

            char[] keyStorePassword = getRandomChars( 50 );
            char[] keyPassword = getRandomChars( 50 );

            createKeyStore( keyStorePath, keyStorePassword, keyPassword,
                    privateKeyPath, certificatePath );

            return new KeyStoreInformation( keyStorePath.getAbsolutePath(),
                    keyStorePassword, keyPassword );

        }
        catch ( Exception e )
        {
            throw new RuntimeException(
                    "Unable to setup keystore for SSL certificate, see nested exception.", e );
        }
    }

    private void createKeyStore( File keyStorePath, char[] keyStorePassword,
                                 char[] keyPassword, File privateKeyFile, File certFile )
            throws KeyStoreException, NoSuchAlgorithmException,
            CertificateException, IOException, InvalidKeyException,
            InvalidKeySpecException, NoSuchPaddingException,
            InvalidAlgorithmParameterException
    {
        FileOutputStream fis = null;
        try
        {

            if ( keyStorePath.exists() )
            {
                keyStorePath.delete();
            }

            ensureFolderExists( keyStorePath.getParentFile() );

            KeyStore keyStore = KeyStore.getInstance( "JKS" );
            keyStore.load( null, keyStorePassword );

            keyStore.setKeyEntry(
                    "key",
                    sslCertificateFactory.loadPrivateKey( privateKeyFile ),
                    keyPassword,
                    sslCertificateFactory.loadCertificates( certFile ) );

            fis = new FileOutputStream( keyStorePath.getAbsolutePath() );
            keyStore.store( fis, keyStorePassword );

        }
        finally
        {
            if ( fis != null )
            {
                try
                {
                    fis.close();
                }
                catch ( IOException e )
                {
                    throw new RuntimeException( e );
                }
            }
        }
    }

    private char[] getRandomChars( int length )
    {
        SecureRandom rand = new SecureRandom();
        char[] chars = new char[length];
        for ( int i = 0; i < length; i++ )
        {
            chars[i] = (char) rand.nextInt();
        }
        return chars;
    }

    private void ensureFolderExists( File path )
    {
        if ( !path.exists() )
        {
            path.mkdirs();
        }
    }
}


File: community/server/src/main/java/org/neo4j/server/security/ssl/KeyStoreInformation.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

public class KeyStoreInformation {

    private final String keyStorePath;
    private final char[] keyStorePassword;
    private final char[] keyPassword;
    
    public KeyStoreInformation(String keyStorePath, char[] keyStorePassword, char[] keyPassword) {
        this.keyStorePassword = keyStorePassword;
        this.keyStorePath = keyStorePath;
        this.keyPassword = keyPassword;
    }
    
    public String getKeyStorePath() {
        return keyStorePath;
    }
    
    public char[] getKeyStorePassword() {
        return keyStorePassword;
    }

    public char[] getKeyPassword() {
        return keyPassword;
    }
    
}


File: community/server/src/main/java/org/neo4j/server/security/ssl/SslCertificateFactory.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Collection;
import java.util.Date;

import javax.crypto.NoSuchPaddingException;

import org.bouncycastle.jce.X509Principal;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.x509.X509V3CertificateGenerator;

public class SslCertificateFactory {

    private static final String CERTIFICATE_TYPE = "X.509";
    private static final String KEY_ENCRYPTION = "RSA";
    
    {
        Security.addProvider(new BouncyCastleProvider());
    }
    
    public void createSelfSignedCertificate(File certificatePath,
            File privateKeyPath, String hostName)
    {
        FileOutputStream fos = null;
        try {

            KeyPairGenerator keyPairGenerator = KeyPairGenerator
                    .getInstance(KEY_ENCRYPTION);
            keyPairGenerator.initialize(1024);
            KeyPair keyPair = keyPairGenerator.generateKeyPair();

            X509V3CertificateGenerator certGenertor = new X509V3CertificateGenerator();

            certGenertor.setSerialNumber(BigInteger.valueOf(
                    new SecureRandom().nextInt()).abs());
            certGenertor.setIssuerDN(new X509Principal("CN=" + hostName
                    + ", OU=None, O=None L=None, C=None"));
            certGenertor.setNotBefore(new Date(System.currentTimeMillis()
                    - 1000L * 60 * 60 * 24 * 30));
            certGenertor.setNotAfter(new Date(System.currentTimeMillis()
                    + (1000L * 60 * 60 * 24 * 365 * 10)));
            certGenertor.setSubjectDN(new X509Principal("CN=" + hostName
                    + ", OU=None, O=None L=None, C=None"));

            certGenertor.setPublicKey(keyPair.getPublic());
            certGenertor.setSignatureAlgorithm("MD5WithRSAEncryption");

            Certificate certificate = certGenertor.generate(
                    keyPair.getPrivate(), "BC");            

            ensureFolderExists(certificatePath.getParentFile());
            ensureFolderExists(privateKeyPath.getParentFile());
            
            fos = new FileOutputStream(certificatePath);
            fos.write(certificate.getEncoded());
            fos.close();

            fos = new FileOutputStream(privateKeyPath);
            fos.write(keyPair.getPrivate().getEncoded());
            fos.close();

        } catch (Exception e)
        {
            throw new RuntimeException("Unable to create self signed SSL certificate, please see nested exception.", e);
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    public Certificate[] loadCertificates(File certFile)
            throws CertificateException, FileNotFoundException {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(certFile);
            Collection<? extends Certificate> certificates = CertificateFactory.getInstance(CERTIFICATE_TYPE).generateCertificates(
                    fis);
            return certificates.toArray(new Certificate[]{});
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    public PrivateKey loadPrivateKey(File privateKeyFile)
            throws IOException, NoSuchAlgorithmException,
            InvalidKeySpecException, NoSuchPaddingException,
            InvalidKeyException, InvalidAlgorithmParameterException 
            {
        DataInputStream dis = null;
        try 
        {
            FileInputStream fis = new FileInputStream(privateKeyFile);
            dis = new DataInputStream(fis);
            byte[] keyBytes = new byte[(int) privateKeyFile.length()];
            dis.readFully(keyBytes);

            KeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);

            return KeyFactory.getInstance(KEY_ENCRYPTION).generatePrivate(keySpec);
        } catch (FileNotFoundException e ) 
        {
            throw new IOException("Could not find private key file to use for SSL support, see nested exception.", e);
        } finally 
        {
            if (dis != null) {
                try {
                    dis.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    private void ensureFolderExists(File path) {
        if(!path.exists()) {
            path.mkdirs();
        }
    }

}


File: community/server/src/main/java/org/neo4j/server/security/ssl/SslSocketConnectorFactory.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

import org.eclipse.jetty.http.HttpScheme;
import org.eclipse.jetty.http.HttpVersion;
import org.eclipse.jetty.server.*;
import org.eclipse.jetty.util.ssl.SslContextFactory;

import org.neo4j.kernel.configuration.Config;
import org.neo4j.server.web.HttpConnectorFactory;
import org.neo4j.server.web.JettyThreadCalculator;


public class SslSocketConnectorFactory extends HttpConnectorFactory
{
    private Config configuration;

    public SslSocketConnectorFactory( Config configuration )
    {
        super(configuration);
        this.configuration = configuration;
    }

    @Override
    protected HttpConfiguration createHttpConfig()
    {
        HttpConfiguration httpConfig = super.createHttpConfig();
        httpConfig.addCustomizer( new HttpConfiguration.Customizer()
        {
            @Override
            public void customize( Connector connector, HttpConfiguration channelConfig, Request request )
            {
                request.setScheme( HttpScheme.HTTPS.asString() );
            }
        } );
        return httpConfig;
    }

    public ServerConnector createConnector( Server server, KeyStoreInformation config, String host, int port, JettyThreadCalculator jettyThreadCalculator )
    {

        SslConnectionFactory sslConnectionFactory = createSslConnectionFactory( config );

        return super.createConnector( server, host, port, jettyThreadCalculator, sslConnectionFactory, createHttpConnectionFactory() );
    }

    private SslConnectionFactory createSslConnectionFactory( KeyStoreInformation config )
    {
        SslContextFactory sslContextFactory = new SslContextFactory();

        sslContextFactory.setKeyStorePath( config.getKeyStorePath() );
        sslContextFactory.setKeyStorePassword( String.valueOf( config.getKeyStorePassword() ) );
        sslContextFactory.setKeyManagerPassword( String.valueOf( config.getKeyPassword() ) );

        return new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString());
    }

}


File: community/server/src/test/java/org/neo4j/server/Neo4jDataProtocolIT.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server;

import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.Arrays;

import org.neo4j.server.configuration.ServerSettings;
import org.neo4j.test.server.ExclusiveServerTestBase;

import static org.neo4j.server.helpers.CommunityServerBuilder.server;

public class Neo4jDataProtocolIT extends ExclusiveServerTestBase
{
    @Rule
    public TemporaryFolder tmpDir = new TemporaryFolder();

    private CommunityNeoServer server;

    @After
    public void stopTheServer()
    {
        server.stop();
    }

    @Test
    public void shouldLaunchNDP() throws Throwable
    {
        // When I run Neo4j with NDP enabled
        server = server()
                .withProperty( ServerSettings.ndp_enabled.name(), "true" )
                .usingDatabaseDir( tmpDir.getRoot().getAbsolutePath() )
                .build();
        server.start();

        // Then
        assertEventuallyServerResponds( "localhost", 7687 );
    }

    @Test
    public void shouldBeAbleToSpecifyHostAndPort() throws Throwable
    {
        // When I run Neo4j with the ndp extension on the class path
        // When I run Neo4j with NDP enabled
        server = server()
                .withProperty( ServerSettings.ndp_enabled.name(), "true" )
                .withProperty( ServerSettings.ndp_socket_address.name(), "localhost:8776" )
                .usingDatabaseDir( tmpDir.getRoot().getAbsolutePath() )
                .build();
        server.start();

        // Then
        assertEventuallyServerResponds( "localhost", 8776 );
    }

    private void assertEventuallyServerResponds( String host, int port ) throws IOException, InterruptedException
    {
        long timeout = System.currentTimeMillis() + 1000 * 30;
        for (; ; )
        {
            if ( serverResponds( host, port ) )
            {
                return;
            }
            else
            {
                Thread.sleep( 100 );
            }

            // Make sure process still is alive
            if ( System.currentTimeMillis() > timeout )
            {
                throw new RuntimeException( "Waited for 30 seconds for server to respond to HTTP calls, " +
                                            "but no response, timing out to avoid blocking forever." );
            }
        }
    }

    private boolean serverResponds( String host, int port ) throws IOException, InterruptedException
    {
        try
        {
            try ( Socket socket = new Socket() )
            {
                // Ok, we can connect - can we perform the version handshake?
                socket.connect( new InetSocketAddress( host, port ) );
                OutputStream out = socket.getOutputStream();
                InputStream in = socket.getInputStream();

                // Hard-coded handshake, a general "test client" would be useful further on.
                out.write( new byte[]{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} );

                byte[] accepted = new byte[4];
                in.read( accepted );

                return Arrays.equals( accepted, new byte[]{0, 0, 0, 1} );
            }
        }
        catch ( ConnectException e )
        {
            return false;
        }
    }
}


File: community/server/src/test/java/org/neo4j/server/security/ssl/KeyStoreFactoryTest.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

import java.io.File;
import java.io.FileInputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.cert.Certificate;

import org.junit.Test;
import org.neo4j.server.security.ssl.KeyStoreFactory;
import org.neo4j.server.security.ssl.KeyStoreInformation;
import org.neo4j.server.security.ssl.SslCertificateFactory;

import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;

public class KeyStoreFactoryTest
{
    @Test
    public void shouldCreateKeyStoreForGivenKeyPair() throws Exception
    {
        // given
        File certificatePath = File.createTempFile( "cert", "test" );
        File privateKeyPath = File.createTempFile( "privatekey", "test" );
        File keyStorePath = File.createTempFile( "keyStore", "test" );

        new SslCertificateFactory().createSelfSignedCertificate( certificatePath, privateKeyPath, "some-hostname" );

        // when
        KeyStoreInformation ks = new KeyStoreFactory().createKeyStore( keyStorePath, privateKeyPath, certificatePath );

        // then
        assertThat( new File( ks.getKeyStorePath() ).exists(), is( true ) );
    }

    @Test
    public void shouldImportSingleCertificateWhenNotInAChain() throws Exception
    {
        // given
        File certificatePath = File.createTempFile( "cert", "test" );
        File privateKeyPath = File.createTempFile( "privatekey", "test" );
        File keyStorePath = File.createTempFile( "keyStore", "test" );

        new SslCertificateFactory().createSelfSignedCertificate( certificatePath, privateKeyPath, "some-hostname" );

        KeyStoreInformation keyStoreInformation = new KeyStoreFactory().createKeyStore( keyStorePath, privateKeyPath,
                certificatePath );


        KeyStore keyStore = KeyStore.getInstance( "JKS" );
        keyStore.load( new FileInputStream( keyStoreInformation.getKeyStorePath() ),
                keyStoreInformation.getKeyStorePassword() );

        // when
        Certificate[] chain = keyStore.getCertificateChain( "key" );

        // then
        assertEquals( "Single certificate expected not a chain of [" + chain.length + "]", 1, chain.length );
    }

    @Test
    public void shouldImportAllCertificatesInAChain() throws Exception
    {
        // given
        File keyStorePath = File.createTempFile( "keyStore", "test" );
        File privateKeyPath = fileFromResources( "/certificates/chained_key.der" );
        File certificatePath = fileFromResources( "/certificates/combined.pem" );
        KeyStoreInformation keyStoreInformation = new KeyStoreFactory().createKeyStore( keyStorePath, privateKeyPath,
                certificatePath );

        KeyStore keyStore = KeyStore.getInstance( "JKS" );
        keyStore.load( new FileInputStream( keyStoreInformation.getKeyStorePath() ),
                keyStoreInformation.getKeyStorePassword() );

        // when
        Certificate[] chain = keyStore.getCertificateChain( "key" );

        // then
        assertEquals( "3 certificates expected in chain: root, intermediary, and user's", 3, chain.length );
    }

    private File fileFromResources( String path )
    {
        URL url = this.getClass().getResource( path );
        return new File( url.getFile() );
    }

}


File: community/server/src/test/java/org/neo4j/server/security/ssl/TestSslCertificateFactory.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.security.ssl;

import java.io.File;
import java.security.PrivateKey;
import java.security.cert.Certificate;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.neo4j.server.security.ssl.SslCertificateFactory;

import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.Assert.assertThat;

public class TestSslCertificateFactory
{
    private File cPath;
    private File pkPath;

    @Test
    public void shouldCreateASelfSignedCertificate() throws Exception
    {
        SslCertificateFactory sslFactory = new SslCertificateFactory();
        sslFactory.createSelfSignedCertificate( cPath, pkPath, "myhost" );

        // Attempt to load certificate
        Certificate[] certificates = sslFactory.loadCertificates( cPath );
        assertThat( certificates.length, is( greaterThan( 0 ) ) );

        // Attempt to load private key
        PrivateKey pk = sslFactory.loadPrivateKey( pkPath );
        assertThat( pk, notNullValue() );
    }
    
    @Before
    public void createFiles() throws Exception
    {
        cPath = File.createTempFile( "cert", "test" );
        pkPath = File.createTempFile( "privatekey", "test" );
    }

    @After
    public void deleteFiles() throws Exception
    {
        pkPath.delete();
        cPath.delete();
    }
}


File: community/server/src/test/java/org/neo4j/server/web/TestJetty9WebServer.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.server.web;

import java.io.File;
import java.io.IOException;

import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.junit.Rule;
import org.junit.Test;

import org.neo4j.kernel.GraphDatabaseDependencies;
import org.neo4j.kernel.configuration.Config;
import org.neo4j.logging.NullLogProvider;
import org.neo4j.server.WrappingNeoServerBootstrapper;
import org.neo4j.server.configuration.Configurator;
import org.neo4j.server.configuration.ServerConfigurator;
import org.neo4j.test.ImpermanentDatabaseRule;
import org.neo4j.test.ImpermanentGraphDatabase;
import org.neo4j.test.Mute;

import static org.junit.Assert.assertEquals;

import static org.neo4j.helpers.collection.MapUtil.stringMap;
import static org.neo4j.test.Mute.muteAll;

public class TestJetty9WebServer
{
    @Test
    public void shouldBeAbleToUsePortZero() throws IOException
    {
        Jetty9WebServer webServer = new Jetty9WebServer( NullLogProvider.getInstance(), new Config() );

        webServer.setPort( 0 );

        webServer.start();

        webServer.stop();
    }

    @Test
    public void shouldBeAbleToRestart() throws Throwable
    {
        Jetty9WebServer server = new Jetty9WebServer( NullLogProvider.getInstance(), new Config() );
        try
        {
            server.setAddress( "127.0.0.1" );
            server.setPort( 7878 );

            server.start();
            server.stop();
            server.start();
        }
        finally
        {
            try
            {
                server.stop();
            }
            catch ( Throwable t )
            {

            }
        }
    }

    @Test
    public void shouldBeAbleToSetExecutionLimit() throws Throwable
    {
        @SuppressWarnings("deprecation")
        ImpermanentGraphDatabase db = new ImpermanentGraphDatabase( new File( "path" ), stringMap(),
                GraphDatabaseDependencies.newDependencies() )
        {
        };

        ServerConfigurator config = new ServerConfigurator( db );
        config.configuration().setProperty( Configurator.WEBSERVER_PORT_PROPERTY_KEY, "7476" );
        config.configuration().setProperty( Configurator.WEBSERVER_LIMIT_EXECUTION_TIME_PROPERTY_KEY, "1000s" );
        WrappingNeoServerBootstrapper testBootstrapper = new WrappingNeoServerBootstrapper( db, config );

        // When
        testBootstrapper.start();
        testBootstrapper.stop();

        // Then it should not have crashed
        // TODO: This is a really poor test, but does not feel worth re-visiting right now since we're removing the
        // guard in subsequent releases.
    }

    @Test
    public void shouldStopCleanlyEvenWhenItHasntBeenStarted()
    {
        new Jetty9WebServer( NullLogProvider.getInstance(), null ).stop();
    }

    /*
     * The default jetty behaviour serves an index page for static resources. The 'directories' exposed through this
     * behaviour are not file system directories, but only a list of resources present on the classpath, so there is no
     * security vulnerability. However, it might seem like a vulnerability to somebody without the context of how the
     * whole stack works, so to avoid confusion we disable the jetty behaviour.
     */
    @Test
    public void shouldDisallowDirectoryListings() throws Exception
    {
        @SuppressWarnings("deprecation")
        ImpermanentGraphDatabase db = new ImpermanentGraphDatabase( new File( "path" ), stringMap(),
                GraphDatabaseDependencies.newDependencies() )
        {
        };

        ServerConfigurator config = new ServerConfigurator( db );
        config.configuration().setProperty( Configurator.WEBSERVER_PORT_PROPERTY_KEY, "7477" );
        WrappingNeoServerBootstrapper testBootstrapper = new WrappingNeoServerBootstrapper( db, config );

        testBootstrapper.start();

        try ( CloseableHttpClient httpClient = HttpClientBuilder.create().build() )
        {
            // Depends on specific resources exposed by the browser module; if this test starts to fail,
            // check whether the structure of the browser module has changed and adjust accordingly.
            assertEquals( 200, httpClient.execute( new HttpGet(
                    "http://localhost:7477/browser/content/help/create.html" ) ).getStatusLine().getStatusCode() );
            assertEquals( 403, httpClient.execute( new HttpGet(
                    "http://localhost:7477/browser/content/help/" ) ).getStatusLine().getStatusCode() );
        }

        testBootstrapper.stop();
    }

    @Rule
    public Mute mute = muteAll();

    @Rule
    public ImpermanentDatabaseRule dbRule = new ImpermanentDatabaseRule();
}


File: community/server/src/test/java/org/neo4j/test/server/ExclusiveServerTestBase.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.test.server;

import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.rules.TestName;

import java.util.concurrent.Callable;

import org.neo4j.test.Mute;
import org.neo4j.test.TargetDirectory;

import static org.neo4j.test.Mute.muteAll;

public class ExclusiveServerTestBase
{
    public TargetDirectory folder = TargetDirectory.forTest( getClass() );

    @Rule
    public Mute mute = muteAll();
    @Rule
    public TestName name = new TestName();

    @BeforeClass
    public static void ensureServerNotRunning() throws Exception
    {
        muteAll().call( new Callable<Void>()
        {
            @Override
            public Void call() throws Exception
            {
                ServerHolder.ensureNotRunning();
                return null;
            }
        } );
    }
}


File: community/server/src/test/java/org/neo4j/test/server/SharedServerTestBase.java
/*
 * Copyright (c) 2002-2015 "Neo Technology,"
 * Network Engine for Objects in Lund AB [http://neotechnology.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.neo4j.test.server;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Rule;

import java.util.concurrent.Callable;

import org.neo4j.server.NeoServer;
import org.neo4j.server.helpers.ServerHelper;
import org.neo4j.test.Mute;

import static org.neo4j.test.Mute.muteAll;

public class SharedServerTestBase
{
    private static boolean useExternal = Boolean.valueOf( System.getProperty( "neo-server.external", "false" ) );

    protected static NeoServer server()
    {
        return server;
    }

    private static NeoServer server;

	@Rule
	public Mute mute = muteAll();

    @BeforeClass
    public static void allocateServer() throws Throwable
    {
        if ( !useExternal )
        {
            muteAll().call( new Callable<Void>()
            {
                @Override
                public Void call() throws Exception
                {
                    server = ServerHolder.allocate();
                    ServerHelper.cleanTheDatabase( server );
                    return null;
                }
            } );
        }
    }

    @AfterClass
    public static void releaseServer() throws Exception
    {
        if ( !useExternal )
        {
            try
            {
                muteAll().call( new Callable<Void>()
                {
                    @Override
                    public Void call() throws Exception
                    {
                        ServerHolder.release( server );
                        return null;
                    }
                } );
            }
            finally
            {
                server = null;
            }
        }
    }
}
