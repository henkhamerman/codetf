Refactoring Types: ['Move Class']
assy/bus/AbstractPubSubSupport.java
package net.engio.mbassy.bus;

import net.engio.mbassy.bus.common.DeadMessage;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.common.PubSubSupport;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionManager;

import java.util.*;

import static net.engio.mbassy.bus.common.Properties.Handler.PublicationError;

/**
 * The base class for all message bus implementations.
 *
 * @param <T>
 */
public abstract class AbstractPubSubSupport<T> implements PubSubSupport<T> {


    // this handler will receive all errors that occur during message dispatch or message handling
    private final List<IPublicationErrorHandler> errorHandlers = new ArrayList<IPublicationErrorHandler>();

    private final MessagePublication.Factory publicationFactory;

    private final SubscriptionManager subscriptionManager;

    private final BusRuntime runtime;

    public static final String ERROR_HANDLER_MSG = "INFO: No error handler has been configured to handle exceptions during publication.\n" +
            "Publication error handlers can be added by IBusConfiguration.addPublicationErrorHandler()\n" +
            "Falling back to console logger.";




    public AbstractPubSubSupport(IBusConfiguration configuration) {

        //transfer publication error handlers from the config object
        this.errorHandlers.addAll(configuration.getRegisteredPublicationErrorHandlers());
        if (errorHandlers.isEmpty()) {
            errorHandlers.add(new IPublicationErrorHandler.ConsoleLogger());
            System.out.println(ERROR_HANDLER_MSG);
        }
        this.runtime = new BusRuntime(this).add(PublicationError, getRegisteredErrorHandlers())
                                           .add(Properties.Common.Id, UUID.randomUUID()
                                                                          .toString());
        // configure the pub sub feature
        Feature.SyncPubSub pubSubFeature = configuration.getFeature(Feature.SyncPubSub.class);
        this.subscriptionManager = pubSubFeature.getSubscriptionManagerProvider()
                                                .createManager(pubSubFeature.getMetadataReader(), pubSubFeature.getSubscriptionFactory(), runtime);
        this.publicationFactory = pubSubFeature.getPublicationFactory();
    }

    protected MessagePublication.Factory getPublicationFactory() {
        return publicationFactory;
    }


    public Collection<IPublicationErrorHandler> getRegisteredErrorHandlers() {
        return Collections.unmodifiableCollection(errorHandlers);
    }

    public boolean unsubscribe(Object listener) {
        return subscriptionManager.unsubscribe(listener);
    }


    public void subscribe(Object listener) {
        subscriptionManager.subscribe(listener);
    }


    @Override
    public BusRuntime getRuntime() {
        return runtime;
    }

    protected IMessagePublication createMessagePublication(T message) {
        Collection<Subscription> subscriptions = getSubscriptionsByMessageType(message.getClass());
        if ((subscriptions == null || subscriptions.isEmpty()) && !message.getClass()
                                                                          .equals(DeadMessage.class)) {
            // Dead Event
            subscriptions = getSubscriptionsByMessageType(DeadMessage.class);
            return getPublicationFactory().createPublication(runtime, subscriptions, new DeadMessage(message));
        } else {
            return getPublicationFactory().createPublication(runtime, subscriptions, message);
        }
    }

    // obtain the set of subscriptions for the given message type
    // Note: never returns null!
    protected Collection<Subscription> getSubscriptionsByMessageType(Class messageType) {
        return subscriptionManager.getSubscriptionsByMessageType(messageType);
    }


    public void handlePublicationError(PublicationError error) {
        for (IPublicationErrorHandler errorHandler : errorHandlers) {
            errorHandler.handleError(error);
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{ " + runtime.get(Properties.Common.Id) + "}";
    }
}


File: src/main/java/net/engio/mbassy/bus/common/ErrorHandlingSupport.java
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;

import java.util.Collection;

/**
 * Publication errors may occur at various points of time during message delivery. A handler may throw an exception,
 * may not be accessible due to security constraints or is not annotated properly.
 * In any of all possible cases a publication error is created and passed to each of the registered error handlers.
 * Error handlers can be added via the {@link IBusConfiguration}.
 *
 */

public interface ErrorHandlingSupport {


    /**
     * Returns an immutable collection containing all the registered error handlers
     *
     * @return
     */
    Collection<IPublicationErrorHandler> getRegisteredErrorHandlers();

}


File: src/main/java/net/engio/mbassy/bus/common/IMessageBus.java
package net.engio.mbassy.bus.common;

import net.engio.mbassy.bus.publication.ISyncAsyncPublicationCommand;

/**
 * A message bus offers facilities for publishing messages to the message handlers of registered listeners.
 * A message publication starts when an object is send to the bus using one of the its publication methods.
 *
 * Messages can be published synchronously or asynchronously and may be of any type that is a valid sub type of the type parameter T.
 * Message handlers can be invoked synchronously or asynchronously depending on their configuration. Thus, there
 * are two notions of synchronicity / asynchronicity. One on the caller side, e.g. the invocation of the message publishing
 * methods. The second on the handler side, e.g. whether the handler is invoked in the same or a different thread.
 *
 * <p/>
 * Each message publication is isolated from all other running publications such that it does not interfere with them.
 * Hence, the bus generally expects message handlers to be stateless as it may invoke them concurrently if multiple
 * messages get published asynchronously. If handlers are stateful and not thread-safe they can be marked to be invoked
 * in a synchronized fashion using @Synchronized annotation
 *
 * <p/>
 * A listener is any object that defines at least one message handler and that has been subscribed to at least
 * one message bus. A message handler can be any method that accepts exactly one parameter (the message) and is marked
 * as a message handler using the @Handler annotation.
 *
 * <p/>
 * By default, the bus uses weak references to all listeners such that registered listeners do not need to
 * be explicitly unregistered to be eligible for garbage collection. Dead (garbage collected) listeners are
 * removed on-the-fly as messages get dispatched. This can be changed using the @Listener annotation.
 *
 * <p/>
 * Generally message handlers will be invoked in inverse sequence of subscription but any
 * client using this bus should not rely on this assumption. The basic contract of the bus is that it will deliver
 * a specific message exactly once to each of the respective message handlers.
 *
 * <p/>
 * Messages are dispatched to all listeners that accept the type or supertype of the dispatched message. Additionally
 * a message handler may define filters to narrow the set of messages that it accepts.
 *
 * <p/>
 * Subscribed message handlers are available to all pending message publications that have not yet started processing.
 * Any message listener may only be subscribed once -> subsequent subscriptions of an already subscribed message listener
 * will be silently ignored)
 *
 * <p/>
 * Removing a listener (unsubscribing) means removing all subscribed message handlers of that listener. This remove operation
 * immediately takes effect and on all running dispatch processes -> A removed listener (a listener
 * is considered removed after the remove(Object) call returned) will under no circumstances receive any message publications.
 * Any running message publication that has not yet delivered the message to the removed listener will not see the listener
 * after the remove operation completed.
 *
 * <p/>
 * NOTE: Generic type parameters of messages will not be taken into account, e.g. a List<Long> will
 * get dispatched to all message handlers that take an instance of List as their parameter
 *
 * @Author bennidi
 * Date: 2/8/12
 */
public interface IMessageBus<T, P extends ISyncAsyncPublicationCommand>
        extends GenericMessagePublicationSupport<T, P>{

    /**
     * {@inheritDoc}
     */
    @Override
    P post(T message);

    /**
     * Check whether any asynchronous message publications are pending to be processed
     *
     * @return true if any unfinished message publications are found
     */
    boolean hasPendingMessages();

    /**
     * Shutdown the bus such that it will stop delivering asynchronous messages. Executor service and
     * other internally used threads will be shutdown gracefully. After calling shutdown it is not safe
     * to further use the message bus.
     */
    void shutdown();


}


File: src/main/java/net/engio/mbassy/bus/common/Properties.java
package net.engio.mbassy.bus.common;

/**
 * A collection of properties commonly used by different parts of the library.
 *
 * @author bennidi
 *         Date: 22.02.15
 */
public final class Properties {

    public static final class Handler {

        public static final String PublicationError = "bus.handlers.error";
        public static final String AsynchronousHandlerExecutor = "bus.handlers.async-executor";
    }

    public static final class Common {

        public static final String Id = "bus.id";
    }




}


File: src/main/java/net/engio/mbassy/dispatch/el/StandardELResolutionContext.java
package net.engio.mbassy.dispatch.el;

import javax.el.*;
import java.lang.reflect.Method;

/**
 *  This ELContext implementation provides support for standard BeanEL resolution in conditional message handlers.
 *  The message parameter of the message handlers is bound to 'msg' such that it can be referenced int the EL expressions.
 *
 *  Example:
 *  @Handler(condition = "msg.type == 'onClick'")
 *  public void handle(ButtonEvent event)
 *
 */
public class StandardELResolutionContext extends ELContext {

	private final ELResolver resolver;
	private final FunctionMapper functionMapper;
	private final VariableMapper variableMapper;
    private final Object message;


	public StandardELResolutionContext(Object message) {
		super();
        this.message = message;
		this.functionMapper = new NoopFunctionMapper();
		this.variableMapper = new MsgMapper();
        // Composite resolver not necessary as the only resolution type currently supported is standard BeanEL
		//this.resolver = new CompositeELResolver();
        this.resolver = new BeanELResolver(true);
	}
	


	/*************************************************************************
	 * The resolver for the event object.
	 * @see javax.el.ELContext#getELResolver()
	 ************************************************************************/
	@Override
	public ELResolver getELResolver() {
		return this.resolver;
	}

	/*************************************************************************
	 * @see javax.el.ELContext#getFunctionMapper()
	 ************************************************************************/
	@Override
	public FunctionMapper getFunctionMapper() {
		return this.functionMapper;
	}

	/*************************************************************************
	 * @see javax.el.ELContext#getVariableMapper()
	 ************************************************************************/
	@Override
	public VariableMapper getVariableMapper() {
		return this.variableMapper;
	}

    /**
     * This mapper resolves the variable identifies "msg" to the message
     * object of the current handler invocation
     */
	private class MsgMapper extends VariableMapper {
        private static final String msg = "msg";
        // reuse the same expression as it always resolves to the same object
        private final ValueExpression msgExpression = ElFilter.ELFactory().createValueExpression(message, message.getClass());

		public ValueExpression resolveVariable(final String s) {
            // resolve 'msg' to the message object of the handler invocation
            return !s.equals(msg) ? null : msgExpression;
		}

		public ValueExpression setVariable(String s,
				ValueExpression valueExpression) {
            // not necessary - the mapper resolves only "msg" and nothing else
			return null;
		}
	}

    /**
     * This function mapper does nothing, i.e. custom EL functions are not
     * supported by default. It may be supported in the future to pass in
     * custom function mappers at bus instanciation time.
     */
	private class NoopFunctionMapper extends FunctionMapper {
		public Method resolveFunction(String s, String s1) {
			return null;
		}
	}

}


File: src/main/java/net/engio/mbassy/listener/IMessageFilter.java
package net.engio.mbassy.listener;

import net.engio.mbassy.subscription.SubscriptionContext;

/**
 * Message filters can be used to control what messages are delivered to a specific message handler.
 * Filters are attached to message handler using the @Listener annotation.
 * If a message handler specifies filters, the filters accepts(...) method will be checked before the actual handler is invoked.
 * The handler will be invoked only if each filter accepted the message.
 *
 * Example:
 *
 * {@code
 * @Lister
 * @Filters(Urlfilter.class)
 * public void someHandler(String message){...}
 *
 * class Urlfilter implements IMessageFilter<String>{
 *     public boolean accepts(String message, MessageHandler metadata){
 *         return message.startsWith("http");
 *     }
 * }
 *
 * bus.post("http://www.infoq.com"); // will be delivered
 * bus.post("www.stackoverflow.com"); // will not be delivered
 *
 * NOTE: A message filter must provide a no-arg constructor!!!
 * }
 *
 * @author bennidi
 *         Date: 2/8/12
 */
public interface IMessageFilter<M> {

    /**
     * Check whether the message matches some criteria
     *
     * @param message The message to be handled by the handler
     * @param  context The context object containing a description of the message handler and the bus environment
     * @return  true: if the message matches the criteria and should be delivered to the handler
     *          false: otherwise
     */
    boolean accepts(M message, SubscriptionContext context);
}


File: src/main/java/net/engio/mbassy/subscription/SubscriptionFactory.java
package net.engio.mbassy.subscription;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.MessageBusException;
import net.engio.mbassy.common.StrongConcurrentSet;
import net.engio.mbassy.common.WeakConcurrentSet;
import net.engio.mbassy.dispatch.*;
import net.engio.mbassy.listener.MessageHandler;

import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.Collection;

/**
 * The subscription factory is used to create an empty subscription for specific message handler.
 * The message handler's configuration is evaluated and a corresponding subscription is built.
 */
public class SubscriptionFactory {

    public Subscription createSubscription(BusRuntime runtime, MessageHandler handlerMetadata) throws MessageBusException{
        try {
            Collection<IPublicationErrorHandler> errorHandlers = runtime.get(Properties.Handler.PublicationError);
            SubscriptionContext context = new SubscriptionContext(runtime, handlerMetadata, errorHandlers);
            IHandlerInvocation invocation = buildInvocationForHandler(context);
            IMessageDispatcher dispatcher = buildDispatcher(context, invocation);
            return new Subscription(context, dispatcher, handlerMetadata.useStrongReferences()
                ? new StrongConcurrentSet<Object>()
                : new WeakConcurrentSet<Object>());
        } catch (Exception e) {
            throw new MessageBusException(e);
        }
    }

    protected IHandlerInvocation buildInvocationForHandler(SubscriptionContext context) throws Exception {
        IHandlerInvocation invocation = createBaseHandlerInvocation(context);
        if(context.getHandler().isSynchronized()){
            invocation = new SynchronizedHandlerInvocation(invocation);
        }
        if (context.getHandler().isAsynchronous()) {
            invocation = new AsynchronousHandlerInvocation(invocation);
        }
        return invocation;
    }

    protected IMessageDispatcher buildDispatcher(SubscriptionContext context, IHandlerInvocation invocation) {
        IMessageDispatcher dispatcher = new MessageDispatcher(context, invocation);
        if (context.getHandler().isEnveloped()) {
            dispatcher = new EnvelopedMessageDispatcher(dispatcher);
        }
        if (context.getHandler().isFiltered()) {
            dispatcher = new FilteredMessageDispatcher(dispatcher);
        }
        return dispatcher;
    }

    protected IHandlerInvocation createBaseHandlerInvocation(SubscriptionContext context) throws MessageBusException {
        Class<? extends HandlerInvocation> invocation = context.getHandler().getHandlerInvocation();
        if(invocation.isMemberClass() && !Modifier.isStatic(invocation.getModifiers())){
            throw new MessageBusException("The handler invocation must be top level class or nested STATIC inner class");
        }
        try {
            Constructor<? extends IHandlerInvocation> constructor = invocation.getConstructor(SubscriptionContext.class);
            return constructor.newInstance(context);
        } catch (NoSuchMethodException e) {
            throw new MessageBusException("The provided handler invocation did not specify the necessary constructor "
                    + invocation.getSimpleName() + "(SubscriptionContext);", e);
        } catch (Exception e) {
            throw new MessageBusException("Could not instantiate the provided handler invocation "
                    + invocation.getSimpleName(), e);
        }
    }
}


File: src/test/java/net/engio/mbassy/AllTests.java
package net.engio.mbassy;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

/**
 * Test suite for running all available unit tests
 *
 * @author bennidi
 *         Date: 11/23/12
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({
        StrongConcurrentSetTest.class,
        WeakConcurrentSetTest.class,
        SyncAsyncTest.class,
        SyncBusTest.MBassadorTest.class,
        SyncBusTest.SyncMessageBusTest.class,
        FilterTest.class,
        MetadataReaderTest.class,
        MethodDispatchTest.class,
        DeadMessageTest.class,
        SynchronizedHandlerTest.class,
        SubscriptionManagerTest.class,
        AsyncFIFOBusTest.class,
        ConditionalHandlers.class
})
public class AllTests {
}


File: src/test/java/net/engio/mbassy/SubscriptionManagerTest.java
package net.engio.mbassy;

import net.engio.mbassy.bus.BusRuntime;
import net.engio.mbassy.bus.common.Properties;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listener.MetadataReader;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.*;
import net.engio.mbassy.subscription.Subscription;
import net.engio.mbassy.subscription.SubscriptionFactory;
import net.engio.mbassy.subscription.SubscriptionManager;
import org.junit.Test;

import java.util.Collection;
import java.util.Collections;

/**
 *
 * Test the subscriptions as generated and organized by the subscription manager. Tests use different sets of listeners
 * and corresponding expected set of subscriptions that should result from subscribing the listeners. The subscriptions
 * are tested for the type of messages they should handle and
 *
 * @author bennidi
 *         Date: 5/12/13
 */
public class SubscriptionManagerTest extends AssertSupport {

    private static final int InstancesPerListener = 5000;
    private static final int ConcurrentUnits = 10;

    @Test
    public void testIMessageListener(){
        ListenerFactory listeners = listeners(
                IMessageListener.DefaultListener.class,
                IMessageListener.AsyncListener.class,
                IMessageListener.DisabledListener.class,
                IMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMessageListener.DefaultListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.AsyncListener.class).handles(IMessage.class,
                        AbstractMessage.class, IMultipartMessage.class, StandardMessage.class, MessageTypes.class)
                .listener(IMessageListener.NoSubtypesListener.class).handles(IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testAbstractMessageListener(){
        ListenerFactory listeners = listeners(
                AbstractMessageListener.DefaultListener.class,
                AbstractMessageListener.AsyncListener.class,
                AbstractMessageListener.DisabledListener.class,
                AbstractMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(AbstractMessageListener.NoSubtypesListener.class).handles(AbstractMessage.class)
                .listener(AbstractMessageListener.DefaultListener.class).handles(StandardMessage.class, AbstractMessage.class)
                .listener(AbstractMessageListener.AsyncListener.class).handles(StandardMessage.class, AbstractMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMessagesListener(){
        ListenerFactory listeners = listeners(
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class,
                MessagesListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MessagesListener.NoSubtypesListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                MultipartMessageListener.DefaultListener.class,
                MultipartMessageListener.AsyncListener.class,
                MultipartMessageListener.DisabledListener.class,
                MultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(MultipartMessageListener.NoSubtypesListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class)
                .listener(MultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testIMultipartMessageListener(){
        ListenerFactory listeners = listeners(
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                IMultipartMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(IMultipartMessageListener.NoSubtypesListener.class).handles(IMultipartMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStandardMessageListener(){
        ListenerFactory listeners = listeners(
                StandardMessageListener.DefaultListener.class,
                StandardMessageListener.AsyncListener.class,
                StandardMessageListener.DisabledListener.class,
                StandardMessageListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(StandardMessageListener.NoSubtypesListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.DefaultListener.class).handles(StandardMessage.class)
                .listener(StandardMessageListener.AsyncListener.class).handles(StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testICountableListener(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                ICountableListener.NoSubtypesListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class).handles(ICountable.class)
                .listener(ICountableListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testMultipleMessageListeners(){
        ListenerFactory listeners = listeners(
                ICountableListener.DefaultListener.class,
                ICountableListener.AsyncListener.class,
                ICountableListener.DisabledListener.class,
                IMultipartMessageListener.DefaultListener.class,
                IMultipartMessageListener.AsyncListener.class,
                IMultipartMessageListener.DisabledListener.class,
                MessagesListener.DefaultListener.class,
                MessagesListener.AsyncListener.class,
                MessagesListener.DisabledListener.class);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(ICountableListener.DefaultListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class, StandardMessage.class)
                .listener(ICountableListener.AsyncListener.class)
                .handles(MultipartMessage.class, IMultipartMessage.class, ICountable.class,  StandardMessage.class)
                .listener(IMultipartMessageListener.DefaultListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(IMultipartMessageListener.AsyncListener.class).handles(MultipartMessage.class, IMultipartMessage.class)
                .listener(MessagesListener.DefaultListener.class).handles(MessageTypes.class)
                .listener(MessagesListener.AsyncListener.class).handles(MessageTypes.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testStrongListenerSubscription() throws Exception {
        ListenerFactory listeners = listeners(CustomInvocationListener.class);
        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();
        runGC();

        Collection<Subscription> subscriptions = subscriptionManager.getSubscriptionsByMessageType(StandardMessage.class);
        assertEquals(1, subscriptions.size());
        for(Subscription sub : subscriptions)
            assertEquals(InstancesPerListener,  sub.size());
    }

    @Test
    public void testOverloadedMessageHandlers(){
        ListenerFactory listeners = listeners(
                Overloading.ListenerBase.class,
                Overloading.ListenerSub.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(Overloading.ListenerBase.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class)
                .listener(Overloading.ListenerSub.class).handles(Overloading.TestMessageA.class, Overloading.TestMessageA.class, Overloading.TestMessageB.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    @Test
    public void testPrioritizedMessageHandlers(){
        ListenerFactory listeners = listeners(PrioritizedListener.class);

        SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        SubscriptionValidator expectedSubscriptions = new SubscriptionValidator(listeners)
                .listener(PrioritizedListener.class).handles(IMessage.class, IMessage.class, IMessage.class, IMessage.class);

        runTestWith(listeners, expectedSubscriptions);
    }

    private BusRuntime mockedRuntime(){
        return new BusRuntime(null)
                .add(Properties.Handler.PublicationError, Collections.EMPTY_SET)
                .add(Properties.Handler.AsynchronousHandlerExecutor, null);
    }

    private ListenerFactory listeners(Class ...listeners){
        ListenerFactory factory = new ListenerFactory();
        for(Class listener : listeners){
            factory.create(InstancesPerListener, listener);
        }
        return factory;
    }

    private void runTestWith(final ListenerFactory listeners, final SubscriptionValidator validator){
        final SubscriptionManager subscriptionManager = new SubscriptionManager(new MetadataReader(), new SubscriptionFactory(), mockedRuntime());

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(subscriptionManager, listeners), ConcurrentUnits);

        validator.validate(subscriptionManager);

        ConcurrentExecutor.runConcurrent(TestUtil.unsubscriber(subscriptionManager, listeners), ConcurrentUnits);

        listeners.clear();

        validator.validate(subscriptionManager);
    }


    /**
     *  define handlers with different priorities which need to be executed
     *  in their respective order
     */
    public static class PrioritizedListener{


        @net.engio.mbassy.listener.Handler(priority = 1)
        public void handlePrio1(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 2)
        public void handlePrio2(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 3)
        public void handlePrio3(IMessage message){
            message.handled(this.getClass());
        }

        @net.engio.mbassy.listener.Handler(priority = 4)
        public void handlePrio4(IMessage message){
            message.handled(this.getClass());
        }
    }


}


File: src/test/java/net/engio/mbassy/SyncAsyncTest.java
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.*;
import net.engio.mbassy.listeners.*;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.
 *
 * @author bennidi
 *         Date: 2/8/12
 */
public class SyncAsyncTest extends MessageBusTest {


    @Test
    public void testSyncPublicationSyncHandlers() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.synchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };

        // test single-threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);

        // test multi-threaded
        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
    }


    @Test
    public void testSyncPublicationAsyncHandlers() throws Exception {
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);

        final MessageManager messageManager = new MessageManager();
        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {

                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, Listeners.join(Listeners.asynchronous(), Listeners.handlesStandardMessage()));
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class, IMultipartMessageListener.AsyncListener.class);

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        messageManager.register(MessageTypes.Simple, InstancesPerListener * ConcurrentUnits, IMessageListener.AsyncListener.class, MessagesListener.AsyncListener.class);
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);
    }

    @Test
    public void testAsynchronousMessagePublication() throws Exception {

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, Listeners.asynchronous())
                .create(InstancesPerListener, Listeners.noHandlers());
        final MBassador bus = createBus(SyncAsync(), listeners);


        final MessageManager messageManager = new MessageManager();

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = messageManager.create(StandardMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);
                MultipartMessage multipartMessage = messageManager.create(MultipartMessage.class, InstancesPerListener, IMessageListener.AsyncListener.class);

                bus.post(standardMessage).asynchronously();
                bus.post(multipartMessage).asynchronously();
                bus.post(MessageTypes.Simple).asynchronously();

            }
        };

        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        messageManager.waitForMessages(processingTimeInMS);

        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        messageManager.waitForMessages(processingTimeInMS);

    }


    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };

        //DS: Exception counter added via config
        IBusConfiguration config = SyncAsync();
        config.addPublicationErrorHandler(ExceptionCounter);
        final MBassador bus = new MBassador(config);

        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                bus.post(new StandardMessage()).asynchronously();

            }
        };

        // single threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener, exceptionCount.get());


        // multi threaded
        exceptionCount.set(0);
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        pause(processingTimeInMS);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());

    }




}


File: src/test/java/net/engio/mbassy/SyncBusTest.java
package net.engio.mbassy;

import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.SyncMessageBus;
import net.engio.mbassy.bus.common.GenericMessagePublicationSupport;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.ConcurrentExecutor;
import net.engio.mbassy.common.ListenerFactory;
import net.engio.mbassy.common.MessageBusTest;
import net.engio.mbassy.common.TestUtil;
import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listeners.CustomInvocationListener;
import net.engio.mbassy.listeners.ExceptionThrowingListener;
import net.engio.mbassy.listeners.IMessageListener;
import net.engio.mbassy.listeners.MessagesListener;
import net.engio.mbassy.messages.MessageTypes;
import net.engio.mbassy.messages.MultipartMessage;
import net.engio.mbassy.messages.StandardMessage;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Test synchronous and asynchronous dispatch in single and multi-threaded scenario.
 *
 * @author bennidi
 *         Date: 2/8/12
 */
public abstract class SyncBusTest extends MessageBusTest {


    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler);

    protected abstract GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException);

    @Test
    public void testSynchronousMessagePublication() throws Exception {

        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, IMessageListener.DefaultListener.class)
                .create(InstancesPerListener, IMessageListener.DisabledListener.class)
                .create(InstancesPerListener, MessagesListener.DefaultListener.class)
                .create(InstancesPerListener, MessagesListener.DisabledListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();
                bus.post(MessageTypes.Multipart).now();

                assertEquals(InstancesPerListener, standardMessage.getTimesHandled(IMessageListener.DefaultListener.class));
                assertEquals(InstancesPerListener, multipartMessage.getTimesHandled(IMessageListener.DefaultListener.class));
            }
        };

        // single threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);

        // multi threaded
        MessageTypes.resetAll();
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(IMessageListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Simple.getTimesHandled(MessagesListener.DefaultListener.class));
        assertEquals(InstancesPerListener * ConcurrentUnits, MessageTypes.Multipart.getTimesHandled(MessagesListener.DefaultListener.class));
    }



    @Test
    public void testExceptionInHandlerInvocation(){
        final AtomicInteger exceptionCount = new AtomicInteger(0);
        IPublicationErrorHandler ExceptionCounter = new IPublicationErrorHandler() {
            @Override
            public void handleError(PublicationError error) {
                exceptionCount.incrementAndGet();
            }
        };

        //DS: modified to pass ExceptionCounter via the configuration object
        final GenericMessagePublicationSupport bus = getSyncMessageBus(false,ExceptionCounter);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, ExceptionThrowingListener.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publish = new Runnable() {
            @Override
            public void run() {
                bus.post(new StandardMessage()).now();
            }
        };

        // single threaded
        ConcurrentExecutor.runConcurrent(publish, 1);

        exceptionCount.set(0);

        // multi threaded
        ConcurrentExecutor.runConcurrent(publish, ConcurrentUnits);
        assertEquals(InstancesPerListener * ConcurrentUnits, exceptionCount.get());
    }

    @Test
    public void testCustomHandlerInvocation(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, CustomInvocationListener.class)
                .create(InstancesPerListener, Object.class);


        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                StandardMessage standardMessage = new StandardMessage();
                MultipartMessage multipartMessage = new MultipartMessage();

                bus.post(standardMessage).now();
                bus.post(multipartMessage).now();
                bus.post(MessageTypes.Simple).now();

                assertEquals(InstancesPerListener * 2, standardMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, multipartMessage.getTimesHandled(CustomInvocationListener.class));
                assertEquals(0, MessageTypes.Simple.getTimesHandled(CustomInvocationListener.class));
            }
        };

        // single threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);

        // multi threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }

    @Test
    public void testHandlerPriorities(){
        final GenericMessagePublicationSupport bus = getSyncMessageBus(true);
        ListenerFactory listeners = new ListenerFactory()
                .create(InstancesPerListener, PrioritizedListener.class)
                .create(InstancesPerListener, Object.class);

        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);

        Runnable publishAndCheck = new Runnable() {
            @Override
            public void run() {
                bus.post(new IncrementingMessage()).now();
            }
        };

        // single threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, 1);

        // multi threaded
        ConcurrentExecutor.runConcurrent(publishAndCheck, ConcurrentUnits);

    }


    public static class MBassadorTest extends SyncBusTest {

        //DS: added errorHandler parameter to allow adding handler from caller
        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration asyncFIFOConfig = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            asyncFIFOConfig.addFeature(Feature.SyncPubSub.Default());
            asyncFIFOConfig.addFeature(Feature.AsynchronousHandlerInvocation.Default(1, 1));
            asyncFIFOConfig.addFeature(Feature.AsynchronousMessageDispatch.Default().setNumberOfMessageDispatchers(1));
            if (errorHandler != null) {
                asyncFIFOConfig.addPublicationErrorHandler(errorHandler);
            }
            return new MBassador(asyncFIFOConfig);

        }


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }

    }

    public static class SyncMessageBusTest extends SyncBusTest {


        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException, IPublicationErrorHandler errorHandler) {
            IBusConfiguration syncPubSubCfg = new BusConfiguration().addPublicationErrorHandler(new AssertionErrorHandler(failOnException));
            syncPubSubCfg.addFeature(Feature.SyncPubSub.Default());
            if (errorHandler != null) {
                syncPubSubCfg.addPublicationErrorHandler(errorHandler);
            }
            return new SyncMessageBus(syncPubSubCfg);
        }

        @Override
        protected GenericMessagePublicationSupport getSyncMessageBus(boolean failOnException) {
            return getSyncMessageBus(failOnException, null);
        }
    }





    static class IncrementingMessage{

        private int count = 1;

        public void markHandled(int newVal){
            // only transitions by the next handler are allowed
            if(count == newVal || count + 1 == newVal) count = newVal;
            else throw new RuntimeException("Message was handled out of order");
        }
    }


    public static class PrioritizedListener{

        @Handler(priority = Integer.MIN_VALUE)
        public void handle1(IncrementingMessage message) {
            message.markHandled(4);
        }

        @Handler(priority = -2)
        public void handle2(IncrementingMessage message) {
            message.markHandled(3);
        }

        @Handler
        public void handle3(IncrementingMessage message) {
            message.markHandled(2);
        }

        @Handler(priority = Integer.MAX_VALUE)
        public void handle4(IncrementingMessage message) {
            message.markHandled(1);
        }


    }



}


File: src/test/java/net/engio/mbassy/bus/AbstractPubSubSupportTest.java
package net.engio.mbassy.bus;

import com.mycila.testing.junit.MycilaJunitRunner;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.common.MessageBusTest;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Added for changes proposed under https://github.com/bennidi/mbassador/issues/106
 * <p/>
 * Created by David Sowerby on 13/04/15.
 */
@RunWith(MycilaJunitRunner.class)
public class AbstractPubSubSupportTest {

    IBusConfiguration configuration;

    @Mock
    IPublicationErrorHandler handler1;

    @Mock
    IPublicationErrorHandler handler2;

    @Mock
    IPublicationErrorHandler handler3;

    @Mock
    PublicationError publicationError;


    @Before
    public void setup() {
        configuration = MessageBusTest.SyncAsync();
    }


    @Test
    public void testHandlePublicationError_handlers_present_sync() {
        //given

        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);
        //when
        SyncMessageBus<String> bus = new SyncMessageBus<String>(configuration);
        bus.handlePublicationError(publicationError);
        //then
        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_handlers_present_async() {
        //given

        configuration.addPublicationErrorHandler(handler1);
        configuration.addPublicationErrorHandler(handler2);
        configuration.addPublicationErrorHandler(handler3);
        //when
        MBassador<String> bus = new MBassador<String>(configuration);
        bus.handlePublicationError(publicationError);
        //then
        verify(handler1).handleError(publicationError);
        verify(handler2).handleError(publicationError);
        verify(handler3).handleError(publicationError);
    }


    @Test
    public void testHandlePublicationError_construct_with_handler_sync() {
        //given

        //when
        SyncMessageBus<String> bus = new SyncMessageBus<String>(handler1);
        bus.handlePublicationError(publicationError);
        //then
        verify(handler1).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_constrcut_with_handler_async() {
        //given

        configuration.addPublicationErrorHandler(handler1);
        //when
        MBassador<String> bus = new MBassador<String>(handler1);
        bus.handlePublicationError(publicationError);
        //then
        verify(handler1).handleError(publicationError);
    }

    @Test
    public void testHandlePublicationError_no_handlers_present_construct_with_config_async() {
        //given
        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);
            //when
            MBassador<String> bus = new MBassador<String>(configuration);
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);
            //then
            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }

    @Test
    public void testHandlePublicationError_default_construct_sync() {
        //given
        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);
            //when
            SyncMessageBus<String> bus = new SyncMessageBus<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);
            //then
            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }
    }

    @Test
    public void testHandlePublicationError_default_construct_async() {
        //given
        final String errorMsg = "Test error";
        when(publicationError.toString()).thenReturn(errorMsg);
        PrintStream old = null;

        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream ps = new PrintStream(baos);
            old = System.out;
            System.setOut(ps);
            //when
            MBassador<String> bus = new MBassador<String>();
            assertThat(baos.toString()).contains(AbstractPubSubSupport.ERROR_HANDLER_MSG);
            bus.handlePublicationError(publicationError);
            //then
            assertThat(baos.toString()).contains(errorMsg);

        } finally {
            System.out.flush();
            if (old != null) {
                System.setOut(old);
            }
        }

    }


}

File: src/test/java/net/engio/mbassy/common/MessageBusTest.java
package net.engio.mbassy.common;

import net.engio.mbassy.bus.IMessagePublication;
import net.engio.mbassy.bus.MBassador;
import net.engio.mbassy.bus.config.BusConfiguration;
import net.engio.mbassy.bus.config.Feature;
import net.engio.mbassy.bus.config.IBusConfiguration;
import net.engio.mbassy.bus.error.IPublicationErrorHandler;
import net.engio.mbassy.bus.error.PublicationError;
import net.engio.mbassy.messages.MessageTypes;
import org.junit.Before;

/**
 * A base test that provides a factory for message bus that makes tests fail if any
 * publication error occurs
 *
 * @author bennidi
 *         Date: 3/2/13
 */
public abstract class MessageBusTest extends AssertSupport {

    // this value probably needs to be adjusted depending on the performance of the underlying plattform
    // otherwise the tests will fail since asynchronous processing might not have finished when
    // evaluation is run
    protected static final int processingTimeInMS = 6000;
    protected static final int InstancesPerListener = 5000;
    protected static final int ConcurrentUnits = 10;
    protected static final int IterationsPerThread = 100;

    public static final class AssertionErrorHandler implements IPublicationErrorHandler{

        private boolean failOnException;

        public AssertionErrorHandler(boolean failOnException) {
            this.failOnException = failOnException;
        }

        @Override
        public void handleError(PublicationError error) {
            if(failOnException)
                org.junit.Assert.fail(error.getCause().getMessage());
        }
    }

    private StrongConcurrentSet<IMessagePublication> issuedPublications = new StrongConcurrentSet<IMessagePublication>();

    @Before
    public void setUp(){
        issuedPublications = new StrongConcurrentSet<IMessagePublication>();
        for(MessageTypes mes : MessageTypes.values())
            mes.reset();
    }

    public static IBusConfiguration SyncAsync() {
        return SyncAsync(true);
    }

    public static IBusConfiguration SyncAsync(boolean failOnError) {
        return new BusConfiguration()
            .addFeature(Feature.SyncPubSub.Default())
            .addFeature(Feature.AsynchronousHandlerInvocation.Default())
            .addFeature(Feature.AsynchronousMessageDispatch.Default());
        //DS: removed as publication error handlers now in configuration object
//            .setProperty(net.engio.mbassy.bus.common.Properties.Handler.PublicationError, new AssertionErrorHandler(failOnError));
    }

    public MBassador createBus(IBusConfiguration configuration) {
        MBassador bus = new MBassador(configuration);
        return bus;
    }

    public MBassador createBus(IBusConfiguration configuration, ListenerFactory listeners) {
        MBassador bus = new MBassador(configuration);
        ConcurrentExecutor.runConcurrent(TestUtil.subscriber(bus, listeners), ConcurrentUnits);
        return bus;
    }

    protected void track(IMessagePublication asynchronously) {
        issuedPublications.add(asynchronously);
    }

    public void waitForPublications(long timeOutInMs){
        long start = System.currentTimeMillis();
        while(issuedPublications.size() > 0 && System.currentTimeMillis() - start < timeOutInMs){
            for(IMessagePublication pub : issuedPublications){
                if(pub.isFinished())
                    issuedPublications.remove(pub);
            }
        }
        if(issuedPublications.size() > 0)
            fail("Issued publications did not finish within specified timeout of " + timeOutInMs + " ms");
    }

    public void addPublication(IMessagePublication publication){
        issuedPublications.add(publication);
    }

}


File: src/test/java/net/engio/mbassy/common/MessageManager.java
package net.engio.mbassy.common;

import net.engio.mbassy.messages.IMessage;

import java.util.Collection;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Created with IntelliJ IDEA.
 * User: benjamin
 * Date: 6/26/13
 * Time: 12:23 PM
 * To change this template use File | Settings | File Templates.
 */
public class MessageManager {
	private static final Logger LOG =
			LoggerFactory.getLogger(MessageManager.class);


    private StrongConcurrentSet<MessageContext> messages = new StrongConcurrentSet();


    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Class ...listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> T create(Class<T> messageType, int expectedCount, Collection<Class> listeners){
        T message;
        try {
            message = messageType.newInstance();
            register(message, expectedCount, listeners);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return message;
    }

    public <T extends IMessage> void register(T message, int expectedCount, Class ...listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public <T extends IMessage> void register(T message, int expectedCount, Collection<Class> listeners){
        try {
            messages.add(new MessageContext(expectedCount, message, listeners));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public void waitForMessages(int timeoutInMs){
        long start = System.currentTimeMillis();
        while(System.currentTimeMillis() - start < timeoutInMs && messages.size() > 0){
            // check each created message once
            for(MessageContext messageCtx : messages){
                boolean handledCompletely = true;
                for(Class listener : messageCtx.getListeners()){
                    handledCompletely &= messageCtx.getMessage().getTimesHandled(listener) == messageCtx.getExpectedCount();
                }
                // remove the ones that were handled as expected
                if(handledCompletely){
                    logSuccess(messageCtx);
                    messages.remove(messageCtx);
                }

            }
            pause(100);
        }
        if(messages.size() > 0){
            logFailingMessages(messages);
            throw new RuntimeException("Message were not fully processed in given time");
        }


    }

    private void pause(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

   private void logSuccess(MessageContext mCtx){
       LOG.info("Message " + mCtx.getMessage() + " was successfully handled " + mCtx.getExpectedCount() + " times by " + mCtx.printListeners());
   }



    private void logFailingMessages(StrongConcurrentSet<MessageContext> failing){
        StringBuilder errorMessage = new StringBuilder();
        errorMessage.append("Failing messages:\n");
        for(MessageContext failingMessage : failing)
            errorMessage.append(failingMessage);
        LOG.info(errorMessage.toString());
    }

    private class MessageContext{

        private long expectedCount;
        private IMessage message;
        private Class[] listeners;

        private MessageContext(long expectedCount, IMessage message, Class[] listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners;
        }

        private MessageContext(long expectedCount, IMessage message, Collection<Class> listeners) {
            this.expectedCount = expectedCount;
            this.message = message;
            this.listeners = listeners.toArray(new Class[]{});
        }

        private long getExpectedCount() {
            return expectedCount;
        }

        private IMessage getMessage() {
            return message;
        }

        private Class[] getListeners() {
            return listeners;
        }

        private String printListeners(){
            StringBuilder listenersAsString = new StringBuilder();
            for(Class listener : listeners){
                listenersAsString.append(listener.getName());
                listenersAsString.append(",");
            }
            return listenersAsString.toString();
        }

        @Override
        public String toString() {
            // TODO: actual count of listeners
            return message.getClass().getSimpleName() + "{" +
                    "expectedCount=" + expectedCount +
                    ", listeners=" + printListeners() +
                    '}';
        }
    }


}


File: src/test/java/net/engio/mbassy/listeners/ExceptionThrowingListener.java
package net.engio.mbassy.listeners;

import net.engio.mbassy.listener.Handler;
import net.engio.mbassy.listener.Listener;
import net.engio.mbassy.listener.References;
import net.engio.mbassy.messages.StandardMessage;

/**
 * @author bennidi
 *         Date: 5/25/13
 */
@Listener(references = References.Strong)
public class ExceptionThrowingListener {


    // this handler will be invoked asynchronously
    @Handler()
    public void handle(StandardMessage message) {
        throw new RuntimeException("This is an expected exception");
    }


}
