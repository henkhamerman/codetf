
Refactoring Type: Inline Method


File: core/java-stub/source_gen/jetbrains/mps/persistence/java/library/JavaClassStubModelDescriptor.java
package jetbrains.mps.persistence.java.library;

/*Generated by MPS */

import jetbrains.mps.extapi.model.ReloadableSModelBase;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.extapi.persistence.FolderSetDataSource;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.baseLanguage.javastub.ASMModelLoader;
import java.util.Set;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SModelRepository;

public class JavaClassStubModelDescriptor extends ReloadableSModelBase {
  private SModel myModel;
  private boolean mySkipPrivate;
  public JavaClassStubModelDescriptor(SModelReference modelReference, FolderSetDataSource source) {
    super(modelReference, source);
  }
  /*package*/ void setSkipPrivate(boolean skipPrivateMembers) {
    mySkipPrivate = skipPrivateMembers;
  }
  @Override
  protected SModel getCurrentModelInternal() {
    return myModel;
  }
  @NotNull
  @Override
  public FolderSetDataSource getSource() {
    return (FolderSetDataSource) super.getSource();
  }
  @Override
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
      fireModelStateChanged(ModelLoadingState.FULLY_LOADED);
    }
    return myModel;
  }
  @Override
  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }
  private SModel createModel() {
    SModel model = new SModel(getReference(), new ForeignNodeIdMap());
    for (SLanguage l : getLanguagesToImport()) {
      model.addLanguage(l);
    }
    ASMModelLoader loader = new ASMModelLoader(getModelRoot().getModule(), getSource().getPaths());
    loader.skipPrivateMembers(mySkipPrivate);
    loader.update(model);
    return model;
  }
  private Set<SLanguage> getLanguagesToImport() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return getLanguagesToImport();
  }
  @Override
  public void reloadFromDiskSafe() {
    assertCanChange();
    if (getSource().getPaths().isEmpty()) {
      SModelRepository.getInstance().deleteModel(this);
      return;
    }
    reload();
    updateTimestamp();
  }
  private void reload() {
    if (myModel == null) {
      return;
    }
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }
}


File: core/kernel/source/jetbrains/mps/extapi/model/SModelDescriptorStub.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.extapi.model;

import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.SModelLegacy;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.adapter.MetaAdapterByDeclaration;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.event.SModelFileChangedEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelListener.SModelListenerPriority;
import jetbrains.mps.smodel.event.SModelRenamedEvent;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * TODO move listeners to openapi
 */
public abstract class SModelDescriptorStub implements SModelInternal, SModel, FastNodeFinder.Factory {

  private static final Logger LOG = LogManager.getLogger(SModelDescriptorStub.class);

  private final List<SModelListener> myModelListeners = new CopyOnWriteArrayList<SModelListener>();

  private ModelLoadingState myModelLoadState = ModelLoadingState.NOT_LOADED;

  /**
   * Migration to 3.0. Loads and returns model data.
   * @deprecated use {@link SModelBase#getModelData()} or {@link #getSModel()}
   * FIXME  there's implicit convention that smodel.SModel has this openapi.SModel (aka descriptor) assigned once
   * this method returns
   */
  @Deprecated
  public abstract jetbrains.mps.smodel.SModel getSModelInternal();

  /**
   * Dangerous, allows to replace model data.
   */
  public void replace(SModelData modelData) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void addModelListener(@NotNull SModelListener listener) {
    if (listener.getPriority() == SModelListenerPriority.PLATFORM) {
      myModelListeners.add(0, listener);
    } else {
      myModelListeners.add(listener);
    }
  }

  @Override
  public void removeModelListener(@NotNull SModelListener listener) {
    myModelListeners.remove(listener);
  }

  @NotNull
  public List<SModelListener> getModelListeners() {
    return myModelListeners;
  }

  protected void clearListeners() {
    myModelListeners.clear();
  }

  @NotNull
  protected ModelLoadingState getLoadingState() {
    return myModelLoadState;
  }

  protected void notifyModelReplaced(jetbrains.mps.smodel.SModel oldSModel) {
    SModelRepository.getInstance().notifyModelReplaced(this, oldSModel);
  }

  // Not SModel-specific listener notifications

  protected void fireBeforeModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelFileChanged(SModelFileChangedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelFileChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireBeforeModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  @Deprecated
  protected void fireModelRenamed(SModelRenamedEvent event) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelRenamed(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelStateChanged(ModelLoadingState newState) {
    myModelLoadState = newState;
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelLoadingStateChanged(this, newState);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireBeforeModelDisposed(SModel model) {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeModelDisposed(model);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  protected void fireModelSaved() {
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.modelSaved(this);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  /**
   * Use {@link SModelBase#getModelData()} wherever possible
   */
  public jetbrains.mps.smodel.SModel getSModel() {
    return getSModelInternal();
  }

  /**
   * Likely, shall return SModelData eventually
   * @return actual model data or <code>null</code> if not initialized yet
   */
  @Nullable
  protected abstract jetbrains.mps.smodel.SModel getCurrentModelInternal();

  //

  @Override
  public final ModelDependenciesManager getModelDepsManager() {
    return getSModelInternal().getModelDepsManager();
  }

  @Override
  @Deprecated
  public final List<SModuleReference> importedLanguages() {
    return new SModelLegacy(getSModelInternal()).importedLanguages();
  }

  @Override
  public final void deleteLanguage(@NotNull SModuleReference ref) {
    getSModelInternal().deleteLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public final void addLanguage(SModuleReference ref) {
    // Identical to SModelLegacy.addLanguage(SModuleReference). Refactor uses of this method and drop it,
    // while SModelLegacy may need to survive few releases as it deals with smodel.SModel instances directly.
    // Users of this class, however, have access to full power of SModel and therefore much more freedom what to do.
    getSModelInternal().addLanguage(MetaAdapterFactory.getLanguage(ref));
  }

  @Override
  public java.util.Collection<SLanguage> importedLanguageIds() {
    return getSModelInternal().usedLanguages();
  }

  @Override
  public void deleteLanguageId(@NotNull SLanguage ref) {
    getSModel().deleteLanguage(ref);
  }

  @Override
  public void addLanguage(Language language) {
    getSModel().addLanguage(MetaAdapterByDeclaration.getLanguage(language));
  }

  @Override
  public void addLanguage(@NotNull SLanguage language) {
    getSModel().addLanguage(language);
  }

  @Override
  public void addLanguageId(SLanguage ref, int version) {
    getSModelInternal().addLanguage(ref, version);
  }

  @Override
  public final List<SModuleReference> importedDevkits() {
    return getSModelInternal().importedDevkits();
  }

  @Override
  public final void addDevKit(SModuleReference ref) {
    getSModelInternal().addDevKit(ref);
  }

  @Override
  public final void deleteDevKit(@NotNull SModuleReference ref) {
    getSModelInternal().deleteDevKit(ref);
  }

  @Override
  public final List<ImportElement> importedModels() {
    return getSModelInternal().importedModels();
  }

  @Override
  public final void addModelImport(SModelReference modelReference, boolean firstVersion) {
    new SModelLegacy(getSModelInternal()).addModelImport(modelReference, firstVersion);
  }

  @Override
  public final void addModelImport(ImportElement importElement) {
    getSModelInternal().addModelImport(importElement);
  }

  @Override
  public final void deleteModelImport(SModelReference modelReference) {
    getSModelInternal().deleteModelImport(modelReference);
  }

  @Override
  public final void calculateImplicitImports() {
    getSModelInternal().getImplicitImportsSupport().calculateImplicitImports();
  }

  @Override
  public final List<SModuleReference> engagedOnGenerationLanguages() {
    return getSModelInternal().engagedOnGenerationLanguages();
  }

  @Override
  public final void addEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().addEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    getSModelInternal().removeEngagedOnGenerationLanguage(ref);
  }

  @Override
  public final List<ImportElement> getAdditionalModelVersions() {
    return getSModelInternal().getImplicitImportsSupport().getAdditionalModelVersions();
  }

  @Override
  public boolean isDisposed() {
    return getDisposedStacktrace() != null;
  }

  @Override
  public final StackTraceElement[] getDisposedStacktrace() {
    return getSModelInternal().getDisposedStacktrace();
  }

  @Override
  public FastNodeFinder createNodeFinder(SModel model) {
    assert model == this;
    return getSModel().createFastNodeFinder();
  }

  @Override
  public final boolean updateSModelReferences() {
    return getSModelInternal().updateSModelReferences();
  }

  @Override
  public final boolean updateModuleReferences() {
    return getSModelInternal().updateModuleReferences();
  }

  @Override
  public void changeModelReference(SModelReference newModelReference) {
    getSModelInternal().changeModelReference(newModelReference);
  }
}


File: core/kernel/source/jetbrains/mps/smodel/SModel.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelDevKitEvent;
import jetbrains.mps.smodel.event.SModelImportEvent;
import jetbrains.mps.smodel.event.SModelLanguageEvent;
import jetbrains.mps.smodel.event.SModelListener;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelRootEvent;
import jetbrains.mps.smodel.nodeidmap.INodeIdToNodeMap;
import jetbrains.mps.smodel.nodeidmap.UniversalOptimizedNodeIdMap;
import jetbrains.mps.util.Computable;
import jetbrains.mps.util.annotation.ToRemove;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModelId;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.module.SRepository;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;

public class SModel implements SModelData {
  private static final Logger LOG = LogManager.getLogger(SModel.class);
  private static AtomicLong ourCounter = new AtomicLong();

  static {
    resetIdCounter();
  }

  protected SModelBase myModelDescriptor;
  private Set<SNode> myRoots = new LinkedHashSet<SNode>();
  private SModelReference myReference;
  private boolean myDisposed;
  private List<SModuleReference> myLanguagesEngagedOnGeneration = new ArrayList<SModuleReference>();
  private Map<SLanguage, Integer> myLanguagesIds = new LinkedHashMap<SLanguage, Integer>();
  private List<SModuleReference> myDevKits = new ArrayList<SModuleReference>();
  private List<ImportElement> myImports = new ArrayList<ImportElement>();
  private INodeIdToNodeMap myIdToNodeMap;
  private StackTraceElement[] myDisposedStacktrace = null;
  private ModelDependenciesManager myModelDependenciesManager;
  private ImplicitImportsLegacyHolder myLegacyImplicitImports;
  // when true, we are attaching newly loaded children to a model loaded partially
  private boolean myIsFullLoadMode = false;
  // nodes from this model communicate with it through this owner instance.
  @NotNull
  private final AttachedNodeOwner myNodeOwner;

  public SModel(@NotNull SModelReference modelReference) {
    this(modelReference, new UniversalOptimizedNodeIdMap());
  }

  public SModel(@NotNull SModelReference modelReference, INodeIdToNodeMap map) {
    myReference = modelReference;
    myIdToNodeMap = map;
    myNodeOwner = new AttachedNodeOwner(this);
  }

  static void resetIdCounter() {
    ourCounter.set(Math.abs(new SecureRandom().nextLong()));
  }

  public static SNodeId generateUniqueId() {
    long id = Math.abs(ourCounter.incrementAndGet());
    return new jetbrains.mps.smodel.SNodeId.Regular(id);
  }


  public SModelId getModelId() {
    return myReference.getModelId();
  }

  @NotNull
  public SModelReference getReference() {
    return myReference;
  }

  @Override
  public Iterable<org.jetbrains.mps.openapi.model.SNode> getRootNodes() {
    fireModelNodesReadAccess();
    return new Iterable<org.jetbrains.mps.openapi.model.SNode>() {
      @Override
      public Iterator<org.jetbrains.mps.openapi.model.SNode> iterator() {
        return new Iterator<org.jetbrains.mps.openapi.model.SNode>() {
          private final Iterator<SNode> myIterator = myRoots.iterator();

          @Override
          public boolean hasNext() {
            return myIterator.hasNext();
          }

          @Override
          public org.jetbrains.mps.openapi.model.SNode next() {
            SNode res = myIterator.next();
            if (res != null) {
              res.assertCanRead();
              res.getNodeOwner().fireNodeRead(res, true);
            }

            return res;
          }

          @Override
          public void remove() {
            throw new UnsupportedOperationException("can't change model roots through roots iterator");
          }
        };
      }
    };
  }

  public boolean isRoot(@Nullable org.jetbrains.mps.openapi.model.SNode node) {
    return myRoots.contains(node);
  }

  //--------------IMPLEMENTATION-------------------

  @Override
  public void addRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      // why not warn?
      return;
    }
    org.jetbrains.mps.openapi.model.SModel model = node.getModel();
    // FIXME why on earth we remove new root from original location, but don't do the same for insertChild?
    if (model != null && model != myModelDescriptor && node.getParent() == null) {
      model.removeRootNode(node);
    } else {
      org.jetbrains.mps.openapi.model.SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      }
    }

    SNode sn = (SNode) node;
    myRoots.add(sn);
    sn.attach(myNodeOwner);
    performUndoableAction(new AddRootUndoableAction(node));
    myNodeOwner.fireNodeAdd(null, null, sn, null);
  }

  @Override
  public void removeRootNode(final org.jetbrains.mps.openapi.model.SNode node) {
    assert node instanceof SNode;
    if (myModelDescriptor != null) {
      ModelChange.assertLegalNodeUnRegistration(this, node);
    }
    enforceFullLoad();
    if (myRoots.contains(node)) {
      myNodeOwner.fireBeforeNodeRemove(null, null, (SNode) node, null);
      myRoots.remove(node);
      SNode sn = (SNode) node;
      sn.detach(new DetachedNodeOwner(this));
      performUndoableAction(new RemoveRootUndoableAction(node, myModelDescriptor));
      myNodeOwner.fireNodeRemove(null, null, sn, null);
    }
  }

  @Override
  @Nullable
  public SNode getNode(@NotNull org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    SNode res = getNode_(nodeId);
    if (res != null) {
      res.assertCanRead();
      myNodeOwner.fireNodeRead(res, true);
    }
    return res;
  }

  private SNode getNode_(org.jetbrains.mps.openapi.model.SNodeId nodeId) {
    checkNotDisposed();
    if (myDisposed) return null;

    org.jetbrains.mps.openapi.model.SNode node = myIdToNodeMap.get(nodeId);
    if (node != null) return ((SNode) node);
    enforceFullLoad();
    return ((SNode) myIdToNodeMap.get(nodeId));
  }

  @NotNull
  public String toString() {
    return myReference.toString();
  }

  //todo get rid of, try to cast, show an error if not casted
  public boolean isDisposed() {
    return myDisposed;
  }

  //todo cast if can be
  public StackTraceElement[] getDisposedStacktrace() {
    return myDisposedStacktrace;
  }

  @Deprecated
  public void addModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().addModelListener(listener);
  }

  @Deprecated
  public void removeModelListener(@NotNull SModelListener listener) {
    getModelDescriptor().removeModelListener(listener);
  }

  /**
   * FIXME it looks we can use openapi.SModel as return value now (i.e. not to restrain to SModelBase use)
   */
  public SModelBase getModelDescriptor() {
    return myModelDescriptor;
  }

  // FIXME (1) synchronized, really? (2) do we really care to have SModelBase here? (3) if yes, why it's not argument type?
  public synchronized void setModelDescriptor(org.jetbrains.mps.openapi.model.SModel modelDescriptor) {
    if (myModelDescriptor == modelDescriptor) {
      // just to guard against accidental second assignment
      return;
    }
    myModelDescriptor = ((SModelBase) modelDescriptor);
    myNodeOwner.setEventDispatch(modelDescriptor == null ? null : myModelDescriptor.getEventDispatch());
  }

  protected void enforceFullLoad() {
    org.jetbrains.mps.openapi.model.SModel md = myModelDescriptor;
    if (md != null) {
      md.load();
    }
  }

  private void fireModelNodesReadAccess() {
    if (!canFireReadEvent()) return;
    if (myModelDescriptor != null) {
      NodeReadEventsCaster.fireModelNodesReadAccess(myModelDescriptor);
    }
  }

//---------listeners--------

  /**
   * Use {@link #performUndoableAction(SNodeUndoableAction)} directly
   */
  @Deprecated
  @ToRemove(version = 3.3)
  protected void performUndoableAction(Computable<SNodeUndoableAction> action) {
    if (!canFireEvent()) return;
    if (!UndoHelper.getInstance().needRegisterUndo()) return;
    performUndoableAction(action.compute());
  }

  protected void performUndoableAction(@NotNull SNodeUndoableAction action) {
    if (!canFireEvent()) {
      return;
    }
    final UndoHelper uh = UndoHelper.getInstance();
    if (uh.needRegisterUndo()) {
      uh.addUndoableAction(action);
    }
  }

    //todo code in the following methods should be written w/o duplication

  public boolean canFireEvent() {
    return myModelDescriptor != null && jetbrains.mps.util.SNodeOperations.isRegistered(myModelDescriptor) && !isUpdateMode();
  }

  public boolean canFireReadEvent() {
    return canFireEvent();
  }

  public void dispose() {
    assertLegalChange();
    if (myDisposed) return;

    myDisposed = true;
    myDisposedStacktrace = new Throwable().getStackTrace();
    myIdToNodeMap = null;
    myRoots.clear();
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.dispose();
      myModelDependenciesManager = null;
    }
  }

  private void checkNotDisposed() {
    if (!myDisposed) return;
    LOG.error(new IllegalModelAccessError("accessing disposed model"));
  }

  private List<SModelListener> getModelListeners() {
    if (myModelDescriptor == null) return Collections.emptyList();
    return ((SModelBase) myModelDescriptor).getModelListeners();
  }

  private void fireDevKitAddedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireDevKitRemovedEvent(@NotNull SModuleReference ref) {
    if (!canFireEvent()) return;
    final SModelDevKitEvent event = new SModelDevKitEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.devkitRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageAddedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireLanguageRemovedEvent(@NotNull SLanguage ref) {
    if (!canFireEvent()) {
      return;
    }
    final SModelLanguageEvent event = new SModelLanguageEvent(getModelDescriptor(), ref, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.languageRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportAddedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  private void fireImportRemovedEvent(@NotNull SModelReference modelReference) {
    if (!canFireEvent()) return;
    final SModelImportEvent event = new SModelImportEvent(getModelDescriptor(), modelReference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.importRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  /*package*/ void fireRootAddedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  /*package*/ void fireRootRemovedEvent(@NotNull SNode root) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), root, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.rootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  /*package*/ void fireBeforeRootRemovedEvent(org.jetbrains.mps.openapi.model.SNode node) {
    if (!canFireEvent()) {
      return;
    }
    final SModelRootEvent event = new SModelRootEvent(getModelDescriptor(), node, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeRootRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void firePropertyChangedEvent(@NotNull SNode node, @NotNull SProperty property, @Nullable String oldValue, @Nullable String newValue) {
    if (!canFireEvent()) {
      return;
    }
    final SModelPropertyEvent event = new SModelPropertyEvent(getModelDescriptor(), property, node, oldValue, newValue);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.propertyChanged(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildAddedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), true, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.childRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireBeforeChildRemovedEvent(@NotNull SNode parent, @NotNull SContainmentLink role, @NotNull org.jetbrains.mps.openapi.model.SNode child, org.jetbrains.mps.openapi.model.SNode anchor) {
    if (!canFireEvent()) {
      return;
    }
    int childIndex = anchor == null ? 0 : parent.getChildren().indexOf(anchor) + 1;
    final SModelChildEvent event = new SModelChildEvent(getModelDescriptor(), false, parent, role, childIndex, child);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.beforeChildRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceAddedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, true);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceAdded(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  void fireReferenceRemovedEvent(@NotNull SReference reference) {
    if (!canFireEvent()) {
      return;
    }
    final SModelReferenceEvent event = new SModelReferenceEvent(getModelDescriptor(), reference, false);
    for (SModelListener sModelListener : getModelListeners()) {
      try {
        sModelListener.referenceRemoved(event);
      } catch (Throwable t) {
        LOG.error(null, t);
      }
    }
  }

  public FastNodeFinder createFastNodeFinder() {
    return new DefaultFastNodeFinder(getModelDescriptor());
  }

  //---------node registration--------

  void registerNode(@NotNull SNode node) {
    checkNotDisposed();
    if (myDisposed) return;

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (id == null) {
      assignNewId(node);
      return;
    }

    org.jetbrains.mps.openapi.model.SNode existingNode = myIdToNodeMap.get(id);
    if (existingNode == null) {
      myIdToNodeMap.put(node.getNodeId(), node);
    }

    if (existingNode != null && existingNode != node) {
      assignNewId(node);
    }
  }

  private void assignNewId(SNode node) {
    SNodeId id;
    id = generateUniqueId();
    while (myIdToNodeMap.containsKey(id)) {
      resetIdCounter();
      id = generateUniqueId();
    }
    node.setId(id);
    myIdToNodeMap.put(id, node);
  }

  //---------imports manipulation--------

  void unregisterNode(@NotNull SNode node) {
    checkNotDisposed();

    enforceFullLoad();
    org.jetbrains.mps.openapi.model.SNodeId id = node.getNodeId();
    if (myDisposed || id == null) return;
    myIdToNodeMap.remove(id);
  }

  public ModelDependenciesManager getModelDepsManager() {
    if (myModelDependenciesManager == null) {
      myModelDependenciesManager = new ModelDependenciesManager(getModelDescriptor());
      // we do not need to track model changes as we are invalidating dep manager right away on any change
      SRepository repo = getRepository();
      if (repo != null) {
        myModelDependenciesManager.trackRepositoryChanges(repo);
      }
    }
    return myModelDependenciesManager;
  }

  private void invalidateModelDepsManager() {
    if (myModelDependenciesManager != null) {
      myModelDependenciesManager.invalidate();
    }
  }

  //language

  public Collection<SLanguage> usedLanguages() {
    return Collections.unmodifiableSet(myLanguagesIds.keySet());
  }

  public Map<SLanguage, Integer> usedLanguagesWithVersions() {
    return Collections.unmodifiableMap(myLanguagesIds);
  }

  public void deleteLanguage(@NotNull SLanguage id) {
    assertLegalChange();
    if (myLanguagesIds.remove(id) != null) {
      invalidateModelDepsManager();
      fireLanguageRemovedEvent(id);
      markChanged();
    }
  }

  public void addLanguage(@NotNull SLanguage language) {
    addLanguage(language, language.getLanguageVersion());
  }

  /**
   * @deprecated  use #addLanguage(SLanguage) instead
   */
  @Deprecated
  public void addLanguage(SLanguage id, int version) {
    assertLegalChange();

    Integer existingVersion = myLanguagesIds.get(id);
    if (existingVersion != null) {
      if (version == -1 || existingVersion == version) {
        return;
      }
      if (existingVersion == -1) {
        myLanguagesIds.remove(id);
      } else {
        throw new IllegalStateException("Can't add language import with different version. Old version: " + existingVersion + "; new version: " + version);
      }
    }

    myLanguagesIds.put(id, version);
    invalidateModelDepsManager();
    fireLanguageAddedEvent(id);
    markChanged();
  }

  //devkit

  public List<SModuleReference> importedDevkits() {
    return Collections.unmodifiableList(myDevKits);
  }

  public void addDevKit(SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.add(ref)) {
      invalidateModelDepsManager();
      fireDevKitAddedEvent(ref);
      markChanged();
    }
  }

  public void deleteDevKit(@NotNull SModuleReference ref) {
    assertLegalChange();

    if (myDevKits.remove(ref)) {
      invalidateModelDepsManager();
      fireDevKitRemovedEvent(ref);
      markChanged();
    }
  }

  //model

  public List<ImportElement> importedModels() {
    return Collections.unmodifiableList(myImports);
  }

  public void addModelImport(ImportElement importElement) {
    assertLegalChange();

    myImports.add(importElement);
    fireImportAddedEvent(importElement.getModelReference());
    markChanged();
  }

  public void deleteModelImport(SModelReference modelReference) {
    assertLegalChange();

    ImportElement importElement = SModelOperations.getImportElement(this, modelReference);
    if (importElement != null) {
      myImports.remove(importElement);
      if (myLegacyImplicitImports != null) {
        // shall keep only if we do track implicit imports
        myLegacyImplicitImports.addAdditionalModelVersion(importElement);  // to save version and ID if model was imported implicitly
      }
      fireImportRemovedEvent(modelReference);
      markChanged();
    }
  }

  /**
   * This is compatibility method with legacy persistence mechanism, unless used, no implicit imports are tracked.
   * Drop once we no longer need to support serialization of old persistence formats (there's no reason to track
   * implicit imports if we aren't going to serialize them afterwards)
   */
  @NotNull
  public ImplicitImportsLegacyHolder getImplicitImportsSupport() {
    if (myLegacyImplicitImports == null) {
      myLegacyImplicitImports = new ImplicitImportsLegacyHolder(this);
    }
    return myLegacyImplicitImports;
  }
  // this method is for sole use of ImplicitImportsLegacyHolder, which used to access myIdToNodeMap, and I don't want to change this
  // (i.e. re-write with model iteration using OpenAPI). Drop it along with getImplicitImportsSupport()
  /*package*/Iterable<org.jetbrains.mps.openapi.model.SNode> allNodes() {
    return myIdToNodeMap.values();
  }

  // this method is for transition period, shall be removed once there are no uses of SModelOperations.getAllImportElements()
  // Once we drop refactorings, there is no need for the method
  @ToRemove(version = 3.2)
  /*package*/List<ImportElement> getAllImportElements() {
    List<ImportElement> result = new ArrayList<ImportElement>();
    result.addAll(myImports);
    if (myLegacyImplicitImports != null) {
      result.addAll(myLegacyImplicitImports.getAdditionalModelVersions());
    }
    return result;
  }

  public List<SModuleReference> engagedOnGenerationLanguages() {
    return myLanguagesEngagedOnGeneration;
  }

  private void markChanged() {
    if (myModelDescriptor == null) return;
    org.jetbrains.mps.openapi.model.SModel model = getModelDescriptor();
    if (model instanceof EditableSModel) {
      ((EditableSModel) model).setChanged(true);
    }
  }

  public void addEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (!myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.add(ref);
      // don't send event but mark model as changed
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  public void removeEngagedOnGenerationLanguage(SModuleReference ref) {
    assertLegalChange();

    if (myLanguagesEngagedOnGeneration.contains(ref)) {
      myLanguagesEngagedOnGeneration.remove(ref);
      // don't send event but mark model as changed
      if (canFireEvent()) {
        markChanged();
      }
    }
  }

  //aspects / additional

  public boolean isUpdateMode() {
    return myIsFullLoadMode;
  }

  public void setUpdateMode(boolean value) {
    // update mode means we are attaching newly loaded children
    this.myIsFullLoadMode = value;
  }

  //to use only from SNode
  protected SRepository getRepository() {
    return myModelDescriptor == null ? null : myModelDescriptor.getRepository();
  }

  private void assertLegalChange() {
    if (myModelDescriptor != null) {
      // FIXME in fact, all modification methods are accessed through SModelInternal iface, and SModelDescriptorStub shall
      // check for legal write instead of SModel itself.
      ModelChange.assertLegalChange_new(myModelDescriptor);
    }
  }

  //---------refactorings--------

  public boolean updateSModelReferences() {
    assertLegalChange();
    enforceFullLoad();

    boolean changed = false;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        SModelReference oldReference = reference.getTargetSModelReference();
        if (oldReference == null) continue;
        jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) oldReference;
        jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
        if (newRef.differs(oldSRef)) {
          changed = true;
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newRef);
        }
      }
    }

    for (ImportElement e : myImports) {
      jetbrains.mps.smodel.SModelReference oldSRef = (jetbrains.mps.smodel.SModelReference) e.myModelReference;
      jetbrains.mps.smodel.SModelReference newRef = oldSRef.update();
      if (newRef.differs(oldSRef)) {
        changed = true;
        e.myModelReference = newRef;
      }
    }
    if (myLegacyImplicitImports != null) {
      changed |= myLegacyImplicitImports.updateSModelReferences();
    }

    return changed;
  }

  public boolean updateModuleReferences() {
    assertLegalChange();


    boolean changed = false;

    if (updateRefs(myDevKits)) {
      changed = true;
    }
    if (updateRefs(myLanguagesEngagedOnGeneration)) {
      changed = true;
    }

    return changed;
  }

  public void changeModelReference(SModelReference newModelReference) {
    enforceFullLoad();
    SModelReference oldReference = myReference;
    myReference = newModelReference;
    for (org.jetbrains.mps.openapi.model.SNode node : myIdToNodeMap.values()) {
      for (SReference reference : node.getReferences()) {
        if (oldReference.equals(reference.getTargetSModelReference())) {
          ((jetbrains.mps.smodel.SReference) reference).setTargetSModelReference(newModelReference);
        }
      }
    }
  }

  public boolean updateRefs(List<SModuleReference> refs) {
    boolean changed = false;
    for (int i = 0; i < refs.size(); i++) {
      SModuleReference ref = refs.get(i);
      SModule module = ModuleRepositoryFacade.getInstance().getModule(ref);
      if (module != null) {
        SModuleReference newRef = module.getModuleReference();
        refs.set(i, newRef);
        changed = changed || ModuleReference.differs(ref, newRef);
      }
    }
    return changed;
  }

  public SModel createEmptyCopy() {
    return new jetbrains.mps.smodel.SModel(getReference());
  }

  public void copyPropertiesTo(SModel to) {
    if (myLegacyImplicitImports != null) {
      for (ImportElement ie : myLegacyImplicitImports.getAdditionalModelVersions()) {
        to.getImplicitImportsSupport().addAdditionalModelVersion(ie.copy());
      }
    }
    for (ImportElement ie : importedModels()) {
      to.addModelImport(ie.copy());
    }
    for (SModuleReference mr : importedDevkits()) {
      to.addDevKit(mr);
    }
    for (SLanguage lang : usedLanguages()) {
      to.addLanguage(lang);
    }
    for (SModuleReference mr : engagedOnGenerationLanguages()) {
      to.addEngagedOnGenerationLanguage(mr);
    }
  }

  public static class ImportElement {
    private SModelReference myModelReference;
    private int myReferenceID;  // persistence related index
    private int myUsedVersion;

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID) {
      this(modelReference, referenceID, -1);
    }

    @Deprecated
    public ImportElement(SModelReference modelReference, int referenceID, int usedVersion) {
      myModelReference = modelReference;
      myReferenceID = referenceID;
      myUsedVersion = usedVersion;
    }

    public ImportElement(SModelReference modelReference) {
      myModelReference = modelReference;
      myReferenceID = 0;
      myUsedVersion = -1;
    }

    public SModelReference getModelReference() {
      return myModelReference;
    }

    public void setModelReference(SModelReference modelReference) {
      myModelReference = modelReference;
    }

    public int getReferenceID() {
      return myReferenceID;
    }

    public void setReferenceID(int referenceID) {
      myReferenceID = referenceID;
    }

    public int getUsedVersion() {
      return myUsedVersion;
    }

    protected ImportElement copy() {
      return new ImportElement(myModelReference, myReferenceID, myUsedVersion);
    }

    public String toString() {
      return "ImportElement(" +
          "uid=" + myModelReference + ", " +
          "referenceId=" + myReferenceID + ", " +
          "usedVersion=" + myUsedVersion + ")";
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      ImportElement that = (ImportElement) o;

      if (myReferenceID != that.myReferenceID) return false;
      if (myUsedVersion != that.myUsedVersion) return false;
      if (myModelReference != null ? !myModelReference.equals(that.myModelReference) : that.myModelReference != null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      int result = myModelReference != null ? myModelReference.hashCode() : 0;
      result = 31 * result + myReferenceID;
      result = 31 * result + myUsedVersion;
      return result;
    }
  }

}


File: core/kernel/source/jetbrains/mps/smodel/SModelInternal.java
/*
 * Copyright 2003-2013 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel;

import jetbrains.mps.extapi.model.ModelWithDisposeInfo;
import jetbrains.mps.project.dependency.ModelDependenciesManager;
import jetbrains.mps.smodel.SModel.ImportElement;
import jetbrains.mps.smodel.event.SModelListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.List;
import java.util.Map;

public interface SModelInternal extends ModelWithDisposeInfo  {

  void addModelListener(@NotNull SModelListener listener);

  void removeModelListener(@NotNull SModelListener listener);

  ModelDependenciesManager getModelDepsManager();

  @Deprecated
  List<SModuleReference> importedLanguages();

  @Deprecated
  void deleteLanguage(@NotNull SModuleReference ref);

  @Deprecated
  void addLanguage(SModuleReference ref);

  // FIXME rename to importedLanguages once original is removed
  java.util.Collection<SLanguage> importedLanguageIds();

  // FIXME refactor, rename to removeLanguage(SLanguage), expose in SModel
  void deleteLanguageId(@NotNull SLanguage ref);

  void addLanguage(Language language);

  void addLanguage(@NotNull SLanguage language);

  /**
   * SLanguage is the reference to a language, and it bears version (SLanguage.getLanguageVersion()), no need to specify it explicitly here
   */
  @Deprecated
  void addLanguageId(SLanguage ref, int version);

  List<SModuleReference> importedDevkits();

  void addDevKit(SModuleReference ref);

  void deleteDevKit(@NotNull SModuleReference ref);

  List<ImportElement> importedModels();

  void addModelImport(SModelReference modelReference, boolean firstVersion);

  void addModelImport(ImportElement importElement);

  void deleteModelImport(SModelReference modelReference);

  // create new implicit import list based on used models, explicit import and old implicit import list
  void calculateImplicitImports();

  List<SModuleReference> engagedOnGenerationLanguages();

  void addEngagedOnGenerationLanguage(SModuleReference ref);

  void removeEngagedOnGenerationLanguage(SModuleReference ref);

  List<ImportElement> getAdditionalModelVersions();

  boolean updateSModelReferences();

  void changeModelReference(SModelReference newModelReference);

  boolean updateModuleReferences();
}


File: core/kernel/source/jetbrains/mps/smodel/adapter/structure/MetaAdapterFactory.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterById;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterById;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterById;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.util.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.annotations.Immutable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public abstract class MetaAdapterFactory {
  private static final ConcurrentMap<LangKey, SLanguage> ourLanguageIds = new ConcurrentHashMap<LangKey, SLanguage>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SConcept> ourConceptIds = new ConcurrentHashMap<Pair<SConceptId, String>, SConcept>();
  private static final ConcurrentMap<Pair<SConceptId, String>, SInterfaceConcept> ourIntfcConceptIds =
      new ConcurrentHashMap<Pair<SConceptId, String>, SInterfaceConcept>();
  private static final ConcurrentMap<Pair<SPropertyId, String>, SProperty> ourPropertyIds = new ConcurrentHashMap<Pair<SPropertyId, String>, SProperty>();
  private static final ConcurrentMap<Pair<SReferenceLinkId, String>, SReferenceLink> ourRefIds =
      new ConcurrentHashMap<Pair<SReferenceLinkId, String>, SReferenceLink>();
  private static final ConcurrentMap<Pair<SContainmentLinkId, String>, SContainmentLink> ourLinkIds =
      new ConcurrentHashMap<Pair<SContainmentLinkId, String>, SContainmentLink>();

  @NotNull
  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName) {
    return getLanguage(id, langName, -1);
  }

  @NotNull
  public static SLanguage getLanguage(@NotNull SLanguageId id, @NotNull String langName, int version) {
    SLanguageAdapterById l = new SLanguageAdapterById(id, langName, version);
    LangKey p = new LangKey(id, langName, version);
    ourLanguageIds.putIfAbsent(p, l);
    return ourLanguageIds.get(p);
  }

  public static SLanguage getLanguage(@NotNull SLanguage original, int anotherVersion) {
    if (original.getLanguageVersion() == anotherVersion) {
      return original;
    }
    SLanguageId langId = null;
    if (original instanceof SLanguageAdapterById) {
      langId = ((SLanguageAdapterById) original).getId();
    } else if (original instanceof SLanguageAdapter) {
      final LanguageRuntime rt = ((SLanguageAdapter) original).getLanguageDescriptor();
      langId = rt == null ? null : rt.getId();
    }
    if (langId == null) {
      langId = MetaIdByDeclaration.ref2LangId(original.getSourceModule().getModuleReference());
    }
    return getLanguage(langId, original.getQualifiedName(), anotherVersion);
  }

  @NotNull
  public static SLanguage getLanguage(long uuidHigh, long uuidLow, String langName) {
    return getLanguage(MetaIdFactory.langId(uuidHigh, uuidLow), langName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SLanguage getLanguage(UUID lang, String langName) {
    return getLanguage(MetaIdFactory.langId(lang), langName);
  }

  @NotNull
  public static SLanguage getLanguage(@NotNull SModuleReference languageModuleRef) {
    return getLanguage(MetaIdByDeclaration.ref2LangId(languageModuleRef), languageModuleRef.getModuleName());
  }

  @NotNull
  public static SConcept getConcept(SConceptId id, String conceptName) {
    SConceptAdapterById c = new SConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourConceptIds.putIfAbsent(p, c);
    return ourConceptIds.get(p);
  }

  @NotNull
  public static SConcept getConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SConcept getConcept(UUID lang, long concept, String conceptName) {
    return getConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(SConceptId id, String conceptName) {
    SInterfaceConceptAdapterById c = new SInterfaceConceptAdapterById(id, conceptName);
    Pair<SConceptId, String> p = new Pair<SConceptId, String>(id, conceptName);
    ourIntfcConceptIds.putIfAbsent(p, c);
    return ourIntfcConceptIds.get(p);
  }

  @NotNull
  public static SInterfaceConcept getInterfaceConcept(long uuidHigh, long uuidLow, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(uuidHigh, uuidLow, concept), conceptName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SInterfaceConcept getInterfaceConcept(UUID lang, long concept, String conceptName) {
    return getInterfaceConcept(MetaIdFactory.conceptId(lang, concept), conceptName);
  }

  @NotNull
  public static SProperty getProperty(SPropertyId id, String propName) {
    SPropertyAdapterById c = new SPropertyAdapterById(id, propName);
    Pair<SPropertyId, String> p = new Pair<SPropertyId, String>(id, propName);
    ourPropertyIds.putIfAbsent(p, c);
    return ourPropertyIds.get(p);
  }

  @NotNull
  public static SProperty getProperty(long uuidHigh, long uuidLow, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(uuidHigh, uuidLow, concept, prop), propName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SProperty getProperty(UUID lang, long concept, long prop, String propName) {
    return getProperty(MetaIdFactory.propId(lang, concept, prop), propName);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(SReferenceLinkId id, String refName) {
    SReferenceLinkAdapterById c = new SReferenceLinkAdapterById(id, refName);
    Pair<SReferenceLinkId, String> p = new Pair<SReferenceLinkId, String>(id, refName);
    ourRefIds.putIfAbsent(p, c);
    return ourRefIds.get(p);
  }

  @NotNull
  public static SReferenceLink getReferenceLink(long uuidHigh, long uuidLow, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(uuidHigh, uuidLow, concept, ref), refName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SReferenceLink getReferenceLink(UUID lang, long concept, long ref, String refName) {
    return getReferenceLink(MetaIdFactory.refId(lang, concept, ref), refName);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(SContainmentLinkId id, String linkName) {
    SContainmentLinkAdapterById c = new SContainmentLinkAdapterById(id, linkName);
    Pair<SContainmentLinkId, String> p = new Pair<SContainmentLinkId, String>(id, linkName);
    ourLinkIds.putIfAbsent(p, c);
    return ourLinkIds.get(p);
  }

  @NotNull
  public static SContainmentLink getContainmentLink(long uuidHigh, long uuidLow, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(uuidHigh, uuidLow, concept, link), linkName);
  }

  @NotNull
  @Deprecated //todo: 2 hex values instead of UUID
  public static SContainmentLink getContainmentLink(UUID lang, long concept, long link, String linkName) {
    return getContainmentLink(MetaIdFactory.linkId(lang, concept, link), linkName);
  }

  @NotNull
  public static SAbstractConcept getAbstractConcept(ConceptDescriptor descriptor) {
    if (descriptor.isInterfaceConcept()) {
      return getInterfaceConcept(descriptor.getId(), descriptor.getConceptFqName());
    } else {
      return getConcept(descriptor.getId(), descriptor.getConceptFqName());
    }
  }

  @Immutable
  private static class LangKey {
    private final SLanguageId myId;
    private final String myName;
    private final int myVersion;

    public LangKey(SLanguageId id, String name, int version) {
      myId = id;
      myName = name;
      myVersion = version;
    }

    @Override
    public int hashCode() {
      return myId.hashCode() * 31 + myName.hashCode() + myVersion;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj instanceof LangKey) {
        LangKey o = (LangKey) obj;
        return myVersion == o.myVersion && myId.equals(o.myId) && myName.equals(o.myName);
      }
      return false;
    }
  }
}


File: core/kernel/source/jetbrains/mps/smodel/adapter/structure/MetaAdapterFactoryByName.java
/*
 * Copyright 2003-2014 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.adapter.structure;

import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterByName;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapterByName;
import jetbrains.mps.smodel.adapter.structure.link.SContainmentLinkAdapterByName;
import jetbrains.mps.smodel.adapter.structure.property.SPropertyAdapterByName;
import jetbrains.mps.smodel.adapter.structure.ref.SReferenceLinkAdapterByName;
import jetbrains.mps.smodel.language.ConceptRegistry;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.illegal.IllegalConceptDescriptor;
import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;

/**
 * {@link jetbrains.mps.smodel.legacy.ConceptMetaInfoConverter} covers transition from string to meta-object within SConcept scope.
 * To get SLanguage or SConcept/SInterfaceConcept, there's no other alternative at the moment but to use static methods of this class.
 */
public class MetaAdapterFactoryByName {
  public static SLanguage getLanguage(String langName) {
    return new SLanguageAdapterByName(langName);
  }

  public static SLanguage getLanguage(String langName, int version) {
    return new SLanguageAdapterByName(langName, version);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  //no usages in MPS except SModelUtil.findConceptDeclaration
  public static SConcept getConcept(String conceptName) {
    return new SConceptAdapterByName(conceptName);
  }

  public static SInterfaceConcept getInterfaceConcept(String conceptName) {
    return new SInterfaceConceptAdapterByName(conceptName);
  }

  /**
   * Generally, this method shall not be used directly. Consider using {@link jetbrains.mps.smodel.legacy.ConceptMetaInfoConverter#convertProperty(String)} instead
   */
  public static SProperty getProperty(String conceptName, String propName) {
    return new SPropertyAdapterByName(conceptName, propName);
  }

  /**
   * Generally, this method shall not be used directly. Consider using {@link jetbrains.mps.smodel.legacy.ConceptMetaInfoConverter#convertAssociation(String)} instead
   */
  public static SReferenceLink getReferenceLink(String conceptName, String refName) {
    return new SReferenceLinkAdapterByName(conceptName, refName);
  }

  /**
   * Generally, this method shall not be used directly. Consider using {@link jetbrains.mps.smodel.legacy.ConceptMetaInfoConverter#convertAggregation(String)}} instead
   */
  public static SContainmentLink getContainmentLink(String conceptName, String linkName) {
    return new SContainmentLinkAdapterByName(conceptName, linkName);
  }

  @Deprecated
  @ToRemove(version = 3.3)
  //not used in MPS
  //this is to use only for compatibility reasons between 3.2 and 3.3. This code does not run normally at all
  public static SAbstractConcept getTypedConcept_DoNotUse(String conceptName) {
    final ConceptDescriptor cd = ConceptRegistry.getInstance().getConceptDescriptor(conceptName);
    if (cd instanceof IllegalConceptDescriptor) return MetaAdapterFactoryByName.getConcept(conceptName);
    return MetaAdapterFactory.getAbstractConcept(cd);
  }
}


File: core/kernel/source/jetbrains/mps/smodel/adapter/structure/language/SLanguageAdapter.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.project.dependency.modules.LanguageDependenciesManager;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.concept.SConceptAdapterById;
import jetbrains.mps.smodel.adapter.structure.concept.SInterfaceConceptAdapterById;
import jetbrains.mps.smodel.language.LanguageRuntime;
import jetbrains.mps.smodel.runtime.BaseStructureAspectDescriptor;
import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import jetbrains.mps.smodel.runtime.StructureAspectDescriptor;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SDependency;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import org.jetbrains.mps.openapi.module.SModuleReference;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public abstract class SLanguageAdapter implements SLanguage {
  protected final String myLanguageFqName;
  /**
   * We use -1 to indicate we care about actual language version available.
   * Positive value indicates this is a reference to the given revision of the language
   */
  private final int myVersion;

  protected SLanguageAdapter(@NotNull String language, int version) {
    this.myLanguageFqName = language;
    myVersion = version;
  }

  @Nullable
  public abstract LanguageRuntime getLanguageDescriptor();

  @NotNull
  public abstract SLanguageId getId();

  @Override
  @Nullable
  public abstract Language getSourceModule();

  @Override
  public String getQualifiedName() {
    return myLanguageFqName;
  }

  @Override
  public Iterable<SAbstractConcept> getConcepts() {
    LanguageRuntime runtime = getLanguageDescriptor();
    if (runtime == null) {
      return Collections.emptySet();
    }

    StructureAspectDescriptor struc = getLanguageDescriptor().getAspect(StructureAspectDescriptor.class);
    if (struc == null) {
      return Collections.emptyList();
    }
    ArrayList<SAbstractConcept> result = new ArrayList<SAbstractConcept>();
    for (ConceptDescriptor cd : ((BaseStructureAspectDescriptor) struc).getDescriptors()) {
      if (cd.isInterfaceConcept()) {
        result.add(new SInterfaceConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      } else {
        result.add(new SConceptAdapterById(cd.getId(), cd.getConceptFqName()));
      }
    }
    return result;
  }

  @Override
  public Iterable<SModuleReference> getLanguageRuntimes() {
    Set<SModuleReference> runtimes = new HashSet<SModuleReference>();
    Language sourceModule = getSourceModule();
    if (sourceModule == null) {
      return Collections.emptyList();
    }
    for (Language language : SetSequence.fromSet(LanguageDependenciesManager.getAllExtendedLanguages(sourceModule))) {
      runtimes.addAll(language.getRuntimeModulesReferences());
      // GeneratesInto doesn't qualify as 'true' language runtime, it's rather generator aspect, however, for the time being,
      // while we transit from using 'Extends' between languages to 'GenerateInto' to grab runtime modules, keep them together
      // although GlobalModuleDependenciesManager might be better place to care about this kind of dependency. Anyway,
      // we likely need to move both true RT and 'GeneratesInto' to LanguageRuntime to get rid of source module use here.
      for (SDependency dep : language.getDeclaredDependencies()) {
        if (dep.getScope() == SDependencyScope.GENERATES_INTO && dep.getTarget() instanceof Language) {
          runtimes.addAll(((Language) dep.getTarget()).getRuntimeModulesReferences());
        }
      }
    }
    return runtimes;
  }

  public int getLanguageVersion() {
    if (myVersion >= 0) {
      return myVersion;
    }
    LanguageRuntime languageDescriptor = getLanguageDescriptor();
    if (languageDescriptor == null) {
      return -1;
    }
    return languageDescriptor.getVersion();
  }

  @Override
  public String toString() {
    return myLanguageFqName;
  }

  @Override
  public int hashCode() {
    return 0;
  }
}


File: core/kernel/source/jetbrains/mps/smodel/adapter/structure/language/SLanguageAdapterById.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.project.ModuleId;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterById extends SLanguageAdapter {
  private final SLanguageId myLanguage;

  public SLanguageAdapterById(@NotNull SLanguageId language, @NotNull String fqName) {
    this(language, fqName, -1);
  }
  public SLanguageAdapterById(@NotNull SLanguageId language, @NotNull String fqName, int version) {
    super(fqName, version);
    this.myLanguage = language;
  }

  @NotNull
  public SLanguageId getId() {
    return myLanguage;
  }

  @Override
  public String getQualifiedName() {
    LanguageRuntime ld = getLanguageDescriptor();
    if (ld == null) {
      return myLanguageFqName;
    }
    return ld.getNamespace();
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguage);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return  false;
    return ( obj instanceof SLanguageAdapterById) ? myLanguage.equals(((SLanguageAdapterById) obj).myLanguage) : myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ((Language) MPSModuleRepository.getInstance().getModule(ModuleId.regular(myLanguage.getIdValue())));
  }
}


File: core/kernel/source/jetbrains/mps/smodel/adapter/structure/language/SLanguageAdapterByName.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.adapter.structure.language;

import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.smodel.language.LanguageRuntime;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;

public final class SLanguageAdapterByName extends SLanguageAdapter {
  public SLanguageAdapterByName(@NotNull String language) {
    super(language, -1);
  }
  public SLanguageAdapterByName(@NotNull String language, int version) {
    super(language, version);
  }

  @Override
  @Nullable
  public LanguageRuntime getLanguageDescriptor() {
    return LanguageRegistry.getInstance().getLanguage(myLanguageFqName);
  }

  @Override
  public SLanguageId getId() {
    LanguageRuntime lr = getLanguageDescriptor();
    if (lr != null) {
      return lr.getId();
    }
    Language l = getSourceModule();
    if (l != null) {
      return MetaIdByDeclaration.getLanguageId(l);
    }
    return MetaIdFactory.INVALID_LANGUAGE_ID;
  }

  @Override
  @Nullable
  public Language getSourceModule() {
    return ModuleRepositoryFacade.getInstance().getModule(myLanguageFqName, Language.class);
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof SLanguage)) return false;
    return myLanguageFqName.equals(((SLanguageAdapter) obj).myLanguageFqName);
  }
}


File: core/kernel/source/jetbrains/mps/smodel/language/LanguageRegistry.java
/*
 * Copyright 2003-2014 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.language;

import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.classloading.MPSClassesListener;
import jetbrains.mps.components.CoreComponent;
import jetbrains.mps.module.ReloadableModuleBase;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.adapter.ids.MetaIdByDeclaration;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.structure.language.SLanguageAdapter;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepository;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;

import static java.lang.String.format;

/**
 * evgeny, 3/11/11
 */
public class LanguageRegistry implements CoreComponent, MPSClassesListener {
  private static final Logger LOG = LogManager.getLogger(LanguageRegistry.class);

  private static LanguageRegistry INSTANCE;

  public static LanguageRegistry getInstance() {
    return INSTANCE;
  }

  private Map<String, LanguageRuntime> myLanguages = new HashMap<String, LanguageRuntime>();
  private Map<SLanguageId, LanguageRuntime> myLanguagesById = new HashMap<SLanguageId, LanguageRuntime>();

  private final List<LanguageRegistryListener> myLanguageListeners = new CopyOnWriteArrayList<LanguageRegistryListener>();

  private final SRepository myRepository;
  private final ClassLoaderManager myClassLoaderManager;

  public LanguageRegistry(SRepository repository, ClassLoaderManager loaderManager) {
    myRepository = repository;
    myClassLoaderManager = loaderManager;
  }

  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myClassLoaderManager.addClassesHandler(this);
  }

  @Override
  public void dispose() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        notifyUnload(myLanguages.values());
        myLanguages.clear();
        myLanguagesById.clear();
      }
    });
    myClassLoaderManager.removeClassesHandler(this);
    INSTANCE = null;
  }

  private void notifyUnload(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.beforeLanguagesUnloaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language unloading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  private void notifyLoad(final Collection<LanguageRuntime> languages) {
    if (languages.isEmpty()) return;

    for (LanguageRegistryListener l : myLanguageListeners) {
      try {
        l.afterLanguagesLoaded(languages);
      } catch (Exception ex) {
        LOG.error(format("Exception on language loading; languages: %s; listener: %s", languages, l), ex);
      }
    }
  }

  @Nullable
  private static LanguageRuntime createRuntime(Language l) {
    final String rtClassName = l.getModuleName() + ".Language";
    // Here, we consider few cases:
    // (a) there's no LR class
    // (b) there's legacy LR class (if we did changes to LR this release)
    // (c) LR in accordance with actual MPS version
    // Both (b) and (c) may fail during class-loading, which we treat as invalid language, although
    // for legacy versions and careless class evolution we might face otherwise valid languages which
    // fail to load due to class validation errors.
    // We aim to support binary compatibility between any two subsequent releases, thus failures for (b)
    // shall serve as an indicator we failed to maintain binary compatibility between releases
    try {
      final Class<?> rtClass = l.getOwnClass(rtClassName);
      if (rtClass != null && LanguageRuntime.class.isAssignableFrom(rtClass)) {
        return ((Class<LanguageRuntime>) rtClass).newInstance();
      }
      return new InterpretedLanguageRuntime(l);
    } catch (ClassNotFoundException ex) {
      return new InterpretedLanguageRuntime(l);
    } catch (InstantiationException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    } catch (IllegalAccessException e) {
      LOG.error(String.format("Failed to load language %s", l.getModuleName()), e);
      return null;
    }
  }

  public String toString() {
    return "LanguageRegistry";
  }

  public void addRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.add(listener);
  }

  public void removeRegistryListener(LanguageRegistryListener listener) {
    myLanguageListeners.remove(listener);
  }

  /*
   *   Collection is valid until the end of the current read action.
   */
  public Collection<LanguageRuntime> getAvailableLanguages() {
    myRepository.getModelAccess().checkReadAccess();
    return myLanguages.values();
  }

  public Collection<SLanguage> getAllLanguages() {
    final Collection<LanguageRuntime> languages = getAvailableLanguages();
    ArrayList<SLanguage> rv = new ArrayList<SLanguage>(languages.size());
    for (LanguageRuntime lr : languages) {
      rv.add(MetaAdapterFactory.getLanguage(lr.getId(), lr.getNamespace(), lr.getVersion()));
    }
    return rv;
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguage language) {
    return ((SLanguageAdapter) language).getLanguageDescriptor();
  }

  @Nullable
  public LanguageRuntime getLanguage(SLanguageId id) {
    return myLanguagesById.get(id);
  }

  @Nullable
  public LanguageRuntime getLanguage(String namespace) {
    return myLanguages.get(namespace);
  }

  public LanguageRuntime getLanguage(Language language) {
    return getLanguage(language.getModuleName());
  }

  /**
   * PROVISIONAL API, DO NOT USE
   * Find respective runtime presentation of generator module
   * FIXME shall decide whether need standalone GeneratorRegistry to supply GeneratorRuntimes
   * FIXME or access to GeneratorRuntime through LanguageRegistry is enough.
   */
  public GeneratorRuntime getGenerator(Generator generator) {
    LanguageRuntime lr = getLanguage(generator.getSourceLanguage());
    if (lr == null) {
      return null;
    }
    for (GeneratorRuntime grt : lr.getGenerators()) {
      if (grt.getModuleReference().equals(generator.getModuleReference())) {
        return grt;
      }
    }
    return null;
  }

  // MPSClassesListener part
  @Override
  public void beforeClassesUnloaded(Set<? extends ReloadableModuleBase> unloadedModules) {
    Set<LanguageRuntime> languagesToUnload = new HashSet<LanguageRuntime>();
    for (SLanguageId languageId : collectLanguagesToUnload(unloadedModules)) {
      if (!myLanguagesById.containsKey(languageId)) {
        LOG.warn("No language with id " + languageId + " to unload");
      } else {
        languagesToUnload.add(myLanguagesById.get(languageId));
      }
    }

    notifyUnload(languagesToUnload);

    for (LanguageRuntime languageRuntime : languagesToUnload) {
      myLanguages.remove(languageRuntime.getNamespace());
      myLanguagesById.remove(languageRuntime.getId());
    }
    reinitialize();
  }

  @Override
  public void afterClassesLoaded(Set<? extends ReloadableModuleBase> loadedModules) {
    Set<LanguageRuntime> loadedRuntimes = new HashSet<LanguageRuntime>();
    for (Language language : collectLanguagesToLoad(loadedModules)) {
      SLanguageId languageId = MetaIdByDeclaration.getLanguageId(language);
      if (myLanguagesById.containsKey(languageId)) {
        LOG.error("", new IllegalArgumentException(String.format("There is already a language '%s' with id '%s'", myLanguagesById.get(languageId), languageId)));
        continue;
      }
      try {
        LanguageRuntime langRuntime = createRuntime(language);
        if (langRuntime == null) continue;

        String langName = langRuntime.getNamespace();
        if (myLanguages.containsKey(langName)) {
          LOG.warn(String.format("There is already a language '%s' with a name '%s'", myLanguages.get(langName), langName));
        }
        myLanguages.put(langName, langRuntime);
        myLanguagesById.put(languageId, langRuntime);
        loadedRuntimes.add(langRuntime);
      } catch (LinkageError le) {
        processLinkageErrorForLanguage(language, le);
      }
    }
    reinitialize();
    notifyLoad(loadedRuntimes);
  }

  private Iterable<SLanguageId> collectLanguagesToUnload(Set<? extends SModule> unloadedModules) {
    Collection<SLanguageId> languagesToUnload = new ArrayList<SLanguageId>();
    for (SModule unloadedModule : unloadedModules) {
      if (unloadedModule instanceof Language) {
        languagesToUnload.add(MetaIdByDeclaration.getLanguageId((Language) unloadedModule));
      }
    }
    return languagesToUnload;
  }

  private Iterable<Language> collectLanguagesToLoad(Set<? extends SModule> loadedModules) {
    Collection<Language> languagesToLoad = new ArrayList<Language>();
    for (SModule loadedModule : loadedModules) {
      if (loadedModule instanceof Language) {
        languagesToLoad.add((Language) loadedModule);
      }
    }

    return languagesToLoad;
  }

  private void reinitialize() {
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.deinitialize();
    }
    for (LanguageRuntime languageRuntime : myLanguages.values()) {
      languageRuntime.initialize(this);
    }
  }

  private static void processLinkageErrorForLanguage(Language language, LinkageError linkageError) {
    LOG.error("Caught a linkage error while creating LanguageRuntime for the `" + language + "` language." +
        "Probably the language sources/classes are outdated, try rebuilding the project.", linkageError);
    LOG.warn("MPS will attempt running in a inconsistent state.");
  }
}


File: core/kernel/source_gen/jetbrains/mps/project/structure/ProjectStructureModule.java
package jetbrains.mps.project.structure;

/*Generated by MPS */

import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.components.CoreComponent;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelId;
import java.util.concurrent.ConcurrentHashMap;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import org.jetbrains.mps.openapi.module.SModuleListener;
import org.jetbrains.mps.openapi.module.SModuleAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.jetbrains.mps.openapi.module.SRepositoryListenerBase;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.DevKit;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.extapi.model.SModelBase;
import org.jetbrains.mps.openapi.module.SModuleId;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.BaseSpecialModelDescriptor;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.NodeReadAccessCasterInEditor;
import jetbrains.mps.project.structure.stub.ProjectStructureBuilder;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.smodel.BaseFastNodeFinder;

public class ProjectStructureModule extends AbstractModule implements CoreComponent {
  private static final String MODULE_REF = "642f71f8-327a-425b-84f9-44ad58786d27(jetbrains.mps.lang.project.modules)";
  private Map<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor> myModels = new ConcurrentHashMap<SModelId, ProjectStructureModule.ProjectStructureSModelDescriptor>();
  private static ProjectStructureModule INSTANCE;
  private final MPSModuleOwner myOwner = new BaseMPSModuleOwner() {};
  private final SModuleListener myModuleListener = new SModuleAdapter() {
    @Override
    public void moduleChanged(SModule module) {
      refreshModule(module, false);
    }
  };
  private final SRepositoryListener myListener = new SRepositoryListenerBase() {
    @Override
    public void moduleAdded(@NotNull SModule module) {
      refreshModule(module, false);
      module.addModuleListener(myModuleListener);
    }
    @Override
    public void beforeModuleRemoved(@NotNull SModule module) {
      module.removeModuleListener(myModuleListener);
      refreshModule(module, true);
    }
  };
  private final MPSModuleRepository myRepository;
  public static ProjectStructureModule getInstance() {
    return INSTANCE;
  }
  public ProjectStructureModule(MPSModuleRepository repository) {
    myRepository = repository;
    setModuleReference(PersistenceFacade.getInstance().createModuleReference(MODULE_REF));
  }
  private void refreshModule(SModule module, boolean isDeleted) {
    assertCanChange();
    if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {
      return;
    }
    SModelReference ref = getSModelReference(module);
    if (isDeleted) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      if (descriptor != null) {
        removeModel(descriptor);
      }
    } else
    if (myModels.containsKey(ref.getModelId())) {
      ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
      descriptor.dropModel();
    } else {
      createModel(module);
    }
  }
  public SModel getModelByModule(SModule module) {
    myRepository.getModelAccess().checkReadAccess();
    if (module == null) {
      return null;
    }
    SModelReference ref = getSModelReference(module);
    ProjectStructureModule.ProjectStructureSModelDescriptor descriptor = myModels.get(ref.getModelId());
    return (descriptor == null ? null : descriptor);
  }
  @Override
  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
    myRepository.addRepositoryListener(myListener);
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.registerModule(ProjectStructureModule.this, myOwner);
      }
    });
  }
  @Override
  public void dispose() {
    // it is disposed as CoreComponent 
    if (INSTANCE == null) {
      return;
    }
    INSTANCE = null;
    clearAll();
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        myRepository.unregisterModule(ProjectStructureModule.this, myOwner);
      }
    });
    myRepository.removeRepositoryListener(myListener);
  }
  public void clearAll() {
    myRepository.getModelAccess().runWriteAction(new Runnable() {
      @Override
      public void run() {
        removeAll();
        dependenciesChanged();
        myModels.clear();
      }
    });
  }
  private void removeAll() {
    List<SModel> models = this.getProjectStructureModels();
    for (SModel model : models) {
      removeModel(model);
    }
  }
  @Override
  public Set<SLanguage> getUsedLanguages() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x86ef829012bb4ca7L, 0x947f093788f263a9L), "jetbrains.mps.lang.project", 0));
  }
  private void removeModel(SModel md) {
    if (myModels.remove(md.getReference().getModelId()) != null) {
      unregisterModel((SModelBase) md);
      if (md instanceof ProjectStructureModule.ProjectStructureSModelDescriptor) {
        ((ProjectStructureModule.ProjectStructureSModelDescriptor) md).dropModel();
      }
    }
  }
  public ProjectStructureModule.ProjectStructureSModelDescriptor createModel(SModule module) {
    ProjectStructureModule.ProjectStructureSModelDescriptor result = new ProjectStructureModule.ProjectStructureSModelDescriptor(getSModelReference(module), module);
    myModels.put(getSModelReference(module).getModelId(), result);
    registerModel(result);
    return result;
  }
  private SModelReference getSModelReference(SModule module) {
    SModuleId moduleId = module.getModuleReference().getModuleId();
    SModelId id = (moduleId != null ? jetbrains.mps.smodel.SModelId.foreign("project", moduleId.toString()) : null);
    return new jetbrains.mps.smodel.SModelReference(this.getModuleReference(), id, "module." + module.getModuleName() + "@" + SModelStereotype.getStubStereotypeForId("project"));
  }
  public String toString() {
    return getModuleName();
  }
  public List<SModel> getProjectStructureModels() {
    return new ArrayList<SModel>(myModels.values());
  }
  @Override
  protected void collectFacetTypes(Set<String> types) {
    // none 
  }
  @Override
  public SModel resolveInDependencies(SModelId ref) {
    return myModels.get(ref);
  }
  public class ProjectStructureSModelDescriptor extends BaseSpecialModelDescriptor {
    private final SModule myModule;
    private ProjectStructureSModelDescriptor(SModelReference ref, SModule module) {
      super(ref);
      myModule = module;
    }
    @Override
    protected ProjectStructureModule.ProjectStructureSModel createModel() {
      final ProjectStructureModule.ProjectStructureSModel model = new ProjectStructureModule.ProjectStructureSModel(getReference());
      final ModuleDescriptor moduleDescriptor = ((AbstractModule) myModule).getModuleDescriptor();
      final IFile file = ((AbstractModule) myModule).getDescriptorFile();
      if (file != null && moduleDescriptor != null) {
        NodeReadAccessCasterInEditor.runReadTransparentAction(new Runnable() {
          @Override
          public void run() {
            new ProjectStructureBuilder(moduleDescriptor, file, model) {
              @Override
              public Iterable<SModelReference> loadReferences(SNode m, ModuleDescriptor descriptor) {
                SModule module = (moduleDescriptor == descriptor ? myModule : ModuleRepositoryFacade.getInstance().getModule(descriptor.getModuleReference()));
                if (module == null) {
                  return Collections.emptyList();
                }
                return Sequence.<SModel>fromIterable(module.getModels()).where(new IWhereFilter<SModel>() {
                  @Override
                  public boolean accept(SModel o) {
                    return SModelStereotype.isUserModel(o);
                  }
                }).select(new ISelector<SModel, SModelReference>() {
                  @Override
                  public SModelReference select(SModel o) {
                    return o.getReference();
                  }
                });
              }
            }.convert();
          }
        });
      }
      return model;
    }
    private void dropModel() {
      if (mySModel == null) {
        return;
      }
      final jetbrains.mps.smodel.SModel oldModel = mySModel;
      mySModel = null;
      replaceModelAndFireEvent(oldModel, null);
    }
  }
  public static class ProjectStructureSModel extends jetbrains.mps.smodel.SModel {
    public ProjectStructureSModel(@NotNull SModelReference modelReference) {
      super(modelReference, new ForeignNodeIdMap());
    }
    @Override
    public boolean canFireEvent() {
      return false;
    }
    @Override
    public FastNodeFinder createFastNodeFinder() {
      return new BaseFastNodeFinder(getModelDescriptor());
    }
  }
}


File: core/kernel/source_gen/jetbrains/mps/smodel/BootstrapLanguages.java
package jetbrains.mps.smodel;

/*Generated by MPS */

import jetbrains.mps.util.annotation.ToRemove;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.project.DevKit;

@Deprecated
@ToRemove(version = 3.3)
public class BootstrapLanguages {
  public static final String ACTIONS_NAMESPACE = "jetbrains.mps.lang.actions";
  public static final String BEHAVIOR_NAMESPACE = "jetbrains.mps.lang.behavior";
  public static final String CONSTRAINTS_NAMESPACE = "jetbrains.mps.lang.constraints";
  public static final String CORE_NAMESPACE = "jetbrains.mps.lang.core";
  public static final String DATA_FLOW_NAMESPACE = "jetbrains.mps.lang.dataFlow";
  public static final String DESCRIPTOR_NAMESPACE = "jetbrains.mps.lang.descriptor";
  public static final String EDITOR_NAMESPACE = "jetbrains.mps.lang.editor";
  public static final String FIND_USAGES_NAMESPACE = "jetbrains.mps.lang.findUsages";
  public static final String PROJECT_NAMESPACE = "jetbrains.mps.lang.project";
  public static final String GENERATOR_NAMESPACE = "jetbrains.mps.lang.generator";
  public static final String GENERATOR_CONTEXT_NAMESPACE = "jetbrains.mps.lang.generator.generationContext";
  public static final String GENERATOR_PARAMETERS_NAMESPACE = "jetbrains.mps.lang.generator.generationParameters";
  public static final String INTENTIONS_NAMESPACE = "jetbrains.mps.lang.intentions";
  public static final String PLUGIN_NAMESPACE = "jetbrains.mps.lang.plugin";
  public static final String MAKE_FACET_NAMESPACE = "jetbrains.mps.make.facet";
  public static final String REFACTORING_NAMESPACE = "jetbrains.mps.lang.refactoring";
  public static final String SCRIPT_NAMESPACE = "jetbrains.mps.lang.script";
  public static final String SHARED_CONCEPTS_NAMESPACE = "jetbrains.mps.lang.sharedConcepts";
  public static final String SMODEL_NAMESPACE = "jetbrains.mps.lang.smodel";
  public static final String STRUCTURE_NAMESPACE = "jetbrains.mps.lang.structure";
  public static final String MIGRATION_NAMESPACE = "jetbrains.mps.lang.migration";
  public static final String TEST_NAMESPACE = "jetbrains.mps.lang.test";
  public static final String TEXT_GEN_NAMESPACE = "jetbrains.mps.lang.textGen";
  public static final String TYPESYSTEM_NAMESPACE = "jetbrains.mps.lang.typesystem";
  public static final String BASE_LANGUAGE_NAMESPACE = "jetbrains.mps.baseLanguage";
  public static final String COLLECTIONS_NAMESPACE = "jetbrains.mps.baseLanguage.collections";
  public static final String CLOSURES_NAMESPACE = "jetbrains.mps.baseLanguage.closures";
  public static final String TUPLES_NAMESPACE = "jetbrains.mps.baseLanguage.tuples";
  public static final String UNITTEST_NAMESPACE = "jetbrains.mps.baseLanguage.unitTest";
  public static final String DEVKIT_GENERAL_NAMESPACE = "jetbrains.mps.devkit.general-purpose";
  public static final String DEVKIT_BOOTSTRAP_NAMESPACE = "jetbrains.mps.devkit.bootstrap-languages";
  public static final String DEVKIT_LANGUAGE_DESIGN_NAMESPACE = "jetbrains.mps.devkit.language-design";
  public static final String JDK_NAMESPACE = "JDK";
  public static final String concept_baseLanguage_Annotation = "jetbrains.mps.baseLanguage.structure.Annotation";
  public static final String concept_baseLanguage_ClassConcept = "jetbrains.mps.baseLanguage.structure.ClassConcept";
  public static final String concept_baseLanguage_EnumClass = "jetbrains.mps.baseLanguage.structure.EnumClass";
  public static final String concept_baseLanguage_Interface = "jetbrains.mps.baseLanguage.structure.Interface";
  public static final String concept_generator_MappingConfiguration = "jetbrains.mps.lang.generator.structure.MappingConfiguration";

  private static final SModuleReference descriptorLanguage = PersistenceFacade.getInstance().createModuleReference("f4ad079d-bc71-4ffb-9600-9328705cf998(jetbrains.mps.lang.descriptor)");
  private static final SModuleReference projectLanguage = PersistenceFacade.getInstance().createModuleReference("86ef8290-12bb-4ca7-947f-093788f263a9(jetbrains.mps.lang.project)");
  private static final SModuleReference coreLanguage = PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)");
  private static final SModuleReference structureLanguage = PersistenceFacade.getInstance().createModuleReference("c72da2b9-7cce-4447-8389-f407dc1158b7(jetbrains.mps.lang.structure)");
  private static final SModuleReference editorLanguage = PersistenceFacade.getInstance().createModuleReference("18bc6592-03a6-4e29-a83a-7ff23bde13ba(jetbrains.mps.lang.editor)");
  private static final SModuleReference actionsLanguage = PersistenceFacade.getInstance().createModuleReference("aee9cad2-acd4-4608-aef2-0004f6a1cdbd(jetbrains.mps.lang.actions)");
  private static final SModuleReference constraintsLanguage = PersistenceFacade.getInstance().createModuleReference("3f4bc5f5-c6c1-4a28-8b10-c83066ffa4a1(jetbrains.mps.lang.constraints)");
  private static final SModuleReference behaviorLanguage = PersistenceFacade.getInstance().createModuleReference("af65afd8-f0dd-4942-87d9-63a55f2a9db1(jetbrains.mps.lang.behavior)");
  private static final SModuleReference typesystemLanguage = PersistenceFacade.getInstance().createModuleReference("7a5dda62-9140-4668-ab76-d5ed1746f2b2(jetbrains.mps.lang.typesystem)");
  private static final SModuleReference baseLanguage = PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)");
  private static final SModuleReference jdkModule = PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)");

  @Deprecated
  private BootstrapLanguages() {
  }
  public static SLanguage getLangCore() {
    return MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL), "jetbrains.mps.lang.core", -1);
  }
  public static Language baseLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"), Language.class);
  }
  public static Language smodelLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("7866978e-a0f0-4cc7-81bc-4d213d9375e1(jetbrains.mps.lang.smodel)"), Language.class);
  }
  public static Language collectionsLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("83888646-71ce-4f1c-9c53-c54016f6ad4f(jetbrains.mps.baseLanguage.collections)"), Language.class);
  }
  public static Language generatorLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("b401a680-8325-4110-8fd3-84331ff25bef(jetbrains.mps.lang.generator)"), Language.class);
  }
  public static Language generatorContextLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("d7706f63-9be2-479c-a3da-ae92af1e64d5(jetbrains.mps.lang.generator.generationContext)"), Language.class);
  }
  public static Language generatorParametersLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("289fcc83-6543-41e8-a5ca-768235715ce4(jetbrains.mps.lang.generator.generationParameters)"), Language.class);
  }
  public static Language coreLanguage() {
    return ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("ceab5195-25ea-4f22-9b92-103b95ca8c0c(jetbrains.mps.lang.core)"), Language.class);
  }
  public static DevKit generalDevKit() {
    return (DevKit) ModuleRepositoryFacade.getInstance().getModule(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }
  public static SModuleReference descriptorLanguageRef() {
    return descriptorLanguage;
  }
  public static SModuleReference projectLanguageRef() {
    return projectLanguage;
  }
  public static SModuleReference coreLanguageRef() {
    return coreLanguage;
  }
  public static SModuleReference structureLanguageRef() {
    return structureLanguage;
  }
  public static SModuleReference editorLanguageRef() {
    return editorLanguage;
  }
  public static SModuleReference actionsLanguageRef() {
    return actionsLanguage;
  }
  public static SModuleReference constraintsLanguageRef() {
    return constraintsLanguage;
  }
  public static SModuleReference behaviorLanguageRef() {
    return behaviorLanguage;
  }
  public static SModuleReference typesystemLanguageRef() {
    return typesystemLanguage;
  }
  public static SModuleReference baseLanguageRef() {
    return baseLanguage;
  }
  public static SModuleReference refactoringLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("3ecd7c84-cde3-45de-886c-135ecc69b742(jetbrains.mps.lang.refactoring)");
  }
  public static SModuleReference scriptLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("0eddeefa-c2d6-4437-bc2c-de50fd4ce470(jetbrains.mps.lang.script)");
  }
  public static SModuleReference intentionsLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("d7a92d38-f7db-40d0-8431-763b0c3c9f20(jetbrains.mps.lang.intentions)");
  }
  public static SModuleReference findUsagesLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("64d34fcd-ad02-4e73-aff8-a581124c2e30(jetbrains.mps.lang.findUsages)");
  }
  public static SModuleReference pluginLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("28f9e497-3b42-4291-aeba-0a1039153ab1(jetbrains.mps.lang.plugin)");
  }
  public static SModuleReference dataFlowLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("7fa12e9c-b949-4976-b4fa-19accbc320b4(jetbrains.mps.lang.dataFlow)");
  }
  public static SModuleReference testLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("8585453e-6bfb-4d80-98de-b16074f1d86c(jetbrains.mps.lang.test)");
  }
  public static SModuleReference textGenLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("b83431fe-5c8f-40bc-8a36-65e25f4dd253(jetbrains.mps.lang.textGen)");
  }
  public static SModuleReference migrationLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("90746344-04fd-4286-97d5-b46ae6a81709(jetbrains.mps.lang.migration)");
  }
  public static SModuleReference unitTestLanguageRef() {
    return PersistenceFacade.getInstance().createModuleReference("f61473f9-130f-42f6-b98d-6c438812c2f6(jetbrains.mps.baseLanguage.unitTest)");
  }
  public static SModuleReference jdkRef() {
    return jdkModule;
  }

}


File: core/migration-runtime/source_gen/jetbrains/mps/lang/migration/runtime/base/MigrationScriptReference.java
package jetbrains.mps.lang.migration.runtime.base;

/*Generated by MPS */

import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;

public class MigrationScriptReference {
  private final SLanguage language;
  private final int fromVersion;
  public MigrationScriptReference(SLanguage language, int fromVersion) {
    this.language = language;
    this.fromVersion = fromVersion;
  }
  public MigrationScriptReference(SLanguage language) {
    this.language = language;
    this.fromVersion = language.getLanguageVersion();
  }
  public SLanguage getLanguage() {
    return language;
  }
  public int getFromVersion() {
    return fromVersion;
  }
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || this.getClass() != o.getClass()) {
      return false;
    }
    MigrationScriptReference that = (MigrationScriptReference) o;
    if (!(language.equals(that.language))) {
      return false;
    }
    if (fromVersion != that.fromVersion) {
      return false;
    }
    return true;
  }
  @Override
  public int hashCode() {
    return language.hashCode() + 31 * fromVersion;
  }
  public String serialize() {
    return IdHelper.getLanguageId(language).serialize() + "(" + language.getQualifiedName() + ")" + "/" + fromVersion;
  }
  public static MigrationScriptReference deserialize(String s) {
    int version = Integer.parseInt(s.substring(s.indexOf('/') + 1));
    int ix = s.indexOf('(');
    SLanguage language = MetaAdapterFactory.getLanguage(SLanguageId.deserialize(s.substring(0, ix)), s.substring(ix + 1, s.indexOf(')', ix)), version);
    return new MigrationScriptReference(language);
  }
}


File: core/openapi/source/org/jetbrains/mps/openapi/language/SLanguage.java
/*
 * Copyright 2003-2012 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jetbrains.mps.openapi.language;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.module.SModuleReference;

/**
 * Reference to a deployed/run-time language.
 * If the specified language is missing in the current MPS instance, only
 * {@link #getQualifiedName() qualified name} is guaranteed to return meaningful value.
 * Besides, {@link #getLanguageVersion()} might be sensible as well, depending on source
 * SLanguage instance comes from (e.g. if it's an used/imported language of a model, then
 * version value indicates actual value at the time import was added/updated).
 * <p>
 * At the moment, equality of instances this class doesn't respect version. This might get changed.
 */
public interface SLanguage {

  /**
   * The namespace of the language.
   */
  @NotNull
  String getQualifiedName();

  /**
   * All concepts defined in the language, empty if the language is invalid (missing).
   */
  Iterable<SAbstractConcept> getConcepts();

  /**
   * All the runtime dependencies that a language needs after generation to run the generated code.
   * These will be resolved from the user repository.
   * Empty sequence in case language is invalid/missing.
   */
  Iterable<SModuleReference> getLanguageRuntimes();

  /**
   * The optional reference to a module containing the sources for the language. This is useful, for example, when showing
   * the definition of a concept for a used language element.
   * It may be null.
   */
  @Nullable
  SModule getSourceModule();

  /**
   * Version of the referenced language.
   * Version is an integer indicating state of a language. It is changed when the structure of this language changes.
   * Typically this means that if some module uses an older version of a language, it should be updated before the user
   * will be able to work with it. E.g. generator can fail on generation of such a model.
   *
   * In MPS 3.2, version is changed only by adding language migrations.
   * @return version of the language, or -1 the version could not be deduced.
   */
  int getLanguageVersion();
}


File: core/persistence/source/jetbrains/mps/persistence/binary/BinaryPersistence.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.persistence.binary;

import jetbrains.mps.extapi.model.GeneratableSModel;
import jetbrains.mps.generator.ModelDigestUtil;
import jetbrains.mps.generator.ModelDigestUtil.DigestBuilderOutputStream;
import jetbrains.mps.persistence.IdHelper;
import jetbrains.mps.persistence.IndexAwareModelFactory.Callback;
import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.MetaModelInfoProvider.BaseMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.RegularMetaModelInfo;
import jetbrains.mps.persistence.MetaModelInfoProvider.StuffedMetaModelInfo;
import jetbrains.mps.persistence.registry.AggregationLinkInfo;
import jetbrains.mps.persistence.registry.AssociationLinkInfo;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.persistence.registry.PropertyInfo;
import jetbrains.mps.smodel.DefaultSModel;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.def.v9.IdInfoCollector;
import jetbrains.mps.smodel.runtime.ConceptKind;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.util.io.ModelInputStream;
import jetbrains.mps.util.io.ModelOutputStream;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.persistence.StreamDataSource;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import static jetbrains.mps.smodel.SModel.ImportElement;

/**
 * @author evgeny, 11/21/12
 * @author Artem Tikhomirov
 */
public final class BinaryPersistence {

  private final MetaModelInfoProvider myMetaInfoProvider;
  private final SModel myModelData;

  public static SModelHeader readHeader(@NotNull StreamDataSource source) throws ModelReadException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(source.openInputStream());
      return loadHeader(mis);
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.getMessage(), e);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  public static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull StreamDataSource source, boolean interfaceOnly) throws ModelReadException {
    final SModelReference desiredModelRef = header.getModelReference();
    try {
      ModelLoadResult rv = loadModel(source.openInputStream(), interfaceOnly, header.getMetaInfoProvider());
      SModelReference actualModelRef = rv.getModel().getReference();
      if (!actualModelRef.equals(desiredModelRef)) {
        throw new ModelReadException(String.format("Intended to read model %s, actually read %s", desiredModelRef, actualModelRef), null, actualModelRef);
      }
      return rv;
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e, desiredModelRef);
    }
  }

  @NotNull
  public static SModel readModel(@NotNull final InputStream content) throws ModelReadException {
    try {
      return loadModel(content, false, null).getModel();
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.toString(), e);
    }
  }

  public static void writeModel(@NotNull SModel model, @NotNull StreamDataSource dataSource) throws IOException {
    if (dataSource.isReadOnly()) {
      throw new IOException(String.format("`%s' is read-only", dataSource.getLocation()));
    }
    writeModel(model, dataSource.openOutputStream());
  }
  public static void writeModel(@NotNull SModel model, @NotNull OutputStream stream) throws IOException {
    ModelOutputStream os = null;
    try {
      os = new ModelOutputStream(stream);
      saveModel(model, os);
    } finally {
      FileUtil.closeFileSafe(os);
    }
  }

  public static Map<String, String> getDigestMap(jetbrains.mps.smodel.SModel model) {
    Map<String, String> result = new LinkedHashMap<String, String>();
    IdInfoRegistry meta = null;
    DigestBuilderOutputStream os = ModelDigestUtil.createDigestBuilderOutputStream();
    try {
      BinaryPersistence bp = new BinaryPersistence(new RegularMetaModelInfo(), model);
      ModelOutputStream mos = new ModelOutputStream(os);
      meta = bp.saveModelProperties(mos);
      mos.flush();
    } catch (IOException ignored) {
      assert false;
      /* should never happen */
    }
    result.put(GeneratableSModel.HEADER, os.getResult());

    assert meta != null;
    // In fact, would be better to translate index attribute of any XXXInfo element into
    // a value not related to meta-element position in the registry. Otherwise, almost any change
    // in a model (e.g. addition of a new root or new property value) might affect all other root hashes
    // as the index of meta-model elements might change. However, as long as our binary models are not exposed
    // for user editing, we don't care.

    for (SNode node : model.getRootNodes()) {
      os = ModelDigestUtil.createDigestBuilderOutputStream();
      try {
        ModelOutputStream mos = new ModelOutputStream(os);
        new NodesWriter(model.getReference(), mos, meta).writeNode(node);
        mos.flush();
      } catch (IOException ignored) {
        assert false;
        /* should never happen */
      }
      SNodeId nodeId = node.getNodeId();
      if (nodeId != null) {
        result.put(nodeId.toString(), os.getResult());
      }
    }

    return result;
  }


  private static final int HEADER_START   = 0x91ABABA9;
  private static final int STREAM_ID_V1   = 0x00000300;
  private static final int STREAM_ID_V2   = 0x00000400;
  private static final int STREAM_ID      = STREAM_ID_V2;
  private static final byte HEADER_ATTRIBUTES = 0x7e;
  private static final int HEADER_END     = 0xabababab;
  private static final int MODEL_START    = 0xbabababa;
  private static final int REGISTRY_START = 0x5a5a5a5a;
  private static final int REGISTRY_END   = 0xa5a5a5a5;
  private static final byte STUB_NONE     = 0x12;
  private static final byte STUB_ID       = 0x13;



  @NotNull
  private static SModelHeader loadHeader(ModelInputStream is) throws IOException {
    if (is.readInt() != HEADER_START) {
      throw new IOException("bad stream, no header");
    }

    int streamId = is.readInt();
    if (streamId == STREAM_ID_V1) {
      throw new IOException(String.format("Can't read old binary persistence version (%x), please re-save models", streamId));
    }
    if (streamId != STREAM_ID) {
      throw new IOException(String.format("bad stream, unknown version: %x", streamId));
    }

    SModelReference modelRef = is.readModelReference();
    SModelHeader result = new SModelHeader();
    result.setModelReference(modelRef);
    is.readInt(); //left for compatibility: old version was here
    is.mark(4);
    if (is.readByte() == HEADER_ATTRIBUTES) {
      result.setDoNotGenerate(is.readBoolean());
      int propsCount = is.readShort();
      for (; propsCount > 0; propsCount--) {
        String key = is.readString();
        String value = is.readString();
        result.setOptionalProperty(key, value);
      }
    } else {
      is.reset();
    }
    assertSyncToken(is, HEADER_END);
    return result;
  }
  @NotNull
  private static ModelLoadResult loadModel(InputStream is, boolean interfaceOnly, @Nullable MetaModelInfoProvider mmiProvider) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(is);
      SModelHeader modelHeader = loadHeader(mis);

      DefaultSModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(mmiProvider == null ? new RegularMetaModelInfo() : mmiProvider, model);
      ReadHelper rh = bp.loadModelProperties(mis);
      rh.requestInterfaceOnly(interfaceOnly);

      NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, rh);
      reader.readNodesInto(model);
      return new ModelLoadResult((SModel) model, reader.hasSkippedNodes() ? ModelLoadingState.INTERFACE_LOADED : ModelLoadingState.FULLY_LOADED);
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void saveModel(SModel model, ModelOutputStream os) throws IOException {
    final MetaModelInfoProvider mmiProvider;
    if (model instanceof DefaultSModel && ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider() != null) {
      mmiProvider = ((DefaultSModel) model).getSModelHeader().getMetaInfoProvider();
    } else {
      mmiProvider = new RegularMetaModelInfo();
    }
    BinaryPersistence bp = new BinaryPersistence(mmiProvider, model);
    IdInfoRegistry meta = bp.saveModelProperties(os);

    Collection<SNode> roots = IterableUtil.asCollection(model.getRootNodes());
    new NodesWriter(model.getReference(), os, meta).writeNodes(roots);
  }

  private BinaryPersistence(@NotNull MetaModelInfoProvider mmiProvider, SModel modelData) {
    myMetaInfoProvider = mmiProvider;
    myModelData = modelData;
  }

  private ReadHelper loadModelProperties(ModelInputStream is) throws IOException {
    final ReadHelper readHelper = loadRegistry(is);

    loadUsedLanguages(is);

    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addEngagedOnGenerationLanguage(ref);
    for (SModuleReference ref : loadModuleRefList(is)) myModelData.addDevKit(ref);

    for (ImportElement imp : loadImports(is)) myModelData.addModelImport(imp);

    assertSyncToken(is, MODEL_START);

    return readHelper;
  }

  private IdInfoRegistry saveModelProperties(ModelOutputStream os) throws IOException {
    // header
    os.writeInt(HEADER_START);
    os.writeInt(STREAM_ID);
    os.writeModelReference(myModelData.getReference());
    os.writeInt(-1);  //old model version
    if (myModelData instanceof DefaultSModel) {
      os.writeByte(HEADER_ATTRIBUTES);
      SModelHeader mh = ((DefaultSModel) myModelData).getSModelHeader();
      os.writeBoolean(mh.isDoNotGenerate());
      Map<String, String> props = new HashMap<String, String>(mh.getOptionalProperties());
      os.writeShort(props.size());
      for (Entry<String, String> e : props.entrySet()) {
        os.writeString(e.getKey());
        os.writeString(e.getValue());
      }
    }
    os.writeInt(HEADER_END);

    final IdInfoRegistry rv = saveRegistry(os);

    //languages
    saveUsedLanguages(os);
    saveModuleRefList(myModelData.engagedOnGenerationLanguages(), os);
    saveModuleRefList(myModelData.importedDevkits(), os);

    // imports
    saveImports(myModelData.importedModels(), os);
    // no need to save implicit imports as we serialize them ad-hoc, the moment we find external reference from a node

    os.writeInt(MODEL_START);
    return rv;
  }

  private IdInfoRegistry saveRegistry(ModelOutputStream os) throws IOException {
    os.writeInt(REGISTRY_START);
    IdInfoRegistry metaInfo = new IdInfoRegistry();
    new IdInfoCollector(metaInfo, myMetaInfoProvider).fill(myModelData.getRootNodes());
    List<LangInfo> languagesInUse = metaInfo.getLanguagesInUse();
    os.writeShort(languagesInUse.size());
    // We use position of an element during persistence as its index, thus don't need to
    // keep the index value - can restore it during read
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;
    for(LangInfo ul : languagesInUse) {
      os.writeUUID(ul.getLanguageId().getIdValue());
      os.writeString(ul.getName());
      ul.setIntIndex(langIndex++);
      //
      List<ConceptInfo> conceptsInUse = ul.getConceptsInUse();
      os.writeShort(conceptsInUse.size());
      for (ConceptInfo ci : conceptsInUse) {
        os.writeLong(ci.getConceptId().getIdValue());
        assert ul.getName().equals(NameUtil.namespaceFromConceptFQName(ci.getName())) : "We save concept short name. This check ensures we can re-construct fqn based on language name";
        os.writeString(ci.getBriefName());
        os.writeByte(ci.getKind().ordinal() << 4 | ci.getScope().ordinal());
        if (ci.isImplementationWithStub()) {
          os.writeByte(STUB_ID);
          os.writeLong(ci.getStubCounterpart().getIdValue());
        } else {
          os.writeByte(STUB_NONE);
        }
        ci.setIntIndex(conceptIndex++);
        //
        List<PropertyInfo> propertiesInUse = ci.getPropertiesInUse();
        os.writeShort(propertiesInUse.size());
        for(PropertyInfo pi : propertiesInUse) {
          os.writeLong(pi.getPropertyId().getIdValue());
          os.writeString(pi.getName());
          pi.setIntIndex(propertyIndex++);
        }
        //
        List<AssociationLinkInfo> associationsInUse = ci.getAssociationsInUse();
        os.writeShort(associationsInUse.size());
        for (AssociationLinkInfo li : associationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          li.setIntIndex(associationIndex++);
        }
        //
        List<AggregationLinkInfo> aggregationsInUse = ci.getAggregationsInUse();
        os.writeShort(aggregationsInUse.size());
        for (AggregationLinkInfo li : aggregationsInUse) {
          os.writeLong(li.getLinkId().getIdValue());
          os.writeString(li.getName());
          os.writeBoolean(li.isUnordered());
          li.setIntIndex(aggregationIndex++);
        }
      }
    }
    os.writeInt(REGISTRY_END);
    return metaInfo;
  }

  private ReadHelper loadRegistry(ModelInputStream is) throws IOException {
    assertSyncToken(is, REGISTRY_START);
    // see #saveRegistry, we use position of an element in persistence as its index
    int langIndex, conceptIndex, propertyIndex, associationIndex, aggregationIndex;
    langIndex = conceptIndex = propertyIndex = associationIndex = aggregationIndex = 0;

    ReadHelper rh = new ReadHelper(myMetaInfoProvider);

    int langCount = is.readShort();
    while (langCount-- > 0) {
      final SLanguageId languageId = new SLanguageId(is.readUUID());
      final String langName = is.readString();
      rh.withLanguage(languageId, langName, langIndex++);
      //
      int conceptCount = is.readShort();
      while (conceptCount-- > 0) {
        final SConceptId conceptId = new SConceptId(languageId, is.readLong());
        final String conceptName = NameUtil.conceptFQNameFromNamespaceAndShortName(langName, is.readString());
        int flags = is.readByte();
        int stubToken = is.readByte();
        final SConceptId stubId;
        if (stubToken == STUB_NONE) {
          stubId = null;
        } else {
          assert stubToken == STUB_ID;
          stubId = new SConceptId(languageId, is.readLong());
        }
        rh.withConcept(conceptId, conceptName, StaticScope.values()[flags & 0x0f], ConceptKind.values()[flags >> 4 & 0x0f], stubId, conceptIndex++);
        //
        int propertyCount = is.readShort();
        while (propertyCount-- > 0) {
          rh.property(new SPropertyId(conceptId, is.readLong()), is.readString(), propertyIndex++);
        }
        //
        int associationCount = is.readShort();
        while (associationCount-- > 0) {
          rh.association(new SReferenceLinkId(conceptId, is.readLong()), is.readString(), associationIndex++);
        }
        //
        int aggregationCount = is.readShort();
        while (aggregationCount-- > 0) {
          rh.aggregation(new SContainmentLinkId(conceptId, is.readLong()), is.readString(), is.readBoolean(), aggregationIndex++);
        }
      }
    }
    assertSyncToken(is, REGISTRY_END);
    return rh;
  }

  private void saveUsedLanguages(ModelOutputStream os) throws IOException {
    Collection<SLanguage> refs = myModelData.usedLanguages();
    os.writeShort(refs.size());
    for (SLanguage l : refs) {
      // id, name, version
      os.writeUUID(IdHelper.getLanguageId(l).getIdValue());
      os.writeString(l.getQualifiedName());
      os.writeInt(l.getLanguageVersion());
    }
  }

  private void loadUsedLanguages(ModelInputStream is) throws IOException {
    int size = is.readShort();
    for (int i = 0; i < size; i++) {
      SLanguageId id = new SLanguageId(is.readUUID());
      String name = is.readString();
      int version = is.readInt();
      SLanguage l = MetaAdapterFactory.getLanguage(id, name, version);
      myModelData.addLanguage(l);
      myMetaInfoProvider.setLanguageName(id, name);
    }
  }

  private static void saveModuleRefList(Collection<SModuleReference> refs, ModelOutputStream os) throws IOException {
    os.writeShort(refs.size());
    for (SModuleReference ref : refs) {
      os.writeModuleReference(ref);
    }
  }

  private static Collection<SModuleReference> loadModuleRefList(ModelInputStream is) throws IOException {
    int size = is.readShort();
    List<SModuleReference> result = new ArrayList<SModuleReference>(size);
    for (int i = 0; i < size; i++) {
      result.add(is.readModuleReference());
    }
    return result;
  }

  private static void saveImports(Collection<ImportElement> elements, ModelOutputStream os) throws IOException {
    os.writeInt(elements.size());
    for (ImportElement element : elements) {
      os.writeModelReference(element.getModelReference());
      os.writeInt(element.getUsedVersion());
    }
  }

  private static List<ImportElement> loadImports(ModelInputStream is) throws IOException {
    int size = is.readInt();
    List<ImportElement> result = new ArrayList<ImportElement>();
    for (int i = 0; i < size; i++) {
      SModelReference ref = is.readModelReference();
      result.add(new ImportElement(ref, -1, is.readInt()));
    }
    return result;
  }

  public static void index(InputStream content, final Callback consumer) throws IOException {
    ModelInputStream mis = null;
    try {
      mis = new ModelInputStream(content);
      SModelHeader modelHeader = loadHeader(mis);
      SModel model = new DefaultSModel(modelHeader.getModelReference(), modelHeader);
      BinaryPersistence bp = new BinaryPersistence(new StuffedMetaModelInfo(new BaseMetaModelInfo()), model);
      final ReadHelper readHelper = bp.loadModelProperties(mis);
      for (ImportElement element : model.importedModels()) {
        consumer.imports(element.getModelReference());
      }
      for (SConceptId cid : readHelper.getParticipatingConcepts()) {
        consumer.instances(cid);
      }
      readHelper.requestInterfaceOnly(false);
      final NodesReader reader = new NodesReader(modelHeader.getModelReference(), mis, readHelper);
      HashSet<SNodeId> externalNodes = new HashSet<SNodeId>();
      HashSet<SNodeId> localNodes = new HashSet<SNodeId>();
      reader.collectExternalTargets(externalNodes);
      reader.collectLocalTargets(localNodes);
      reader.readChildren(null);
      for (SNodeId n : externalNodes) {
        consumer.externalNodeRef(n);
      }
      for (SNodeId n : localNodes) {
        consumer.localNodeRef(n);
      }
    } finally {
      FileUtil.closeFileSafe(mis);
    }
  }

  private static void assertSyncToken(ModelInputStream is, int token) throws IOException {
    if (is.readInt() != token) {
      throw new IOException("bad stream, no sync token");
    }
  }
}


File: core/persistence/source/jetbrains/mps/smodel/persistence/def/v9/IdInfoReadHelper.java
/*
 * Copyright 2003-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package jetbrains.mps.smodel.persistence.def.v9;

import jetbrains.mps.persistence.MetaModelInfoProvider;
import jetbrains.mps.persistence.registry.ConceptInfo;
import jetbrains.mps.persistence.registry.IdInfoRegistry;
import jetbrains.mps.persistence.registry.LangInfo;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import jetbrains.mps.smodel.adapter.ids.SContainmentLinkId;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import jetbrains.mps.smodel.adapter.ids.SPropertyId;
import jetbrains.mps.smodel.adapter.ids.SReferenceLinkId;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.runtime.ConceptKind;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;

import java.util.HashMap;
import java.util.Map;

/**
 * Facility to read meta-model information persisted in a model file, to fill {@link jetbrains.mps.smodel.persistence.def.v9.IdInfoCollector} back from the
 * serialized registry. Serves the task to parametrize ModelReader as well.
 *
 * Although barely a mediator to few other facilities, grabs great portion of code one would otherwise write in ModelReaderHandler.
 *
 * Stateful, withLanguage() identifies language for subsequent withConcept, which, furthermore, identify concept for any
 * subsequent #property(), #association() and #aggregation call.
 */
class IdInfoReadHelper {
  private final IdInfoRegistry myMetaRegistry;
  private final IdEncoder myIdEncoder;
  private final MetaModelInfoProvider myMetaInfoProvider;
  private LangInfo myActualLang;
  private ConceptInfo myActualConcept;
  private final Map<String, SConcept> myConcepts = new HashMap<String, SConcept>();
  private final Map<String, SProperty> myProperties = new HashMap<String, SProperty>();
  private final Map<String, SReferenceLink> myAssociations = new HashMap<String, SReferenceLink>();
  private final Map<String, SContainmentLink> myAggregations = new HashMap<String, SContainmentLink>();
  private final boolean myInterfaceOnly;
  private final boolean myStripImplementation;

  public IdInfoReadHelper(@NotNull MetaModelInfoProvider mmiProvider, boolean interfaceOnly, boolean stripImplementation) {
    myMetaInfoProvider = mmiProvider;
    myIdEncoder = new IdEncoder();
    myMetaRegistry = new IdInfoRegistry();
    myInterfaceOnly = interfaceOnly;
    myStripImplementation = stripImplementation;
  }

  @NotNull
  public IdEncoder getIdEncoder() {
    return myIdEncoder;
  }

  public boolean isRequestedInterfaceOnly() {
    return myInterfaceOnly;
  }

  public boolean isRequestedStripImplementation() {
    return myStripImplementation;
  }

  // Fill methods, populate myInfoCollector with persisted meta-model info

  public void withLanguage(String id, String name) {
    final SLanguageId languageId = myIdEncoder.parseLanguageId(id);
    myActualLang = myMetaRegistry.registerLanguage(languageId, name);
    myMetaInfoProvider.setLanguageName(languageId, name);
  }

  // @param stub is optional
  public void withConcept(String id, String name, String index, String nodeInfo, String stub) {
    assert myActualLang != null;
    SConceptId conceptId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), id);
    myActualConcept = myMetaRegistry.registerConcept(conceptId, name);
    myActualConcept.parseImplementationKind(nodeInfo);
    myConcepts.put(index, MetaAdapterFactory.getConcept(conceptId, name));
    myMetaInfoProvider.setConceptName(conceptId, name);
    myMetaInfoProvider.setKind(conceptId, myActualConcept.getKind());
    myMetaInfoProvider.setScope(conceptId, myActualConcept.getScope());
    if (stub != null) {
      // XXX here we imply stub concepts live in the save language as their origin
      final SConceptId stubId = myIdEncoder.parseConceptId(myActualLang.getLanguageId(), stub);
      myActualConcept.setStubCounterpart(stubId);
      myMetaInfoProvider.setStubConcept(conceptId, stubId);
    }
  }

  public void property(String id, String name, String index) {
    assert myActualConcept != null;
    SPropertyId propertyId = myIdEncoder.parsePropertyId(myActualConcept.getConceptId(), id);
    myActualConcept.addProperty(propertyId, name);
    myProperties.put(index, MetaAdapterFactory.getProperty(propertyId, name));
    myMetaInfoProvider.setPropertyName(propertyId, name);
  }

  public void association(String id, String name, String index) {
    assert myActualConcept != null;
    SReferenceLinkId linkId = myIdEncoder.parseAssociation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name);
    myAssociations.put(index, MetaAdapterFactory.getReferenceLink(linkId, name));
    myMetaInfoProvider.setAssociationName(linkId, name);
  }

  public void aggregation(String id, String name, String index, boolean unordered) {
    assert myActualConcept != null;
    SContainmentLinkId linkId = myIdEncoder.parseAggregation(myActualConcept.getConceptId(), id);
    myActualConcept.addLink(linkId, name, unordered);
    myAggregations.put(index, MetaAdapterFactory.getContainmentLink(linkId, name));
    myMetaInfoProvider.setAggregationName(linkId, name);
    myMetaInfoProvider.setUnordered(linkId, unordered);
  }

  // Query. De-serialize ids, resolve indexes and retrieve meta-objects according to myInfoCollector state

  public SConcept readConcept(@NotNull String index) {
    assert myConcepts.containsKey(index);
    return myConcepts.get(index);
  }

  public SProperty readProperty(@NotNull String index) {
    assert myProperties.containsKey(index);
    return myProperties.get(index);
  }

  public SReferenceLink readAssociation(@NotNull String index) {
    assert myAssociations.containsKey(index);
    return myAssociations.get(index);
  }

  // nullable for root nodes; to minimize code in the sax reader check is done here
  public SContainmentLink readAggregation(@Nullable String index) {
    if (index == null) {
      return null;
    }
    assert myAggregations.containsKey(index);
    return myAggregations.get(index);
  }

  public boolean isInterface(@NotNull SConcept concept) {
    return ConceptKind.INTERFACE == myMetaRegistry.find(concept).getKind();
  }

  public boolean isImplementation(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementation();
  }
  public boolean isImplementationWithStub(@NotNull SConcept concept) {
    return myMetaRegistry.find(concept).isImplementationWithStub();
  }

  /**
   * This method shall be invoked only if {@link #isImplementationWithStub(org.jetbrains.mps.openapi.language.SConcept)} == <code>true</code>
   */
  @NotNull
  public SConcept getStubConcept(@NotNull SConcept original) {
    final ConceptInfo ci = myMetaRegistry.find(original);
    assert ci.getKind() == ConceptKind.IMPLEMENTATION_WITH_STUB;
    final SConceptId stub = ci.getStubCounterpart();
    assert stub != null;
    return MetaAdapterFactory.getConcept(stub, ci.constructStubConceptName());
  }

  public SLanguage getLanguage(@NotNull SLanguageId langId, @NotNull String langName, int version) {
    // used languages is a subset of languages detected for meta-registry, don't want to use
    // set of languages available from myInfoCollector, which might not be yet ready, unless we ensure
    // proper read order (first registry, then used languages). It's even more complicated for per-root
    // persistence, where usedLanguages are kept in a header file only, while registry spans few.
    return MetaAdapterFactory.getLanguage(langId, langName, version);
  }
}


File: core/persistence/source_gen/jetbrains/mps/smodel/persistence/def/v9/ModelReader9Handler.java
package jetbrains.mps.smodel.persistence.def.v9;

/*Generated by MPS */

import jetbrains.mps.util.xml.XMLSAXHandler;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import java.util.Stack;
import org.xml.sax.Locator;
import jetbrains.mps.smodel.SModelHeader;
import jetbrains.mps.smodel.DefaultSModel;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXParseException;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.adapter.ids.SLanguageId;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.smodel.InterfaceSNode;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.util.Pair;

public class ModelReader9Handler extends XMLSAXHandler<ModelLoadResult> {
  private ModelReader9Handler.ModelElementHandler modelHandler = new ModelReader9Handler.ModelElementHandler();
  private ModelReader9Handler.PersistenceElementHandler persistenceHandler = new ModelReader9Handler.PersistenceElementHandler();
  private ModelReader9Handler.Model_attributeElementHandler model_attributeHandler = new ModelReader9Handler.Model_attributeElementHandler();
  private ModelReader9Handler.RegistryElementHandler registryHandler = new ModelReader9Handler.RegistryElementHandler();
  private ModelReader9Handler.Registry_languageElementHandler registry_languageHandler = new ModelReader9Handler.Registry_languageElementHandler();
  private ModelReader9Handler.Registry_conceptElementHandler registry_conceptHandler = new ModelReader9Handler.Registry_conceptElementHandler();
  private ModelReader9Handler.Registry_propertyElementHandler registry_propertyHandler = new ModelReader9Handler.Registry_propertyElementHandler();
  private ModelReader9Handler.Registry_associationElementHandler registry_associationHandler = new ModelReader9Handler.Registry_associationElementHandler();
  private ModelReader9Handler.Registry_aggregationElementHandler registry_aggregationHandler = new ModelReader9Handler.Registry_aggregationElementHandler();
  private ModelReader9Handler.LanguagesElementHandler languagesHandler = new ModelReader9Handler.LanguagesElementHandler();
  private ModelReader9Handler.Used_languageElementHandler used_languageHandler = new ModelReader9Handler.Used_languageElementHandler();
  private ModelReader9Handler.Module_referenceElementHandler module_referenceHandler = new ModelReader9Handler.Module_referenceElementHandler();
  private ModelReader9Handler.ImportsElementHandler importsHandler = new ModelReader9Handler.ImportsElementHandler();
  private ModelReader9Handler.Model_importElementHandler model_importHandler = new ModelReader9Handler.Model_importElementHandler();
  private ModelReader9Handler.NodeElementHandler nodeHandler = new ModelReader9Handler.NodeElementHandler();
  private ModelReader9Handler.PropertyElementHandler propertyHandler = new ModelReader9Handler.PropertyElementHandler();
  private ModelReader9Handler.ReferenceElementHandler referenceHandler = new ModelReader9Handler.ReferenceElementHandler();
  private ModelReader9Handler.IgnoredNodeElementHandler ignoredNodeHandler = new ModelReader9Handler.IgnoredNodeElementHandler();
  private ModelReader9Handler.IgnoredPropertyElementHandler ignoredPropertyHandler = new ModelReader9Handler.IgnoredPropertyElementHandler();
  private ModelReader9Handler.IgnoredReferenceElementHandler ignoredReferenceHandler = new ModelReader9Handler.IgnoredReferenceElementHandler();
  private Stack<ModelReader9Handler.ElementHandler> myHandlersStack = new Stack<ModelReader9Handler.ElementHandler>();
  private Stack<ModelReader9Handler.ChildHandler> myChildHandlersStack = new Stack<ModelReader9Handler.ChildHandler>();
  private Stack<Object> myValues = new Stack<Object>();
  private Locator myLocator;
  private ModelLoadResult myResult;
  private SModelHeader my_headerParam;
  private IdInfoReadHelper my_readHelperParam;
  private DefaultSModel my_modelField;
  private ImportsHelper my_importHelperField;
  private IdEncoder my_idEncoderField;
  public ModelReader9Handler(SModelHeader header, IdInfoReadHelper readHelper) {
    my_headerParam = header;
    my_readHelperParam = readHelper;
  }
  public ModelLoadResult getResult() {
    return myResult;
  }
  @Override
  public void setDocumentLocator(Locator locator) {
    myLocator = locator;
  }
  @Override
  public void characters(char[] array, int start, int len) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current != null) {
      current.handleText(myValues.peek(), new String(array, start, len));
    }
  }
  @Override
  public void endElement(String uri, String localName, String qName) throws SAXException {
    ModelReader9Handler.ElementHandler current = myHandlersStack.pop();
    Object childValue = myValues.pop();
    current.validate(childValue);
    if (myChildHandlersStack.empty()) {
      myResult = (ModelLoadResult) childValue;
    } else {
      ModelReader9Handler.ChildHandler ch = myChildHandlersStack.pop();
      if (ch != null) {
        ch.apply(myValues.peek(), childValue);
      }
    }
  }
  @Override
  public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    ModelReader9Handler.ElementHandler current = (myHandlersStack.empty() ? (ModelReader9Handler.ElementHandler) null : myHandlersStack.peek());
    if (current == null) {
      // root 
      current = modelHandler;
    } else {
      current = current.createChild(myValues.peek(), qName, attributes);
    }

    // check required 
    for (String attr : current.requiredAttributes()) {
      if (attributes.getValue(attr) == null) {
        throw new SAXParseException("attribute " + attr + " is absent", null);
      }
    }

    Object result = current.createObject(attributes);
    if (myHandlersStack.empty()) {
      myResult = (ModelLoadResult) result;
    }

    // handle attributes 
    for (int i = 0; i < attributes.getLength(); i++) {
      String name = attributes.getQName(i);
      String value = attributes.getValue(i);
      current.handleAttribute(result, name, value);
    }
    myHandlersStack.push(current);
    myValues.push(result);
  }
  private static interface ChildHandler {
    public void apply(Object resultObject, Object value) throws SAXException;
  }
  private class ElementHandler {
    private String[] requiredAttributes = new String[0];

    private ElementHandler() {
    }
    protected Object createObject(Attributes attrs) throws SAXException {
      return null;
    }
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
    }
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      throw new SAXParseException("unknown tag: " + tagName, null);
    }
    protected void handleText(Object resultObject, String value) throws SAXException {
      if (value.trim().length() == 0) {
        return;
      }
      throw new SAXParseException("text is not accepted: '" + value + "'", null);
    }
    protected String[] requiredAttributes() {
      return requiredAttributes;
    }
    protected void setRequiredAttributes(String... required) {
      requiredAttributes = required;
    }
    protected void validate(Object resultObject) throws SAXException {
    }
  }
  public class ModelElementHandler extends ModelReader9Handler.ElementHandler {
    public ModelElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected ModelLoadResult createObject(Attributes attrs) throws SAXException {
      my_idEncoderField = my_readHelperParam.getIdEncoder();
      SModelReference ref = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_modelField = new DefaultSModel(ref, my_headerParam);
      my_modelField.getSModelHeader().setPersistenceVersion(9);
      my_importHelperField = new ImportsHelper(ref);
      ModelLoadResult result = new ModelLoadResult((SModel) my_modelField, ModelLoadingState.NOT_LOADED);
      result.setState((my_readHelperParam.isRequestedInterfaceOnly() ? ModelLoadingState.INTERFACE_LOADED : ((my_readHelperParam.isRequestedStripImplementation() ? ModelLoadingState.NO_IMPLEMENTATION : ModelLoadingState.FULLY_LOADED))));
      return result;
    }
    @Override
    protected void handleAttribute(Object resultObject, String name, String value) throws SAXException {
      ModelLoadResult result = (ModelLoadResult) resultObject;
      if ("doNotGenerate".equals(name)) {
        my_modelField.getSModelHeader().setDoNotGenerate(Boolean.parseBoolean(value));
        return;
      }
      if ("content".equals(name)) {
        if ("header".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_HEADER);
        } else if ("root".equals(value)) {
          result.setContentKind(ModelLoadResult.ContentKind.MODEL_ROOT);
        } else {
          throw new SAXException("unknown content attribute value: " + value);
        }
        return;
      }
      super.handleAttribute(resultObject, name, value);
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("node".equals(tagName) && checknode_8237920533349931304(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931271(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_8237920533349931307(resultObject, value);
          }
        });
        return nodeHandler;
      }
      if ("persistence".equals(tagName)) {
        myChildHandlersStack.push(null);
        return persistenceHandler;
      }
      if ("attribute".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_attributeHandler;
      }
      if ("languages".equals(tagName)) {
        myChildHandlersStack.push(null);
        return languagesHandler;
      }
      if ("imports".equals(tagName)) {
        myChildHandlersStack.push(null);
        return importsHandler;
      }
      if ("registry".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registryHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533349931304(Object resultObject, Attributes attrs) {
      return my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    private void handleChild_8237920533349931271(Object resultObject, Object value) throws SAXException {
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SConcept concept = child._1();
      if (my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        my_modelField.addRootNode(new SNode(stubConcept));
      }
    }
    private void handleChild_8237920533349931307(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      my_modelField.addRootNode(child._0());
    }
  }
  public class PersistenceElementHandler extends ModelReader9Handler.ElementHandler {
    public PersistenceElementHandler() {
    }
  }
  public class Model_attributeElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_attributeElementHandler() {
      setRequiredAttributes("name", "value");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_modelField.getSModelHeader().setOptionalProperty(attrs.getValue("name"), attrs.getValue("value"));
      return null;
    }
  }
  public class RegistryElementHandler extends ModelReader9Handler.ElementHandler {
    public RegistryElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("language".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_languageHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_languageElementHandler() {
      setRequiredAttributes("id", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withLanguage(attrs.getValue("id"), attrs.getValue("name"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("concept".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_conceptHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_conceptElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_conceptElementHandler() {
      setRequiredAttributes("id", "name", "index", "flags");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.withConcept(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), attrs.getValue("flags"), attrs.getValue("stub"));
      return null;
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_propertyHandler;
      }
      if ("reference".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_associationHandler;
      }
      if ("child".equals(tagName)) {
        myChildHandlersStack.push(null);
        return registry_aggregationHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Registry_propertyElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_propertyElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.property(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_associationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_associationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.association(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"));
      return null;
    }
  }
  public class Registry_aggregationElementHandler extends ModelReader9Handler.ElementHandler {
    public Registry_aggregationElementHandler() {
      setRequiredAttributes("id", "name", "index");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      my_readHelperParam.aggregation(attrs.getValue("id"), attrs.getValue("name"), attrs.getValue("index"), Boolean.parseBoolean(attrs.getValue("unordered")));
      return null;
    }
  }
  public class LanguagesElementHandler extends ModelReader9Handler.ElementHandler {
    public LanguagesElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("use".equals(tagName)) {
        myChildHandlersStack.push(null);
        return used_languageHandler;
      }
      if ("generationPart".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804036(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      if ("devkit".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804044(resultObject, value);
          }
        });
        return module_referenceHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private void handleChild_5480414999147804036(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addEngagedOnGenerationLanguage(child);
    }
    private void handleChild_5480414999147804044(Object resultObject, Object value) throws SAXException {
      SModuleReference child = (SModuleReference) value;
      my_modelField.addDevKit(child);
    }
  }
  public class Used_languageElementHandler extends ModelReader9Handler.ElementHandler {
    public Used_languageElementHandler() {
      setRequiredAttributes("id", "version", "name");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SLanguageId langId = my_idEncoderField.parseLanguageId(attrs.getValue("id"));
      int langVersion = Integer.parseInt(attrs.getValue("version"));
      my_modelField.addLanguage(my_readHelperParam.getLanguage(langId, attrs.getValue("name"), langVersion));
      return null;
    }
  }
  public class Module_referenceElementHandler extends ModelReader9Handler.ElementHandler {
    public Module_referenceElementHandler() {
      setRequiredAttributes("ref");
    }
    @Override
    protected SModuleReference createObject(Attributes attrs) throws SAXException {
      return my_idEncoderField.parseModuleReference(attrs.getValue("ref"));
    }
  }
  public class ImportsElementHandler extends ModelReader9Handler.ElementHandler {
    public ImportsElementHandler() {
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("import".equals(tagName)) {
        myChildHandlersStack.push(null);
        return model_importHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class Model_importElementHandler extends ModelReader9Handler.ElementHandler {
    public Model_importElementHandler() {
      setRequiredAttributes("index", "ref");
    }
    @Override
    protected Object createObject(Attributes attrs) throws SAXException {
      SModelReference modelRef = my_idEncoderField.parseModelReference(attrs.getValue("ref"));
      my_importHelperField.addModelImport(attrs.getValue("index"), modelRef);
      if (!(Boolean.parseBoolean(attrs.getValue("implicit")))) {
        my_modelField.addModelImport(new SModel.ImportElement(modelRef));
      }
      return null;
    }
  }
  public class NodeElementHandler extends ModelReader9Handler.ElementHandler {
    public NodeElementHandler() {
      setRequiredAttributes("concept", "id");
    }
    @Override
    protected Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> createObject(Attributes attrs) throws SAXException {
      SConcept concept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      boolean interfaceNode = false;
      if (my_readHelperParam.isRequestedInterfaceOnly()) {
        interfaceNode = (my_readHelperParam.isInterface(concept) || attrs.getValue("role") == null);
      }
      SNodeId nodeId;
      try {
        nodeId = my_idEncoderField.parseNodeId(attrs.getValue("id"));
      } catch (IdEncoder.EncodingException e) {
        throw new IllegalArgumentException(e);
      }
      SNode result = (interfaceNode ? new InterfaceSNode(concept, nodeId) : new SNode(concept, nodeId));
      // can be root 
      return MultiTuple.<org.jetbrains.mps.openapi.model.SNode,SContainmentLink>from(((org.jetbrains.mps.openapi.model.SNode) result), my_readHelperParam.readAggregation(attrs.getValue("role")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804176(resultObject, value);
          }
        });
        return propertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_4968492044127349726(resultObject, value);
          }
        });
        return referenceHandler;
      }
      if ("node".equals(tagName) && checknode_8237920533350080210(resultObject, attrs)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804300(resultObject, value);
          }
        });
        return ignoredNodeHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(new ModelReader9Handler.ChildHandler() {
          @Override
          public void apply(Object resultObject, Object value) throws SAXException {
            handleChild_5480414999147804248(resultObject, value);
          }
        });
        return nodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
    private boolean checknode_8237920533350080210(Object resultObject, Attributes attrs) {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      SConcept childConcept = my_readHelperParam.readConcept(attrs.getValue("concept"));
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementation(childConcept)) {
        return true;
      }
      return result._0() instanceof InterfaceSNode && !(my_readHelperParam.isInterface(childConcept));
    }
    private void handleChild_5480414999147804176(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SProperty, String> child = (Tuples._2<SProperty, String>) value;
      result._0().setProperty(child._0(), child._1());
    }
    private void handleChild_4968492044127349726(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._4<SReferenceLink, SModelReference, SNodeId, String> child = (Tuples._4<SReferenceLink, SModelReference, SNodeId, String>) value;
      SModelReference targetModel = child._1();
      SNodeId nodeId = child._2();
      SReferenceLink link = child._0();
      String resolveInfo = child._3();
      StaticReference ref = new StaticReference(link, result._0(), targetModel, nodeId, resolveInfo);
      result._0().setReference(link, ref);
    }
    private void handleChild_5480414999147804300(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<SContainmentLink, SConcept> child = (Tuples._2<SContainmentLink, SConcept>) value;
      SContainmentLink link = child._0();
      SConcept concept = child._1();
      if (my_readHelperParam.isRequestedStripImplementation() && my_readHelperParam.isImplementationWithStub(concept)) {
        SConcept stubConcept = my_readHelperParam.getStubConcept(concept);
        SNode childNode = new SNode(stubConcept);
        result._0().addChild(link, childNode);
        return;
      }
      if (result._0() instanceof InterfaceSNode) {
        ((InterfaceSNode) result._0()).skipRole(link);
      }
    }
    private void handleChild_5480414999147804248(Object resultObject, Object value) throws SAXException {
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> result = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) resultObject;
      Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink> child = (Tuples._2<org.jetbrains.mps.openapi.model.SNode, SContainmentLink>) value;
      result._0().addChild(child._1(), child._0());
    }
  }
  public class PropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public PropertyElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._2<SProperty, String> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SProperty,String>from(my_readHelperParam.readProperty(attrs.getValue("role")), attrs.getValue("value"));
    }
  }
  public class ReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public ReferenceElementHandler() {
      setRequiredAttributes("role");
    }
    @Override
    protected Tuples._4<SReferenceLink, SModelReference, SNodeId, String> createObject(Attributes attrs) throws SAXException {
      SReferenceLink association = my_readHelperParam.readAssociation(attrs.getValue("role"));
      if (attrs.getValue("node") != null) {
        // local reference 
        SNodeId targetNode = my_idEncoderField.parseLocalNodeReference(attrs.getValue("node"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, my_modelField.getReference(), targetNode, attrs.getValue("resolve"));
      } else {
        Pair<SModelReference, SNodeId> r = my_idEncoderField.parseExternalNodeReference(my_importHelperField, attrs.getValue("to"));
        return MultiTuple.<SReferenceLink,SModelReference,SNodeId,String>from(association, r.o1, r.o2, attrs.getValue("resolve"));
      }
    }
  }
  public class IgnoredNodeElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredNodeElementHandler() {
      setRequiredAttributes("concept");
    }
    @Override
    protected Tuples._2<SContainmentLink, SConcept> createObject(Attributes attrs) throws SAXException {
      return MultiTuple.<SContainmentLink,SConcept>from(my_readHelperParam.readAggregation(attrs.getValue("role")), my_readHelperParam.readConcept(attrs.getValue("concept")));
    }
    @Override
    protected ModelReader9Handler.ElementHandler createChild(Object resultObject, String tagName, Attributes attrs) throws SAXException {
      if ("property".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredPropertyHandler;
      }
      if ("ref".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredReferenceHandler;
      }
      if ("node".equals(tagName)) {
        myChildHandlersStack.push(null);
        return ignoredNodeHandler;
      }
      return super.createChild(resultObject, tagName, attrs);
    }
  }
  public class IgnoredPropertyElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredPropertyElementHandler() {
    }
  }
  public class IgnoredReferenceElementHandler extends ModelReader9Handler.ElementHandler {
    public IgnoredReferenceElementHandler() {
    }
  }
}


File: plugins/console/source_gen/jetbrains/mps/console/tool/BaseConsoleTab.java
package jetbrains.mps.console.tool;

/*Generated by MPS */

import javax.swing.JPanel;
import com.intellij.openapi.Disposable;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.openapi.fileEditor.FileEditor;
import jetbrains.mps.nodeEditor.UIEditorComponent;
import jetbrains.mps.nodeEditor.Highlighter;
import jetbrains.mps.nodeEditor.EditorComponent;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import java.util.Collection;
import jetbrains.mps.smodel.SLanguageHierarchy;
import java.util.Collections;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.smodel.tempmodel.TemporaryModels;
import jetbrains.mps.workbench.action.BaseAction;
import com.intellij.openapi.actionSystem.CustomShortcutSet;
import javax.swing.KeyStroke;
import java.awt.event.KeyEvent;
import com.intellij.openapi.actionSystem.ShortcutSet;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NonNls;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.ide.PasteProvider;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import org.apache.log4j.Level;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.workbench.action.ActionUtils;
import com.intellij.openapi.actionSystem.ActionManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.actionSystem.DataContext;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.nodeEditor.datatransfer.NodePaster;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.util.Base64Converter;
import jetbrains.mps.persistence.PersistenceUtil;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.ide.findusages.model.scopes.ProjectScope;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Scanner;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import com.intellij.openapi.actionSystem.MouseShortcut;
import java.awt.event.MouseEvent;
import java.awt.BorderLayout;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.actionSystem.ActionPlaces;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import com.intellij.openapi.wm.IdeFocusManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelUtil_new;

public abstract class BaseConsoleTab extends JPanel implements Disposable {
  protected ConsoleTool myTool;
  protected SModel myModel;
  protected SNode myRoot;
  protected FileEditor myFileEditor;
  protected UIEditorComponent myEditor;
  protected Highlighter myHighlighter;
  protected String myTabTitle;

  public String getTitle() {
    return myTabTitle;
  }

  public SModel getConsoleModel() {
    return myModel;
  }

  public EditorComponent getEditorComponent() {
    return myEditor;
  }

  public SNode getRoot() {
    return myRoot;
  }

  public ConsoleTool getConsoleTool() {
    return myTool;
  }

  protected void addBuiltInImports() {
    SLanguage base = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L), "jetbrains.mps.console.base", -1);
    Collection<SLanguage> baseAndExtensions = new SLanguageHierarchy(Collections.singleton(base)).getExtending();
    SModelInternal modelInternal = ((SModelInternal) myModel);
    for (SLanguage l : CollectionSequence.fromCollection(baseAndExtensions)) {
      modelInternal.addLanguage(l);
      Language sourceLangModule = (Language) l.getSourceModule();
      if (sourceLangModule == null) {
        continue;
      }
      modelInternal.addModelImport(sourceLangModule.getStructureModelDescriptor().getReference(), false);
      ((AbstractModule) myModel.getModule()).addDependency(sourceLangModule.getModuleReference(), false);
    }
    modelInternal.addDevKit(PersistenceFacade.getInstance().createModuleReference("fbc25dd2-5da4-483a-8b19-70928e1b62d7(jetbrains.mps.devkit.general-purpose)"));
  }

  protected void validateImports() {
    SModelInternal modelInternal = (SModelInternal) myModel;
    for (SModuleReference devKit : ListSequence.fromListWithValues(new ArrayList<SModuleReference>(), modelInternal.importedDevkits())) {
      modelInternal.deleteDevKit(devKit);
    }
    for (SLanguage language : ListSequence.fromListWithValues(new ArrayList<SLanguage>(), modelInternal.importedLanguageIds())) {
      modelInternal.deleteLanguageId(language);
    }
    for (jetbrains.mps.smodel.SModel.ImportElement model : ListSequence.fromListWithValues(new ArrayList<jetbrains.mps.smodel.SModel.ImportElement>(), modelInternal.importedModels())) {
      modelInternal.deleteModelImport(model.getModelReference());
    }
    addBuiltInImports();
    TemporaryModels.getInstance().addMissingImports(myModel);
  }

  protected BaseAction registerKeyShortcut(BaseAction a, int key) {
    return registerShortcutSet(a, new CustomShortcutSet(KeyStroke.getKeyStroke(key, KeyEvent.CTRL_MASK)));
  }

  protected BaseAction registerShortcutSet(BaseAction a, ShortcutSet shortcutSet) {
    a.registerCustomShortcutSet(shortcutSet, myEditor);
    return a;
  }

  protected void createEditor() {
    this.myEditor = new UIEditorComponent(check_6q36mf_a0a0a0a62(ProjectHelper.toMPSProject(myTool.getProject())), null) {
      @Nullable
      @Override
      public Object getData(@NonNls String key) {
        if (PlatformDataKeys.FILE_EDITOR.is(key)) {
          return myFileEditor;
        }
        if (PlatformDataKeys.PASTE_PROVIDER.is(key)) {
          PasteProvider parentPasteProvider = as_6q36mf_a0a0a1a0a0a0a0ab(super.getData(key), PasteProvider.class);
          return (myTool.getPasteAsRef() ? new BaseConsoleTab.MyPasteProvider(parentPasteProvider) : parentPasteProvider);
        }
        return super.getData(key);
      }
    };
    myEditor.editNode(myRoot);
  }


  protected void createConsoleModel() {
    this.myModel = TemporaryModels.getInstance().create(false, TempModuleOptions.forDefaultModuleWithSourceAndClassesGen());
    if (myModel == null) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Error: could not create console model");
      }
      return;
    }
  }

  public void dispose() {
    disposeConsoleTab();
  }

  public void disposeConsoleTab() {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        if (myEditor != null) {
          myEditor.dispose();
        }
        TemporaryModels.getInstance().dispose(myModel);
      }
    });
    myHighlighter.removeAdditionalEditorComponent(myEditor);
  }

  protected class ExecuteClosureAction extends BaseAction {
    public ExecuteClosureAction() {
      super("Execute Closure");
    }
    protected void doExecute(AnActionEvent event, Map<String, Object> map) {
      ActionUtils.updateAndPerformAction(((BaseAction) ActionManager.getInstance().getAction("jetbrains.mps.console.actions.ExecuteActionAttachedToCurrentNode_Action")), event);
    }
  }

  public class MyPasteProvider implements PasteProvider {

    private PasteProvider myDefaultPasteProvider;

    public MyPasteProvider(PasteProvider defaultPasteProvider) {
      myDefaultPasteProvider = defaultPasteProvider;
    }

    public void performPaste(@NotNull final DataContext context) {
      getProject().getModelAccess().executeCommand(new Runnable() {
        public void run() {
          SNodeReference pastingNodeReference = null;
          try {
            for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
              if (trf != null && trf.isDataFlavorSupported(SModelDataFlavor.sNodeReference)) {
                pastingNodeReference = (SNodeReference) trf.getTransferData(SModelDataFlavor.sNodeReference);
              }
              break;
            }
          } catch (UnsupportedFlavorException ignored) {
          } catch (IOException ignored) {
          }
          EditorCell currentCell = myEditor.getSelectedCell();
          SRepository repository = getProject().getRepository();
          SNode referenceTarget = check_6q36mf_a0e0a0a0a5lb(pastingNodeReference, repository);
          if (referenceTarget != null && currentCell != null && !(check_6q36mf_a0a5a0a0a0f73(check_6q36mf_a0a0f0a0a0a5lb(pastingNodeReference), myModel))) {
            SNode refContainer = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x51132a123c89fa7eL, "jetbrains.mps.console.base.structure.PastedNodeReference")));
            SLinkOperations.setTarget(refContainer, MetaAdapterFactory.getReferenceLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x36ac6f29ae8c1fb5L, 0x4904fd89e74fc6fL, "target"), referenceTarget);
            NodePaster paster = new NodePaster(ListSequence.fromListAndArray(new ArrayList<SNode>(), refContainer));
            if (paster.canPaste(currentCell)) {
              paster.paste(currentCell);
            } else if (paster.canPasteWithRemove(myEditor.getSelectedNodes())) {
              paster.pasteWithRemove(myEditor.getSelectedNodes());
            }
            TemporaryModels.getInstance().addMissingImports(myModel);
          } else {
            check_6q36mf_a0a0f0a0a0a5lb_0(myDefaultPasteProvider, context);
          }
        }
      });
    }
    public boolean isPastePossible(@NotNull DataContext context) {
      return true;
    }
    public boolean isPasteEnabled(@NotNull DataContext context) {
      return true;
    }
  }

  protected abstract void loadHistory(String state);

  @Nullable
  public String saveHistory() {
    final Wrappers._T<String> result = new Wrappers._T<String>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          result.value = (myModel == null ? null : Base64Converter.encode(PersistenceUtil.saveBinaryModel(myModel)));
        } catch (Exception e) {
          if (LOG.isEnabledFor(Level.WARN)) {
            LOG.warn("Error on console model saving", e);
          }
        }
      }
    });
    return result.value;
  }

  protected ConsoleContext getConsoleContext() {
    return new ConsoleContext() {
      public Project getProject() {
        return ProjectHelper.toMPSProject(myTool.getProject());
      }
      public SearchScope getDefaultSearchscope() {
        return new ProjectScope(getProject());
      }
      public BaseConsoleTab getConsoleTab() {
        return BaseConsoleTab.this;
      }
    };
  }

  protected SNode getLastReponse() {
    SNode last = SNodeOperations.as(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).last(), MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response"));
    if (last != null) {
      return last;
    }
    return SLinkOperations.addNewChild(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, "jetbrains.mps.console.base.structure.Response")));
  }

  protected void addNodeImports(SNode node) {
    final SModelInternal modelInternal = (SModelInternal) myModel;
    final AbstractModule module = ((AbstractModule) myModel.getModule());
    final Collection<SLanguage> importedLanguages = modelInternal.importedLanguageIds();
    for (SNode subNode : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, true, new SAbstractConcept[]{}))) {
      SLanguage usedLanguage = subNode.getConcept().getLanguage();
      if (!(importedLanguages.contains(usedLanguage))) {
        modelInternal.addLanguage(usedLanguage);
      }
      for (SReference ref : Sequence.fromIterable(SNodeOperations.getReferences(subNode))) {
        SModel usedModel = SNodeOperations.getModel(SLinkOperations.getTargetNode(ref));
        if (usedModel != null && !(modelInternal.importedModels().contains(usedModel))) {
          modelInternal.addModelImport(usedModel.getReference(), false);
          module.addDependency(SNodeOperations.getModel(SLinkOperations.getTargetNode(ref)).getModule().getModuleReference(), false);
        }
      }
    }
  }

  public ConsoleStream getConsoleStream() {
    return new ConsoleStream() {
      public void addText(String text) {
        Scanner scanner = new Scanner(text);
        while (scanner.hasNextLine()) {
          String line = scanner.nextLine();
          if ((line != null && line.length() > 0)) {
            ListSequence.fromList(SLinkOperations.getChildren(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"))).addElement(createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(line));
          }
          if (scanner.hasNextLine() || text.charAt(text.length() - 1) == '\n') {
            SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35d30L, "jetbrains.mps.console.base.structure.NewLineResponseItem")));
          }
        }
      }
      public void addNode(SNode node) {
        addNodeImports(node);
        SLinkOperations.setTarget(SLinkOperations.addNewChild(getLastReponse(), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171a5ba02L, 0x4e3b035171b356edL, "item"), SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, "jetbrains.mps.console.base.structure.NodeResponseItem"))), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c14L, 0x4e3b035171b35c15L, "node"), node);
      }
    };
  }


  public BaseConsoleTab(ConsoleTool tool, String title, @Nullable String history) {
    myTool = tool;
    myTabTitle = title;
    initConsoleTab(history);
  }

  protected void registerActions(DefaultActionGroup group) {
    registerShortcutSet(new BaseConsoleTab.ExecuteClosureAction(), new CustomShortcutSet(new MouseShortcut(MouseEvent.BUTTON1, 0, 1)));
  }

  @NotNull
  private Project getProject() {
    Project mpsProject = ProjectHelper.toMPSProject(this.getConsoleTool().getProject());
    if (mpsProject == null) {
      throw new IllegalStateException("Cannot convert idea project to the mps project");
    }
    return mpsProject;
  }

  protected void initConsoleTab(@Nullable final String history) {
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        createConsoleModel();
        addBuiltInImports();
        loadHistory(history);
        createEditor();
        myFileEditor = new ConsoleFileEditor(myEditor);
      }
    });

    this.setLayout(new BorderLayout());


    DefaultActionGroup group = new DefaultActionGroup();
    registerActions(group);
    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, false);
    JPanel toolbarComponent = new JPanel(new BorderLayout());
    toolbarComponent.add(toolbar.getComponent(), BorderLayout.CENTER);

    this.add(toolbarComponent, BorderLayout.WEST);
    this.add(myEditor.getExternalComponent(), BorderLayout.CENTER);

    myHighlighter = check_6q36mf_a0o0gc(myTool.getProject());
    myHighlighter.addAdditionalEditorComponent(myEditor);
  }

  public void execute(@Nullable final SNode command, @Nullable final Runnable executeBefore, @Nullable final Runnable executeAfter) {
    myTool.selectTab(this);
    final SNode[] typedCommand = new SNode[1];
    getProject().getModelAccess().executeCommand(new Runnable() {
      public void run() {
        typedCommand[0] = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, "jetbrains.mps.console.base.structure.CommandHolder")));
        if (command != null) {
          addNodeImports(command);
          SLinkOperations.setTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"))));
          SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SNodeOperations.copyNode(command));
        }
      }
    });
    BehaviorReflection.invokeVirtual(Void.class, SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")), "virtual_execute_6854397602732226506", new Object[]{getConsoleContext(), getConsoleStream(), new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bafL, "history")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0xa835f28c1aa02beL, 0x63da33792b5df49aL, "item"))).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder"))));
            SNodeOperations.deleteNode(SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a2a0a0a0a0a2a0d0ic(executeBefore);
          }
        });
      }
    }, new Runnable() {
      public void run() {
        getProject().getModelAccess().executeCommand(new Runnable() {
          public void run() {
            SLinkOperations.setTarget(SLinkOperations.getTarget(myRoot, MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x15fb34051f725a2cL, 0x15fb34051f725bb1L, "commandHolder")), MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command"), SLinkOperations.getTarget(typedCommand[0], MetaAdapterFactory.getContainmentLink(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e27160acb4484bL, 0x4e27160acb44924L, "command")));
            check_6q36mf_a1a0a0a0a0a3a0d0ic(executeAfter);
          }
        });
      }
    }});
  }

  public void selectNode(final SNode nodeToSelect) {
    myTool.getToolWindow().activate(new Runnable() {
      public void run() {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myEditor.selectNode(nodeToSelect);
            getEditorComponent().ensureSelectionVisible();
            IdeFocusManager.getInstance(myTool.getProject()).requestFocus(myEditor, false);
          }
        });
      }
    });
    myTool.selectTab(this);
  }

  protected SModel loadHistoryModel(String state) {
    if (state != null) {
      try {
        final Wrappers._T<SModel> loadedModel = new Wrappers._T<SModel>(PersistenceUtil.loadBinaryModel(Base64Converter.decode(state.getBytes())));
        ListSequence.fromList(SModelOperations.nodes(loadedModel.value, null)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(it.getConcept().isValid());
          }
        }).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            if ((SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false) != null)) {
              SNodeOperations.deleteNode(SNodeOperations.getNodeAncestor(it, MetaAdapterFactory.getInterfaceConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x5f195a051bd47defL, "jetbrains.mps.console.base.structure.HistoryItem"), false, false));
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: removing enclosing history item");
              }
            } else {
              loadedModel.value = null;
              if (LOG.isEnabledFor(Level.ERROR)) {
                LOG.error("Unknown concept on loading console history: not loading history");
              }
            }
          }
        });
        return loadedModel.value;
      } catch (RuntimeException e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Console history was not loaded. Maybe you are opening project from previous MPS versions?");
        }
      } catch (Throwable e) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Error on loading console history.", e);
        }
      }
    }
    return null;
  }

  protected static Logger LOG = LogManager.getLogger(BaseConsoleTab.class);
  private static SRepository check_6q36mf_a0a0a0a62(Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRepository();
    }
    return null;
  }
  private static SNode check_6q36mf_a0e0a0a0a5lb(SNodeReference checkedDotOperand, SRepository repository) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.resolve(repository);
    }
    return null;
  }
  private static boolean check_6q36mf_a0a5a0a0a0f73(SModelReference checkedDotOperand, SModel myModel) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.equals(myModel.getReference());
    }
    return false;
  }
  private static SModelReference check_6q36mf_a0a0f0a0a0a5lb(SNodeReference checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelReference();
    }
    return null;
  }
  private static void check_6q36mf_a0a0f0a0a0a5lb_0(PasteProvider checkedDotOperand, DataContext context) {
    if (null != checkedDotOperand) {
      checkedDotOperand.performPaste(context);
    }

  }
  private static SNode createTextResponseItem_6q36mf_a0a0a1a1a0a0a0a94(Object p0) {
    PersistenceFacade facade = PersistenceFacade.getInstance();
    SNode n1 = SModelUtil_new.instantiateConceptDeclaration(MetaAdapterFactory.getConcept(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, "jetbrains.mps.console.base.structure.TextResponseItem"), null, null, false);
    n1.setProperty(MetaAdapterFactory.getProperty(0xde1ad86d6e504a02L, 0xb306d4d17f64c375L, 0x4e3b035171b35c38L, 0x4e3b035171b35d11L, "text"), String.valueOf(p0));
    return n1;
  }
  private static Highlighter check_6q36mf_a0o0gc(com.intellij.openapi.project.Project checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getComponent(Highlighter.class);
    }
    return null;
  }
  private static void check_6q36mf_a2a0a0a0a0a2a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static void check_6q36mf_a1a0a0a0a0a3a0d0ic(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
  private static <T> T as_6q36mf_a0a0a1a0a0a0a0ab(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}


File: plugins/debugger-java/runtime/source_gen/jetbrains/mps/debugger/java/runtime/evaluation/model/EvaluationWithContextContainer.java
package jetbrains.mps.debugger.java.runtime.evaluation.model;

/*Generated by MPS */

import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationContainer;
import jetbrains.mps.project.Project;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SModuleReference;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.debugger.java.runtime.evaluation.container.IEvaluationContainer;
import jetbrains.mps.debugger.java.runtime.evaluation.container.EvaluationModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.debugger.java.runtime.evaluation.container.BaseLanguagesImportHelper;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.sun.jdi.InvalidStackFrameException;
import org.apache.log4j.Level;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.ide.findusages.model.scopes.ModelsScope;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.smodel.SModelStereotype;
import java.util.ArrayList;
import jetbrains.mps.smodel.CopyUtil;
import com.intellij.openapi.extensions.PluginId;
import com.intellij.ide.plugins.PluginManager;
import jetbrains.mps.debug.api.Debuggers;
import jetbrains.mps.debugger.java.runtime.JavaDebugger;
import java.io.File;
import com.intellij.ide.plugins.IdeaPluginDescriptorImpl;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SNodePointer;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class EvaluationWithContextContainer extends EvaluationContainer {
  private final boolean myIsInWatch;
  private boolean myVariablesInitialized = false;
  protected final EvaluationContext myEvaluationContext;
  public EvaluationWithContextContainer(Project project, DebugSession session, @NotNull SModuleReference containerModule, List<SNodeReference> nodesToImport, boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    super(project, session, containerModule, nodesToImport, onNodeSetUp);
    myIsInWatch = isInWatch;
    myEvaluationContext = new StackFrameContext(session.getUiState());
  }

  @Override
  protected void setUpNode(List<SNodeReference> nodesToImport) {
    EvaluationModule containerModule = (EvaluationModule) myContainerModule.resolve(myDebuggerRepository);
    // wanted to use resolve method here, but it was not implemented:( 
    SModel containerModel = SModelRepository.getInstance().getModelDescriptor(myContainerModel);

    setUpDependencies(containerModule, containerModel);


    final SNode evaluatorNode = createEvaluatorNode();
    containerModel.addRootNode(evaluatorNode);
    myNode = evaluatorNode.getReference();

    createVars();
    tryToImport(evaluatorNode, nodesToImport);

    SModelOperations.validateLanguagesAndImports(containerModel, true, true);
  }
  private void setUpDependencies(final EvaluationModule containerModule, SModel containerModel) {
    ListSequence.fromList(myEvaluationContext.getClassPath()).union(ListSequence.fromList(getDebuggerStubPath())).visitAll(new IVisitor<String>() {
      public void visit(String it) {
        containerModule.addClassPathItem(it);
      }
    });
    containerModule.updateModelsSet();

    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x7da4580f9d754603L, 0x816251a896d78375L), "jetbrains.mps.debugger.java.evaluation", -1));
    ((SModelInternal) containerModel).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0x802088974572437dL, 0xb50e8f050cba9566L), "jetbrains.mps.debugger.java.privateMembers", -1));
    containerModule.addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);
  }
  private void tryToImport(final SNode evaluatorNode, List<SNodeReference> nodesToImport) {
    BaseLanguagesImportHelper helper = new EvaluationWithContextContainer.MyBaseLanguagesImportHelper(evaluatorNode);
    helper.tryToImport(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), evaluatorNode, "virtual_getCode_317191294093624551", new Object[]{}), nodesToImport);
  }
  @Override
  protected SNode createEvaluatorNode() {
    SNode evaluatorConcept = SNodeFactoryOperations.createNewNode(SNodeFactoryOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")), null);
    SPropertyOperations.set(evaluatorConcept, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (myIsInWatch));
    AttributeOperations.createAndSetAttrbiute(SLinkOperations.getTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x10093bb8b0669700L, "evaluatedStatements")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x4135c73fbe7fc985L, "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation")), "jetbrains.mps.debugger.java.evaluation.structure.ToEvaluateAnnotation");
    return evaluatorConcept;
  }
  private void createVars() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        fillVariables(SNodeOperations.cast(getNode(), MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, "jetbrains.mps.debugger.java.evaluation.structure.EvaluatorConcept")));
      }
    });
  }
  private void fillVariables(SNode evaluatorConcept) {
    try {
      _FunctionTypes._return_P1_E0<? extends SNode, ? super String> createClassifierType = new _FunctionTypes._return_P1_E0<SNode, String>() {
        public SNode invoke(String name) {
          return createClassifierType(name);
        }
      };
      Map<String, VariableDescription> contextVariables = myEvaluationContext.getVariables(createClassifierType);

      Map<String, SNode> declaredVariables = MapSequence.fromMap(new LinkedHashMap<String, SNode>(16, (float) 0.75, false));
      for (SNode var : ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables")))) {
        MapSequence.fromMap(declaredVariables).put(SPropertyOperations.getString(var, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x4db8c07036eb94eeL, "lowLevelName")), var);
      }

      final Set<SNode> foundVars = SetSequence.fromSet(new HashSet<SNode>());
      for (String variable : MapSequence.fromMap(contextVariables).keySet()) {

        String name = variable;
        SNode lowLevelVarNode = MapSequence.fromMap(declaredVariables).get(name);

        if (needUpdateVariables()) {
          // we should update variables if we are first time here or if we do not show context (i.e. in evaluation) 
          if (lowLevelVarNode == null) {
            lowLevelVarNode = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariable")));
            ListSequence.fromList(SLinkOperations.getChildren(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).addElement(lowLevelVarNode);
            MapSequence.fromMap(declaredVariables).put(name, lowLevelVarNode);
          }
          MapSequence.fromMap(contextVariables).get(variable).updateLowLevelVariable(lowLevelVarNode);
        }

        SetSequence.fromSet(foundVars).addElement(lowLevelVarNode);
      }

      // now mark vars which are currently out of scope 
      Sequence.fromIterable(MapSequence.fromMap(declaredVariables).values()).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SPropertyOperations.set(it, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x554b4e03d5950431L, "isOutOfScope"), "" + (!(SetSequence.fromSet(foundVars).contains(it))));
        }
      });

      if (needUpdateVariables()) {
        // create static context type 
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23615L, "contextNode"), myEvaluationContext.getStaticContextType(createClassifierType));
        // create this 
        SLinkOperations.setTarget(evaluatorConcept, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x3f11b1341fa23613L, "thisNode"), myEvaluationContext.getThisClassifierType(createClassifierType));
      }
      // todo highlight when this type or static context type are invalid 
    } catch (InvalidStackFrameException e) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("InvalidStackFrameException", e);
      }
    }
    myVariablesInitialized = true;
  }

  @Override
  public void updateState() {
    super.updateState();
    if (myDebugSession.getEvaluationProvider().canEvaluate()) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          createVars();
        }
      });
    }
  }
  @Nullable
  private SNode createClassifierType(final String unitFqName) {
    SNode unit = findUnit(unitFqName);
    if (unit == null) {
      return null;
    }
    SNode classifierType = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")));
    SLinkOperations.setTarget(classifierType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"), SNodeOperations.cast(unit, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
    return classifierType;
  }
  public SNode findUnit(final String unitName) {
    // I hate the next piece of code 
    // (and this class in general, since it inherited a lot of the ugly stuff from the old evaluation code) 
    SModel stub = findStubForFqName(modelFqNameFromUnitName(unitName));
    if (stub != null) {
      SModel model = stub;
      SNode node = ListSequence.fromList(jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations.nodes(model, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return eq_v5yv3u_a0a0a0a0a0a0b0d0o(BehaviorReflection.invokeVirtual(String.class, it, "virtual_getUnitName_5067982036267369911", new Object[]{}), unitName) && SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"));
        }
      });
      if (node != null) {
        return node;
      }
    }

    FindUsagesFacade findUsages = FindUsagesFacade.getInstance();
    SAbstractConcept concept = MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept");

    Set<SNode> instances = findUsages.findInstances(new ModelsScope(getCandidateNonStubModels(unitName)), Collections.singleton(concept), false, new EmptyProgressMonitor());
    return SNodeOperations.cast(SetSequence.fromSet(instances).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(((SNode) it), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) && BehaviorReflection.invokeVirtual(String.class, SNodeOperations.cast(it, MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept")), "virtual_getUnitName_5067982036267369911", new Object[]{}).equals(unitName);
      }
    }), MetaAdapterFactory.getInterfaceConcept(0x9ded098bad6a4657L, 0xbfd948636cfe8bc3L, 0x465516cf87c705a4L, "jetbrains.mps.lang.traceable.structure.UnitConcept"));
  }
  @Nullable
  private SModel findStubForFqName(String fqName) {
    return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(fqName, SModelStereotype.JAVA_STUB));
  }
  private boolean needUpdateVariables() {
    return !(myVariablesInitialized) || !(myIsInWatch);
  }
  @Override
  public EvaluationWithContextContainer copy(final boolean isInWatch, _FunctionTypes._void_P1_E0<? super IEvaluationContainer> onNodeSetUp) {
    final SNodeReference reference = myNode;
    return new EvaluationWithContextContainer(myProject, myDebugSession, myContainerModule, ListSequence.fromList(new ArrayList<SNodeReference>()), isInWatch, onNodeSetUp) {
      @Override
      protected SNode createEvaluatorNode() {
        SNode newEvaluator = (SNode) CopyUtil.copyAndPreserveId(reference.resolve(myDebuggerRepository), true);
        SPropertyOperations.set(newEvaluator, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c79bL, "isShowContext"), "" + (isInWatch));
        return newEvaluator;
      }
    };
  }
  public static List<String> getDebuggerStubPath() {
    PluginId apiPlugin = PluginManager.getPluginByClassName(Debuggers.class.getName());
    PluginId javaPlugin = PluginManager.getPluginByClassName(JavaDebugger.class.getName());

    List<File> paths = ListSequence.fromList(new ArrayList<File>());
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(apiPlugin)).getClassPath()));
    ListSequence.fromList(paths).addSequence(ListSequence.fromList(((IdeaPluginDescriptorImpl) PluginManager.getPlugin(javaPlugin)).getClassPath()));

    return ListSequence.fromList(paths).select(new ISelector<File, String>() {
      public String select(File it) {
        return (String) it.getAbsolutePath();
      }
    }).toListSequence();
  }
  public static Iterable<SModel> getCandidateNonStubModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(SModelStereotype.withStereotype(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }
  public static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ? "" : unitName.substring(0, lastDot)));
  }
  private class MyBaseLanguagesImportHelper extends BaseLanguagesImportHelper {
    private final SNode myEvaluatorNode;
    public MyBaseLanguagesImportHelper(SNode evaluatorNode) {
      myEvaluatorNode = evaluatorNode;
    }
    @Override
    public SNode findVariable(final SReference variableReference) {
      SNode matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
        public boolean accept(SNode variable) {
          return eq_v5yv3u_a0a0a0a0a0a0a2v(SNodePointer.deserialize(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d926L, 0x6db8b4aef007e84fL, "highLevelNodeId"))), SLinkOperations.getTargetNode(variableReference).getReference());
        }
      });
      if (matchingVar == null) {
        matchingVar = ListSequence.fromList(SLinkOperations.getChildren(myEvaluatorNode, MetaAdapterFactory.getContainmentLink(0x7da4580f9d754603L, 0x816251a896d78375L, 0x53c5060c6b18d925L, 0x53c5060c6b19c797L, "variables"))).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode variable) {
            return eq_v5yv3u_a0a0a0a0a0a0a1a2v(SPropertyOperations.getString(variable, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")), SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTargetNode(variableReference), MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }
        });
      }
      return matchingVar;
    }
    @Override
    public SNode createVariableReference(SNode variable) {
      SNode newVariableReference = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0x7da4580f9d754603L, 0x816251a896d78375L, 0x7d9a547f857a394bL, "jetbrains.mps.debugger.java.evaluation.structure.LowLevelVariableReference")));
      SLinkOperations.setTarget(newVariableReference, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x4c4b92003e49a704L, 0x4c4b92003e49a705L, "baseVariableDeclaration"), variable);
      return newVariableReference;
    }
  }
  protected static Logger LOG = LogManager.getLogger(EvaluationWithContextContainer.class);
  private static boolean eq_v5yv3u_a0a0a0a0a0a0b0d0o(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
  private static boolean eq_v5yv3u_a0a0a0a0a0a0a1a2v(Object a, Object b) {
    return (a != null ? a.equals(b) : a == b);
  }
}


File: plugins/migrationAssistant/solutions/component/source_gen/jetbrains/mps/migration/component/util/MigrationComponent.java
package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;
import java.util.Map;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;
import javax.swing.SwingUtilities;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.ArrayList;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + BehaviorReflection.invokeNonVirtualStatic(String.class, SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L, "jetbrains.mps.lang.migration.structure.MigrationScript").getDeclarationNode()), "call_getGeneratedClassName_8648538385393994830", new Object[]{});
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchScript(MigrationScriptReference scriptReference) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0u(md, current);
    if (script == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static boolean areDepsSatisfied(final ScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        result.value = isMigrationRequired(mpsProject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean languageMig = isLanguageMigrationRequired(modules);
    return projectMig || languageMig;
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (fetchScript(new MigrationScriptReference(lang, v)) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule,SLanguage,Integer>from(module, lang, v));
                // next used language, please 
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isLanguageMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
      public boolean accept(final AbstractModule module) {
        return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
          public boolean accept(MigrationScriptReference item) {
            return MigrationsUtil.isMigrationNeeded(item.getLanguage(), item.getFromVersion(), module);
          }
        });
      }
    });
  }

  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    final SLanguage toLanguage = MetaAdapterFactory.getLanguage(fromLanguage, toVersion);
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(fromLanguage);
      ((SModelInternal) model).addLanguage(toLanguage);
    }

    return true;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }
      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(mpsProject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int languageStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(new ISelector<AbstractModule, Integer>() {
          public Integer select(AbstractModule module) {
            int scripts = 0;
            for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
              int currentLangVersion = lang.getLanguageVersion();
              int ver = module.getUsedLanguageVersion(lang);

              ver = Math.max(ver, 0);
              currentLangVersion = Math.max(currentLangVersion, 0);

              if (ver < currentLangVersion) {
                scripts += currentLangVersion - ver;
              }
            }
            return scripts;
          }
        });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextLanguageStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());

        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
          public boolean accept(final AbstractModule module) {
            return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
              public boolean accept(MigrationScriptReference it) {
                if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {
                  return false;
                }
                MigrationScript loaded = fetchScript(it);
                if (loaded == null) {
                  return false;
                }
                final ScriptApplied applied = new ScriptApplied(loaded, module);
                if (!(areDepsSatisfied(applied))) {
                  return false;
                }
                result.value = new MigrationManager.MigrationStep() {
                  public String getDescription() {
                    return applied.toString();
                  }
                  public boolean execute() {
                    final Wrappers._boolean res = new Wrappers._boolean();
                    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                      public void run() {
                        res.value = executeScript(applied);
                      }
                    });
                    return res.value;
                  }
                  public void forceExecutionNextTime() {
                    throw new UnsupportedOperationException("not supported for language migrations");
                  }
                };
                return true;
              }
            });
          }
        });
      }
    }));

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);
  private static MigrationScript check_gd1mrb_a0e0u(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}


File: plugins/mpsjava/basePlatform/source_gen/jetbrains/mps/ide/java/newparser/JavaToMpsConverter.java
package jetbrains.mps.ide.java.newparser;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.module.ModelAccess;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.io.IOException;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.extapi.model.EditableSModelBase;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ISequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.DynamicReference;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.vfs.IFileUtils;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.StaticReference;
import jetbrains.mps.scope.Scope;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.LinkedList;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.persistence.ModelFactory;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.persistence.PersistenceRegistry;
import jetbrains.mps.persistence.FilePerRootModelPersistence;
import jetbrains.mps.project.MPSExtentions;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class JavaToMpsConverter {
  private static final Logger LOG = LogManager.getLogger(JavaToMpsConverter.class);

  private SModule myModule;
  private SModel myModel;
  private boolean myCreatePerRoot;
  private boolean myCreateInplace;
  private SRepository myRepository;
  private ModelAccess myModelAccess;


  private JavaParser myJavaParser = new JavaParser();
  private Map<String, Set<SNode>> classesPerPackage = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<String, List<IFile>> filesPerPackage = MapSequence.fromMap(new HashMap<String, List<IFile>>());
  private Map<String, IFile> packageDirs = MapSequence.fromMap(new HashMap<String, IFile>());
  private List<SModel> myModels = ListSequence.fromList(new ArrayList<SModel>());
  private List<SNode> myRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<SNode> myAttachedRoots = ListSequence.fromList(new ArrayList<SNode>());
  private List<IFile> mySuccessfulFiles = ListSequence.fromList(new ArrayList<IFile>());

  private boolean wasDefaultPkg = false;
  private int myRootCount = 0;

  public JavaToMpsConverter(SModule module, SRepository repository) {
    this(module, repository, false, false);
  }

  public Set<SNode> getRootsBuilt() {
    return Collections.<SNode>unmodifiableSet(SetSequence.fromSetWithValues(new HashSet<SNode>(), myAttachedRoots));
  }

  public JavaToMpsConverter(SModule module, SRepository repository, boolean perRoot, boolean inPlace) {
    // currently perRoot==false and inPlace==true doesn't make it in-place 
    // because of how DefaultModelRoot is implemented 
    myModule = module;
    myCreatePerRoot = perRoot;
    myCreateInplace = inPlace;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public JavaToMpsConverter(SModel model, SRepository repository) {
    myModel = model;
    myRepository = repository;
    myModelAccess = repository.getModelAccess();
  }

  public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {

    progress.start("Converting...", 31);

    // first we build AST 
    final ProgressMonitor parseProgress = progress.subTask(1);
    parseProgress.start("Parsing...", ListSequence.fromList(files).count());

    // read action needed only because java parser does new node<Concept> 

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (IFile file : ListSequence.fromList(files)) {
          try {
            parseFile(file);
            parseProgress.advance(1);

          } catch (JavaParseException e) {
          } catch (IOException e) {
          }
        }
      }
    });

    parseProgress.done();


    int rootCount = 0;

    // now we attach the models and try to resolve      

    runCommand("roots creation pass", new Runnable() {
      public void run() {

        SModule module;

        if (myModel == null) {
          ((AbstractModule) myModule).addDependency(PersistenceFacade.getInstance().createModuleReference("6354ebe7-c22a-4a0f-ac54-50b52ab9b065(JDK)"), false);

          for (String pakage : MapSequence.fromMap(classesPerPackage).keySet()) {
            final SModel model = getModel(pakage, MapSequence.fromMap(packageDirs).get(pakage));
            if (model == null) {
              continue;
            }

            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
            ((SModelBase) model).addLanguage(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf280165065d5424eL, 0xbb1b463a8781b786L), "jetbrains.mps.baseLanguage.javadoc", -1));

            Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);
            SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {
              public void visit(SNode it) {
                model.addRootNode(it);
              }
            });

            ListSequence.fromList(mySuccessfulFiles).addSequence(ListSequence.fromList(MapSequence.fromMap(filesPerPackage).get(pakage)));
            ListSequence.fromList(myAttachedRoots).addSequence(SetSequence.fromSet(roots));

            ((EditableSModelBase) model).save();
            ListSequence.fromList(myModels).addElement(model);
          }
          module = myModule;

        } else {
          // todo maybe do something clever with packages <-> java imports 
          // with regard to model where we put it all 
          for (SNode root : ListSequence.fromList(myRoots)) {
            // todo be more accurate with duplicates 
            myModel.addRootNode(root);
          }
          myAttachedRoots = myRoots;
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)"));
          ((SModelBase) myModel).addLanguage(PersistenceFacade.getInstance().createModuleReference("f2801650-65d5-424e-bb1b-463a8781b786(jetbrains.mps.baseLanguage.javadoc)"));
          module = myModel.getModule();
        }

        JavaParser.tryResolveUnknowns(myAttachedRoots);
      }
    });

    myRootCount = myAttachedRoots.size();

    ProgressMonitor resolveProgress = progress.subTask(30);
    tryResolveRefs(myAttachedRoots, FeatureKind.CLASS, resolveProgress);
    progress.done();
  }

  public void tryResolveRefs(Iterable<SNode> nodes, FeatureKind level, ProgressMonitor progress) {
    progress.start("Resolving...", 10);

    if (FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("top level references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getTopLevelRefs(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")));
        }
      }, progress.subTask(1));
    }

    if (FeatureKind.CLASS_CONTENT.equals(level) || FeatureKind.CLASS.equals(level)) {
      resolveUpdatePass("field/method type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
        public Iterable<SReference> invoke(SNode node) {
          return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember")));
        }
      }, progress.subTask(1));
    }

    resolveUpdatePass("type references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVarTypeRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("variable references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return getVariableRefs(node);
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operands", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("dot operations", nodes, new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {
      public ISequence<SReference> invoke(SNode node) {
        return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
          public Iterable<SReference> translate(SNode it) {
            if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")))).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return (SReference) it instanceof DynamicReference;
              }
            })) {
              return ListSequence.fromList(new ArrayList<SReference>());
            } else {
              if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration")));
              } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"))) {
                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46b36c4L, "operation")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration")));
              } else {
                return ListSequence.fromList(new ArrayList<SReference>());
              }
            }
          }
        });
      }
    }, progress.subTask(1));

    resolveUpdatePass("classifiers in static access", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("static member references", nodes, new _FunctionTypes._return_P1_E0<List<SReference>, SNode>() {
      public List<SReference> invoke(SNode node) {
        List<SReference> result = ListSequence.fromList(new ArrayList<SReference>());

        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
          }
        }));
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference"), false, new SAbstractConcept[]{})).select(new ISelector<SNode, SReference>() {
          public SReference select(SNode it) {
            return SNodeOperations.getReference(it, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
          }
        }));

        return result;
      }
    }, progress.subTask(1));

    resolveUpdatePass("remaining references", nodes, new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {
      public Iterable<SReference> invoke(SNode node) {
        return deepReferences(node);
      }
    }, progress.subTask(1));

    codeTransformPass(nodes, progress.subTask(1));

    removeJavaImportsPass(nodes, progress.subTask(1));

    progress.done();
  }

  public List<IFile> getSuccessfulFiles() {
    return mySuccessfulFiles;
  }

  public List<SModel> getModels() {
    return myModels;
  }

  private void parseFile(IFile file) throws JavaParseException, IOException {
    String contents = IFileUtils.getTextContents(file);
    JavaParser.JavaParseResult parseResult = myJavaParser.parseCompilationUnit(contents);
    String pkg = parseResult.getPackage();

    if (pkg == null) {
      // default package (i.e. none), bad 
      if (!(wasDefaultPkg)) {
        LOG.error("default package is not supported in java source directory input (first such file in dir: " + file.getName() + ")");
        wasDefaultPkg = true;
      }
      return;
    }

    IFile dir = file.getParent();
    if (!(DirParser.checkPackageMatchesSourceDirectory(pkg, dir))) {
      LOG.error("package " + pkg + " doesn't match directory " + dir.getPath() + " (in file " + file.getName() + ")");
      return;
    }

    IFile currentDir = MapSequence.fromMap(packageDirs).get(pkg);
    // if it's already set, leave it as is 
    // it means one package is present in more than one dir, but we will have only one model 
    // and it has to be somewhere 
    if (currentDir == null) {
      MapSequence.fromMap(packageDirs).put(pkg, dir);
    }

    Iterable<SNode> roots = parseResult.getNodes();

    Set<SNode> classesInPackage = MapSequence.fromMap(classesPerPackage).get(pkg);
    if (classesInPackage == null) {
      classesInPackage = SetSequence.fromSet(new HashSet<SNode>(Sequence.fromIterable(roots).count()));
      MapSequence.fromMap(classesPerPackage).put(pkg, classesInPackage);
    }
    SetSequence.fromSet(classesInPackage).addSequence(Sequence.fromIterable(roots));

    List<IFile> files = MapSequence.fromMap(filesPerPackage).get(pkg);
    if (files == null) {
      files = ListSequence.fromList(new ArrayList<IFile>());
      MapSequence.fromMap(filesPerPackage).put(pkg, files);
    }
    ListSequence.fromList(files).addElement(file);

    ListSequence.fromList(myRoots).addSequence(Sequence.fromIterable(roots));
    myRootCount += Sequence.fromIterable(roots).count();

  }

  private void runCommand(String name, final Runnable runnable) {
    if (SwingUtilities.isEventDispatchThread()) {
      myModelAccess.executeCommand(runnable);

    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          public void run() {
            myModelAccess.executeCommand(runnable);
          }
        });

      } catch (InterruptedException e) {
        LOG.error(name + " was interrupted", e);
      } catch (InvocationTargetException e) {
        LOG.error("Exception in " + name, e.getCause());
      }
    }
  }

  private Set<SReference> myVisitedRefs = SetSequence.fromSet(new HashSet<SReference>());

  private void resolveUpdatePass(String name, final Iterable<SNode> nodes, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {
    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());
    progress.start(name, Sequence.fromIterable(nodes).count() + 1);

    myModelAccess.runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {

          if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"))) {
            progress.step("class: " + SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
          }

          Iterable<SReference> refs = extractor.invoke(node);
          resolveRefs(refs, resolveMap);

          SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));
          progress.advance(1);
        }

      }
    });

    progress.step("updating references...");

    runCommand(name, new Runnable() {
      public void run() {
        updateReference(resolveMap);
      }
    });

    progress.advance(1);
    progress.done();
  }

  private void codeTransformPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Code transforms", Sequence.fromIterable(nodes).count() * 5 + 1);
    final TypeChecker typeChecker = TypeChecker.getInstance();

    // all this can be replaced by one map old -> new 
    final List<SNode> toReplaceWithArrayLength = ListSequence.fromList(new ArrayList<SNode>());
    final List<SNode> toReplaceWithArrayClone = ListSequence.fromList(new ArrayList<SNode>());
    final Map<SNode, SNode> enumConstRefs = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticMethodQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());
    final Map<SNode, SNode> staticFieldQualifiers = MapSequence.fromMap(new HashMap<SNode, SNode>());

    myModelAccess.runReadAction(new Runnable() {
      public void run() {
        for (SNode node : Sequence.fromIterable(nodes)) {

          for (SNode fieldRefOp : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, "jetbrains.mps.baseLanguage.structure.FieldReferenceOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(fieldRefOp, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b483d77aL, 0x116b484a653L, "fieldDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "length".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(fieldRefOp), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayLength).addElement(fieldRefOp);
            }
          }

          progress.advance(1);

          for (SNode imco : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x118154a6332L, "jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation"), false, new SAbstractConcept[]{}))) {

            SReference fieldRef = SNodeOperations.getReference(imco, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
            if (!((fieldRef instanceof DynamicReference && "clone".equals((((DynamicReference) fieldRef).getResolveInfo()))))) {
              continue;
            }

            SNode operand = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(imco), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand"));

            Iterable<SReference> operandRefs = SNodeOperations.getReferences(operand);
            if (Sequence.fromIterable(operandRefs).any(new IWhereFilter<SReference>() {
              public boolean accept(SReference it) {
                return it instanceof DynamicReference;
              }
            })) {
              continue;
            }

            SNode operandType = typeChecker.getTypeOf(operand);
            if (SNodeOperations.isInstanceOf(operandType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d819f7L, "jetbrains.mps.baseLanguage.structure.ArrayType"))) {
              ListSequence.fromList(toReplaceWithArrayClone).addElement(imco);
            }
          }

          progress.advance(1);

          for (SNode localCall : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9404L, "jetbrains.mps.baseLanguage.structure.LocalMethodCall"), false, new SAbstractConcept[]{}))) {
            SNode smc = transformLocalCall(localCall);
            if ((smc == null)) {
              continue;
            }
            MapSequence.fromMap(staticMethodQualifiers).put(localCall, smc);
          }

          progress.advance(1);

          TypeChecker typeChecker = TypeChecker.getInstance();

          for (SNode swicthCase : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, "jetbrains.mps.baseLanguage.structure.SwitchCase"), false, new SAbstractConcept[]{}))) {
            SNode subst = transformUnqualifedEnumUnderSwitch(swicthCase, typeChecker);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(SNodeOperations.cast(SLinkOperations.getTarget(swicthCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression")), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), subst);
          }


          progress.advance(1);

          for (SNode varRef : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{}))) {
            SNode exp = transformLocalNameRef(varRef);
            if ((exp != null)) {
              MapSequence.fromMap(staticFieldQualifiers).put(varRef, exp);
              continue;
            }

            SNode subst = transformUnqualifedEnum(varRef);
            if ((subst == null)) {
              continue;
            }
            MapSequence.fromMap(enumConstRefs).put(varRef, subst);
          }

          progress.advance(1);
        }

      }
    });

    progress.step("updating models...");

    runCommand("Code transforms", new Runnable() {
      public void run() {
        for (SNode fieldRefOp : ListSequence.fromList(toReplaceWithArrayLength)) {
          SNodeOperations.replaceWithNewChild(fieldRefOp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1197781411dL, "jetbrains.mps.baseLanguage.structure.ArrayLengthOperation"));
        }
        for (SNode imco : ListSequence.fromList(toReplaceWithArrayClone)) {
          SNodeOperations.replaceWithNewChild(imco, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x483ee9d7f09580d6L, "jetbrains.mps.baseLanguage.structure.ArrayCloneOperation"));
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(enumConstRefs)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticMethodQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }
        for (IMapping<SNode, SNode> pair : MapSequence.fromMap(staticFieldQualifiers)) {
          SNodeOperations.replaceWithAnother(pair.key(), pair.value());
        }

      }
    });

    progress.advance(1);
    progress.done();
  }

  private void removeJavaImportsPass(final Iterable<SNode> nodes, final ProgressMonitor progress) {
    progress.start("Removing java imports", Sequence.fromIterable(nodes).count() + 1);
    final Map<SNode, Iterable<SNode>> toRemove = MapSequence.fromMap(new HashMap<SNode, Iterable<SNode>>());

    myRepository.getModelAccess().runReadAction(new Runnable() {
      public void run() {

        for (SNode node : Sequence.fromIterable(nodes)) {
          progress.advance(1);

          if (!(SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
            continue;
          }
          if ((AttributeOperations.getAttribute(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))) == null)) {
            continue;
          }

          MapSequence.fromMap(toRemove).put(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), getImportsToRemove(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))));
        }
      }
    });

    runCommand("removing java imports", new Runnable() {
      public void run() {
        for (SNode node : SetSequence.fromSet(MapSequence.fromMap(toRemove).keySet())) {
          Iterable<SNode> imps = MapSequence.fromMap(toRemove).get(node);
          Sequence.fromIterable(imps).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });

          SNode importAnnotation = AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
          if (ListSequence.fromList(SLinkOperations.getChildren(importAnnotation, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).isEmpty()) {
            SNodeOperations.deleteNode(importAnnotation);
          }
        }
      }
    });

    progress.advance(1);
    progress.done();

  }

  private SNode transformUnqualifedEnum(SNode varRef) {
    // FIXME share or re-use code with the corresponding NonTypesystemRule 

    if (!(SConceptOperations.isExactly(SNodeOperations.asSConcept(SNodeOperations.getConceptDeclaration(varRef)), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    if (ref.getTargetNode() != null) {
      return null;
    }

    // now we can try to search 
    SNode gateway = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved")));

    String enumConstName = ((DynamicReference) ref).getResolveInfo();

    for (SNode enclosingEnum : ListSequence.fromList(SNodeOperations.getNodeAncestors(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass"), false))) {
      SNode enumConstRef = makeEnumConstRef(enclosingEnum, enumConstName);
      if (enumConstRef != null) {
        return enumConstRef;
      }
    }

    SNode root = SNodeOperations.getContainingRoot(varRef);
    if (!(SNodeOperations.isInstanceOf(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")))) {
      return null;
    }
    SNode javaImports = AttributeOperations.getAttribute(SNodeOperations.cast(root, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports")));
    if ((javaImports == null)) {
      return null;
    }

    for (SNode singleNameImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticSingleName_5230012391903395274", new Object[]{}))) {
      if (!(enumConstName.equals(BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{})))) {
        continue;
      }

      String enumClassCandidateName = BehaviorReflection.invokeNonVirtual(String.class, singleNameImport, "jetbrains.mps.baseLanguage.structure.Tokens", "call_withoutLastToken_6148840541591441572", new Object[]{});
      SNode enumClassCandidate = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, enumClassCandidateName});
      if ((enumClassCandidate == null)) {
        // seems like there is no need to continue 
        // we had import of the form: import static <class>.<ourName> 
        // if we meet <ourName> in java code then it must strictly reference this import, not any other 
        return null;
      }
      if (!(SNodeOperations.isInstanceOf(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        return null;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(enumClassCandidate, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }

    for (SNode onDemandImport : Sequence.fromIterable(BehaviorReflection.invokeNonVirtual((Class<Iterable<SNode>>) ((Class) Object.class), javaImports, "jetbrains.mps.baseLanguage.structure.JavaImports", "call_staticOnDemand_5230012391903366883", new Object[]{}))) {
      SNode claz = BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), gateway, "jetbrains.mps.baseLanguage.structure.IYetUnresolved", "call_findClass_5230012391932867419", new Object[]{varRef, SPropertyOperations.getString(onDemandImport, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x5a98df4004080866L, 0x1996ec29712bdd92L, "tokens"))});
      if ((claz == null)) {
        continue;
      }
      if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
        continue;
      }
      SNode result = makeEnumConstRef(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), enumConstName);
      if (result != null) {
        return null;
      }
    }
    return null;
  }
  private SNode makeEnumConstRef(SNode enumClass, final String constName) {
    // Q: maybe not findFirst, but rather fail if there are more than one... 
    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return constName.equals(SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")));
      }
    });
    if ((enumConst == null)) {
      return null;
    }

    SNode result = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(enumClass, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(result, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return result;
  }

  private SNode transformUnqualifedEnumUnderSwitch(SNode switchCase, TypeChecker typeChecker) {
    // FIXME share or re-use code with the corresponding NonTypesystemRule 

    SNode caseExp = SLinkOperations.getTarget(switchCase, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02cdd1bL, 0x10ef02d67cfL, "expression"));
    if (!(SNodeOperations.isInstanceOf(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")))) {
      return null;
    }
    SReference ref = SNodeOperations.getReference(SNodeOperations.cast(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof DynamicReference)) {
      return null;
    }

    final String enumConstName = ((DynamicReference) ref).getResolveInfo();

    SNode scrutenee = SLinkOperations.getTarget(SNodeOperations.getNodeAncestor(caseExp, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, "jetbrains.mps.baseLanguage.structure.SwitchStatement"), false, false), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x10ef02a8c6aL, 0x10ef02ec241L, "expression"));
    if ((scrutenee == null)) {
      return null;
    }

    SNode scruteneeType = typeChecker.getTypeOf(scrutenee);
    if (!(SNodeOperations.isInstanceOf(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")))) {
      return null;
    }

    SNode claz = SLinkOperations.getTarget(SNodeOperations.cast(scruteneeType, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"));
    if (!(SNodeOperations.isInstanceOf(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")))) {
      return null;
    }

    SNode enumConst = ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, 0xfc367503acL, "enumConstant"))).findFirst(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SPropertyOperations.getString(it, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name")).equals(enumConstName);
      }
    });
    SNode enumConstRef = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, "jetbrains.mps.baseLanguage.structure.EnumConstantReference")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0x10a758428feL, "enumClass"), SNodeOperations.cast(claz, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc367070a5L, "jetbrains.mps.baseLanguage.structure.EnumClass")));
    SLinkOperations.setTarget(enumConstRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfc37588bc8L, 0xfc37588bcaL, "enumConstantDeclaration"), enumConst);

    return enumConstRef;
  }


  private SNode transformLocalCall(SNode localCall) {
    // FIXME share or re-use code with the corresponding NonTypesystemRule 

    SReference ref = SNodeOperations.getReference(localCall, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")))) {
      return null;
    }

    Scope staticMethodScope = Scope.getScope(SNodeOperations.getParent(localCall), localCall, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration").getDeclarationNode());
    if (staticMethodScope.contains(target)) {
      return null;
    }

    // it's out of scope, let's make it StaticMethodCall 
    SNode smc = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, "jetbrains.mps.baseLanguage.structure.StaticMethodCall")));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf09L, 0x10a7588b546L, "classConcept"), SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"), false, false));
    SLinkOperations.setTarget(smc, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301adL, "baseMethodDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xfbbebabf0aL, "jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration")));
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0xf8c78301aeL, "actualArgument"))).addElement(SNodeOperations.copyNode(arg));
    }
    for (SNode arg : ListSequence.fromList(SLinkOperations.getChildren(localCall, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument")))) {
      ListSequence.fromList(SLinkOperations.getChildren(smc, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x11857355952L, 0x4500f31eb02a7788L, "typeArgument"))).addElement(SNodeOperations.copyNode(arg));
    }

    return smc;
  }

  private SNode transformLocalNameRef(SNode varRef) {
    // it's either EnumConstReference or StaticFieldReference 

    // FIXME share or re-use code with the corresponding NonTypesystemRule 

    SReference ref = SNodeOperations.getReference(varRef, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
    if (!(ref instanceof StaticReference)) {
      return null;
    }
    SNode target = ref.getTargetNode();
    if (!(SNodeOperations.isInstanceOf(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")))) {
      return null;
    }

    // now check whether it's in another class 
    SNode thisClass = SNodeOperations.getNodeAncestor(varRef, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    SNode thatClass = SNodeOperations.getNodeAncestor(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, false);
    // it should be ok to use ==, I think 
    if (thisClass == thatClass) {
      // same class, such local method call is ok in baseLanguage 
      return null;
    }

    // different class, let's make this reference non-local, but qualified 
    SNode sfr = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, 0x10a75869f9bL, "classifier"), thatClass);
    SLinkOperations.setTarget(sfr, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"), SNodeOperations.cast(target, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, "jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration")));

    return sfr;
  }


  private Iterable<SNode> getImportsToRemove(SNode root) {
    // FIXME share or re-use code with the corresponding NonTypesystemRule 

    final Map<String, SNode> importsByName = MapSequence.fromMap(new HashMap<String, SNode>());
    ListSequence.fromList(SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SPropertyOperations.getBoolean(it, MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x64c0181e603bcfL, 0x64c0181e603bd0L, "onDemand")));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(importsByName).put(BehaviorReflection.invokeNonVirtual(String.class, it, "jetbrains.mps.baseLanguage.structure.Tokens", "call_lastToken_1296023605440030462", new Object[]{}), it);

      }
    });

    boolean unknownPresent = false;
    boolean dynRefsPresent = false;
    Set<SNode> retain = SetSequence.fromSet(new HashSet<SNode>());

    Deque<SNode> stack = DequeSequence.fromDequeNew(new LinkedList<SNode>());
    DequeSequence.fromDequeNew(stack).pushElement(root);

    while (DequeSequence.fromDequeNew(stack).isNotEmpty()) {
      SNode node = DequeSequence.fromDequeNew(stack).popElement();
      DequeSequence.fromDequeNew(stack).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));

      if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x70ea1dc4c5721865L, "jetbrains.mps.baseLanguage.structure.IYetUnresolved"))) {
        unknownPresent = true;
        break;
      }

      Iterable<? extends SReference> refs = node.getReferences();
      for (SReference ref : Sequence.fromIterable(refs)) {
        if (!(ref instanceof DynamicReference)) {
          continue;
        }

        dynRefsPresent = true;

        String resolveInfo = ((DynamicReference) ref).getResolveInfo();
        SetSequence.fromSet(retain).addElement(MapSequence.fromMap(importsByName).get(resolveInfo));
      }
    }

    // retain all imports if 'unknown' concepts still present 
    if (unknownPresent) {
      return null;
    }
    // on the other hand, if everything is resolved, remove all imports altogether 
    if (dynRefsPresent == false) {
      // quick-fix 
      return SLinkOperations.getChildren(AttributeOperations.getAttribute(root, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, "jetbrains.mps.baseLanguage.structure.JavaImports"))), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x53f7c33f069862f2L, 0x64c0181e6020a7L, "entries"));
    }
    // removing only those single-type imports that didn't get into retain set 
    // quick fix 
    Iterable<SNode> unneeded = Sequence.fromIterable(MapSequence.fromMap(importsByName).values()).subtract(SetSequence.fromSet(retain));
    return unneeded;
  }

  private Iterable<SReference> getTopLevelRefs(SNode node) {
    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")))));
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });

    } else if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
      ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface"))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));
        }
      });
    }

    for (SNode inner : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"), false, new SAbstractConcept[]{}))) {
      if (SNodeOperations.isInstanceOf(inner, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
        continue;
      }
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));
    }

    return refs;
  }

  private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    Iterable<SNode> members = (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")) ? SLinkOperations.getChildren(SNodeOperations.cast(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, 0x4a9a46de59132803L, "member")) : Sequence.<SNode>singleton(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x112574373bdL, "jetbrains.mps.baseLanguage.structure.ClassifierMember"))));

    for (SNode member : Sequence.fromIterable(members)) {
      if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x6c6b6a1e379f9408L, "jetbrains.mps.baseLanguage.structure.MethodDeclaration"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1fdL, "returnType")))));
        for (SNode param : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0xf8cc56b1feL, "parameter")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(param, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
        }
        for (SNode thrws : ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration")), MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, 0x10f383d6949L, "throwsItem")))) {
          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(thrws)));
        }

      } else if (SNodeOperations.isInstanceOf(member, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, "jetbrains.mps.baseLanguage.structure.Classifier"))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(member)));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVarTypeRefs(SNode node) {
    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());

    for (SNode block : ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b200L, "jetbrains.mps.baseLanguage.structure.StatementList"), false, new SAbstractConcept[]{}))) {

      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getNodeDescendants(block, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c37a7f6eL, "jetbrains.mps.baseLanguage.structure.VariableDeclaration"), false, new SAbstractConcept[]{}))) {
        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(varDecl, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x450368d90ce15bc3L, 0x4ed4d318133c80ceL, "type")))));
      }
    }

    return refs;
  }

  private Iterable<SReference> getVariableRefs(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference"), false, new SAbstractConcept[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940c80846L, "jetbrains.mps.baseLanguage.structure.StaticFieldReference")));
      }
    }).select(new ISelector<SNode, SReference>() {
      public SReference select(SNode it) {
        return SNodeOperations.getReference(SNodeOperations.cast(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, "jetbrains.mps.baseLanguage.structure.VariableReference")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c77f1e98L, 0xf8cc6bf960L, "variableDeclaration"));
      }
    });
  }

  private Iterable<SReference> getDotExpLeftParts(SNode node) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(node, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, "jetbrains.mps.baseLanguage.structure.DotExpression"), false, new SAbstractConcept[]{})).translate(new ITranslator2<SNode, SReference>() {
      public Iterable<SReference> translate(SNode it) {
        return deepReferences(SLinkOperations.getTarget(it, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x116b46a08c4L, 0x116b46a4416L, "operand")));
      }
    });
  }

  private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {
    for (SReference ref : refs) {
      if (!(ref instanceof DynamicReference)) {
        continue;
      }
      if (SetSequence.fromSet(myVisitedRefs).contains((SReference) ref)) {
        continue;
      }

      SNode target = ref.getTargetNode();
      if (target == null) {
        continue;
      }

      SNode source = ref.getSourceNode();
      SModelReference targetModel = target.getModel().getReference();

      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId(), ((DynamicReference) ref).getResolveInfo());

      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());
      if (nodeRefs == null) {
        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());
        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);
      }
      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);
    }
  }

  private void updateReference(Map<SNodeReference, List<SReference>> refMap) {
    for (SNodeReference nodeRef : SetSequence.fromSet(MapSequence.fromMap(refMap).keySet())) {
      final SNode node = nodeRef.resolve(myRepository);
      if (node == null) {
        continue;
      }
      final SModel sourceModel = node.getModel();
      ListSequence.fromList(MapSequence.fromMap(refMap).get(nodeRef)).visitAll(new IVisitor<SReference>() {
        public void visit(SReference it) {

          SModelReference targetModelRef = it.getTargetSModelReference();
          if (!(sourceModel.getReference().equals(targetModelRef))) {
            // avoiding self-import 
            ((SModelInternal) sourceModel).addModelImport(targetModelRef, true);
          }

          node.setReference(it.getRole(), it);
        }
      });
    }
  }

  public static Iterable<SReference> deepReferences(SNode node) {

    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());
    ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(node)));
    for (SNode child : ListSequence.fromList(SNodeOperations.getChildren(node))) {
      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(child)));
    }

    return refs;

    // generator for yield broken? 
  }

  private SModel getModel(String pkgFqName, IFile pkgDir) {
    for (SModel model : Sequence.fromIterable(myModule.getModels())) {
      // not handling stereotype on purpose: if there's my.pkg@java_stub, it shouldn't prevent us 
      // from creating my.pkg 
      if (pkgFqName.equals(model.getModelName())) {
        return model;
      }
    }
    return createModel(pkgFqName, pkgDir);
  }
  private SModel createModel(String pkgFqName, IFile pkgDir) {
    SModel modelDescr;
    try {

      if (myCreateInplace) {
        Tuples._2<ModelRoot, String> place = getRootContainingDir(pkgDir);
        ModelRoot modelRoot = place._0();
        String sourceRoot = place._1();
        if (modelRoot == null) {
          LOG.error("Cannot convert to MPS in-place: java sources not under proper model root");
          return null;
        }
        Map<String, String> options = MapSequence.fromMap(new HashMap<String, String>());
        // I don't like it but currently clients of getRelativePath() do this, 
        // and I don't want to change that right before 3.2 
        String fullPath = pkgDir.getPath().replace('\\', '/');
        String sr = sourceRoot.replace('\\', '/');
        MapSequence.fromMap(options).put(ModelFactory.OPTION_RELPATH, FileUtil.getRelativePath(pkgDir.getPath(), sourceRoot, "/"));
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, sourceRoot, options, PersistenceRegistry.getInstance().getFolderModelFactory(FilePerRootModelPersistence.FACTORY_ID));

      } else {
        ModelRoot modelRoot = getFirstRootToCreateModel(pkgFqName);
        if (modelRoot == null) {
          LOG.error("Failed to find model root to create model in");
          return null;
        }
        modelDescr = ((DefaultModelRoot) modelRoot).createModel(pkgFqName, null, null, PersistenceRegistry.getInstance().getModelFactory(MPSExtentions.MODEL));
      }

      if (modelDescr == null) {
        LOG.error("Failed to create model: createModel returned null");
        return null;
      }
    } catch (IOException e) {
      LOG.error("Failed to create model", e);
      return null;
    }

    // load() is needed to mark model loaded (really?!), without it save() would be a no-op 
    // FIXME something bad: see MPS-18545 SModel api: createModel(), setChanged(), isLoaded(), save() 
    modelDescr.load();
    ((EditableSModel) modelDescr).setChanged(true);
    ((EditableSModel) modelDescr).save();

    return modelDescr;
  }
  @Nullable
  private ModelRoot getFirstRootToCreateModel(String packageName) {
    for (ModelRoot root : Sequence.fromIterable(myModule.getModelRoots())) {
      if (!(root instanceof DefaultModelRoot)) {
        continue;
      }
      if (root.canCreateModel(packageName)) {
        return root;
      }
    }
    return null;
  }
  private Tuples._2<ModelRoot, String> getRootContainingDir(IFile dir) {
    // returns modelRoot and sourceRoot within 
    for (ModelRoot modelRoot : Sequence.fromIterable(myModule.getModelRoots())) {
      // or maybe more general: file based model root? 
      if (!(modelRoot instanceof DefaultModelRoot)) {
        continue;
      }
      for (String sourceRoot : ((DefaultModelRoot) modelRoot).getFiles(FileBasedModelRoot.SOURCE_ROOTS)) {
        if (FileUtil.isSubPath(sourceRoot, dir.getPath())) {
          return MultiTuple.<ModelRoot,String>from(modelRoot, sourceRoot);
        }
      }
    }
    return MultiTuple.<ModelRoot,String>from((ModelRoot) null, (String) null);
  }

}


File: plugins/mpsjava/basePlatform/source_gen/jetbrains/mps/ide/java/sourceStubs/JavaSourceStubModelDescriptor.java
package jetbrains.mps.ide.java.sourceStubs;

/*Generated by MPS */

import jetbrains.mps.extapi.model.ReloadableSModelBase;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSourceListener;
import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModel;
import java.util.Map;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeId;
import org.jetbrains.mps.openapi.persistence.MultiStreamDataSource;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.persistence.DataSource;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.ide.java.newparser.JavaParser;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.io.InputStream;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.io.IOException;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import java.util.List;
import java.util.LinkedList;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;

public class JavaSourceStubModelDescriptor extends ReloadableSModelBase implements MultiStreamDataSourceListener {

  private static Logger LOG = Logger.wrap(LogManager.getLogger(JavaSourceStubModelDescriptor.class));

  private SModelReference myModelRef;
  private SModel myModel;
  private Map<String, Set<SNode>> myRootsPerFile = MapSequence.fromMap(new HashMap<String, Set<SNode>>());
  private Map<SNodeId, SNode> myRootsById = MapSequence.fromMap(new HashMap<SNodeId, SNode>());


  public JavaSourceStubModelDescriptor(SModelReference modelRef, MultiStreamDataSource dataSource) {
    super(modelRef, dataSource);
    myModelRef = modelRef;
  }

  private SModel createModel() {
    SModel model = new SModel(myModelRef);
    processStreams(getSource().getAvailableStreams(), model);
    for (SLanguage l : CollectionSequence.fromCollection(importedLanguageIds())) {
      model.addLanguage(l);
    }
    return model;
  }

  @Override
  public void attach(SRepository repository) {
    getSource().addListener(this);
    super.attach(repository);
  }

  @Override
  public void detach() {
    super.detach();
    getSource().removeListener(this);
  }

  @Override
  @NotNull
  public MultiStreamDataSource getSource() {
    return (MultiStreamDataSource) super.getSource();
  }

  @Override
  public void changed(DataSource source, Iterable<String> changedItems) {
    // FIXME it works, but is not incremental and is ugly 

    assertCanChange();

    // already attached but not createModel'd yet 
    if (myModel == null) {
      return;
    }
    MapSequence.fromMap(myRootsPerFile).clear();
    MapSequence.fromMap(myRootsById).clear();
    final SModel oldModel = myModel;
    myModel = createModel();
    replaceModelAndFireEvent(oldModel, myModel);
  }

  @Override
  public boolean needsReloading() {
    return false;
  }

  @Override
  public void changed(DataSource source) {
    // ignore 
  }

  public void processStreams(Iterable<String> names, SModelData into) {
    JavaParser parser = new JavaParser();

    for (String fileName : names) {
      try {
        Set<SNode> oldNodes = SetSequence.fromSetWithValues(new HashSet<SNode>(), MapSequence.fromMap(myRootsPerFile).get(fileName));

        InputStream is = getSource().openInputStream(fileName);
        // we've come from event and file has been deleted 
        if (is == null) {
          SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
            public void visit(SNode it) {
              SNodeOperations.deleteNode(it);
            }
          });
          MapSequence.fromMap(myRootsPerFile).removeKey(fileName);
          continue;
        }
        String code = readInputStream(is);
        try {
          is.close();
        } catch (IOException e) {
          LOG.warning("failed to close file " + fileName, e);
        }

        JavaParser.JavaParseResult parseResult = parser.parse(code, FeatureKind.CLASS_STUB, null, true);
        if (ListSequence.fromList(parseResult.getNodes()).isNotEmpty()) {
          for (SNode newNode : ListSequence.fromList(parseResult.getNodes())) {
            final SNodeId newNodeId = newNode.getNodeId();
            // oldNodes is usually very very small (number of root classes in java file) 
            SNode oldNode = SetSequence.fromSet(oldNodes).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return it.getNodeId().equals(newNodeId);
              }
            }).first();
            if (oldNode == null) {
              into.addRootNode(newNode);
              SetSequence.fromSet(oldNodes).removeElement(oldNode);
            } else {
              SNodeOperations.replaceWithAnother(oldNode, newNode);
            }
            MapSequence.fromMap(myRootsById).put(newNode.getNodeId(), newNode);
          }
        }

        SetSequence.fromSet(oldNodes).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SNodeOperations.deleteNode(it);
          }
        });
        MapSequence.fromMap(myRootsPerFile).put(fileName, SetSequence.fromSetWithValues(new HashSet<SNode>(), parseResult.getNodes()));

      } catch (IOException e) {
        LOG.error("Failed to read java file. " + e.getMessage(), e);
      } catch (JavaParseException e) {
        LOG.error("Failed to parse java file. " + e.getMessage());
      }
    }
  }

  private static final int BUFSIZE = 65536;
  private String readInputStream(InputStream is) throws IOException {

    List<byte[]> blocks = ListSequence.fromList(new LinkedList<byte[]>());

    byte[] buffer = new byte[BUFSIZE];
    int lastRead = -1;
    int read = is.read(buffer);

    while (read > 0) {
      lastRead = read;
      ListSequence.fromList(blocks).addElement(buffer);

      buffer = new byte[BUFSIZE];
      read = is.read(buffer);
    }

    if (lastRead > 0) {
      int blks = ListSequence.fromList(blocks).count();
      byte[] wholeBuffer;

      if (blks == 1) {
        wholeBuffer = ListSequence.fromList(blocks).getElement(0);
      } else {
        int size = (blks - 1) * BUFSIZE + lastRead;
        wholeBuffer = new byte[size];
        int c = 0;
        int p = 0;
        for (byte[] buf : blocks) {
          int n = (c == blks - 1 ? lastRead : BUFSIZE);
          System.arraycopy(buf, 0, wholeBuffer, p, n);
          p = p + BUFSIZE;
          c++;
        }
      }

      // Attention: default platform charset used. 
      return new String(wholeBuffer);

    } else {
      return "";
    }
  }

  protected SModel getCurrentModelInternal() {
    return myModel;
  }

  @Deprecated
  public SModel getSModelInternal() {
    if (myModel == null) {
      synchronized (this) {
        if (myModel != null) {
          return myModel;
        }
        myModel = createModel();
        myModel.setModelDescriptor(this);
      }
    }
    return myModel;
  }

  public boolean isLoaded() {
    return myModel != null;
  }
  @Override
  public void unload() {
    assertCanChange();

    SModel oldModel = myModel;
    if (oldModel != null) {
      oldModel.setModelDescriptor(null);
      myModel = null;
      fireModelStateChanged(ModelLoadingState.NOT_LOADED);
    }
  }

  @Override
  public Collection<SLanguage> importedLanguageIds() {
    return Collections.singleton(MetaAdapterFactory.getLanguage(MetaIdFactory.langId(0xf3061a5392264cc5L, 0xa443f952ceaf5816L), "jetbrains.mps.baseLanguage", -1));
  }

  public void reloadFromDiskSafe() {
    changed(getSource(), getSource().getAvailableStreams());
  }
}
